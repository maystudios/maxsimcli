//#region \0rolldown/runtime.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esmMin = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __exportAll = (all, no_symbols) => {
	let target = {};
	for (var name in all) {
		__defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	}
	if (!no_symbols) {
		__defProp(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __toCommonJS = (mod) => __hasOwnProp.call(mod, "module.exports") ? mod["module.exports"] : __copyProps(__defProp({}, "__esModule", { value: true }), mod);

//#endregion
let node_path = require("node:path");
node_path = __toESM(node_path);
let node_fs = require("node:fs");
node_fs = __toESM(node_fs);
let node_http = require("node:http");
let path = require("path");
path = __toESM(path);
let fs = require("fs");
let events = require("events");
let node_querystring = require("node:querystring");
node_querystring = __toESM(node_querystring);
let node_net = require("node:net");
let node_util = require("node:util");
let node_os = require("node:os");
node_os = __toESM(node_os);
let node_fs_promises = require("node:fs/promises");
node_fs_promises = __toESM(node_fs_promises);
let node_child_process = require("node:child_process");
node_child_process = __toESM(node_child_process);
let node_process = require("node:process");
node_process = __toESM(node_process);
let node_buffer = require("node:buffer");
let node_url = require("node:url");
let node_tty = require("node:tty");
node_tty = __toESM(node_tty);
let fs_promises = require("fs/promises");
let node_stream = require("node:stream");
let os = require("os");

//#region ../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js
var require_depd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* depd
	* Copyright(c) 2014-2018 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module dependencies.
	*/
	var relative = require("path").relative;
	/**
	* Module exports.
	*/
	module.exports = depd;
	/**
	* Get the path to base files on.
	*/
	var basePath = process.cwd();
	/**
	* Determine if namespace is contained in the string.
	*/
	function containsNamespace(str, namespace) {
		var vals = str.split(/[ ,]+/);
		var ns = String(namespace).toLowerCase();
		for (var i = 0; i < vals.length; i++) {
			var val = vals[i];
			if (val && (val === "*" || val.toLowerCase() === ns)) return true;
		}
		return false;
	}
	/**
	* Convert a data descriptor to accessor descriptor.
	*/
	function convertDataDescriptorToAccessor(obj, prop, message) {
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		var value = descriptor.value;
		descriptor.get = function getter() {
			return value;
		};
		if (descriptor.writable) descriptor.set = function setter(val) {
			return value = val;
		};
		delete descriptor.value;
		delete descriptor.writable;
		Object.defineProperty(obj, prop, descriptor);
		return descriptor;
	}
	/**
	* Create arguments string to keep arity.
	*/
	function createArgumentsString(arity) {
		var str = "";
		for (var i = 0; i < arity; i++) str += ", arg" + i;
		return str.substr(2);
	}
	/**
	* Create stack string from stack.
	*/
	function createStackString(stack) {
		var str = this.name + ": " + this.namespace;
		if (this.message) str += " deprecated " + this.message;
		for (var i = 0; i < stack.length; i++) str += "\n    at " + stack[i].toString();
		return str;
	}
	/**
	* Create deprecate for namespace in caller.
	*/
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		var file = callSiteLocation(getStack()[1])[0];
		function deprecate(message) {
			log.call(deprecate, message);
		}
		deprecate._file = file;
		deprecate._ignored = isignored(namespace);
		deprecate._namespace = namespace;
		deprecate._traced = istraced(namespace);
		deprecate._warned = Object.create(null);
		deprecate.function = wrapfunction;
		deprecate.property = wrapproperty;
		return deprecate;
	}
	/**
	* Determine if event emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function eehaslisteners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if namespace is ignored.
	*/
	function isignored(namespace) {
		if (process.noDeprecation) return true;
		return containsNamespace(process.env.NO_DEPRECATION || "", namespace);
	}
	/**
	* Determine if namespace is traced.
	*/
	function istraced(namespace) {
		if (process.traceDeprecation) return true;
		return containsNamespace(process.env.TRACE_DEPRECATION || "", namespace);
	}
	/**
	* Display deprecation message.
	*/
	function log(message, site) {
		var haslisteners = eehaslisteners(process, "deprecation");
		if (!haslisteners && this._ignored) return;
		var caller;
		var callFile;
		var callSite;
		var depSite;
		var i = 0;
		var seen = false;
		var stack = getStack();
		var file = this._file;
		if (site) {
			depSite = site;
			callSite = callSiteLocation(stack[1]);
			callSite.name = depSite.name;
			file = callSite[0];
		} else {
			i = 2;
			depSite = callSiteLocation(stack[i]);
			callSite = depSite;
		}
		for (; i < stack.length; i++) {
			caller = callSiteLocation(stack[i]);
			callFile = caller[0];
			if (callFile === file) seen = true;
			else if (callFile === this._file) file = this._file;
			else if (seen) break;
		}
		var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
		if (key !== void 0 && key in this._warned) return;
		this._warned[key] = true;
		var msg = message;
		if (!msg) msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
		if (haslisteners) {
			var err = DeprecationError(this._namespace, msg, stack.slice(i));
			process.emit("deprecation", err);
			return;
		}
		var output = (process.stderr.isTTY ? formatColor : formatPlain).call(this, msg, caller, stack.slice(i));
		process.stderr.write(output + "\n", "utf8");
	}
	/**
	* Get call site location as array.
	*/
	function callSiteLocation(callSite) {
		var file = callSite.getFileName() || "<anonymous>";
		var line = callSite.getLineNumber();
		var colm = callSite.getColumnNumber();
		if (callSite.isEval()) file = callSite.getEvalOrigin() + ", " + file;
		var site = [
			file,
			line,
			colm
		];
		site.callSite = callSite;
		site.name = callSite.getFunctionName();
		return site;
	}
	/**
	* Generate a default message from the site.
	*/
	function defaultMessage(site) {
		var callSite = site.callSite;
		var funcName = site.name;
		if (!funcName) funcName = "<anonymous@" + formatLocation(site) + ">";
		var context = callSite.getThis();
		var typeName = context && callSite.getTypeName();
		if (typeName === "Object") typeName = void 0;
		if (typeName === "Function") typeName = context.name || typeName;
		return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
	}
	/**
	* Format deprecation message without color.
	*/
	function formatPlain(msg, caller, stack) {
		var formatted = (/* @__PURE__ */ new Date()).toUTCString() + " " + this._namespace + " deprecated " + msg;
		if (this._traced) {
			for (var i = 0; i < stack.length; i++) formatted += "\n    at " + stack[i].toString();
			return formatted;
		}
		if (caller) formatted += " at " + formatLocation(caller);
		return formatted;
	}
	/**
	* Format deprecation message with color.
	*/
	function formatColor(msg, caller, stack) {
		var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
		if (this._traced) {
			for (var i = 0; i < stack.length; i++) formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
			return formatted;
		}
		if (caller) formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
		return formatted;
	}
	/**
	* Format call site location.
	*/
	function formatLocation(callSite) {
		return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
	}
	/**
	* Get the stack as array of call sites.
	*/
	function getStack() {
		var limit = Error.stackTraceLimit;
		var obj = {};
		var prep = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareObjectStackTrace;
		Error.stackTraceLimit = Math.max(10, limit);
		Error.captureStackTrace(obj);
		var stack = obj.stack.slice(1);
		Error.prepareStackTrace = prep;
		Error.stackTraceLimit = limit;
		return stack;
	}
	/**
	* Capture call site stack from v8.
	*/
	function prepareObjectStackTrace(obj, stack) {
		return stack;
	}
	/**
	* Return a wrapped function in a deprecation message.
	*/
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		var args = createArgumentsString(fn.length);
		var site = callSiteLocation(getStack()[1]);
		site.name = fn.name;
		return new Function("fn", "log", "deprecate", "message", "site", "\"use strict\"\nreturn function (" + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
	}
	/**
	* Wrap property in a deprecation message.
	*/
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
		var deprecate = this;
		var site = callSiteLocation(getStack()[1]);
		site.name = prop;
		if ("value" in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
		var get = descriptor.get;
		var set = descriptor.set;
		if (typeof get === "function") descriptor.get = function getter() {
			log.call(deprecate, message, site);
			return get.apply(this, arguments);
		};
		if (typeof set === "function") descriptor.set = function setter() {
			log.call(deprecate, message, site);
			return set.apply(this, arguments);
		};
		Object.defineProperty(obj, prop, descriptor);
	}
	/**
	* Create DeprecationError for deprecation
	*/
	function DeprecationError(namespace, message, stack) {
		var error = /* @__PURE__ */ new Error();
		var stackString;
		Object.defineProperty(error, "constructor", { value: DeprecationError });
		Object.defineProperty(error, "message", {
			configurable: true,
			enumerable: false,
			value: message,
			writable: true
		});
		Object.defineProperty(error, "name", {
			enumerable: false,
			configurable: true,
			value: "DeprecationError",
			writable: true
		});
		Object.defineProperty(error, "namespace", {
			configurable: true,
			enumerable: false,
			value: namespace,
			writable: true
		});
		Object.defineProperty(error, "stack", {
			configurable: true,
			enumerable: false,
			get: function() {
				if (stackString !== void 0) return stackString;
				return stackString = createStackString.call(this, stack);
			},
			set: function setter(val) {
				stackString = val;
			}
		});
		return error;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
/*!
* bytes
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015 Jed Watson
* MIT Licensed
*/
var require_bytes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = bytes;
	module.exports.format = format;
	module.exports.parse = parse;
	/**
	* Module variables.
	* @private
	*/
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	/**
	* Convert the given value in bytes into a string or parse to string to an integer in bytes.
	*
	* @param {string|number} value
	* @param {{
	*  case: [string],
	*  decimalPlaces: [number]
	*  fixedDecimals: [boolean]
	*  thousandsSeparator: [string]
	*  unitSeparator: [string]
	*  }} [options] bytes options.
	*
	* @returns {string|number|null}
	*/
	function bytes(value, options) {
		if (typeof value === "string") return parse(value);
		if (typeof value === "number") return format(value, options);
		return null;
	}
	/**
	* Format the given value in bytes into a string.
	*
	* If the value is negative, it is kept as such. If it is a float,
	* it is rounded.
	*
	* @param {number} value
	* @param {object} [options]
	* @param {number} [options.decimalPlaces=2]
	* @param {number} [options.fixedDecimals=false]
	* @param {string} [options.thousandsSeparator=]
	* @param {string} [options.unit=]
	* @param {string} [options.unitSeparator=]
	*
	* @returns {string|null}
	* @public
	*/
	function format(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str = str.split(".").map(function(s, i) {
			return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
		}).join(".");
		return str + unitSeparator + unit;
	}
	/**
	* Parse the string value into an integer in bytes.
	*
	* If no unit is given, it is assumed the value is in bytes.
	*
	* @param {number|string} val
	*
	* @returns {number|null}
	* @public
	*/
	function parse(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js
/*!
* content-type
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_content_type = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	*/
	var QUOTE_REGEXP = /([\\"])/g;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* Module exports.
	* @public
	*/
	exports.format = format;
	exports.parse = parse;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @public
	*/
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || !TYPE_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = type;
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				if (!TOKEN_REGEXP.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @public
	*/
	function parse(string) {
		if (!string) throw new TypeError("argument string is required");
		var header = typeof string === "object" ? getcontenttype(string) : string;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index = header.indexOf(";");
		var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (!TYPE_REGEXP.test(type)) throw new TypeError("invalid media type");
		var obj = new ContentType(type.toLowerCase());
		if (index !== -1) {
			var key;
			var match;
			var value;
			PARAM_REGEXP.lastIndex = index;
			while (match = PARAM_REGEXP.exec(header)) {
				if (match.index !== index) throw new TypeError("invalid parameter format");
				index += match[0].length;
				key = match[1].toLowerCase();
				value = match[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP, "$1");
				}
				obj.parameters[key] = value;
			}
			if (index !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @private
	*/
	function getcontenttype(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring(val) {
		var str = String(val);
		if (TOKEN_REGEXP.test(str)) return str;
		if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	/**
	* Class to represent a content type.
	* @private
	*/
	function ContentType(type) {
		this.parameters = Object.create(null);
		this.type = type;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js
var require_setprototypeof = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}
	function mixinProperties(obj, proto) {
		for (var prop in proto) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
		return obj;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js
/*!
* statuses
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_statuses = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Create a map of message to status code.
	* @private
	*/
	function createMessageToStatusCodeMap(codes) {
		var map = {};
		Object.keys(codes).forEach(function forEachCode(code) {
			var message = codes[code];
			var status = Number(code);
			map[message.toLowerCase()] = status;
		});
		return map;
	}
	/**
	* Create a list of all status codes.
	* @private
	*/
	function createStatusCodeList(codes) {
		return Object.keys(codes).map(function mapCode(code) {
			return Number(code);
		});
	}
	/**
	* Get the status code for given message.
	* @private
	*/
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	/**
	* Get the status message for given code.
	* @private
	*/
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error("invalid status code: " + code);
		return status.message[code];
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	try {
		var util$2 = require("util");
		/* istanbul ignore next */
		if (typeof util$2.inherits !== "function") throw "";
		module.exports = util$2.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js
/*!
* toidentifier
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_toidentifier = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = toIdentifier;
	/**
	* Trasform the given string into a JavaScript identifier
	*
	* @param {string} str
	* @returns {string}
	* @public
	*/
	function toIdentifier(str) {
		return str.split(" ").map(function(token) {
			return token.slice(0, 1).toUpperCase() + token.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/http-errors@2.0.1/node_modules/http-errors/index.js
/*!
* http-errors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_http_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("http-errors");
	var setPrototypeOf = require_setprototypeof();
	var statuses = require_statuses();
	var inherits = require_inherits();
	var toIdentifier = require_toidentifier();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createError;
	module.exports.HttpError = createHttpErrorConstructor();
	module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
	/**
	* Get the code class of a status code.
	* @private
	*/
	function codeClass(status) {
		return Number(String(status).charAt(0) + "00");
	}
	/**
	* Create a new HTTP Error.
	*
	* @returns {Error}
	* @public
	*/
	function createError() {
		var err;
		var msg;
		var status = 500;
		var props = {};
		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			var type = typeof arg;
			if (type === "object" && arg instanceof Error) {
				err = arg;
				status = err.status || err.statusCode || status;
			} else if (type === "number" && i === 0) status = arg;
			else if (type === "string") msg = arg;
			else if (type === "object") props = arg;
			else throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
		}
		if (typeof status === "number" && (status < 400 || status >= 600)) deprecate("non-error status code; use only 4xx or 5xx status codes");
		if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) status = 500;
		var HttpError = createError[status] || createError[codeClass(status)];
		if (!err) {
			err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
			Error.captureStackTrace(err, createError);
		}
		if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
			err.expose = status < 500;
			err.status = err.statusCode = status;
		}
		for (var key in props) if (key !== "status" && key !== "statusCode") err[key] = props[key];
		return err;
	}
	/**
	* Create HTTP error abstract base class.
	* @private
	*/
	function createHttpErrorConstructor() {
		function HttpError() {
			throw new TypeError("cannot construct abstract class");
		}
		inherits(HttpError, Error);
		return HttpError;
	}
	/**
	* Create a constructor for a client error.
	* @private
	*/
	function createClientErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ClientError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ClientError);
			setPrototypeOf(err, ClientError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ClientError, HttpError);
		nameFunc(ClientError, className);
		ClientError.prototype.status = code;
		ClientError.prototype.statusCode = code;
		ClientError.prototype.expose = true;
		return ClientError;
	}
	/**
	* Create function to test is a value is a HttpError.
	* @private
	*/
	function createIsHttpErrorFunction(HttpError) {
		return function isHttpError(val) {
			if (!val || typeof val !== "object") return false;
			if (val instanceof HttpError) return true;
			return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
		};
	}
	/**
	* Create a constructor for a server error.
	* @private
	*/
	function createServerErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ServerError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ServerError);
			setPrototypeOf(err, ServerError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ServerError, HttpError);
		nameFunc(ServerError, className);
		ServerError.prototype.status = code;
		ServerError.prototype.statusCode = code;
		ServerError.prototype.expose = false;
		return ServerError;
	}
	/**
	* Set the name of a function, if possible.
	* @private
	*/
	function nameFunc(func, name) {
		var desc = Object.getOwnPropertyDescriptor(func, "name");
		if (desc && desc.configurable) {
			desc.value = name;
			Object.defineProperty(func, "name", desc);
		}
	}
	/**
	* Populate the exports object with constructors for every error class.
	* @private
	*/
	function populateConstructorExports(exports$1, codes, HttpError) {
		codes.forEach(function forEachCode(code) {
			var CodeError;
			var name = toIdentifier(statuses.message[code]);
			switch (codeClass(code)) {
				case 400:
					CodeError = createClientErrorConstructor(HttpError, name, code);
					break;
				case 500:
					CodeError = createServerErrorConstructor(HttpError, name, code);
					break;
			}
			if (CodeError) {
				exports$1[code] = CodeError;
				exports$1[name] = CodeError;
			}
		});
	}
	/**
	* Get a class name from a name identifier.
	*
	* @param {string} name
	* @returns {string}
	* @private
	*/
	function toClassName(name) {
		return name.slice(-5) === "Error" ? name : name + "Error";
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js
var require_ms$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n, name) {
		if (ms < n) return;
		if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
		return Math.ceil(ms / n) + " " + name + "s";
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js
var require_debug = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms$1();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i;
		for (i in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug() {
			if (!debug.enabled) return;
			var self = debug;
			var curr = +/* @__PURE__ */ new Date();
			self.diff = curr - (prevTime || curr);
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self, args);
			(debug.log || exports.log || console.log.bind(console)).apply(self, args);
		}
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug);
		return debug;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i = 0; i < len; i++) {
			if (!split[i]) continue;
			namespaces = split[i].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
		for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var useColors = this.useColors;
		args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ("%%" === match) return;
			index++;
			if ("%c" === match) lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty$1 = require("tty");
	var util$1 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$1.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$1.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$1.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$1.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log() {
		return stream.write(util$1.format.apply(util$1, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream(fd) {
		var stream;
		switch (process.binding("tty_wrap").guessHandleType(fd)) {
			case "TTY":
				stream = new tty$1.WriteStream(fd);
				stream._type = "tty";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			case "FILE":
				stream = new (require("fs")).SyncWriteStream(fd, { autoClose: false });
				stream._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream = new (require("net")).Socket({
					fd,
					readable: false,
					writable: true
				});
				stream.readable = false;
				stream.read = null;
				stream._type = "pipe";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream.fd = fd;
		stream._isStdio = true;
		return stream;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}));

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js
var require_src = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser();
	else module.exports = require_node();
}));

//#endregion
//#region ../../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js
/*!
* destroy
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_destroy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var EventEmitter$4 = require("events").EventEmitter;
	var ReadStream = require("fs").ReadStream;
	var Stream$1 = require("stream");
	var Zlib = require("zlib");
	/**
	* Module exports.
	* @public
	*/
	module.exports = destroy;
	/**
	* Destroy the given stream, and optionally suppress any future `error` events.
	*
	* @param {object} stream
	* @param {boolean} suppress
	* @public
	*/
	function destroy(stream, suppress) {
		if (isFsReadStream(stream)) destroyReadStream(stream);
		else if (isZlibStream(stream)) destroyZlibStream(stream);
		else if (hasDestroy(stream)) stream.destroy();
		if (isEventEmitter(stream) && suppress) {
			stream.removeAllListeners("error");
			stream.addListener("error", noop);
		}
		return stream;
	}
	/**
	* Destroy a ReadStream.
	*
	* @param {object} stream
	* @private
	*/
	function destroyReadStream(stream) {
		stream.destroy();
		if (typeof stream.close === "function") stream.on("open", onOpenClose);
	}
	/**
	* Close a Zlib stream.
	*
	* Zlib streams below Node.js 4.5.5 have a buggy implementation
	* of .close() when zlib encountered an error.
	*
	* @param {object} stream
	* @private
	*/
	function closeZlibStream(stream) {
		if (stream._hadError === true) {
			var prop = stream._binding === null ? "_binding" : "_handle";
			stream[prop] = { close: function() {
				this[prop] = null;
			} };
		}
		stream.close();
	}
	/**
	* Destroy a Zlib stream.
	*
	* Zlib streams don't have a destroy function in Node.js 6. On top of that
	* simply calling destroy on a zlib stream in Node.js 8+ will result in a
	* memory leak. So until that is fixed, we need to call both close AND destroy.
	*
	* PR to fix memory leak: https://github.com/nodejs/node/pull/23734
	*
	* In Node.js 6+8, it's important that destroy is called before close as the
	* stream would otherwise emit the error 'zlib binding closed'.
	*
	* @param {object} stream
	* @private
	*/
	function destroyZlibStream(stream) {
		if (typeof stream.destroy === "function")
 // istanbul ignore if: node.js 0.8
		if (stream._binding) {
			stream.destroy();
			if (stream._processing) {
				stream._needDrain = true;
				stream.once("drain", onDrainClearBinding);
			} else stream._binding.clear();
		} else if (stream._destroy && stream._destroy !== Stream$1.Transform.prototype._destroy) stream.destroy();
		else if (stream._destroy && typeof stream.close === "function") {
			stream.destroyed = true;
			stream.close();
		} else
 // istanbul ignore next
		stream.destroy();
		else if (typeof stream.close === "function") closeZlibStream(stream);
	}
	/**
	* Determine if stream has destroy.
	* @private
	*/
	function hasDestroy(stream) {
		return stream instanceof Stream$1 && typeof stream.destroy === "function";
	}
	/**
	* Determine if val is EventEmitter.
	* @private
	*/
	function isEventEmitter(val) {
		return val instanceof EventEmitter$4;
	}
	/**
	* Determine if stream is fs.ReadStream stream.
	* @private
	*/
	function isFsReadStream(stream) {
		return stream instanceof ReadStream;
	}
	/**
	* Determine if stream is Zlib stream.
	* @private
	*/
	function isZlibStream(stream) {
		return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
	}
	/**
	* No-op function.
	* @private
	*/
	function noop() {}
	/**
	* On drain handler to clear binding.
	* @private
	*/
	// istanbul ignore next: node.js 0.8
	function onDrainClearBinding() {
		this._binding.clear();
	}
	/**
	* On open handler to close stream.
	* @private
	*/
	function onOpenClose() {
		if (typeof this.fd === "number") this.close();
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer$1 = require("buffer");
	var Buffer = buffer$1.Buffer;
	var safer = {};
	var key;
	for (key in buffer$1) {
		if (!buffer$1.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer$1[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer) {
		if (!Buffer.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer[key];
	}
	safer.Buffer.prototype = Buffer.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = /* @__PURE__ */ __commonJSMin(((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js
var require_internal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = require("string_decoder").StringDecoder;
	if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
	function InternalDecoder(options, codec) {
		StringDecoder.call(this, codec.enc);
	}
	InternalDecoder.prototype = StringDecoder.prototype;
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var charCode = str.charCodeAt(i);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
		for (var i = 0; i < buf.length; i++) {
			var curByte = buf[i];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer.from(str, "ucs2");
		for (var i = 0; i < buf.length; i += 2) {
			var tmp = buf[i];
			buf[i] = buf[i + 1];
			buf[i + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer.alloc(buf.length + 1), i = 0, j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i = 1;
			j = 2;
		}
		for (; i < buf.length - 1; i += 2, j += 2) {
			buf2[j] = buf[i + 1];
			buf2[j + 1] = buf[i];
		}
		this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBytes = [];
		this.initialBytesLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBytes.push(buf);
			this.initialBytesLen += buf.length;
			if (this.initialBytesLen < 16) return "";
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			this.initialBytes.length = this.initialBytesLen = 0;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var res = this.decoder.write(buf), trail = this.decoder.end();
			return trail ? res + trail : res;
		}
		return this.decoder.end();
	};
	function detectEncoding(buf, defaultEncoding) {
		var enc = defaultEncoding || "utf-16le";
		if (buf.length >= 2) if (buf[0] == 254 && buf[1] == 255) enc = "utf-16be";
		else if (buf[0] == 255 && buf[1] == 254) enc = "utf-16le";
		else {
			var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
			for (var i = 0; i < _len; i += 2) {
				if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
				if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
			}
			if (asciiCharsBE > asciiCharsLE) enc = "utf-16be";
			else if (asciiCharsBE < asciiCharsLE) enc = "utf-16le";
		}
		return enc;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "+";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString();
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString();
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer.alloc(str.length * 5 + 10), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var uChar = str.charCodeAt(i);
			if (32 <= uChar && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer.alloc(10), bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "&";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, "/");
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
		for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length);
		for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer.alloc(buf.length * 2);
		var idx1 = 0, idx2 = 0;
		for (var i = 0; i < buf.length; i++) {
			idx1 = buf[i] * 2;
			idx2 = i * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"10029": "maccenteuro",
		"maccenteuro": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"808": "cp808",
		"ibm808": "cp808",
		"cp808": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"mik": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii8bit": "ascii",
		"usascii": "ascii",
		"ansix34": "ascii",
		"ansix341968": "ascii",
		"ansix341986": "ascii",
		"csascii": "ascii",
		"cp367": "ascii",
		"ibm367": "ascii",
		"isoir6": "ascii",
		"iso646us": "ascii",
		"iso646irv": "ascii",
		"us": "ascii",
		"latin1": "iso88591",
		"latin2": "iso88592",
		"latin3": "iso88593",
		"latin4": "iso88594",
		"latin5": "iso88599",
		"latin6": "iso885910",
		"latin7": "iso885913",
		"latin8": "iso885914",
		"latin9": "iso885915",
		"latin10": "iso885916",
		"csisolatin1": "iso88591",
		"csisolatin2": "iso88592",
		"csisolatin3": "iso88593",
		"csisolatin4": "iso88594",
		"csisolatincyrillic": "iso88595",
		"csisolatinarabic": "iso88596",
		"csisolatingreek": "iso88597",
		"csisolatinhebrew": "iso88598",
		"csisolatin5": "iso88599",
		"csisolatin6": "iso885910",
		"l1": "iso88591",
		"l2": "iso88592",
		"l3": "iso88593",
		"l4": "iso88594",
		"l5": "iso88599",
		"l6": "iso885910",
		"l7": "iso885913",
		"l8": "iso885914",
		"l9": "iso885915",
		"l10": "iso885916",
		"isoir14": "iso646jp",
		"isoir57": "iso646cn",
		"isoir100": "iso88591",
		"isoir101": "iso88592",
		"isoir109": "iso88593",
		"isoir110": "iso88594",
		"isoir144": "iso88595",
		"isoir127": "iso88596",
		"isoir126": "iso88597",
		"isoir138": "iso88598",
		"isoir148": "iso88599",
		"isoir157": "iso885910",
		"isoir166": "tis620",
		"isoir179": "iso885913",
		"isoir199": "iso885914",
		"isoir203": "iso885915",
		"isoir226": "iso885916",
		"cp819": "iso88591",
		"ibm819": "iso88591",
		"cyrillic": "iso88595",
		"arabic": "iso88596",
		"arabic8": "iso88596",
		"ecma114": "iso88596",
		"asmo708": "iso88596",
		"greek": "iso88597",
		"greek8": "iso88597",
		"ecma118": "iso88597",
		"elot928": "iso88597",
		"hebrew": "iso88598",
		"hebrew8": "iso88598",
		"turkish": "iso88599",
		"turkish8": "iso88599",
		"thai": "iso885911",
		"thai8": "iso885911",
		"celtic": "iso885914",
		"celtic8": "iso885914",
		"isoceltic": "iso885914",
		"tis6200": "tis620",
		"tis62025291": "tis620",
		"tis62025330": "tis620",
		"10000": "macroman",
		"10006": "macgreek",
		"10007": "maccyrillic",
		"10079": "maciceland",
		"10081": "macturkish",
		"cspc8codepage437": "cp437",
		"cspc775baltic": "cp775",
		"cspc850multilingual": "cp850",
		"cspcp852": "cp852",
		"cspc862latinhebrew": "cp862",
		"cpgr": "cp869",
		"msee": "cp1250",
		"mscyrl": "cp1251",
		"msansi": "cp1252",
		"msgreek": "cp1253",
		"msturk": "cp1254",
		"mshebr": "cp1255",
		"msarab": "cp1256",
		"winbaltrim": "cp1257",
		"cp20866": "koi8r",
		"20866": "koi8r",
		"ibm878": "koi8r",
		"cskoi8r": "koi8r",
		"cp21866": "koi8u",
		"21866": "koi8u",
		"ibm1168": "koi8u",
		"strk10482002": "rk1048",
		"tcvn5712": "tcvn",
		"tcvn57121": "tcvn",
		"gb198880": "iso646cn",
		"cn": "iso646cn",
		"csiso14jisc6220ro": "iso646jp",
		"jisc62201969ro": "iso646jp",
		"jp": "iso646jp",
		"cshproman8": "hproman8",
		"r8": "hproman8",
		"roman8": "hproman8",
		"xroman8": "hproman8",
		"ibm1051": "hproman8",
		"mac": "macintosh",
		"csmacintosh": "macintosh"
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
	for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
		this.defaultCharUnicode = iconv.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
			var val = codecOptions.encodeSkipVals[i];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var thirdByteNodeIdx = this.decodeTables.length;
			var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			var fourthByteNodeIdx = this.decodeTables.length;
			var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			for (var i = 129; i <= 254; i++) {
				var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
				var secondByteNode = this.decodeTables[secondByteNodeIdx];
				for (var j = 48; j <= 57; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
			}
			for (var i = 129; i <= 254; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
			for (var i = 48; i <= 57; i++) fourthByteNode[i] = GB18030_CODE;
		}
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes = [];
		for (; addr > 0; addr >>= 8) bytes.push(addr & 255);
		if (bytes.length == 0) bytes.push(0);
		var node = this.decodeTables[0];
		for (var i = bytes.length - 1; i > 0; i--) {
			var val = node[bytes[i]];
			if (val == UNASSIGNED) {
				node[bytes[i]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (55296 <= code && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (4080 < code && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		for (var i = 0; i < 256; i++) {
			var uCode = node[i];
			var mbCode = prefix + i;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
			else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
			else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
		}
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i == str.length) break;
				var uCode = str.charCodeAt(i++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (55296 <= uCode && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode == "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer.alloc(10), j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBuf = Buffer.alloc(0);
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
		if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
		for (var i = 0, j = 0; i < buf.length; i++) {
			var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				i = seqStart;
				uCode = this.defaultCharUnicode.charCodeAt(0);
			} else if (uCode === GB18030_CODE) {
				var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
				var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode > 65535) {
				uCode -= 65536;
				var uCodeLead = 55296 + Math.floor(uCode / 1024);
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 + uCode % 1024;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBuf.length > 0) {
			ret += this.defaultCharUnicode;
			var buf = this.prevBuf.slice(1);
			this.prevBuf = Buffer.alloc(0);
			this.nodeIdx = 0;
			if (buf.length > 0) ret += this.write(buf);
		}
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0, r = table.length;
		while (l < r - 1) {
			var mid = l + Math.floor((r - l + 1) / 2);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"shiftjis": {
			type: "_dbcs",
			table: function() {
				return require_shiftjis();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		"csshiftjis": "shiftjis",
		"mskanji": "shiftjis",
		"sjis": "shiftjis",
		"windows31j": "shiftjis",
		"ms31j": "shiftjis",
		"xsjis": "shiftjis",
		"windows932": "shiftjis",
		"ms932": "shiftjis",
		"932": "shiftjis",
		"cp932": "shiftjis",
		"eucjp": {
			type: "_dbcs",
			table: function() {
				return require_eucjp();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		"gb2312": "cp936",
		"gb231280": "cp936",
		"gb23121980": "cp936",
		"csgb2312": "cp936",
		"csiso58gb231280": "cp936",
		"euccn": "cp936",
		"windows936": "cp936",
		"ms936": "cp936",
		"936": "cp936",
		"cp936": {
			type: "_dbcs",
			table: function() {
				return require_cp936();
			}
		},
		"gbk": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			}
		},
		"xgbk": "gbk",
		"isoir58": "gbk",
		"gb18030": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			},
			gb18030: function() {
				return require_gb18030_ranges();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		"chinese": "gb18030",
		"windows949": "cp949",
		"ms949": "cp949",
		"949": "cp949",
		"cp949": {
			type: "_dbcs",
			table: function() {
				return require_cp949();
			}
		},
		"cseuckr": "cp949",
		"csksc56011987": "cp949",
		"euckr": "cp949",
		"isoir149": "cp949",
		"korean": "cp949",
		"ksc56011987": "cp949",
		"ksc56011989": "cp949",
		"ksc5601": "cp949",
		"windows950": "cp950",
		"ms950": "cp950",
		"950": "cp950",
		"cp950": {
			type: "_dbcs",
			table: function() {
				return require_cp950();
			}
		},
		"big5": "big5hkscs",
		"big5hkscs": {
			type: "_dbcs",
			table: function() {
				return require_cp950().concat(require_big5_added());
			},
			encodeSkipVals: [41676]
		},
		"cnbig5": "big5hkscs",
		"csbig5": "big5hkscs",
		"xxbig5": "big5hkscs"
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js
var require_encodings = /* @__PURE__ */ __commonJSMin(((exports) => {
	var modules = [
		require_internal(),
		require_utf16(),
		require_utf7(),
		require_sbcs_codec(),
		require_sbcs_data(),
		require_sbcs_data_generated(),
		require_dbcs_codec(),
		require_dbcs_data()
	];
	for (var i = 0; i < modules.length; i++) {
		var module = modules[i];
		for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js
var require_streams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$3 = require("buffer").Buffer, Transform = require("stream").Transform;
	module.exports = function(iconv) {
		iconv.encodeStream = function encodeStream(encoding, options) {
			return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
		};
		iconv.decodeStream = function decodeStream(encoding, options) {
			return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
		};
		iconv.supportsStreams = true;
		iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
		iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
		iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};
	function IconvLiteEncoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.decodeStrings = false;
		Transform.call(this, options);
	}
	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
		if (typeof chunk != "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype.collect = function(cb) {
		var chunks = [];
		this.on("error", cb);
		this.on("data", function(chunk) {
			chunks.push(chunk);
		});
		this.on("end", function() {
			cb(null, Buffer$3.concat(chunks));
		});
		return this;
	};
	function IconvLiteDecoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.encoding = this.encoding = "utf8";
		Transform.call(this, options);
	}
	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
		if (!Buffer$3.isBuffer(chunk)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype.collect = function(cb) {
		var res = "";
		this.on("error", cb);
		this.on("data", function(chunk) {
			res += chunk;
		});
		this.on("end", function() {
			cb(null, res);
		});
		return this;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$2 = require("buffer").Buffer;
	module.exports = function(iconv) {
		var original = void 0;
		iconv.supportsNodeEncodingsExtension = !(Buffer$2.from || new Buffer$2(0) instanceof Uint8Array);
		iconv.extendNodeEncodings = function extendNodeEncodings() {
			if (original) return;
			original = {};
			if (!iconv.supportsNodeEncodingsExtension) {
				console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
				console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
				return;
			}
			var nodeNativeEncodings = {
				"hex": true,
				"utf8": true,
				"utf-8": true,
				"ascii": true,
				"binary": true,
				"base64": true,
				"ucs2": true,
				"ucs-2": true,
				"utf16le": true,
				"utf-16le": true
			};
			Buffer$2.isNativeEncoding = function(enc) {
				return enc && nodeNativeEncodings[enc.toLowerCase()];
			};
			var SlowBuffer = require("buffer").SlowBuffer;
			original.SlowBufferToString = SlowBuffer.prototype.toString;
			SlowBuffer.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.SlowBufferWrite = SlowBuffer.prototype.write;
			SlowBuffer.prototype.write = function(string, offset, length, encoding) {
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			original.BufferIsEncoding = Buffer$2.isEncoding;
			Buffer$2.isEncoding = function(encoding) {
				return Buffer$2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
			};
			original.BufferByteLength = Buffer$2.byteLength;
			Buffer$2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
				return iconv.encode(str, encoding).length;
			};
			original.BufferToString = Buffer$2.prototype.toString;
			Buffer$2.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.BufferWrite = Buffer$2.prototype.write;
			Buffer$2.prototype.write = function(string, offset, length, encoding) {
				var _offset = offset, _length = length, _encoding = encoding;
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				original.ReadableSetEncoding = Readable.prototype.setEncoding;
				Readable.prototype.setEncoding = function setEncoding(enc, options) {
					this._readableState.decoder = iconv.getDecoder(enc, options);
					this._readableState.encoding = enc;
				};
				Readable.prototype.collect = iconv._collect;
			}
		};
		iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
			if (!iconv.supportsNodeEncodingsExtension) return;
			if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
			delete Buffer$2.isNativeEncoding;
			var SlowBuffer = require("buffer").SlowBuffer;
			SlowBuffer.prototype.toString = original.SlowBufferToString;
			SlowBuffer.prototype.write = original.SlowBufferWrite;
			Buffer$2.isEncoding = original.BufferIsEncoding;
			Buffer$2.byteLength = original.BufferByteLength;
			Buffer$2.prototype.toString = original.BufferToString;
			Buffer$2.prototype.write = original.BufferWrite;
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				Readable.prototype.setEncoding = original.ReadableSetEncoding;
				delete Readable.prototype.collect;
			}
			original = void 0;
		};
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	var bomHandling = require_bom_handling(), iconv = module.exports;
	iconv.encodings = null;
	iconv.defaultCharUnicode = "";
	iconv.defaultCharSingleByte = "?";
	iconv.encode = function encode(str, encoding, options) {
		str = "" + (str || "");
		var encoder = iconv.getEncoder(encoding, options);
		var res = encoder.write(str);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
	};
	iconv.decode = function decode(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv.skipDecodeWarning = true;
			}
			buf = Buffer.from("" + (buf || ""), "binary");
		}
		var decoder = iconv.getDecoder(encoding, options);
		var res = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res + trail : res;
	};
	iconv.encodingExists = function encodingExists(enc) {
		try {
			iconv.getCodec(enc);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;
	iconv._codecDataCache = {};
	iconv.getCodec = function getCodec(encoding) {
		if (!iconv.encodings) iconv.encodings = require_encodings();
		var enc = iconv._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv._codecDataCache[enc];
			if (codec) return codec;
			var codecDef = iconv.encodings[enc];
			switch (typeof codecDef) {
				case "string":
					enc = codecDef;
					break;
				case "object":
					for (var key in codecDef) codecOptions[key] = codecDef[key];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					enc = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					codec = new codecDef(codecOptions, iconv);
					iconv._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
			}
		}
	};
	iconv._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv.getDecoder = function getDecoder(encoding, options) {
		var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
	if (nodeVer) {
		var nodeVerArr = nodeVer.split(".").map(Number);
		if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) require_streams()(iconv);
		require_extend_node()(iconv);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
/*!
* unpipe
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_unpipe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream) {
		var listeners = stream.listeners("data");
		for (var i = 0; i < listeners.length; i++) if (listeners[i].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe(stream) {
		if (!stream) throw new TypeError("argument stream is required");
		if (typeof stream.unpipe === "function") {
			stream.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream)) return;
		var listener;
		var listeners = stream.listeners("close");
		for (var i = 0; i < listeners.length; i++) {
			listener = listeners[i];
			if (listener.name !== "cleanup" && listener.name !== "onclose") continue;
			listener.call(stream);
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/raw-body@2.5.3/node_modules/raw-body/index.js
/*!
* raw-body
* Copyright(c) 2013-2014 Jonathan Ong
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_raw_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks$1();
	var bytes = require_bytes();
	var createError = require_http_errors();
	var iconv = require_lib$1();
	var unpipe = require_unpipe();
	/**
	* Module exports.
	* @public
	*/
	module.exports = getRawBody;
	/**
	* Module variables.
	* @private
	*/
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	/**
	* Get the decoder for a given encoding.
	*
	* @param {string} encoding
	* @private
	*/
	function getDecoder(encoding) {
		if (!encoding) return null;
		try {
			return iconv.getDecoder(encoding);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError(415, "specified encoding unsupported", {
				encoding,
				type: "encoding.unsupported"
			});
		}
	}
	/**
	* Get the raw body of a stream (typically HTTP).
	*
	* @param {object} stream
	* @param {object|string|function} [options]
	* @param {function} [callback]
	* @public
	*/
	function getRawBody(stream, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !global.Promise) throw new TypeError("argument callback is required");
		var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit = bytes.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream(stream, encoding, length, limit, wrap(done));
		return new Promise(function executor(resolve, reject) {
			readStream(stream, encoding, length, limit, function onRead(err, buf) {
				if (err) return reject(err);
				resolve(buf);
			});
		});
	}
	/**
	* Halt a stream.
	*
	* @param {Object} stream
	* @private
	*/
	function halt(stream) {
		unpipe(stream);
		if (typeof stream.pause === "function") stream.pause();
	}
	/**
	* Read the data from the stream.
	*
	* @param {object} stream
	* @param {string} encoding
	* @param {number} length
	* @param {number} limit
	* @param {function} callback
	* @public
	*/
	function readStream(stream, encoding, length, limit, callback) {
		var complete = false;
		var sync = true;
		if (limit !== null && length !== null && length > limit) return done(createError(413, "request entity too large", {
			expected: length,
			length,
			limit,
			type: "entity.too.large"
		}));
		var state = stream._readableState;
		if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream.readable !== "undefined" && !stream.readable) return done(createError(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding);
		} catch (err) {
			return done(err);
		}
		var buffer = decoder ? "" : [];
		stream.on("aborted", onAborted);
		stream.on("close", cleanup);
		stream.on("data", onData);
		stream.on("end", onEnd);
		stream.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit !== null && received > limit) done(createError(413, "request entity too large", {
				limit,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer += decoder.write(chunk);
			else buffer.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else done(null, decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer));
		}
		function cleanup() {
			buffer = null;
			stream.removeListener("aborted", onAborted);
			stream.removeListener("data", onData);
			stream.removeListener("end", onEnd);
			stream.removeListener("error", onEnd);
			stream.removeListener("close", cleanup);
		}
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks$1() {
		try {
			return require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js
/*!
* ee-first
* Copyright(c) 2014 Jonathan Ong
* MIT Licensed
*/
var require_ee_first = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = first;
	/**
	* Get the first event in a set of event emitters and event pairs.
	*
	* @param {array} stuff
	* @param {function} done
	* @public
	*/
	function first(stuff, done) {
		if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");
		var cleanups = [];
		for (var i = 0; i < stuff.length; i++) {
			var arr = stuff[i];
			if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");
			var ee = arr[0];
			for (var j = 1; j < arr.length; j++) {
				var event = arr[j];
				var fn = listener(event, callback);
				ee.on(event, fn);
				cleanups.push({
					ee,
					event,
					fn
				});
			}
		}
		function callback() {
			cleanup();
			done.apply(null, arguments);
		}
		function cleanup() {
			var x;
			for (var i = 0; i < cleanups.length; i++) {
				x = cleanups[i];
				x.ee.removeListener(x.event, x.fn);
			}
		}
		function thunk(fn) {
			done = fn;
		}
		thunk.cancel = cleanup;
		return thunk;
	}
	/**
	* Create the event listener.
	* @private
	*/
	function listener(event, done) {
		return function onevent(arg1) {
			var args = new Array(arguments.length);
			var ee = this;
			var err = event === "error" ? arg1 : null;
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			done(err, ee, event, args);
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js
/*!
* on-finished
* Copyright(c) 2013 Jonathan Ong
* Copyright(c) 2014 Douglas Christopher Wilson
* MIT Licensed
*/
var require_on_finished = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onFinished;
	module.exports.isFinished = isFinished;
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks();
	var first = require_ee_first();
	/**
	* Variables.
	* @private
	*/
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Invoke callback when the response has finished, useful for
	* cleaning up resources afterwards.
	*
	* @param {object} msg
	* @param {function} listener
	* @return {object}
	* @public
	*/
	function onFinished(msg, listener) {
		if (isFinished(msg) !== false) {
			defer(listener, null, msg);
			return msg;
		}
		attachListener(msg, wrap(listener));
		return msg;
	}
	/**
	* Determine if message is already finished.
	*
	* @param {object} msg
	* @return {boolean}
	* @public
	*/
	function isFinished(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	/**
	* Attach a finished listener to the message.
	*
	* @param {object} msg
	* @param {function} callback
	* @private
	*/
	function attachFinishedListener(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error);
		}
		eeMsg = eeSocket = first([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0)
 // istanbul ignore next: node.js 0.8 patch
		patchAssignSocket(msg, onSocket);
	}
	/**
	* Attach the listener to the message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function attachListener(msg, listener) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener(msg);
			attachFinishedListener(msg, attached);
		}
		attached.queue.push(listener);
	}
	/**
	* Create listener on message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function createListener(msg) {
		function listener(err) {
			if (msg.__onFinished === listener) msg.__onFinished = null;
			if (!listener.queue) return;
			var queue = listener.queue;
			listener.queue = null;
			for (var i = 0; i < queue.length; i++) queue[i](err, msg);
		}
		listener.queue = [];
		return listener;
	}
	/**
	* Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	*
	* @param {ServerResponse} res
	* @param {function} callback
	* @private
	*/
	// istanbul ignore next: node.js 0.8 patch
	function patchAssignSocket(res, callback) {
		var assignSocket = res.assignSocket;
		if (typeof assignSocket !== "function") return;
		res.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks() {
		try {
			return require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/lib/read.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_read = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError = require_http_errors();
	var destroy = require_destroy();
	var getBody = require_raw_body();
	var iconv = require_lib$1();
	var onFinished = require_on_finished();
	var unpipe = require_unpipe();
	var zlib$1 = require("zlib");
	/**
	* Module exports.
	*/
	module.exports = read;
	/**
	* Read a request into a buffer and parse.
	*
	* @param {object} req
	* @param {object} res
	* @param {function} next
	* @param {function} parse
	* @param {function} debug
	* @param {object} options
	* @private
	*/
	function read(req, res, next, parse, debug, options) {
		var length;
		var opts = options;
		var stream;
		req._body = true;
		var encoding = opts.encoding !== null ? opts.encoding : null;
		var verify = opts.verify;
		try {
			stream = contentstream(req, debug, opts.inflate);
			length = stream.length;
			stream.length = void 0;
		} catch (err) {
			return next(err);
		}
		opts.length = length;
		opts.encoding = verify ? null : encoding;
		if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) return next(createError(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
			charset: encoding.toLowerCase(),
			type: "charset.unsupported"
		}));
		debug("read body");
		getBody(stream, opts, function(error, body) {
			if (error) {
				var _error;
				if (error.type === "encoding.unsupported") _error = createError(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
					charset: encoding.toLowerCase(),
					type: "charset.unsupported"
				});
				else _error = createError(400, error);
				if (stream !== req) {
					unpipe(req);
					destroy(stream, true);
				}
				dump(req, function onfinished() {
					next(createError(400, _error));
				});
				return;
			}
			if (verify) try {
				debug("verify body");
				verify(req, res, body, encoding);
			} catch (err) {
				next(createError(403, err, {
					body,
					type: err.type || "entity.verify.failed"
				}));
				return;
			}
			var str = body;
			try {
				debug("parse body");
				str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
				req.body = parse(str);
			} catch (err) {
				next(createError(400, err, {
					body: str,
					type: err.type || "entity.parse.failed"
				}));
				return;
			}
			next();
		});
	}
	/**
	* Get the content stream of the request.
	*
	* @param {object} req
	* @param {function} debug
	* @param {boolean} [inflate=true]
	* @return {object}
	* @api private
	*/
	function contentstream(req, debug, inflate) {
		var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
		var length = req.headers["content-length"];
		var stream;
		debug("content-encoding \"%s\"", encoding);
		if (inflate === false && encoding !== "identity") throw createError(415, "content encoding unsupported", {
			encoding,
			type: "encoding.unsupported"
		});
		switch (encoding) {
			case "deflate":
				stream = zlib$1.createInflate();
				debug("inflate body");
				req.pipe(stream);
				break;
			case "gzip":
				stream = zlib$1.createGunzip();
				debug("gunzip body");
				req.pipe(stream);
				break;
			case "identity":
				stream = req;
				stream.length = length;
				break;
			default: throw createError(415, "unsupported content encoding \"" + encoding + "\"", {
				encoding,
				type: "encoding.unsupported"
			});
		}
		return stream;
	}
	/**
	* Dump the contents of a request.
	*
	* @param {object} req
	* @param {function} callback
	* @api private
	*/
	function dump(req, callback) {
		if (onFinished.isFinished(req)) callback(null);
		else {
			onFinished(req, callback);
			req.resume();
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js
var require_media_typer = /* @__PURE__ */ __commonJSMin(((exports) => {
	/*!
	* media-typer
	* Copyright(c) 2014 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* SHT           = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	*/
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	*/
	var qescRegExp = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	*/
	var quoteRegExp = /([\\"])/g;
	/**
	* RegExp to match type in RFC 6838
	*
	* type-name = restricted-name
	* subtype-name = restricted-name
	* restricted-name = restricted-name-first *126restricted-name-chars
	* restricted-name-first  = ALPHA / DIGIT
	* restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	*                          "$" / "&" / "-" / "^" / "_"
	* restricted-name-chars =/ "." ; Characters before first dot always
	*                              ; specify a facet name
	* restricted-name-chars =/ "+" ; Characters after last plus always
	*                              ; specify a structured syntax suffix
	* ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	* DIGIT =  %x30-39             ; 0-9
	*/
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	/**
	* Module exports.
	*/
	exports.format = format;
	exports.parse = parse;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @api public
	*/
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var subtype = obj.subtype;
		var suffix = obj.suffix;
		var type = obj.type;
		if (!type || !typeNameRegExp.test(type)) throw new TypeError("invalid type");
		if (!subtype || !subtypeNameRegExp.test(subtype)) throw new TypeError("invalid subtype");
		var string = type + "/" + subtype;
		if (suffix) {
			if (!typeNameRegExp.test(suffix)) throw new TypeError("invalid suffix");
			string += "+" + suffix;
		}
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				if (!tokenRegExp.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @api public
	*/
	function parse(string) {
		if (!string) throw new TypeError("argument string is required");
		if (typeof string === "object") string = getcontenttype(string);
		if (typeof string !== "string") throw new TypeError("argument string is required to be a string");
		var index = string.indexOf(";");
		var type = index !== -1 ? string.substr(0, index) : string;
		var key;
		var match;
		var obj = splitType(type);
		var params = {};
		var value;
		paramRegExp.lastIndex = index;
		while (match = paramRegExp.exec(string)) {
			if (match.index !== index) throw new TypeError("invalid parameter format");
			index += match[0].length;
			key = match[1].toLowerCase();
			value = match[2];
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
			params[key] = value;
		}
		if (index !== -1 && index !== string.length) throw new TypeError("invalid parameter format");
		obj.parameters = params;
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @api private
	*/
	function getcontenttype(obj) {
		if (typeof obj.getHeader === "function") return obj.getHeader("content-type");
		if (typeof obj.headers === "object") return obj.headers && obj.headers["content-type"];
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @api private
	*/
	function qstring(val) {
		var str = String(val);
		if (tokenRegExp.test(str)) return str;
		if (str.length > 0 && !textRegExp.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(quoteRegExp, "\\$1") + "\"";
	}
	/**
	* Simply "type/subtype+siffx" into parts.
	*
	* @param {string} string
	* @return {Object}
	* @api private
	*/
	function splitType(string) {
		var match = typeRegExp.exec(string.toLowerCase());
		if (!match) throw new TypeError("invalid media type");
		var type = match[1];
		var subtype = match[2];
		var suffix;
		var index = subtype.lastIndexOf("+");
		if (index !== -1) {
			suffix = subtype.substr(index + 1);
			subtype = subtype.substr(0, index);
		}
		return {
			type,
			subtype,
			suffix
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"application/1d-interleaved-parityfec": { "source": "iana" },
		"application/3gpdash-qoe-report+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/3gpp-ims+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphalforms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/a2l": { "source": "iana" },
		"application/ace+cbor": { "source": "iana" },
		"application/activemessage": { "source": "iana" },
		"application/activity+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamcontrol+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": { "source": "iana" },
		"application/andrew-inset": {
			"source": "iana",
			"extensions": ["ez"]
		},
		"application/applefile": { "source": "iana" },
		"application/applixware": {
			"source": "apache",
			"extensions": ["aw"]
		},
		"application/at+jwt": { "source": "iana" },
		"application/atf": { "source": "iana" },
		"application/atfx": { "source": "iana" },
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atom"]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomcat"]
		},
		"application/atomdeleted+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomdeleted"]
		},
		"application/atomicmail": { "source": "iana" },
		"application/atomsvc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomsvc"]
		},
		"application/atsc-dwd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dwd"]
		},
		"application/atsc-dynamic-event-message": { "source": "iana" },
		"application/atsc-held+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["held"]
		},
		"application/atsc-rdt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/atsc-rsat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsat"]
		},
		"application/atxml": { "source": "iana" },
		"application/auth-policy+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/bacnet-xdd+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/batch-smtp": { "source": "iana" },
		"application/bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/beep+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xcs"]
		},
		"application/call-completion": { "source": "iana" },
		"application/cals-1840": { "source": "iana" },
		"application/captive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cbor": { "source": "iana" },
		"application/cbor-seq": { "source": "iana" },
		"application/cccex": { "source": "iana" },
		"application/ccmp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ccxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ccxml"]
		},
		"application/cdfx+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdfx"]
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": ["cdmia"]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": ["cdmic"]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": ["cdmid"]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": ["cdmio"]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": ["cdmiq"]
		},
		"application/cdni": { "source": "iana" },
		"application/cea": { "source": "iana" },
		"application/cea-2018+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cellml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cfw": { "source": "iana" },
		"application/city+json": {
			"source": "iana",
			"compressible": true
		},
		"application/clr": { "source": "iana" },
		"application/clue+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/clue_info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cms": { "source": "iana" },
		"application/cnrp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-payload": { "source": "iana" },
		"application/commonground": { "source": "iana" },
		"application/conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cose": { "source": "iana" },
		"application/cose-key": { "source": "iana" },
		"application/cose-key-set": { "source": "iana" },
		"application/cpl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cpl"]
		},
		"application/csrattrs": { "source": "iana" },
		"application/csta+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cstadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": ["cu"]
		},
		"application/cwt": { "source": "iana" },
		"application/cybercash": { "source": "iana" },
		"application/dart": { "compressible": true },
		"application/dash+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpd"]
		},
		"application/dash-patch+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpp"]
		},
		"application/dashdelta": { "source": "iana" },
		"application/davmount+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["davmount"]
		},
		"application/dca-rft": { "source": "iana" },
		"application/dcd": { "source": "iana" },
		"application/dec-dx": { "source": "iana" },
		"application/dialog-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom": { "source": "iana" },
		"application/dicom+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dii": { "source": "iana" },
		"application/dit": { "source": "iana" },
		"application/dns": { "source": "iana" },
		"application/dns+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dns-message": { "source": "iana" },
		"application/docbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dbk"]
		},
		"application/dots+cbor": { "source": "iana" },
		"application/dskpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": ["dssc"]
		},
		"application/dssc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdssc"]
		},
		"application/dvcs": { "source": "iana" },
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es", "ecma"]
		},
		"application/edi-consent": { "source": "iana" },
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": { "source": "iana" },
		"application/elm+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/elm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.cap+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.ecall.msd": { "source": "iana" },
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.veds+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emma+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emma"]
		},
		"application/emotionml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emotionml"]
		},
		"application/encaprtp": { "source": "iana" },
		"application/epp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/epub+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["epub"]
		},
		"application/eshop": { "source": "iana" },
		"application/exi": {
			"source": "iana",
			"extensions": ["exi"]
		},
		"application/expect-ct-report+json": {
			"source": "iana",
			"compressible": true
		},
		"application/express": {
			"source": "iana",
			"extensions": ["exp"]
		},
		"application/fastinfoset": { "source": "iana" },
		"application/fastsoap": { "source": "iana" },
		"application/fdt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fdt"]
		},
		"application/fhir+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fhir+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fido.trusted-apps+json": { "compressible": true },
		"application/fits": { "source": "iana" },
		"application/flexfec": { "source": "iana" },
		"application/font-sfnt": { "source": "iana" },
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": ["pfr"]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false
		},
		"application/framework-attributes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["geojson"]
		},
		"application/geo+json-seq": { "source": "iana" },
		"application/geopackage+sqlite3": { "source": "iana" },
		"application/geoxacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/gltf-buffer": { "source": "iana" },
		"application/gml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gml"]
		},
		"application/gpx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["gpx"]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": ["gxf"]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gz"]
		},
		"application/h224": { "source": "iana" },
		"application/held+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/hjson": { "extensions": ["hjson"] },
		"application/http": { "source": "iana" },
		"application/hyperstudio": {
			"source": "iana",
			"extensions": ["stk"]
		},
		"application/ibe-key-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pp-data": { "source": "iana" },
		"application/iges": { "source": "iana" },
		"application/im-iscomposing+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/index": { "source": "iana" },
		"application/index.cmd": { "source": "iana" },
		"application/index.obj": { "source": "iana" },
		"application/index.response": { "source": "iana" },
		"application/index.vnd": { "source": "iana" },
		"application/inkml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ink", "inkml"]
		},
		"application/iotp": { "source": "iana" },
		"application/ipfix": {
			"source": "iana",
			"extensions": ["ipfix"]
		},
		"application/ipp": { "source": "iana" },
		"application/isup": { "source": "iana" },
		"application/its+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["its"]
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": ["ser"]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["class"]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["js", "mjs"]
		},
		"application/jf2feed+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jose": { "source": "iana" },
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jscalendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["json", "map"]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": { "source": "iana" },
		"application/json5": { "extensions": ["json5"] },
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": ["jsonml"]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": { "source": "iana" },
		"application/kpml-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/kpml-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["jsonld"]
		},
		"application/lgr+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lgr"]
		},
		"application/link-format": { "source": "iana" },
		"application/load-control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lost+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lostxml"]
		},
		"application/lostsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lpf+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/lxf": { "source": "iana" },
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": ["hqx"]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": ["cpt"]
		},
		"application/macwriteii": { "source": "iana" },
		"application/mads+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mads"]
		},
		"application/manifest+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["webmanifest"]
		},
		"application/marc": {
			"source": "iana",
			"extensions": ["mrc"]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mrcx"]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mathml"]
		},
		"application/mathml-content+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mathml-presentation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-deregister+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-envelope+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-protection-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-reception-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-schedule+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbox": {
			"source": "iana",
			"extensions": ["mbox"]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpf"]
		},
		"application/media_control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mscml"]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["metalink"]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["meta4"]
		},
		"application/mets+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mets"]
		},
		"application/mf4": { "source": "iana" },
		"application/mikey": { "source": "iana" },
		"application/mipc": { "source": "iana" },
		"application/missing-blocks+cbor-seq": { "source": "iana" },
		"application/mmt-aei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["maei"]
		},
		"application/mmt-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musd"]
		},
		"application/mods+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mods"]
		},
		"application/moss-keys": { "source": "iana" },
		"application/moss-signature": { "source": "iana" },
		"application/mosskey-data": { "source": "iana" },
		"application/mosskey-request": { "source": "iana" },
		"application/mp21": {
			"source": "iana",
			"extensions": ["m21", "mp21"]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": ["mp4s", "m4p"]
		},
		"application/mpeg4-generic": { "source": "iana" },
		"application/mpeg4-iod": { "source": "iana" },
		"application/mpeg4-iod-xmt": { "source": "iana" },
		"application/mrb-consumer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mrb-publish+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/msc-ivr+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msc-mixer+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": ["doc", "dot"]
		},
		"application/mud+json": {
			"source": "iana",
			"compressible": true
		},
		"application/multipart-core": { "source": "iana" },
		"application/mxf": {
			"source": "iana",
			"extensions": ["mxf"]
		},
		"application/n-quads": {
			"source": "iana",
			"extensions": ["nq"]
		},
		"application/n-triples": {
			"source": "iana",
			"extensions": ["nt"]
		},
		"application/nasdata": { "source": "iana" },
		"application/news-checkgroups": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-groupinfo": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-transmission": { "source": "iana" },
		"application/nlsml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/node": {
			"source": "iana",
			"extensions": ["cjs"]
		},
		"application/nss": { "source": "iana" },
		"application/oauth-authz-req+jwt": { "source": "iana" },
		"application/oblivious-dns-message": { "source": "iana" },
		"application/ocsp-request": { "source": "iana" },
		"application/ocsp-response": { "source": "iana" },
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": ["oda"]
		},
		"application/odm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/odx": { "source": "iana" },
		"application/oebps-package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["opf"]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogx"]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["omdoc"]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/opc-nodeset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/oscore": { "source": "iana" },
		"application/oxps": {
			"source": "iana",
			"extensions": ["oxps"]
		},
		"application/p21": { "source": "iana" },
		"application/p21+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/p2p-overlay+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["relo"]
		},
		"application/parityfec": { "source": "iana" },
		"application/passport": { "source": "iana" },
		"application/patch-ops-error+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xer"]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pdf"]
		},
		"application/pdx": { "source": "iana" },
		"application/pem-certificate-chain": { "source": "iana" },
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pgp"]
		},
		"application/pgp-keys": {
			"source": "iana",
			"extensions": ["asc"]
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": ["asc", "sig"]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": ["prf"]
		},
		"application/pidf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pidf-diff+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": ["p10"]
		},
		"application/pkcs12": { "source": "iana" },
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": ["p7m", "p7c"]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": ["p7s"]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": ["p8"]
		},
		"application/pkcs8-encrypted": { "source": "iana" },
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": ["ac"]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": ["cer"]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": ["crl"]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": ["pkipath"]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": ["pki"]
		},
		"application/pls+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pls"]
		},
		"application/poc-settings+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/provenance+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["provx"]
		},
		"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
		"application/prs.cww": {
			"source": "iana",
			"extensions": ["cww"]
		},
		"application/prs.cyn": {
			"source": "iana",
			"charset": "7-BIT"
		},
		"application/prs.hpub+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/prs.nprend": { "source": "iana" },
		"application/prs.plucker": { "source": "iana" },
		"application/prs.rdf-xml-crypt": { "source": "iana" },
		"application/prs.xsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/pskc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pskcxml"]
		},
		"application/pvd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/qsig": { "source": "iana" },
		"application/raml+yaml": {
			"compressible": true,
			"extensions": ["raml"]
		},
		"application/raptorfec": { "source": "iana" },
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rdf", "owl"]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rif"]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": ["rnc"]
		},
		"application/remote-printing": { "source": "iana" },
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rl"]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rld"]
		},
		"application/rfc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/riscos": { "source": "iana" },
		"application/rlmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/rls-services+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rs"]
		},
		"application/route-apd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rapd"]
		},
		"application/route-s-tsid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sls"]
		},
		"application/route-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rusd"]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": ["gbr"]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": ["mft"]
		},
		"application/rpki-publication": { "source": "iana" },
		"application/rpki-roa": {
			"source": "iana",
			"extensions": ["roa"]
		},
		"application/rpki-updown": { "source": "iana" },
		"application/rsd+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rsd"]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rss"]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"application/rtploopback": { "source": "iana" },
		"application/rtx": { "source": "iana" },
		"application/samlassertion+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/samlmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif-external-properties+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sbe": { "source": "iana" },
		"application/sbml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sbml"]
		},
		"application/scaip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": ["scq"]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": ["scs"]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": ["spq"]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": ["spp"]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": ["sdp"]
		},
		"application/secevent+jwt": { "source": "iana" },
		"application/senml+cbor": { "source": "iana" },
		"application/senml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["senmlx"]
		},
		"application/senml-etch+cbor": { "source": "iana" },
		"application/senml-etch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml-exi": { "source": "iana" },
		"application/sensml+cbor": { "source": "iana" },
		"application/sensml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sensml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sensmlx"]
		},
		"application/sensml-exi": { "source": "iana" },
		"application/sep+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sep-exi": { "source": "iana" },
		"application/session-info": { "source": "iana" },
		"application/set-payment": { "source": "iana" },
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": ["setpay"]
		},
		"application/set-registration": { "source": "iana" },
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": ["setreg"]
		},
		"application/sgml": { "source": "iana" },
		"application/sgml-open-catalog": { "source": "iana" },
		"application/shf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["shf"]
		},
		"application/sieve": {
			"source": "iana",
			"extensions": ["siv", "sieve"]
		},
		"application/simple-filter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/simple-message-summary": { "source": "iana" },
		"application/simplesymbolcontainer": { "source": "iana" },
		"application/sipc": { "source": "iana" },
		"application/slate": { "source": "iana" },
		"application/smil": { "source": "iana" },
		"application/smil+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["smi", "smil"]
		},
		"application/smpte336m": { "source": "iana" },
		"application/soap+fastinfoset": { "source": "iana" },
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": ["rq"]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["srx"]
		},
		"application/spdx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/spirits-event+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sql": { "source": "iana" },
		"application/srgs": {
			"source": "iana",
			"extensions": ["gram"]
		},
		"application/srgs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["grxml"]
		},
		"application/sru+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sru"]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ssdl"]
		},
		"application/ssml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ssml"]
		},
		"application/stix+json": {
			"source": "iana",
			"compressible": true
		},
		"application/swid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["swidtag"]
		},
		"application/tamp-apex-update": { "source": "iana" },
		"application/tamp-apex-update-confirm": { "source": "iana" },
		"application/tamp-community-update": { "source": "iana" },
		"application/tamp-community-update-confirm": { "source": "iana" },
		"application/tamp-error": { "source": "iana" },
		"application/tamp-sequence-adjust": { "source": "iana" },
		"application/tamp-sequence-adjust-confirm": { "source": "iana" },
		"application/tamp-status-query": { "source": "iana" },
		"application/tamp-status-response": { "source": "iana" },
		"application/tamp-update": { "source": "iana" },
		"application/tamp-update-confirm": { "source": "iana" },
		"application/tar": { "compressible": true },
		"application/taxii+json": {
			"source": "iana",
			"compressible": true
		},
		"application/td+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tei", "teicorpus"]
		},
		"application/tetra_isi": { "source": "iana" },
		"application/thraud+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tfi"]
		},
		"application/timestamp-query": { "source": "iana" },
		"application/timestamp-reply": { "source": "iana" },
		"application/timestamped-data": {
			"source": "iana",
			"extensions": ["tsd"]
		},
		"application/tlsrpt+gzip": { "source": "iana" },
		"application/tlsrpt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tnauthlist": { "source": "iana" },
		"application/token-introspection+jwt": { "source": "iana" },
		"application/toml": {
			"compressible": true,
			"extensions": ["toml"]
		},
		"application/trickle-ice-sdpfrag": { "source": "iana" },
		"application/trig": {
			"source": "iana",
			"extensions": ["trig"]
		},
		"application/ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttml"]
		},
		"application/tve-trigger": { "source": "iana" },
		"application/tzif": { "source": "iana" },
		"application/tzif-leap": { "source": "iana" },
		"application/ubjson": {
			"compressible": false,
			"extensions": ["ubj"]
		},
		"application/ulpfec": { "source": "iana" },
		"application/urc-grpsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/urc-ressheet+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsheet"]
		},
		"application/urc-targetdesc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["td"]
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vemmi": { "source": "iana" },
		"application/vividence.scriptfile": { "source": "apache" },
		"application/vnd.1000minds.decision-model+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["1km"]
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
		"application/vnd.3gpp.5gnas": { "source": "iana" },
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gmop+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gtpc": { "source": "iana" },
		"application/vnd.3gpp.interworking-data": { "source": "iana" },
		"application/vnd.3gpp.lpp": { "source": "iana" },
		"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
		"application/vnd.3gpp.mcdata-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ngap": { "source": "iana" },
		"application/vnd.3gpp.pfcp": { "source": "iana" },
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": ["plb"]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": ["psb"]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": ["pvb"]
		},
		"application/vnd.3gpp.s1ap": { "source": "iana" },
		"application/vnd.3gpp.sms": { "source": "iana" },
		"application/vnd.3gpp.sms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.sms": { "source": "iana" },
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": ["tcap"]
		},
		"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": ["pwn"]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": ["aso"]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": ["imp"]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": ["acu"]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": ["atc", "acutc"]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["air"]
		},
		"application/vnd.adobe.flash.movie": { "source": "iana" },
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": ["fcdt"]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": ["fxp", "fxpl"]
		},
		"application/vnd.adobe.partial-upload": { "source": "iana" },
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdp"]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": ["xfdf"]
		},
		"application/vnd.aether.imp": { "source": "iana" },
		"application/vnd.afpc.afplinedata": { "source": "iana" },
		"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
		"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
		"application/vnd.afpc.foca-charset": { "source": "iana" },
		"application/vnd.afpc.foca-codedfont": { "source": "iana" },
		"application/vnd.afpc.foca-codepage": { "source": "iana" },
		"application/vnd.afpc.modca": { "source": "iana" },
		"application/vnd.afpc.modca-cmtable": { "source": "iana" },
		"application/vnd.afpc.modca-formdef": { "source": "iana" },
		"application/vnd.afpc.modca-mediummap": { "source": "iana" },
		"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
		"application/vnd.afpc.modca-overlay": { "source": "iana" },
		"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
		"application/vnd.age": {
			"source": "iana",
			"extensions": ["age"]
		},
		"application/vnd.ah-barcode": { "source": "iana" },
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": ["ahead"]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": ["azf"]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": ["azs"]
		},
		"application/vnd.amadeus+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": ["azw"]
		},
		"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": ["acc"]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": ["ami"]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.android.ota": { "source": "iana" },
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": ["apk"]
		},
		"application/vnd.anki": { "source": "iana" },
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": ["cii"]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": ["fti"]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": ["atx"]
		},
		"application/vnd.apache.arrow.file": { "source": "iana" },
		"application/vnd.apache.arrow.stream": { "source": "iana" },
		"application/vnd.apache.thrift.binary": { "source": "iana" },
		"application/vnd.apache.thrift.compact": { "source": "iana" },
		"application/vnd.apache.thrift.json": { "source": "iana" },
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.aplextor.warrp+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apothekende.reservation+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpkg"]
		},
		"application/vnd.apple.keynote": {
			"source": "iana",
			"extensions": ["key"]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": ["m3u8"]
		},
		"application/vnd.apple.numbers": {
			"source": "iana",
			"extensions": ["numbers"]
		},
		"application/vnd.apple.pages": {
			"source": "iana",
			"extensions": ["pages"]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": ["pkpass"]
		},
		"application/vnd.arastra.swi": { "source": "iana" },
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": ["swi"]
		},
		"application/vnd.artisan+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.artsquare": { "source": "iana" },
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": ["iota"]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": ["aep"]
		},
		"application/vnd.autopackage": { "source": "iana" },
		"application/vnd.avalon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.avistar+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmml"]
		},
		"application/vnd.balsamiq.bmpr": { "source": "iana" },
		"application/vnd.banana-accounting": { "source": "iana" },
		"application/vnd.bbf.usp.error": { "source": "iana" },
		"application/vnd.bbf.usp.msg": { "source": "iana" },
		"application/vnd.bbf.usp.msg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bint.med-content": { "source": "iana" },
		"application/vnd.biopax.rdf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": ["mpm"]
		},
		"application/vnd.bluetooth.ep.oob": { "source": "iana" },
		"application/vnd.bluetooth.le.oob": { "source": "iana" },
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": ["bmi"]
		},
		"application/vnd.bpf": { "source": "iana" },
		"application/vnd.bpf3": { "source": "iana" },
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": ["rep"]
		},
		"application/vnd.byu.uapi+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cab-jscript": { "source": "iana" },
		"application/vnd.canon-cpdl": { "source": "iana" },
		"application/vnd.canon-lips": { "source": "iana" },
		"application/vnd.capasystems-pg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
		"application/vnd.century-systems.tcp_stream": { "source": "iana" },
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdxml"]
		},
		"application/vnd.chess-pgn": { "source": "iana" },
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": ["mmd"]
		},
		"application/vnd.ciedi": { "source": "iana" },
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": ["cdy"]
		},
		"application/vnd.cirpack.isdn-ext": { "source": "iana" },
		"application/vnd.citationstyles.style+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csl"]
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": ["cla"]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": ["rp9"]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": ["c11amc"]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": ["c11amz"]
		},
		"application/vnd.coffeescript": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.comicbook-rar": { "source": "iana" },
		"application/vnd.commerce-battelle": { "source": "iana" },
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": ["csp"]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": ["cdbcmsg"]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": ["cmc"]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": ["clkx"]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": ["clkk"]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": ["clkp"]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": ["clkt"]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": ["clkw"]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wbs"]
		},
		"application/vnd.cryptii.pipe+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.crypto-shade-file": { "source": "iana" },
		"application/vnd.cryptomator.encrypted": { "source": "iana" },
		"application/vnd.cryptomator.vault": { "source": "iana" },
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": ["pml"]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cups-pdf": { "source": "iana" },
		"application/vnd.cups-postscript": { "source": "iana" },
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": ["ppd"]
		},
		"application/vnd.cups-raster": { "source": "iana" },
		"application/vnd.cups-raw": { "source": "iana" },
		"application/vnd.curl": { "source": "iana" },
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": ["car"]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": ["pcurl"]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cybank": { "source": "iana" },
		"application/vnd.cyclonedx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cyclonedx+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.d3m-dataset": { "source": "iana" },
		"application/vnd.d3m-problem": { "source": "iana" },
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dart"]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": ["rdz"]
		},
		"application/vnd.datapackage+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dataresource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dbf": {
			"source": "iana",
			"extensions": ["dbf"]
		},
		"application/vnd.debian.binary-package": { "source": "iana" },
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uvt", "uvvt"]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": ["uvx", "uvvx"]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": ["uvz", "uvvz"]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": ["fe_launch"]
		},
		"application/vnd.desmume.movie": { "source": "iana" },
		"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
		"application/vnd.dm.delegation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": ["dna"]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": ["mlp"]
		},
		"application/vnd.dolby.mobile.1": { "source": "iana" },
		"application/vnd.dolby.mobile.2": { "source": "iana" },
		"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": ["dpg"]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": ["dfac"]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": ["kpxx"]
		},
		"application/vnd.dtg.local": { "source": "iana" },
		"application/vnd.dtg.local.flash": { "source": "iana" },
		"application/vnd.dtg.local.html": { "source": "iana" },
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": ["ait"]
		},
		"application/vnd.dvb.dvbisl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.dvbj": { "source": "iana" },
		"application/vnd.dvb.esgcontainer": { "source": "iana" },
		"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
		"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
		"application/vnd.dvb.ipdcroaming": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.pfr": { "source": "iana" },
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": ["svc"]
		},
		"application/vnd.dxr": { "source": "iana" },
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": ["geo"]
		},
		"application/vnd.dzr": { "source": "iana" },
		"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
		"application/vnd.ecdis-update": { "source": "iana" },
		"application/vnd.ecip.rlp": { "source": "iana" },
		"application/vnd.eclipse.ditto+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": ["mag"]
		},
		"application/vnd.ecowin.filerequest": { "source": "iana" },
		"application/vnd.ecowin.fileupdate": { "source": "iana" },
		"application/vnd.ecowin.series": { "source": "iana" },
		"application/vnd.ecowin.seriesrequest": { "source": "iana" },
		"application/vnd.ecowin.seriesupdate": { "source": "iana" },
		"application/vnd.efi.img": { "source": "iana" },
		"application/vnd.efi.iso": { "source": "iana" },
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": ["nml"]
		},
		"application/vnd.enphase.envoy": { "source": "iana" },
		"application/vnd.eprints.data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": ["esf"]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": ["msf"]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": ["qam"]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": ["slt"]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": ["ssf"]
		},
		"application/vnd.ericsson.quickcall": { "source": "iana" },
		"application/vnd.espass-espass+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es3", "et3"]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mheg5": { "source": "iana" },
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.timestamp-token": { "source": "iana" },
		"application/vnd.etsi.tsl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.tsl.der": { "source": "iana" },
		"application/vnd.eu.kasparian.car+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.eudora.data": { "source": "iana" },
		"application/vnd.evolv.ecig.profile": { "source": "iana" },
		"application/vnd.evolv.ecig.settings": { "source": "iana" },
		"application/vnd.evolv.ecig.theme": { "source": "iana" },
		"application/vnd.exstream-empower+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.exstream-package": { "source": "iana" },
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": ["ez2"]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": ["ez3"]
		},
		"application/vnd.f-secure.mobile": { "source": "iana" },
		"application/vnd.familysearch.gedcom+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.fastcopy-disk-image": { "source": "iana" },
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": ["fdf"]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": ["mseed"]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": ["seed", "dataless"]
		},
		"application/vnd.ffsns": { "source": "iana" },
		"application/vnd.ficlab.flb+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.filmit.zfc": { "source": "iana" },
		"application/vnd.fints": { "source": "iana" },
		"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": ["gph"]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": ["ftc"]
		},
		"application/vnd.font-fontforge-sfd": { "source": "iana" },
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": ["fnc"]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": ["ltf"]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": ["fsc"]
		},
		"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
		"application/vnd.fujifilm.fb.jfi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": ["oas"]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": ["oa2"]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": ["oa3"]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": ["fg5"]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": ["bh2"]
		},
		"application/vnd.fujixerox.art-ex": { "source": "iana" },
		"application/vnd.fujixerox.art4": { "source": "iana" },
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": ["ddd"]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": ["xdw"]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": ["xbd"]
		},
		"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
		"application/vnd.fujixerox.hbpl": { "source": "iana" },
		"application/vnd.fut-misnet": { "source": "iana" },
		"application/vnd.futoin+cbor": { "source": "iana" },
		"application/vnd.futoin+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": ["fzs"]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": ["txd"]
		},
		"application/vnd.gentics.grd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": ["ggb"]
		},
		"application/vnd.geogebra.slides": { "source": "iana" },
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": ["ggt"]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": ["gex", "gre"]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": ["gxt"]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": ["g2w"]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": ["g3w"]
		},
		"application/vnd.gerber": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": ["gmx"]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": ["gdoc"]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": ["gslides"]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": ["gsheet"]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["kml"]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": ["kmz"]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": ["gqf", "gqs"]
		},
		"application/vnd.gridmp": { "source": "iana" },
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": ["gac"]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": ["ghf"]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": ["gim"]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": ["grv"]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": ["gtm"]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": ["tpl"]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": ["vcg"]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["hal"]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zmm"]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": ["hbci"]
		},
		"application/vnd.hc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hcl-bireports": { "source": "iana" },
		"application/vnd.hdt": { "source": "iana" },
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": ["les"]
		},
		"application/vnd.hl7cda+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hl7v2+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": ["hpgl"]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": ["hpid"]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": ["hps"]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": ["jlt"]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": ["pcl"]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": ["pclxl"]
		},
		"application/vnd.httphone": { "source": "iana" },
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": ["sfd-hdstx"]
		},
		"application/vnd.hyper+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyper-item+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": { "source": "iana" },
		"application/vnd.ibm.afplinedata": { "source": "iana" },
		"application/vnd.ibm.electronic-media": { "source": "iana" },
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": ["mpy"]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": ["irm"]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": ["sc"]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": ["icc", "icm"]
		},
		"application/vnd.ieee.1905": { "source": "iana" },
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": ["igl"]
		},
		"application/vnd.imagemeter.folder+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.imagemeter.image+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": ["ivp"]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": ["ivu"]
		},
		"application/vnd.ims.imsccv1p1": { "source": "iana" },
		"application/vnd.ims.imsccv1p2": { "source": "iana" },
		"application/vnd.ims.imsccv1p3": { "source": "iana" },
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informix-visionary": { "source": "iana" },
		"application/vnd.infotech.project": { "source": "iana" },
		"application/vnd.infotech.project+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.innopath.wamp.notification": { "source": "iana" },
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": ["igm"]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": ["xpw", "xpx"]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": ["i2g"]
		},
		"application/vnd.intertrust.digibox": { "source": "iana" },
		"application/vnd.intertrust.nncp": { "source": "iana" },
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": ["qbo"]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": ["qfx"]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": ["rcprofile"]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["irp"]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": ["xpr"]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": ["fcs"]
		},
		"application/vnd.iso11783-10+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": ["jam"]
		},
		"application/vnd.japannet-directory-service": { "source": "iana" },
		"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-payment-wakeup": { "source": "iana" },
		"application/vnd.japannet-registration": { "source": "iana" },
		"application/vnd.japannet-registration-wakeup": { "source": "iana" },
		"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-verification": { "source": "iana" },
		"application/vnd.japannet-verification-wakeup": { "source": "iana" },
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": ["rms"]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": ["jisp"]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": ["joda"]
		},
		"application/vnd.jsk.isdn-ngn": { "source": "iana" },
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": ["ktz", "ktr"]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": ["karbon"]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": ["chrt"]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": ["kfo"]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": ["flw"]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": ["kon"]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": ["kpr", "kpt"]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": ["ksp"]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": ["kwd", "kwt"]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": ["htke"]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": ["kia"]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": ["kne", "knp"]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": ["sse"]
		},
		"application/vnd.las": { "source": "iana" },
		"application/vnd.las.las+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lasxml"]
		},
		"application/vnd.laszip": { "source": "iana" },
		"application/vnd.leap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": ["lbd"]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lbe"]
		},
		"application/vnd.logipipe.circuit+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.loom": { "source": "iana" },
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": ["123"]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": ["apr"]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": ["pre"]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": ["nsf"]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": ["org"]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": ["scm"]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": ["lwp"]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": ["portpkg"]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana",
			"extensions": ["mvt"]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.mdcf": { "source": "iana" },
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxar.archive.3tz+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.maxmind.maxmind-db": { "source": "iana" },
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": ["mcd"]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": ["mc1"]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": ["cdkey"]
		},
		"application/vnd.meridian-slingshot": { "source": "iana" },
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": ["mwf"]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": ["mfm"]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": ["flo"]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": ["igx"]
		},
		"application/vnd.microsoft.portable-executable": { "source": "iana" },
		"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": ["mif"]
		},
		"application/vnd.minisoft-hp3000-save": { "source": "iana" },
		"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": ["daf"]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": ["dis"]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": ["mbk"]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": ["mqy"]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": ["msl"]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": ["plc"]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": ["txf"]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": ["mpn"]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": ["mpc"]
		},
		"application/vnd.motorola.flexsuite": { "source": "iana" },
		"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
		"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
		"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
		"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
		"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
		"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
		"application/vnd.motorola.iprm": { "source": "iana" },
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xul"]
		},
		"application/vnd.ms-3mfdocument": { "source": "iana" },
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": ["cil"]
		},
		"application/vnd.ms-asf": { "source": "iana" },
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": ["cab"]
		},
		"application/vnd.ms-color.iccprofile": { "source": "apache" },
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlam"]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsb"]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsm"]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["xltm"]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eot"]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": ["chm"]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": ["ims"]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": ["lrm"]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": ["thmx"]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-outlook": {
			"compressible": false,
			"extensions": ["msg"]
		},
		"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": ["cat"]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": ["stl"]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppam"]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": ["pptm"]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": ["sldm"]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppsm"]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["potm"]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": ["mpp", "mpt"]
		},
		"application/vnd.ms-tnef": { "source": "iana" },
		"application/vnd.ms-windows.devicepairing": { "source": "iana" },
		"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
		"application/vnd.ms-windows.printerpairing": { "source": "iana" },
		"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": ["docm"]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["dotm"]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": ["wpl"]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xps"]
		},
		"application/vnd.msa-disk-image": { "source": "iana" },
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": ["mseq"]
		},
		"application/vnd.msign": { "source": "iana" },
		"application/vnd.multiad.creator": { "source": "iana" },
		"application/vnd.multiad.creator.cif": { "source": "iana" },
		"application/vnd.music-niff": { "source": "iana" },
		"application/vnd.musician": {
			"source": "iana",
			"extensions": ["mus"]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": ["msty"]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": ["taglet"]
		},
		"application/vnd.nacamar.ybrid+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ncd.control": { "source": "iana" },
		"application/vnd.ncd.reference": { "source": "iana" },
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nebumind.line": { "source": "iana" },
		"application/vnd.nervana": { "source": "iana" },
		"application/vnd.netfpx": { "source": "iana" },
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": ["nlu"]
		},
		"application/vnd.nimn": { "source": "iana" },
		"application/vnd.nintendo.nitro.rom": { "source": "iana" },
		"application/vnd.nintendo.snes.rom": { "source": "iana" },
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": ["ntf", "nitf"]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": ["nnd"]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": ["nns"]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": ["nnw"]
		},
		"application/vnd.nokia.catalogs": { "source": "iana" },
		"application/vnd.nokia.conml+wbxml": { "source": "iana" },
		"application/vnd.nokia.conml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
		"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
		"application/vnd.nokia.landmark+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ac"]
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": ["ngdat"]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": ["n-gage"]
		},
		"application/vnd.nokia.ncd": { "source": "iana" },
		"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
		"application/vnd.nokia.pcd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": ["rpst"]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": ["rpss"]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": ["edm"]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": ["edx"]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": ["ext"]
		},
		"application/vnd.ntt-local.content-share": { "source": "iana" },
		"application/vnd.ntt-local.file-transfer": { "source": "iana" },
		"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": ["odc"]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": ["otc"]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": ["odb"]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": ["odf"]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": ["odft"]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odg"]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": ["otg"]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": ["odi"]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": ["oti"]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odp"]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": ["otp"]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ods"]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": ["ots"]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odt"]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": ["odm"]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": ["ott"]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": ["oth"]
		},
		"application/vnd.obn": { "source": "iana" },
		"application/vnd.ocf+cbor": { "source": "iana" },
		"application/vnd.oci.image.manifest.v1+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.pae.gem": { "source": "iana" },
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": ["xo"]
		},
		"application/vnd.oma-scws-config": { "source": "iana" },
		"application/vnd.oma-scws-http-request": { "source": "iana" },
		"application/vnd.oma-scws-http-response": { "source": "iana" },
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.ltkm": { "source": "iana" },
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
		"application/vnd.oma.bcast.sgboot": { "source": "iana" },
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sgdu": { "source": "iana" },
		"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.stkm": { "source": "iana" },
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.dcd": { "source": "iana" },
		"application/vnd.oma.dcdc": { "source": "iana" },
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dd2"]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
		"application/vnd.oma.pal+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.push": { "source": "iana" },
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.omads-email+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-file+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omaloc-supl-init": { "source": "iana" },
		"application/vnd.onepager": { "source": "iana" },
		"application/vnd.onepagertamp": { "source": "iana" },
		"application/vnd.onepagertamx": { "source": "iana" },
		"application/vnd.onepagertat": { "source": "iana" },
		"application/vnd.onepagertatp": { "source": "iana" },
		"application/vnd.onepagertatx": { "source": "iana" },
		"application/vnd.openblox.game+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["obgx"]
		},
		"application/vnd.openblox.game-binary": { "source": "iana" },
		"application/vnd.openeye.oeb": { "source": "iana" },
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": ["oxt"]
		},
		"application/vnd.openstreetmap.data+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osm"]
		},
		"application/vnd.opentimestamps.ots": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pptx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": ["sldx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": ["ppsx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "iana",
			"extensions": ["potx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xlsx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "iana",
			"extensions": ["xltx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": ["docx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "iana",
			"extensions": ["dotx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": { "source": "iana" },
		"application/vnd.osa.netdeploy": { "source": "iana" },
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": ["mgp"]
		},
		"application/vnd.osgi.bundle": { "source": "iana" },
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": ["dp"]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": ["esa"]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oxli.countgraph": { "source": "iana" },
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": { "source": "iana" },
		"application/vnd.paos.xml": { "source": "iana" },
		"application/vnd.patentdive": { "source": "iana" },
		"application/vnd.patientecommsdoc": { "source": "iana" },
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": ["paw"]
		},
		"application/vnd.pcos": { "source": "iana" },
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": ["str"]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": ["ei6"]
		},
		"application/vnd.piaccess.application-licence": { "source": "iana" },
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": ["efif"]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": ["wg"]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": ["plf"]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": ["pbd"]
		},
		"application/vnd.powerbuilder6-s": { "source": "iana" },
		"application/vnd.powerbuilder7": { "source": "iana" },
		"application/vnd.powerbuilder7-s": { "source": "iana" },
		"application/vnd.powerbuilder75": { "source": "iana" },
		"application/vnd.powerbuilder75-s": { "source": "iana" },
		"application/vnd.preminet": { "source": "iana" },
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": ["box"]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": ["mgz"]
		},
		"application/vnd.psfs": { "source": "iana" },
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": ["qps"]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": ["ptid"]
		},
		"application/vnd.pwg-multiplexed": { "source": "iana" },
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
		"application/vnd.quarantainenet": { "source": "iana" },
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": { "source": "iana" },
		"application/vnd.radisys.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rainstor.data": { "source": "iana" },
		"application/vnd.rapid": { "source": "iana" },
		"application/vnd.rar": {
			"source": "iana",
			"extensions": ["rar"]
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": ["bed"]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": ["mxl"]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musicxml"]
		},
		"application/vnd.renlearn.rlprint": { "source": "iana" },
		"application/vnd.resilient.logic": { "source": "iana" },
		"application/vnd.restful+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": ["cryptonote"]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": ["cod"]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": ["rm"]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": ["rmvb"]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["link66"]
		},
		"application/vnd.rs-274x": { "source": "iana" },
		"application/vnd.ruckus.download": { "source": "iana" },
		"application/vnd.s3sms": { "source": "iana" },
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": ["st"]
		},
		"application/vnd.sar": { "source": "iana" },
		"application/vnd.sbm.cid": { "source": "iana" },
		"application/vnd.sbm.mid2": { "source": "iana" },
		"application/vnd.scribus": { "source": "iana" },
		"application/vnd.sealed.3df": { "source": "iana" },
		"application/vnd.sealed.csf": { "source": "iana" },
		"application/vnd.sealed.doc": { "source": "iana" },
		"application/vnd.sealed.eml": { "source": "iana" },
		"application/vnd.sealed.mht": { "source": "iana" },
		"application/vnd.sealed.net": { "source": "iana" },
		"application/vnd.sealed.ppt": { "source": "iana" },
		"application/vnd.sealed.tiff": { "source": "iana" },
		"application/vnd.sealed.xls": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": ["see"]
		},
		"application/vnd.seis+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": ["sema"]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": ["semd"]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": ["semf"]
		},
		"application/vnd.shade-save-file": { "source": "iana" },
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": ["ifm"]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": ["itp"]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": ["iif"]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": ["ipk"]
		},
		"application/vnd.shootproof+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shopkick+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shp": { "source": "iana" },
		"application/vnd.shx": { "source": "iana" },
		"application/vnd.sigrok.session": { "source": "iana" },
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": ["twd", "twds"]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": ["mmf"]
		},
		"application/vnd.smart.notebook": { "source": "iana" },
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": ["teacher"]
		},
		"application/vnd.snesdev-page-table": { "source": "iana" },
		"application/vnd.software602.filler.form+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fo"]
		},
		"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sdkm", "sdkd"]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": ["dxp"]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": ["sfs"]
		},
		"application/vnd.sqlite3": { "source": "iana" },
		"application/vnd.sss-cod": { "source": "iana" },
		"application/vnd.sss-dtf": { "source": "iana" },
		"application/vnd.sss-ntf": { "source": "iana" },
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": ["sdc"]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": ["sda"]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": ["sdd"]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": ["smf"]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": ["sdw", "vor"]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": ["sgl"]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": ["smzip"]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": ["sm"]
		},
		"application/vnd.street-stream": { "source": "iana" },
		"application/vnd.sun.wadl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wadl"]
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": ["sxc"]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": ["stc"]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": ["sxd"]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": ["std"]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": ["sxi"]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": ["sti"]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": ["sxm"]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": ["sxw"]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": ["sxg"]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": ["stw"]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": ["sus", "susp"]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": ["svd"]
		},
		"application/vnd.swiftview-ics": { "source": "iana" },
		"application/vnd.sycle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.syft+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": ["sis", "sisx"]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xsm"]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["bdm"]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xdm"]
		},
		"application/vnd.syncml.dm.notification": { "source": "iana" },
		"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["ddf"]
		},
		"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.syncml.ds.notification": { "source": "iana" },
		"application/vnd.tableschema+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": ["tao"]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.think-cell.ppttc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tml": { "source": "iana" },
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": ["tmo"]
		},
		"application/vnd.tri.onesource": { "source": "iana" },
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": ["tpt"]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": ["mxs"]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": ["tra"]
		},
		"application/vnd.truedoc": { "source": "iana" },
		"application/vnd.ubisoft.webplayer": { "source": "iana" },
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": ["ufd", "ufdl"]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": ["utz"]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": ["umj"]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": ["unityweb"]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uoml"]
		},
		"application/vnd.uplanet.alert": { "source": "iana" },
		"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
		"application/vnd.uplanet.cacheop": { "source": "iana" },
		"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
		"application/vnd.uplanet.channel": { "source": "iana" },
		"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
		"application/vnd.uplanet.list": { "source": "iana" },
		"application/vnd.uplanet.list-wbxml": { "source": "iana" },
		"application/vnd.uplanet.listcmd": { "source": "iana" },
		"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
		"application/vnd.uplanet.signal": { "source": "iana" },
		"application/vnd.uri-map": { "source": "iana" },
		"application/vnd.valve.source.material": { "source": "iana" },
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": ["vcx"]
		},
		"application/vnd.vd-study": { "source": "iana" },
		"application/vnd.vectorworks": { "source": "iana" },
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": { "source": "iana" },
		"application/vnd.veritone.aion+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.veryant.thin": { "source": "iana" },
		"application/vnd.ves.encrypted": { "source": "iana" },
		"application/vnd.vidsoft.vidconference": { "source": "iana" },
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": ["vis"]
		},
		"application/vnd.vividence.scriptfile": { "source": "iana" },
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": ["vsf"]
		},
		"application/vnd.wap.sic": { "source": "iana" },
		"application/vnd.wap.slc": { "source": "iana" },
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["wbxml"]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": ["wmlc"]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": ["wmlsc"]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": ["wtb"]
		},
		"application/vnd.wfa.dpp": { "source": "iana" },
		"application/vnd.wfa.p2p": { "source": "iana" },
		"application/vnd.wfa.wsc": { "source": "iana" },
		"application/vnd.windows.devicepairing": { "source": "iana" },
		"application/vnd.wmc": { "source": "iana" },
		"application/vnd.wmf.bootstrap": { "source": "iana" },
		"application/vnd.wolfram.mathematica": { "source": "iana" },
		"application/vnd.wolfram.mathematica.package": { "source": "iana" },
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": ["nbp"]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": ["wpd"]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": ["wqd"]
		},
		"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": ["stf"]
		},
		"application/vnd.wv.csp+wbxml": { "source": "iana" },
		"application/vnd.wv.csp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": ["xar"]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": ["xfdl"]
		},
		"application/vnd.xfdl.webform": { "source": "iana" },
		"application/vnd.xmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xmpie.cpkg": { "source": "iana" },
		"application/vnd.xmpie.dpkg": { "source": "iana" },
		"application/vnd.xmpie.plan": { "source": "iana" },
		"application/vnd.xmpie.ppkg": { "source": "iana" },
		"application/vnd.xmpie.xlim": { "source": "iana" },
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": ["hvd"]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": ["hvs"]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": ["hvp"]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": ["osf"]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osfpvg"]
		},
		"application/vnd.yamaha.remote-setup": { "source": "iana" },
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": ["saf"]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": ["spf"]
		},
		"application/vnd.yamaha.through-ngn": { "source": "iana" },
		"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
		"application/vnd.yaoweme": { "source": "iana" },
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": ["cmp"]
		},
		"application/vnd.youtube.yt": { "source": "iana" },
		"application/vnd.zul": {
			"source": "iana",
			"extensions": ["zir", "zirz"]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zaz"]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vxml"]
		},
		"application/voucher-cms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vq-rtcpxr": { "source": "iana" },
		"application/wasm": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wasm"]
		},
		"application/watcherinfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wif"]
		},
		"application/webpush-options+json": {
			"source": "iana",
			"compressible": true
		},
		"application/whoispp-query": { "source": "iana" },
		"application/whoispp-response": { "source": "iana" },
		"application/widget": {
			"source": "iana",
			"extensions": ["wgt"]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": ["hlp"]
		},
		"application/wita": { "source": "iana" },
		"application/wordperfect5.1": { "source": "iana" },
		"application/wsdl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wsdl"]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wspolicy"]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["7z"]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": ["abw"]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": ["ace"]
		},
		"application/x-amf": { "source": "apache" },
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": ["dmg"]
		},
		"application/x-arj": {
			"compressible": false,
			"extensions": ["arj"]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": ["aam"]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": ["aas"]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": ["bcpio"]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": ["torrent"]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": ["blb", "blorb"]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz"]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz2", "boz"]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": ["vcd"]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": ["cfs"]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": ["chat"]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": ["pgn"]
		},
		"application/x-chrome-extension": { "extensions": ["crx"] },
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": ["cco"]
		},
		"application/x-compress": { "source": "apache" },
		"application/x-conference": {
			"source": "apache",
			"extensions": ["nsc"]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": ["cpio"]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": ["csh"]
		},
		"application/x-deb": { "compressible": false },
		"application/x-debian-package": {
			"source": "apache",
			"extensions": ["deb", "udeb"]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": ["dgc"]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": ["wad"]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ncx"]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dtb"]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["res"]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": ["dvi"]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": ["evy"]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": ["eva"]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": ["bdf"]
		},
		"application/x-font-dos": { "source": "apache" },
		"application/x-font-framemaker": { "source": "apache" },
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": ["gsf"]
		},
		"application/x-font-libgrx": { "source": "apache" },
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": ["psf"]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": ["pcf"]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": ["snf"]
		},
		"application/x-font-speedo": { "source": "apache" },
		"application/x-font-sunos-news": { "source": "apache" },
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": { "source": "apache" },
		"application/x-freearc": {
			"source": "apache",
			"extensions": ["arc"]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": ["spl"]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": ["gca"]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": ["ulx"]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": ["gnumeric"]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": ["gramps"]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": ["gtar"]
		},
		"application/x-gzip": { "source": "apache" },
		"application/x-hdf": {
			"source": "apache",
			"extensions": ["hdf"]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": ["php"]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": ["install"]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": ["iso"]
		},
		"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
		"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
		"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": ["jardiff"]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": ["jnlp"]
		},
		"application/x-javascript": { "compressible": true },
		"application/x-keepass2": { "extensions": ["kdbx"] },
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": ["latex"]
		},
		"application/x-lua-bytecode": { "extensions": ["luac"] },
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": ["lzh", "lha"]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": ["run"]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": ["mie"]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": ["prc", "mobi"]
		},
		"application/x-mpegurl": { "compressible": false },
		"application/x-ms-application": {
			"source": "apache",
			"extensions": ["application"]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": ["lnk"]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": ["wmd"]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": ["wmz"]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": ["xbap"]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": ["mdb"]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": ["obd"]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": ["crd"]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": ["clp"]
		},
		"application/x-msdos-program": { "extensions": ["exe"] },
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": ["mny"]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": ["pub"]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": ["scd"]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": ["trm"]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": ["wri"]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": ["nc", "cdf"]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": ["pac"]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": ["nzb"]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": ["pl", "pm"]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": ["prc", "pdb"]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": ["p12", "pfx"]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": ["p7b", "spc"]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": ["p7r"]
		},
		"application/x-pki-message": { "source": "iana" },
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["rar"]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": ["rpm"]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": ["ris"]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": ["sea"]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": ["sh"]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": ["shar"]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": ["swf"]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": ["xap"]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": ["sql"]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": ["sit"]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": ["sitx"]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": ["srt"]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": ["sv4cpio"]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": ["sv4crc"]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": ["t3"]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": ["gam"]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": ["tar"]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": ["tcl", "tk"]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": ["tex"]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": ["tfm"]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": ["texinfo", "texi"]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": ["obj"]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": ["ustar"]
		},
		"application/x-virtualbox-hdd": {
			"compressible": true,
			"extensions": ["hdd"]
		},
		"application/x-virtualbox-ova": {
			"compressible": true,
			"extensions": ["ova"]
		},
		"application/x-virtualbox-ovf": {
			"compressible": true,
			"extensions": ["ovf"]
		},
		"application/x-virtualbox-vbox": {
			"compressible": true,
			"extensions": ["vbox"]
		},
		"application/x-virtualbox-vbox-extpack": {
			"compressible": false,
			"extensions": ["vbox-extpack"]
		},
		"application/x-virtualbox-vdi": {
			"compressible": true,
			"extensions": ["vdi"]
		},
		"application/x-virtualbox-vhd": {
			"compressible": true,
			"extensions": ["vhd"]
		},
		"application/x-virtualbox-vmdk": {
			"compressible": true,
			"extensions": ["vmdk"]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": ["src"]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": ["webapp"]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "iana",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-x509-ca-ra-cert": { "source": "iana" },
		"application/x-x509-next-ca-cert": { "source": "iana" },
		"application/x-xfig": {
			"source": "apache",
			"extensions": ["fig"]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": ["xpi"]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": ["xz"]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": { "source": "iana" },
		"application/xacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xaml+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xaml"]
		},
		"application/xcap-att+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xav"]
		},
		"application/xcap-caps+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xca"]
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdf"]
		},
		"application/xcap-el+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xel"]
		},
		"application/xcap-error+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcap-ns+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xns"]
		},
		"application/xcon-conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xenc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xenc"]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xhtml", "xht"]
		},
		"application/xhtml-voice+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/xliff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dtd"]
		},
		"application/xml-external-parsed-entity": { "source": "iana" },
		"application/xml-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xmpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xop"]
		},
		"application/xproc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xpl"]
		},
		"application/xslt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xsl", "xslt"]
		},
		"application/xspf+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xspf"]
		},
		"application/xv+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": ["yang"]
		},
		"application/yang-data+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yin+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["yin"]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["zip"]
		},
		"application/zlib": { "source": "iana" },
		"application/zstd": { "source": "iana" },
		"audio/1d-interleaved-parityfec": { "source": "iana" },
		"audio/32kadpcm": { "source": "iana" },
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": ["3gpp"]
		},
		"audio/3gpp2": { "source": "iana" },
		"audio/aac": { "source": "iana" },
		"audio/ac3": { "source": "iana" },
		"audio/adpcm": {
			"source": "apache",
			"extensions": ["adp"]
		},
		"audio/amr": {
			"source": "iana",
			"extensions": ["amr"]
		},
		"audio/amr-wb": { "source": "iana" },
		"audio/amr-wb+": { "source": "iana" },
		"audio/aptx": { "source": "iana" },
		"audio/asc": { "source": "iana" },
		"audio/atrac-advanced-lossless": { "source": "iana" },
		"audio/atrac-x": { "source": "iana" },
		"audio/atrac3": { "source": "iana" },
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": ["au", "snd"]
		},
		"audio/bv16": { "source": "iana" },
		"audio/bv32": { "source": "iana" },
		"audio/clearmode": { "source": "iana" },
		"audio/cn": { "source": "iana" },
		"audio/dat12": { "source": "iana" },
		"audio/dls": { "source": "iana" },
		"audio/dsr-es201108": { "source": "iana" },
		"audio/dsr-es202050": { "source": "iana" },
		"audio/dsr-es202211": { "source": "iana" },
		"audio/dsr-es202212": { "source": "iana" },
		"audio/dv": { "source": "iana" },
		"audio/dvi4": { "source": "iana" },
		"audio/eac3": { "source": "iana" },
		"audio/encaprtp": { "source": "iana" },
		"audio/evrc": { "source": "iana" },
		"audio/evrc-qcp": { "source": "iana" },
		"audio/evrc0": { "source": "iana" },
		"audio/evrc1": { "source": "iana" },
		"audio/evrcb": { "source": "iana" },
		"audio/evrcb0": { "source": "iana" },
		"audio/evrcb1": { "source": "iana" },
		"audio/evrcnw": { "source": "iana" },
		"audio/evrcnw0": { "source": "iana" },
		"audio/evrcnw1": { "source": "iana" },
		"audio/evrcwb": { "source": "iana" },
		"audio/evrcwb0": { "source": "iana" },
		"audio/evrcwb1": { "source": "iana" },
		"audio/evs": { "source": "iana" },
		"audio/flexfec": { "source": "iana" },
		"audio/fwdred": { "source": "iana" },
		"audio/g711-0": { "source": "iana" },
		"audio/g719": { "source": "iana" },
		"audio/g722": { "source": "iana" },
		"audio/g7221": { "source": "iana" },
		"audio/g723": { "source": "iana" },
		"audio/g726-16": { "source": "iana" },
		"audio/g726-24": { "source": "iana" },
		"audio/g726-32": { "source": "iana" },
		"audio/g726-40": { "source": "iana" },
		"audio/g728": { "source": "iana" },
		"audio/g729": { "source": "iana" },
		"audio/g7291": { "source": "iana" },
		"audio/g729d": { "source": "iana" },
		"audio/g729e": { "source": "iana" },
		"audio/gsm": { "source": "iana" },
		"audio/gsm-efr": { "source": "iana" },
		"audio/gsm-hr-08": { "source": "iana" },
		"audio/ilbc": { "source": "iana" },
		"audio/ip-mr_v2.5": { "source": "iana" },
		"audio/isac": { "source": "apache" },
		"audio/l16": { "source": "iana" },
		"audio/l20": { "source": "iana" },
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": { "source": "iana" },
		"audio/lpc": { "source": "iana" },
		"audio/melp": { "source": "iana" },
		"audio/melp1200": { "source": "iana" },
		"audio/melp2400": { "source": "iana" },
		"audio/melp600": { "source": "iana" },
		"audio/mhas": { "source": "iana" },
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana",
			"extensions": ["mxmf"]
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": ["mp3"]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": ["m4a", "mp4a"]
		},
		"audio/mp4a-latm": { "source": "iana" },
		"audio/mpa": { "source": "iana" },
		"audio/mpa-robust": { "source": "iana" },
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": { "source": "iana" },
		"audio/musepack": { "source": "apache" },
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx",
				"opus"
			]
		},
		"audio/opus": { "source": "iana" },
		"audio/parityfec": { "source": "iana" },
		"audio/pcma": { "source": "iana" },
		"audio/pcma-wb": { "source": "iana" },
		"audio/pcmu": { "source": "iana" },
		"audio/pcmu-wb": { "source": "iana" },
		"audio/prs.sid": { "source": "iana" },
		"audio/qcelp": { "source": "iana" },
		"audio/raptorfec": { "source": "iana" },
		"audio/red": { "source": "iana" },
		"audio/rtp-enc-aescm128": { "source": "iana" },
		"audio/rtp-midi": { "source": "iana" },
		"audio/rtploopback": { "source": "iana" },
		"audio/rtx": { "source": "iana" },
		"audio/s3m": {
			"source": "apache",
			"extensions": ["s3m"]
		},
		"audio/scip": { "source": "iana" },
		"audio/silk": {
			"source": "apache",
			"extensions": ["sil"]
		},
		"audio/smv": { "source": "iana" },
		"audio/smv-qcp": { "source": "iana" },
		"audio/smv0": { "source": "iana" },
		"audio/sofa": { "source": "iana" },
		"audio/sp-midi": { "source": "iana" },
		"audio/speex": { "source": "iana" },
		"audio/t140c": { "source": "iana" },
		"audio/t38": { "source": "iana" },
		"audio/telephone-event": { "source": "iana" },
		"audio/tetra_acelp": { "source": "iana" },
		"audio/tetra_acelp_bb": { "source": "iana" },
		"audio/tone": { "source": "iana" },
		"audio/tsvcis": { "source": "iana" },
		"audio/uemclip": { "source": "iana" },
		"audio/ulpfec": { "source": "iana" },
		"audio/usac": { "source": "iana" },
		"audio/vdvi": { "source": "iana" },
		"audio/vmr-wb": { "source": "iana" },
		"audio/vnd.3gpp.iufp": { "source": "iana" },
		"audio/vnd.4sb": { "source": "iana" },
		"audio/vnd.audiokoz": { "source": "iana" },
		"audio/vnd.celp": { "source": "iana" },
		"audio/vnd.cisco.nse": { "source": "iana" },
		"audio/vnd.cmles.radio-events": { "source": "iana" },
		"audio/vnd.cns.anp1": { "source": "iana" },
		"audio/vnd.cns.inf1": { "source": "iana" },
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": ["uva", "uvva"]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": ["eol"]
		},
		"audio/vnd.dlna.adts": { "source": "iana" },
		"audio/vnd.dolby.heaac.1": { "source": "iana" },
		"audio/vnd.dolby.heaac.2": { "source": "iana" },
		"audio/vnd.dolby.mlp": { "source": "iana" },
		"audio/vnd.dolby.mps": { "source": "iana" },
		"audio/vnd.dolby.pl2": { "source": "iana" },
		"audio/vnd.dolby.pl2x": { "source": "iana" },
		"audio/vnd.dolby.pl2z": { "source": "iana" },
		"audio/vnd.dolby.pulse.1": { "source": "iana" },
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": ["dra"]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": ["dts"]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": ["dtshd"]
		},
		"audio/vnd.dts.uhd": { "source": "iana" },
		"audio/vnd.dvb.file": { "source": "iana" },
		"audio/vnd.everad.plj": { "source": "iana" },
		"audio/vnd.hns.audio": { "source": "iana" },
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": ["lvp"]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": ["pya"]
		},
		"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
		"audio/vnd.nortel.vbk": { "source": "iana" },
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": ["ecelp4800"]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": ["ecelp7470"]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": ["ecelp9600"]
		},
		"audio/vnd.octel.sbc": { "source": "iana" },
		"audio/vnd.presonus.multitrack": { "source": "iana" },
		"audio/vnd.qcelp": { "source": "iana" },
		"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": ["rip"]
		},
		"audio/vnd.rn-realaudio": { "compressible": false },
		"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
		"audio/vnd.vmx.cvsd": { "source": "iana" },
		"audio/vnd.wave": { "compressible": false },
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": { "source": "iana" },
		"audio/wav": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["weba"]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": ["aac"]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": ["caf"]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": ["flac"]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": ["m4a"]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": ["mka"]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": ["m3u"]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": ["wax"]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": ["wma"]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": ["ram", "ra"]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": ["rmp"]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": ["ra"]
		},
		"audio/x-tta": { "source": "apache" },
		"audio/x-wav": {
			"source": "apache",
			"extensions": ["wav"]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": ["xm"]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": ["cdx"]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": ["cif"]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": ["cmdf"]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": ["cml"]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": ["csml"]
		},
		"chemical/x-pdb": { "source": "apache" },
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": ["xyz"]
		},
		"font/collection": {
			"source": "iana",
			"extensions": ["ttc"]
		},
		"font/otf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["otf"]
		},
		"font/sfnt": { "source": "iana" },
		"font/ttf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttf"]
		},
		"font/woff": {
			"source": "iana",
			"extensions": ["woff"]
		},
		"font/woff2": {
			"source": "iana",
			"extensions": ["woff2"]
		},
		"image/aces": {
			"source": "iana",
			"extensions": ["exr"]
		},
		"image/apng": {
			"compressible": false,
			"extensions": ["apng"]
		},
		"image/avci": {
			"source": "iana",
			"extensions": ["avci"]
		},
		"image/avcs": {
			"source": "iana",
			"extensions": ["avcs"]
		},
		"image/avif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["avif"]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": ["cgm"]
		},
		"image/dicom-rle": {
			"source": "iana",
			"extensions": ["drle"]
		},
		"image/emf": {
			"source": "iana",
			"extensions": ["emf"]
		},
		"image/fits": {
			"source": "iana",
			"extensions": ["fits"]
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": ["g3"]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gif"]
		},
		"image/heic": {
			"source": "iana",
			"extensions": ["heic"]
		},
		"image/heic-sequence": {
			"source": "iana",
			"extensions": ["heics"]
		},
		"image/heif": {
			"source": "iana",
			"extensions": ["heif"]
		},
		"image/heif-sequence": {
			"source": "iana",
			"extensions": ["heifs"]
		},
		"image/hej2k": {
			"source": "iana",
			"extensions": ["hej2"]
		},
		"image/hsj2": {
			"source": "iana",
			"extensions": ["hsj2"]
		},
		"image/ief": {
			"source": "iana",
			"extensions": ["ief"]
		},
		"image/jls": {
			"source": "iana",
			"extensions": ["jls"]
		},
		"image/jp2": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jp2", "jpg2"]
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jph": {
			"source": "iana",
			"extensions": ["jph"]
		},
		"image/jphc": {
			"source": "iana",
			"extensions": ["jhc"]
		},
		"image/jpm": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpm"]
		},
		"image/jpx": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpx", "jpf"]
		},
		"image/jxr": {
			"source": "iana",
			"extensions": ["jxr"]
		},
		"image/jxra": {
			"source": "iana",
			"extensions": ["jxra"]
		},
		"image/jxrs": {
			"source": "iana",
			"extensions": ["jxrs"]
		},
		"image/jxs": {
			"source": "iana",
			"extensions": ["jxs"]
		},
		"image/jxsc": {
			"source": "iana",
			"extensions": ["jxsc"]
		},
		"image/jxsi": {
			"source": "iana",
			"extensions": ["jxsi"]
		},
		"image/jxss": {
			"source": "iana",
			"extensions": ["jxss"]
		},
		"image/ktx": {
			"source": "iana",
			"extensions": ["ktx"]
		},
		"image/ktx2": {
			"source": "iana",
			"extensions": ["ktx2"]
		},
		"image/naplps": { "source": "iana" },
		"image/pjpeg": { "compressible": false },
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": ["png"]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": ["btif"]
		},
		"image/prs.pti": {
			"source": "iana",
			"extensions": ["pti"]
		},
		"image/pwg-raster": { "source": "iana" },
		"image/sgi": {
			"source": "apache",
			"extensions": ["sgi"]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["svg", "svgz"]
		},
		"image/t38": {
			"source": "iana",
			"extensions": ["t38"]
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": ["tif", "tiff"]
		},
		"image/tiff-fx": {
			"source": "iana",
			"extensions": ["tfx"]
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": ["psd"]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana",
			"extensions": ["azv"]
		},
		"image/vnd.cns.inf2": { "source": "iana" },
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": ["djvu", "djv"]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": ["dwg"]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": ["dxf"]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": ["fbs"]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": ["fpx"]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": ["fst"]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": ["mmr"]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": ["rlc"]
		},
		"image/vnd.globalgraphics.pgb": { "source": "iana" },
		"image/vnd.microsoft.icon": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/vnd.mix": { "source": "iana" },
		"image/vnd.mozilla.apng": { "source": "iana" },
		"image/vnd.ms-dds": {
			"compressible": true,
			"extensions": ["dds"]
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": ["mdi"]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": ["wdp"]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": ["npx"]
		},
		"image/vnd.pco.b16": {
			"source": "iana",
			"extensions": ["b16"]
		},
		"image/vnd.radiance": { "source": "iana" },
		"image/vnd.sealed.png": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
		"image/vnd.svf": { "source": "iana" },
		"image/vnd.tencent.tap": {
			"source": "iana",
			"extensions": ["tap"]
		},
		"image/vnd.valve.source.texture": {
			"source": "iana",
			"extensions": ["vtf"]
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": ["wbmp"]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": ["xif"]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana",
			"extensions": ["pcx"]
		},
		"image/webp": {
			"source": "apache",
			"extensions": ["webp"]
		},
		"image/wmf": {
			"source": "iana",
			"extensions": ["wmf"]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": ["3ds"]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": ["ras"]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": ["cmx"]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": ["jng"]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": ["sid"]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": ["pcx"]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": ["pic", "pct"]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": ["pnm"]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": ["pbm"]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": ["pgm"]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": ["ppm"]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": ["rgb"]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": ["tga"]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": ["xbm"]
		},
		"image/x-xcf": { "compressible": false },
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": ["xpm"]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": ["xwd"]
		},
		"message/cpim": { "source": "iana" },
		"message/delivery-status": { "source": "iana" },
		"message/disposition-notification": {
			"source": "iana",
			"extensions": ["disposition-notification"]
		},
		"message/external-body": { "source": "iana" },
		"message/feedback-report": { "source": "iana" },
		"message/global": {
			"source": "iana",
			"extensions": ["u8msg"]
		},
		"message/global-delivery-status": {
			"source": "iana",
			"extensions": ["u8dsn"]
		},
		"message/global-disposition-notification": {
			"source": "iana",
			"extensions": ["u8mdn"]
		},
		"message/global-headers": {
			"source": "iana",
			"extensions": ["u8hdr"]
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": { "source": "iana" },
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eml", "mime"]
		},
		"message/s-http": { "source": "iana" },
		"message/sip": { "source": "iana" },
		"message/sipfrag": { "source": "iana" },
		"message/tracking-status": { "source": "iana" },
		"message/vnd.si.simp": { "source": "iana" },
		"message/vnd.wfa.wsc": {
			"source": "iana",
			"extensions": ["wsc"]
		},
		"model/3mf": {
			"source": "iana",
			"extensions": ["3mf"]
		},
		"model/e57": { "source": "iana" },
		"model/gltf+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gltf"]
		},
		"model/gltf-binary": {
			"source": "iana",
			"compressible": true,
			"extensions": ["glb"]
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": ["igs", "iges"]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/mtl": {
			"source": "iana",
			"extensions": ["mtl"]
		},
		"model/obj": {
			"source": "iana",
			"extensions": ["obj"]
		},
		"model/step": { "source": "iana" },
		"model/step+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["stpx"]
		},
		"model/step+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpz"]
		},
		"model/step-xml+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpxz"]
		},
		"model/stl": {
			"source": "iana",
			"extensions": ["stl"]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dae"]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": ["dwf"]
		},
		"model/vnd.flatland.3dml": { "source": "iana" },
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": ["gdl"]
		},
		"model/vnd.gs-gdl": { "source": "apache" },
		"model/vnd.gs.gdl": { "source": "iana" },
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": ["gtw"]
		},
		"model/vnd.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": ["mts"]
		},
		"model/vnd.opengex": {
			"source": "iana",
			"extensions": ["ogex"]
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana",
			"extensions": ["x_b"]
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana",
			"extensions": ["x_t"]
		},
		"model/vnd.pytha.pyox": { "source": "iana" },
		"model/vnd.rosette.annotated-data-model": { "source": "iana" },
		"model/vnd.sap.vds": {
			"source": "iana",
			"extensions": ["vds"]
		},
		"model/vnd.usdz+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["usdz"]
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana",
			"extensions": ["bsp"]
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": ["vtu"]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": ["wrl", "vrml"]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3db", "x3dbz"]
		},
		"model/x3d+fastinfoset": {
			"source": "iana",
			"extensions": ["x3db"]
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3dv", "x3dvz"]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["x3d", "x3dz"]
		},
		"model/x3d-vrml": {
			"source": "iana",
			"extensions": ["x3dv"]
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": { "source": "iana" },
		"multipart/byteranges": { "source": "iana" },
		"multipart/digest": { "source": "iana" },
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": { "source": "iana" },
		"multipart/mixed": { "source": "iana" },
		"multipart/multilingual": { "source": "iana" },
		"multipart/parallel": { "source": "iana" },
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": { "source": "iana" },
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/vnd.bint.med-plus": { "source": "iana" },
		"multipart/voice-message": { "source": "iana" },
		"multipart/x-mixed-replace": { "source": "iana" },
		"text/1d-interleaved-parityfec": { "source": "iana" },
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": ["appcache", "manifest"]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": ["ics", "ifb"]
		},
		"text/calender": { "compressible": true },
		"text/cmd": { "compressible": true },
		"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
		"text/cql": { "source": "iana" },
		"text/cql-expression": { "source": "iana" },
		"text/cql-identifier": { "source": "iana" },
		"text/css": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["css"]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csv"]
		},
		"text/csv-schema": { "source": "iana" },
		"text/directory": { "source": "iana" },
		"text/dns": { "source": "iana" },
		"text/ecmascript": { "source": "iana" },
		"text/encaprtp": { "source": "iana" },
		"text/enriched": { "source": "iana" },
		"text/fhirpath": { "source": "iana" },
		"text/flexfec": { "source": "iana" },
		"text/fwdred": { "source": "iana" },
		"text/gff3": { "source": "iana" },
		"text/grammar-ref-list": { "source": "iana" },
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": { "extensions": ["jade"] },
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": { "source": "iana" },
		"text/jsx": {
			"compressible": true,
			"extensions": ["jsx"]
		},
		"text/less": {
			"compressible": true,
			"extensions": ["less"]
		},
		"text/markdown": {
			"source": "iana",
			"compressible": true,
			"extensions": ["markdown", "md"]
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": ["mml"]
		},
		"text/mdx": {
			"compressible": true,
			"extensions": ["mdx"]
		},
		"text/mizar": { "source": "iana" },
		"text/n3": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["n3"]
		},
		"text/parameters": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/parityfec": { "source": "iana" },
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/prs.fallenstein.rst": { "source": "iana" },
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": ["dsc"]
		},
		"text/prs.prop.logic": { "source": "iana" },
		"text/raptorfec": { "source": "iana" },
		"text/red": { "source": "iana" },
		"text/rfc822-headers": { "source": "iana" },
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtx"]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"text/rtp-enc-aescm128": { "source": "iana" },
		"text/rtploopback": { "source": "iana" },
		"text/rtx": { "source": "iana" },
		"text/sgml": {
			"source": "iana",
			"extensions": ["sgml", "sgm"]
		},
		"text/shaclc": { "source": "iana" },
		"text/shex": {
			"source": "iana",
			"extensions": ["shex"]
		},
		"text/slim": { "extensions": ["slim", "slm"] },
		"text/spdx": {
			"source": "iana",
			"extensions": ["spdx"]
		},
		"text/strings": { "source": "iana" },
		"text/stylus": { "extensions": ["stylus", "styl"] },
		"text/t140": { "source": "iana" },
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tsv"]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["ttl"]
		},
		"text/ulpfec": { "source": "iana" },
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vcard"]
		},
		"text/vnd.a": { "source": "iana" },
		"text/vnd.abc": { "source": "iana" },
		"text/vnd.ascii-art": { "source": "iana" },
		"text/vnd.curl": {
			"source": "iana",
			"extensions": ["curl"]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": ["dcurl"]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": ["mcurl"]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": ["scurl"]
		},
		"text/vnd.debian.copyright": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.dmclientscript": { "source": "iana" },
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.familysearch.gedcom": {
			"source": "iana",
			"extensions": ["ged"]
		},
		"text/vnd.ficlab.flt": { "source": "iana" },
		"text/vnd.fly": {
			"source": "iana",
			"extensions": ["fly"]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": ["flx"]
		},
		"text/vnd.gml": { "source": "iana" },
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": ["gv"]
		},
		"text/vnd.hans": { "source": "iana" },
		"text/vnd.hgl": { "source": "iana" },
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": ["3dml"]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": ["spot"]
		},
		"text/vnd.iptc.newsml": { "source": "iana" },
		"text/vnd.iptc.nitf": { "source": "iana" },
		"text/vnd.latex-z": { "source": "iana" },
		"text/vnd.motorola.reflex": { "source": "iana" },
		"text/vnd.ms-mediapackage": { "source": "iana" },
		"text/vnd.net2phone.commcenter.command": { "source": "iana" },
		"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
		"text/vnd.senx.warpscript": { "source": "iana" },
		"text/vnd.si.uricatalogue": { "source": "iana" },
		"text/vnd.sosi": { "source": "iana" },
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["jad"]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.wap.si": { "source": "iana" },
		"text/vnd.wap.sl": { "source": "iana" },
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": ["wml"]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": ["wmls"]
		},
		"text/vtt": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["vtt"]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": ["s", "asm"]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": ["htc"]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": { "compressible": true },
		"text/x-handlebars-template": { "extensions": ["hbs"] },
		"text/x-java-source": {
			"source": "apache",
			"extensions": ["java"]
		},
		"text/x-jquery-tmpl": { "compressible": true },
		"text/x-lua": { "extensions": ["lua"] },
		"text/x-markdown": {
			"compressible": true,
			"extensions": ["mkd"]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": ["nfo"]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": ["opml"]
		},
		"text/x-org": {
			"compressible": true,
			"extensions": ["org"]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": ["p", "pas"]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": ["pde"]
		},
		"text/x-sass": { "extensions": ["sass"] },
		"text/x-scss": { "extensions": ["scss"] },
		"text/x-setext": {
			"source": "apache",
			"extensions": ["etx"]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": ["sfv"]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": ["ymp"]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": ["uu"]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": ["vcs"]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": ["vcf"]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xml"]
		},
		"text/xml-external-parsed-entity": { "source": "iana" },
		"text/yaml": {
			"compressible": true,
			"extensions": ["yaml", "yml"]
		},
		"video/1d-interleaved-parityfec": { "source": "iana" },
		"video/3gpp": {
			"source": "iana",
			"extensions": ["3gp", "3gpp"]
		},
		"video/3gpp-tt": { "source": "iana" },
		"video/3gpp2": {
			"source": "iana",
			"extensions": ["3g2"]
		},
		"video/av1": { "source": "iana" },
		"video/bmpeg": { "source": "iana" },
		"video/bt656": { "source": "iana" },
		"video/celb": { "source": "iana" },
		"video/dv": { "source": "iana" },
		"video/encaprtp": { "source": "iana" },
		"video/ffv1": { "source": "iana" },
		"video/flexfec": { "source": "iana" },
		"video/h261": {
			"source": "iana",
			"extensions": ["h261"]
		},
		"video/h263": {
			"source": "iana",
			"extensions": ["h263"]
		},
		"video/h263-1998": { "source": "iana" },
		"video/h263-2000": { "source": "iana" },
		"video/h264": {
			"source": "iana",
			"extensions": ["h264"]
		},
		"video/h264-rcdo": { "source": "iana" },
		"video/h264-svc": { "source": "iana" },
		"video/h265": { "source": "iana" },
		"video/iso.segment": {
			"source": "iana",
			"extensions": ["m4s"]
		},
		"video/jpeg": {
			"source": "iana",
			"extensions": ["jpgv"]
		},
		"video/jpeg2000": { "source": "iana" },
		"video/jpm": {
			"source": "apache",
			"extensions": ["jpm", "jpgm"]
		},
		"video/jxsv": { "source": "iana" },
		"video/mj2": {
			"source": "iana",
			"extensions": ["mj2", "mjp2"]
		},
		"video/mp1s": { "source": "iana" },
		"video/mp2p": { "source": "iana" },
		"video/mp2t": {
			"source": "iana",
			"extensions": ["ts"]
		},
		"video/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": { "source": "iana" },
		"video/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": { "source": "iana" },
		"video/mpv": { "source": "iana" },
		"video/nv": { "source": "iana" },
		"video/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogv"]
		},
		"video/parityfec": { "source": "iana" },
		"video/pointer": { "source": "iana" },
		"video/quicktime": {
			"source": "iana",
			"compressible": false,
			"extensions": ["qt", "mov"]
		},
		"video/raptorfec": { "source": "iana" },
		"video/raw": { "source": "iana" },
		"video/rtp-enc-aescm128": { "source": "iana" },
		"video/rtploopback": { "source": "iana" },
		"video/rtx": { "source": "iana" },
		"video/scip": { "source": "iana" },
		"video/smpte291": { "source": "iana" },
		"video/smpte292m": { "source": "iana" },
		"video/ulpfec": { "source": "iana" },
		"video/vc1": { "source": "iana" },
		"video/vc2": { "source": "iana" },
		"video/vnd.cctv": { "source": "iana" },
		"video/vnd.dece.hd": {
			"source": "iana",
			"extensions": ["uvh", "uvvh"]
		},
		"video/vnd.dece.mobile": {
			"source": "iana",
			"extensions": ["uvm", "uvvm"]
		},
		"video/vnd.dece.mp4": { "source": "iana" },
		"video/vnd.dece.pd": {
			"source": "iana",
			"extensions": ["uvp", "uvvp"]
		},
		"video/vnd.dece.sd": {
			"source": "iana",
			"extensions": ["uvs", "uvvs"]
		},
		"video/vnd.dece.video": {
			"source": "iana",
			"extensions": ["uvv", "uvvv"]
		},
		"video/vnd.directv.mpeg": { "source": "iana" },
		"video/vnd.directv.mpeg-tts": { "source": "iana" },
		"video/vnd.dlna.mpeg-tts": { "source": "iana" },
		"video/vnd.dvb.file": {
			"source": "iana",
			"extensions": ["dvb"]
		},
		"video/vnd.fvt": {
			"source": "iana",
			"extensions": ["fvt"]
		},
		"video/vnd.hns.video": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.ttsavc": { "source": "iana" },
		"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
		"video/vnd.motorola.video": { "source": "iana" },
		"video/vnd.motorola.videop": { "source": "iana" },
		"video/vnd.mpegurl": {
			"source": "iana",
			"extensions": ["mxu", "m4u"]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "iana",
			"extensions": ["pyv"]
		},
		"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
		"video/vnd.nokia.mp4vr": { "source": "iana" },
		"video/vnd.nokia.videovoip": { "source": "iana" },
		"video/vnd.objectvideo": { "source": "iana" },
		"video/vnd.radgamettools.bink": { "source": "iana" },
		"video/vnd.radgamettools.smacker": { "source": "iana" },
		"video/vnd.sealed.mpeg1": { "source": "iana" },
		"video/vnd.sealed.mpeg4": { "source": "iana" },
		"video/vnd.sealed.swf": { "source": "iana" },
		"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
		"video/vnd.uvvu.mp4": {
			"source": "iana",
			"extensions": ["uvu", "uvvu"]
		},
		"video/vnd.vivo": {
			"source": "iana",
			"extensions": ["viv"]
		},
		"video/vnd.youtube.yt": { "source": "iana" },
		"video/vp8": { "source": "iana" },
		"video/vp9": { "source": "iana" },
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["webm"]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": ["f4v"]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": ["fli"]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["flv"]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": ["m4v"]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": ["mng"]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": ["asf", "asx"]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": ["vob"]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": ["wm"]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["wmv"]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": ["wmx"]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": ["wvx"]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": ["avi"]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": ["movie"]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": ["smv"]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": ["ice"]
		},
		"x-shader/x-fragment": { "compressible": true },
		"x-shader/x-vertex": { "compressible": true }
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* mime-db
	* Copyright(c) 2014 Jonathan Ong
	* Copyright(c) 2015-2022 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module exports.
	*/
	module.exports = require_db();
}));

//#endregion
//#region ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
/*!
* mime-types
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_mime_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var db = require_mime_db();
	var extname = require("path").extname;
	/**
	* Module variables.
	* @private
	*/
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	/**
	* Module exports.
	* @public
	*/
	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	/**
	* Get the default charset for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function charset(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var mime = match && db[match[1].toLowerCase()];
		if (mime && mime.charset) return mime.charset;
		if (match && TEXT_TYPE_REGEXP.test(match[1])) return "UTF-8";
		return false;
	}
	/**
	* Create a full Content-Type header given a MIME type or extension.
	*
	* @param {string} str
	* @return {boolean|string}
	*/
	function contentType(str) {
		if (!str || typeof str !== "string") return false;
		var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime) return false;
		if (mime.indexOf("charset") === -1) {
			var charset = exports.charset(mime);
			if (charset) mime += "; charset=" + charset.toLowerCase();
		}
		return mime;
	}
	/**
	* Get the default extension for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function extension(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var exts = match && exports.extensions[match[1].toLowerCase()];
		if (!exts || !exts.length) return false;
		return exts[0];
	}
	/**
	* Lookup the MIME type for a file path/extension.
	*
	* @param {string} path
	* @return {boolean|string}
	*/
	function lookup(path$59) {
		if (!path$59 || typeof path$59 !== "string") return false;
		var extension = extname("x." + path$59).toLowerCase().substr(1);
		if (!extension) return false;
		return exports.types[extension] || false;
	}
	/**
	* Populate the extensions and types maps.
	* @private
	*/
	function populateMaps(extensions, types) {
		var preference = [
			"nginx",
			"apache",
			void 0,
			"iana"
		];
		Object.keys(db).forEach(function forEachMimeType(type) {
			var mime = db[type];
			var exts = mime.extensions;
			if (!exts || !exts.length) return;
			extensions[type] = exts;
			for (var i = 0; i < exts.length; i++) {
				var extension = exts[i];
				if (types[extension]) {
					var from = preference.indexOf(db[types[extension]].source);
					var to = preference.indexOf(mime.source);
					if (types[extension] !== "application/octet-stream" && (from > to || from === to && types[extension].substr(0, 12) === "application/")) continue;
				}
				types[extension] = type;
			}
		});
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js
/*!
* type-is
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_type_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var typer = require_media_typer();
	var mime = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = typeofrequest;
	module.exports.is = typeis;
	module.exports.hasBody = hasbody;
	module.exports.normalize = normalize;
	module.exports.match = mimeMatch;
	/**
	* Compare a `value` content-type with `types`.
	* Each `type` can be an extension like `html`,
	* a special shortcut like `multipart` or `urlencoded`,
	* or a mime type.
	*
	* If no types match, `false` is returned.
	* Otherwise, the first `type` that matches is returned.
	*
	* @param {String} value
	* @param {Array} types
	* @public
	*/
	function typeis(value, types_) {
		var i;
		var types = types_;
		var val = tryNormalizeType(value);
		if (!val) return false;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length - 1);
			for (i = 0; i < types.length; i++) types[i] = arguments[i + 1];
		}
		if (!types || !types.length) return val;
		var type;
		for (i = 0; i < types.length; i++) if (mimeMatch(normalize(type = types[i]), val)) return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
		return false;
	}
	/**
	* Check if a request has a request body.
	* A request with a body __must__ either have `transfer-encoding`
	* or `content-length` headers set.
	* http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	*
	* @param {Object} request
	* @return {Boolean}
	* @public
	*/
	function hasbody(req) {
		return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
	}
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains any of the give mime `type`s.
	* If there is no request body, `null` is returned.
	* If there is no content type, `false` is returned.
	* Otherwise, it returns the first `type` that matches.
	*
	* Examples:
	*
	*     // With Content-Type: text/html; charset=utf-8
	*     this.is('html'); // => 'html'
	*     this.is('text/html'); // => 'text/html'
	*     this.is('text/*', 'application/json'); // => 'text/html'
	*
	*     // When Content-Type is application/json
	*     this.is('json', 'urlencoded'); // => 'json'
	*     this.is('application/json'); // => 'application/json'
	*     this.is('html', 'application/*'); // => 'application/json'
	*
	*     this.is('html'); // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	function typeofrequest(req, types_) {
		var types = types_;
		if (!hasbody(req)) return null;
		if (arguments.length > 2) {
			types = new Array(arguments.length - 1);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i + 1];
		}
		var value = req.headers["content-type"];
		return typeis(value, types);
	}
	/**
	* Normalize a mime type.
	* If it's a shorthand, expand it to a valid mime type.
	*
	* In general, you probably want:
	*
	*   var type = is(req, ['urlencoded', 'json', 'multipart']);
	*
	* Then use the appropriate body parsers.
	* These three are the most common request body types
	* and are thus ensured to work.
	*
	* @param {String} type
	* @private
	*/
	function normalize(type) {
		if (typeof type !== "string") return false;
		switch (type) {
			case "urlencoded": return "application/x-www-form-urlencoded";
			case "multipart": return "multipart/*";
		}
		if (type[0] === "+") return "*/*" + type;
		return type.indexOf("/") === -1 ? mime.lookup(type) : type;
	}
	/**
	* Check if `expected` mime type
	* matches `actual` mime type with
	* wildcard and +suffix support.
	*
	* @param {String} expected
	* @param {String} actual
	* @return {Boolean}
	* @private
	*/
	function mimeMatch(expected, actual) {
		if (expected === false) return false;
		var actualParts = actual.split("/");
		var expectedParts = expected.split("/");
		if (actualParts.length !== 2 || expectedParts.length !== 2) return false;
		if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) return false;
		if (expectedParts[1].substr(0, 2) === "*+") return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
		if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) return false;
		return true;
	}
	/**
	* Normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function normalizeType(value) {
		var type = typer.parse(value);
		type.parameters = void 0;
		return typer.format(type);
	}
	/**
	* Try to normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function tryNormalizeType(value) {
		if (!value) return null;
		try {
			return normalizeType(value);
		} catch (err) {
			return null;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/lib/types/json.js
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_json = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var createError = require_http_errors();
	var debug = require_src()("body-parser:json");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = json;
	/**
	* RegExp to match the first non-space in a string.
	*
	* Allowed whitespace is defined in RFC 7159:
	*
	*    ws = *(
	*            %x20 /              ; Space
	*            %x09 /              ; Horizontal tab
	*            %x0A /              ; Line feed or New line
	*            %x0D )              ; Carriage return
	*/
	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
	var JSON_SYNTAX_CHAR = "#";
	var JSON_SYNTAX_REGEXP = /#+/g;
	/**
	* Create a middleware to parse JSON bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function json(options) {
		var opts = options || {};
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var inflate = opts.inflate !== false;
		var reviver = opts.reviver;
		var strict = opts.strict !== false;
		var type = opts.type || "application/json";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(body) {
			if (body.length === 0) return {};
			if (strict) {
				var first = firstchar(body);
				if (first !== "{" && first !== "[") {
					debug("strict violation");
					throw createStrictSyntaxError(body, first);
				}
			}
			try {
				debug("parse json");
				return JSON.parse(body, reviver);
			} catch (e) {
				throw normalizeJsonSyntaxError(e, {
					message: e.message,
					stack: e.stack
				});
			}
		}
		return function jsonParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			var charset = getCharset(req) || "utf-8";
			if (charset.slice(0, 4) !== "utf-") {
				debug("invalid charset");
				next(createError(415, "unsupported charset \"" + charset.toUpperCase() + "\"", {
					charset,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: charset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Create strict violation syntax error matching native error.
	*
	* @param {string} str
	* @param {string} char
	* @return {Error}
	* @private
	*/
	function createStrictSyntaxError(str, char) {
		var index = str.indexOf(char);
		var partial = "";
		if (index !== -1) {
			partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
			for (var i = index + 1; i < str.length; i++) partial += JSON_SYNTAX_CHAR;
		}
		try {
			JSON.parse(partial);
			/* istanbul ignore next */ throw new SyntaxError("strict violation");
		} catch (e) {
			return normalizeJsonSyntaxError(e, {
				message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
					return str.substring(index, index + placeholder.length);
				}),
				stack: e.stack
			});
		}
	}
	/**
	* Get the first non-whitespace character in a string.
	*
	* @param {string} str
	* @return {function}
	* @private
	*/
	function firstchar(str) {
		var match = FIRST_CHAR_REGEXP.exec(str);
		return match ? match[1] : void 0;
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Normalize a SyntaxError for JSON.parse.
	*
	* @param {SyntaxError} error
	* @param {object} obj
	* @return {SyntaxError}
	*/
	function normalizeJsonSyntaxError(error, obj) {
		var keys = Object.getOwnPropertyNames(error);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (key !== "stack" && key !== "message") delete error[key];
		}
		error.stack = obj.stack.replace(error.message, obj.message);
		error.message = obj.message;
		return error;
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/lib/types/raw.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_raw = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes = require_bytes();
	var debug = require_src()("body-parser:raw");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = raw;
	/**
	* Create a middleware to parse raw bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function raw(options) {
		var opts = options || {};
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/octet-stream";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(buf) {
			return buf;
		}
		return function rawParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: null,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/lib/types/text.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_text = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var debug = require_src()("body-parser:text");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = text;
	/**
	* Create a middleware to parse text bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function text(options) {
		var opts = options || {};
		var defaultCharset = opts.defaultCharset || "utf-8";
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "text/plain";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(buf) {
			return buf;
		}
		return function textParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: getCharset(req) || defaultCharset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./type')} */
	module.exports = TypeError;
}));

//#endregion
//#region ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js
var require_util_inspect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require("util").inspect;
}));

//#endregion
//#region ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js
var require_object_inspect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasMap = typeof Map === "function" && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === "function" && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var weakMapHas = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap.prototype.has : null;
	var weakSetHas = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet.prototype.has : null;
	var weakRefDeref = typeof WeakRef === "function" && WeakRef.prototype ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
	var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
		return O.__proto__;
	} : null);
	function addNumericSeparator(num, str) {
		if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) return str;
		var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		if (typeof num === "number") {
			var int = num < 0 ? -$floor(-num) : $floor(num);
			if (int !== num) {
				var intStr = String(int);
				var dec = $slice.call(str, intStr.length + 1);
				return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
			}
		}
		return $replace.call(str, sepRegex, "$&_");
	}
	var utilInspect = require_util_inspect();
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
	var quotes = {
		__proto__: null,
		"double": "\"",
		single: "'"
	};
	var quoteREs = {
		__proto__: null,
		"double": /(["\\])/g,
		single: /(['\\])/g
	};
	module.exports = function inspect_(obj, options, depth, seen) {
		var opts = options || {};
		if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) throw new TypeError("option \"quoteStyle\" must be \"single\" or \"double\"");
		if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError("option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`");
		var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
		if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
		if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError("option \"indent\" must be \"\\t\", an integer > 0, or `null`");
		if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError("option \"numericSeparator\", if provided, must be `true` or `false`");
		var numericSeparator = opts.numericSeparator;
		if (typeof obj === "undefined") return "undefined";
		if (obj === null) return "null";
		if (typeof obj === "boolean") return obj ? "true" : "false";
		if (typeof obj === "string") return inspectString(obj, opts);
		if (typeof obj === "number") {
			if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
			var str = String(obj);
			return numericSeparator ? addNumericSeparator(obj, str) : str;
		}
		if (typeof obj === "bigint") {
			var bigIntStr = String(obj) + "n";
			return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		}
		var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
		if (typeof depth === "undefined") depth = 0;
		if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray(obj) ? "[Array]" : "[Object]";
		var indent = getIndent(opts, depth);
		if (typeof seen === "undefined") seen = [];
		else if (indexOf(seen, obj) >= 0) return "[Circular]";
		function inspect(value, from, noIndent) {
			if (from) {
				seen = $arrSlice.call(seen);
				seen.push(from);
			}
			if (noIndent) {
				var newOpts = { depth: opts.depth };
				if (has(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
				return inspect_(value, newOpts, depth + 1, seen);
			}
			return inspect_(value, opts, depth + 1, seen);
		}
		if (typeof obj === "function" && !isRegExp(obj)) {
			var name = nameOf(obj);
			var keys = arrObjKeys(obj, inspect);
			return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
		}
		if (isSymbol(obj)) {
			var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
			return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
		}
		if (isElement(obj)) {
			var s = "<" + $toLowerCase.call(String(obj.nodeName));
			var attrs = obj.attributes || [];
			for (var i = 0; i < attrs.length; i++) s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
			s += ">";
			if (obj.childNodes && obj.childNodes.length) s += "...";
			s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
			return s;
		}
		if (isArray(obj)) {
			if (obj.length === 0) return "[]";
			var xs = arrObjKeys(obj, inspect);
			if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
			return "[ " + $join.call(xs, ", ") + " ]";
		}
		if (isError(obj)) {
			var parts = arrObjKeys(obj, inspect);
			if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
			if (parts.length === 0) return "[" + String(obj) + "]";
			return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
		}
		if (typeof obj === "object" && customInspect) {
			if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, { depth: maxDepth - depth });
			else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
		}
		if (isMap(obj)) {
			var mapParts = [];
			if (mapForEach) mapForEach.call(obj, function(value, key) {
				mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
			});
			return collectionOf("Map", mapSize.call(obj), mapParts, indent);
		}
		if (isSet(obj)) {
			var setParts = [];
			if (setForEach) setForEach.call(obj, function(value) {
				setParts.push(inspect(value, obj));
			});
			return collectionOf("Set", setSize.call(obj), setParts, indent);
		}
		if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
		if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
		if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
		if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
		if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
		if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
		if (isString(obj)) return markBoxed(inspect(String(obj)));
		if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
		if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) return "{ [object globalThis] }";
		if (!isDate(obj) && !isRegExp(obj)) {
			var ys = arrObjKeys(obj, inspect);
			var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
			var protoTag = obj instanceof Object ? "" : "null prototype";
			var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
			var tag = (isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
			if (ys.length === 0) return tag + "{}";
			if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
			return tag + "{ " + $join.call(ys, ", ") + " }";
		}
		return String(obj);
	};
	function wrapQuotes(s, defaultStyle, opts) {
		var quoteChar = quotes[opts.quoteStyle || defaultStyle];
		return quoteChar + s + quoteChar;
	}
	function quote(s) {
		return $replace.call(String(s), /"/g, "&quot;");
	}
	function canTrustToString(obj) {
		return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
	}
	function isArray(obj) {
		return toStr(obj) === "[object Array]" && canTrustToString(obj);
	}
	function isDate(obj) {
		return toStr(obj) === "[object Date]" && canTrustToString(obj);
	}
	function isRegExp(obj) {
		return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
	}
	function isError(obj) {
		return toStr(obj) === "[object Error]" && canTrustToString(obj);
	}
	function isString(obj) {
		return toStr(obj) === "[object String]" && canTrustToString(obj);
	}
	function isNumber(obj) {
		return toStr(obj) === "[object Number]" && canTrustToString(obj);
	}
	function isBoolean(obj) {
		return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
	}
	function isSymbol(obj) {
		if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
		if (typeof obj === "symbol") return true;
		if (!obj || typeof obj !== "object" || !symToString) return false;
		try {
			symToString.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	function isBigInt(obj) {
		if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
		try {
			bigIntValueOf.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	var hasOwn = Object.prototype.hasOwnProperty || function(key) {
		return key in this;
	};
	function has(obj, key) {
		return hasOwn.call(obj, key);
	}
	function toStr(obj) {
		return objectToString.call(obj);
	}
	function nameOf(f) {
		if (f.name) return f.name;
		var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		if (m) return m[1];
		return null;
	}
	function indexOf(xs, x) {
		if (xs.indexOf) return xs.indexOf(x);
		for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
		return -1;
	}
	function isMap(x) {
		if (!mapSize || !x || typeof x !== "object") return false;
		try {
			mapSize.call(x);
			try {
				setSize.call(x);
			} catch (s) {
				return true;
			}
			return x instanceof Map;
		} catch (e) {}
		return false;
	}
	function isWeakMap(x) {
		if (!weakMapHas || !x || typeof x !== "object") return false;
		try {
			weakMapHas.call(x, weakMapHas);
			try {
				weakSetHas.call(x, weakSetHas);
			} catch (s) {
				return true;
			}
			return x instanceof WeakMap;
		} catch (e) {}
		return false;
	}
	function isWeakRef(x) {
		if (!weakRefDeref || !x || typeof x !== "object") return false;
		try {
			weakRefDeref.call(x);
			return true;
		} catch (e) {}
		return false;
	}
	function isSet(x) {
		if (!setSize || !x || typeof x !== "object") return false;
		try {
			setSize.call(x);
			try {
				mapSize.call(x);
			} catch (m) {
				return true;
			}
			return x instanceof Set;
		} catch (e) {}
		return false;
	}
	function isWeakSet(x) {
		if (!weakSetHas || !x || typeof x !== "object") return false;
		try {
			weakSetHas.call(x, weakSetHas);
			try {
				weakMapHas.call(x, weakMapHas);
			} catch (s) {
				return true;
			}
			return x instanceof WeakSet;
		} catch (e) {}
		return false;
	}
	function isElement(x) {
		if (!x || typeof x !== "object") return false;
		if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
		return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
	}
	function inspectString(str, opts) {
		if (str.length > opts.maxStringLength) {
			var remaining = str.length - opts.maxStringLength;
			var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
			return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		}
		var quoteRE = quoteREs[opts.quoteStyle || "single"];
		quoteRE.lastIndex = 0;
		return wrapQuotes($replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte), "single", opts);
	}
	function lowbyte(c) {
		var n = c.charCodeAt(0);
		var x = {
			8: "b",
			9: "t",
			10: "n",
			12: "f",
			13: "r"
		}[n];
		if (x) return "\\" + x;
		return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
	}
	function markBoxed(str) {
		return "Object(" + str + ")";
	}
	function weakCollectionOf(type) {
		return type + " { ? }";
	}
	function collectionOf(type, size, entries, indent) {
		var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
		return type + " (" + size + ") {" + joinedEntries + "}";
	}
	function singleLineValues(xs) {
		for (var i = 0; i < xs.length; i++) if (indexOf(xs[i], "\n") >= 0) return false;
		return true;
	}
	function getIndent(opts, depth) {
		var baseIndent;
		if (opts.indent === "	") baseIndent = "	";
		else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
		else return null;
		return {
			base: baseIndent,
			prev: $join.call(Array(depth + 1), baseIndent)
		};
	}
	function indentedJoin(xs, indent) {
		if (xs.length === 0) return "";
		var lineJoiner = "\n" + indent.prev + indent.base;
		return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
	}
	function arrObjKeys(obj, inspect) {
		var isArr = isArray(obj);
		var xs = [];
		if (isArr) {
			xs.length = obj.length;
			for (var i = 0; i < obj.length; i++) xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
		}
		var syms = typeof gOPS === "function" ? gOPS(obj) : [];
		var symMap;
		if (hasShammedSymbols) {
			symMap = {};
			for (var k = 0; k < syms.length; k++) symMap["$" + syms[k]] = syms[k];
		}
		for (var key in obj) {
			if (!has(obj, key)) continue;
			if (isArr && String(Number(key)) === key && key < obj.length) continue;
			if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue;
			else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
			else xs.push(key + ": " + inspect(obj[key], obj));
		}
		if (typeof gOPS === "function") {
			for (var j = 0; j < syms.length; j++) if (isEnumerable.call(obj, syms[j])) xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
		}
		return xs;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js
var require_side_channel_list = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inspect = require_object_inspect();
	var $TypeError = require_type();
	/** @type {import('./list.d.ts').listGetNode} */
	var listGetNode = function(list, key, isDelete) {
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		for (; (curr = prev.next) != null; prev = curr) if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				curr.next = list.next;
				list.next = curr;
			}
			return curr;
		}
	};
	/** @type {import('./list.d.ts').listGet} */
	var listGet = function(objects, key) {
		if (!objects) return;
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	/** @type {import('./list.d.ts').listSet} */
	var listSet = function(objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) node.value = value;
		else objects.next = {
			key,
			next: objects.next,
			value
		};
	};
	/** @type {import('./list.d.ts').listHas} */
	var listHas = function(objects, key) {
		if (!objects) return false;
		return !!listGetNode(objects, key);
	};
	/** @type {import('./list.d.ts').listDelete} */
	var listDelete = function(objects, key) {
		if (objects) return listGetNode(objects, key, true);
	};
	/** @type {import('.')} */
	module.exports = function getSideChannelList() {
		/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				var root = $o && $o.next;
				var deletedNode = listDelete($o, key);
				if (deletedNode && root && root === deletedNode) $o = void 0;
				return !!deletedNode;
			},
			get: function(key) {
				return listGet($o, key);
			},
			has: function(key) {
				return listHas($o, key);
			},
			set: function(key, value) {
				if (!$o) $o = { next: void 0 };
				listSet($o, key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	module.exports = Object;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	module.exports = Error;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./eval')} */
	module.exports = EvalError;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./range')} */
	module.exports = RangeError;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./uri')} */
	module.exports = URIError;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./max')} */
	module.exports = Math.max;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./min')} */
	module.exports = Math.min;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./round')} */
	module.exports = Math.round;
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN(a) {
		return a !== a;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $isNaN = require_isNaN();
	/** @type {import('./sign')} */
	module.exports = function sign(number) {
		if ($isNaN(number) || number === 0) return number;
		return number < 0 ? -1 : 1;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
}));

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	var $gOPD = require_gOPD();
	if ($gOPD) try {
		$gOPD([], "length");
	} catch (e) {
		$gOPD = null;
	}
	module.exports = $gOPD;
}));

//#endregion
//#region ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) try {
		$defineProperty({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty = false;
	}
	module.exports = $defineProperty;
}));

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
}));

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $Object = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object.getPrototypeOf || null;
}));

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty(a, b) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j = 0; j < b.length; j += 1) arr[j + a.length] = b[j];
		return arr;
	};
	var slicy = function slicy(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) arr[j] = arrLike[i];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bind = require_function_bind();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind.call($call, $apply);
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bind = require_function_bind();
	var $TypeError = require_type();
	var $call = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError("a function is required");
		return $actualApply(bind, $call, args);
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object(value));
	} : false;
}));

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto(O) {
		return reflectGetProto(O);
	} : originalGetProto ? function getProto(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O);
	} : getDunderProto ? function getProto(O) {
		return getDunderProto(O);
	} : null;
}));

//#endregion
//#region ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind.call(call, $hasOwn);
}));

//#endregion
//#region ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var undefined;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor = require_floor();
	var max = require_max();
	var min = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
		"%AsyncFromSyncIteratorPrototype%": undefined,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
		"%JSON%": typeof JSON === "object" ? JSON : undefined,
		"%Map%": typeof Map === "undefined" ? undefined : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
		"%Symbol%": hasSymbols ? Symbol : undefined,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor,
		"%Math.max%": max,
		"%Math.min%": min,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto) try {
		null.error;
	} catch (e) {
		INTRINSICS["%Error.prototype%"] = getProto(getProto(e));
	}
	var doEval = function doEval(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval("%AsyncGenerator%");
			if (gen && getProto) value = getProto(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind = require_function_bind();
	var hasOwn = require_hasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string, rePropName, function(match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;
					if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
					else value = value[part];
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
var require_call_bound = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBindBasic = require_call_bind_apply_helpers();
	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
	/** @type {import('.')} */
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBindBasic([intrinsic]);
		return intrinsic;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js
var require_side_channel_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect = require_object_inspect();
	var $TypeError = require_type();
	var $Map = GetIntrinsic("%Map%", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
	var $mapGet = callBound("Map.prototype.get", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
	var $mapSet = callBound("Map.prototype.set", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapHas = callBound("Map.prototype.has", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapDelete = callBound("Map.prototype.delete", true);
	/** @type {<K, V>(thisArg: Map<K, V>) => number} */
	var $mapSize = callBound("Map.prototype.size", true);
	/** @type {import('.')} */
	module.exports = !!$Map && function getSideChannelMap() {
		/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {Map<K, V> | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($m) {
					var result = $mapDelete($m, key);
					if ($mapSize($m) === 0) $m = void 0;
					return result;
				}
				return false;
			},
			get: function(key) {
				if ($m) return $mapGet($m, key);
			},
			has: function(key) {
				if ($m) return $mapHas($m, key);
				return false;
			},
			set: function(key, value) {
				if (!$m) $m = new $Map();
				$mapSet($m, key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect = require_object_inspect();
	var getSideChannelMap = require_side_channel_map();
	var $TypeError = require_type();
	var $WeakMap = GetIntrinsic("%WeakMap%", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
	var $weakMapGet = callBound("WeakMap.prototype.get", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
	var $weakMapSet = callBound("WeakMap.prototype.set", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapHas = callBound("WeakMap.prototype.has", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
	/** @type {import('.')} */
	module.exports = $WeakMap ? function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapDelete($wm, key);
				} else if (getSideChannelMap) {
					if ($m) return $m["delete"](key);
				}
				return false;
			},
			get: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapGet($wm, key);
				}
				return $m && $m.get(key);
			},
			has: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapHas($wm, key);
				}
				return !!$m && $m.has(key);
			},
			set: function(key, value) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if (!$wm) $wm = new $WeakMap();
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) $m = getSideChannelMap();
					/** @type {NonNullable<typeof $m>} */ $m.set(key, value);
				}
			}
		};
		return channel;
	} : getSideChannelMap;
}));

//#endregion
//#region ../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js
var require_side_channel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $TypeError = require_type();
	var inspect = require_object_inspect();
	var getSideChannelList = require_side_channel_list();
	var getSideChannelMap = require_side_channel_map();
	var makeChannel = require_side_channel_weakmap() || getSideChannelMap || getSideChannelList;
	/** @type {import('.')} */
	module.exports = function getSideChannel() {
		/** @typedef {ReturnType<typeof getSideChannel>} Channel */
		/** @type {Channel | undefined} */ var $channelData;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				return !!$channelData && $channelData["delete"](key);
			},
			get: function(key) {
				return $channelData && $channelData.get(key);
			},
			has: function(key) {
				return !!$channelData && $channelData.has(key);
			},
			set: function(key, value) {
				if (!$channelData) $channelData = makeChannel();
				$channelData.set(key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.2/node_modules/qs/lib/formats.js
var require_formats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	var Format = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	module.exports = {
		"default": Format.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace.call(value, percentTwenties, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format.RFC1738,
		RFC3986: Format.RFC3986
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.2/node_modules/qs/lib/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var formats = require_formats();
	var getSideChannel = require_side_channel();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var overflowChannel = getSideChannel();
	var markOverflow = function markOverflow(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
		return obj;
	};
	var isOverflow = function isOverflow(obj) {
		return overflowChannel.has(obj);
	};
	var getMaxIndex = function getMaxIndex(obj) {
		return overflowChannel.get(obj);
	};
	var setMaxIndex = function setMaxIndex(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
	};
	var hexTable = function() {
		var array = [];
		for (var i = 0; i < 256; ++i) array[array.length] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
		return array;
	}();
	var compactQueue = function compactQueue(queue) {
		while (queue.length > 1) {
			var item = queue.pop();
			var obj = item.obj[item.prop];
			if (isArray(obj)) {
				var compacted = [];
				for (var j = 0; j < obj.length; ++j) if (typeof obj[j] !== "undefined") compacted[compacted.length] = obj[j];
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject = function arrayToObject(source, options) {
		var obj = options && options.plainObjects ? { __proto__: null } : {};
		for (var i = 0; i < source.length; ++i) if (typeof source[i] !== "undefined") obj[i] = source[i];
		return obj;
	};
	var merge = function merge(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object" && typeof source !== "function") {
			if (isArray(target)) {
				var nextIndex = target.length;
				if (options && typeof options.arrayLimit === "number" && nextIndex > options.arrayLimit) return markOverflow(arrayToObject(target.concat(source), options), nextIndex);
				target[nextIndex] = source;
			} else if (target && typeof target === "object") {
				if (isOverflow(target)) {
					var newIndex = getMaxIndex(target) + 1;
					target[newIndex] = source;
					setMaxIndex(target, newIndex);
				} else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") {
			if (isOverflow(source)) {
				var sourceKeys = Object.keys(source);
				var result = options && options.plainObjects ? {
					__proto__: null,
					0: target
				} : { 0: target };
				for (var m = 0; m < sourceKeys.length; m++) {
					var oldKey = parseInt(sourceKeys[m], 10);
					result[oldKey + 1] = source[sourceKeys[m]];
				}
				return markOverflow(result, getMaxIndex(source) + 1);
			}
			var combined = [target].concat(source);
			if (options && typeof options.arrayLimit === "number" && combined.length > options.arrayLimit) return markOverflow(arrayToObject(combined, options), combined.length - 1);
			return combined;
		}
		var mergeTarget = target;
		if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
		if (isArray(target) && isArray(source)) {
			source.forEach(function(item, i) {
				if (has.call(target, i)) {
					var targetItem = target[i];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i] = merge(targetItem, item, options);
					else target[target.length] = item;
				} else target[i] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key) {
			var value = source[key];
			if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
			else acc[key] = value;
			if (isOverflow(source) && !isOverflow(acc)) markOverflow(acc, getMaxIndex(source));
			if (isOverflow(acc)) {
				var keyNum = parseInt(key, 10);
				if (String(keyNum) === key && keyNum >= 0 && keyNum > getMaxIndex(acc)) setMaxIndex(acc, keyNum);
			}
			return acc;
		}, mergeTarget);
	};
	var assign = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key) {
			acc[key] = source[key];
			return acc;
		}, target);
	};
	var decode = function(str, defaultDecoder, charset) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit = 1024;
	var encode = function encode(str, defaultEncoder, charset, kind, format) {
		if (str.length === 0) return str;
		var string = str;
		if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
		else if (typeof str !== "string") string = String(str);
		if (charset === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
			return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
		});
		var out = "";
		for (var j = 0; j < string.length; j += limit) {
			var segment = string.length >= limit ? string.slice(j, j + limit) : string;
			var arr = [];
			for (var i = 0; i < segment.length; ++i) {
				var c = segment.charCodeAt(i);
				if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
					arr[arr.length] = segment.charAt(i);
					continue;
				}
				if (c < 128) {
					arr[arr.length] = hexTable[c];
					continue;
				}
				if (c < 2048) {
					arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
					continue;
				}
				if (c < 55296 || c >= 57344) {
					arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
					continue;
				}
				i += 1;
				c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
				arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
			}
			out += arr.join("");
		}
		return out;
	};
	var compact = function compact(value) {
		var queue = [{
			obj: { o: value },
			prop: "o"
		}];
		var refs = [];
		for (var i = 0; i < queue.length; ++i) {
			var item = queue[i];
			var obj = item.obj[item.prop];
			var keys = Object.keys(obj);
			for (var j = 0; j < keys.length; ++j) {
				var key = keys[j];
				var val = obj[key];
				if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
					queue[queue.length] = {
						obj,
						prop: key
					};
					refs[refs.length] = val;
				}
			}
		}
		compactQueue(queue);
		return value;
	};
	var isRegExp = function isRegExp(obj) {
		return Object.prototype.toString.call(obj) === "[object RegExp]";
	};
	var isBuffer = function isBuffer(obj) {
		if (!obj || typeof obj !== "object") return false;
		return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	var combine = function combine(a, b, arrayLimit, plainObjects) {
		if (isOverflow(a)) {
			var newIndex = getMaxIndex(a) + 1;
			a[newIndex] = b;
			setMaxIndex(a, newIndex);
			return a;
		}
		var result = [].concat(a, b);
		if (result.length > arrayLimit) return markOverflow(arrayToObject(result, { plainObjects }), result.length - 1);
		return result;
	};
	var maybeMap = function maybeMap(val, fn) {
		if (isArray(val)) {
			var mapped = [];
			for (var i = 0; i < val.length; i += 1) mapped[mapped.length] = fn(val[i]);
			return mapped;
		}
		return fn(val);
	};
	module.exports = {
		arrayToObject,
		assign,
		combine,
		compact,
		decode,
		encode,
		isBuffer,
		isOverflow,
		isRegExp,
		markOverflow,
		maybeMap,
		merge
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.2/node_modules/qs/lib/stringify.js
var require_stringify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getSideChannel = require_side_channel();
	var utils = require_utils$1();
	var formats = require_formats();
	var has = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key) {
			return prefix + "[" + key + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function(arr, valueOrArray) {
		push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO = Date.prototype.toISOString;
	var defaultFormat = formats["default"];
	var defaults = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		commaRoundTrip: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils.encode,
		encodeValuesOnly: false,
		filter: void 0,
		format: defaultFormat,
		formatter: formats.formatters[defaultFormat],
		indices: false,
		serializeDate: function serializeDate(date) {
			return toISO.call(date);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel = {};
	var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
		var obj = object;
		var tmpSc = sideChannel;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
			if (value instanceof Date) return serializeDate(value);
			return value;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format)) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray(obj)) {
			if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray(filter)) objKeys = filter;
		else {
			var keys = Object.keys(obj);
			objKeys = sort ? keys.sort(sort) : keys;
		}
		var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
		var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j = 0; j < objKeys.length; ++j) {
			var key = objKeys[j];
			var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
			var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel.set(object, step);
			var valueSideChannel = getSideChannel();
			valueSideChannel.set(sentinel, sideChannel);
			pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset = opts.charset || defaults.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format = formats["default"];
		if (typeof opts.format !== "undefined") {
			if (!has.call(formats.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format = opts.format;
		}
		var formatter = formats.formatters[format];
		var filter = defaults.filter;
		if (typeof opts.filter === "function" || isArray(opts.filter)) filter = opts.filter;
		var arrayFormat;
		if (opts.arrayFormat in arrayPrefixGenerators) arrayFormat = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
		else arrayFormat = defaults.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			arrayFormat,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			commaRoundTrip: !!opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
			filter,
			format,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
		};
	};
	module.exports = function(object, opts) {
		var obj = object;
		var options = normalizeStringifyOptions(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel = getSideChannel();
		for (var i = 0; i < objKeys.length; ++i) {
			var key = objKeys[i];
			var value = obj[key];
			if (options.skipNulls && value === null) continue;
			pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
		}
		var joined = keys.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.2/node_modules/qs/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var utils = require_utils$1();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var defaults = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false,
		throwOnLimitExceeded: false
	};
	var interpretNumericEntities = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue = function(val, options, currentArrayLength) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
		return val;
	};
	var isoSentinel = "utf8=%26%2310003%3B";
	var charsetSentinel = "utf8=%E2%9C%93";
	var parseValues = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
		if (options.throwOnLimitExceeded && parts.length > limit) throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
		var skipIndex = -1;
		var i;
		var charset = options.charset;
		if (options.charsetSentinel) {
			for (i = 0; i < parts.length; ++i) if (parts[i].indexOf("utf8=") === 0) {
				if (parts[i] === charsetSentinel) charset = "utf-8";
				else if (parts[i] === isoSentinel) charset = "iso-8859-1";
				skipIndex = i;
				i = parts.length;
			}
		}
		for (i = 0; i < parts.length; ++i) {
			if (i === skipIndex) continue;
			var part = parts[i];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key;
			var val;
			if (pos === -1) {
				key = options.decoder(part, defaults.decoder, charset, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
				if (key !== null) val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
					return options.decoder(encodedVal, defaults.decoder, charset, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset === "iso-8859-1") val = interpretNumericEntities(String(val));
			if (part.indexOf("[]=") > -1) val = isArray(val) ? [val] : val;
			if (options.comma && isArray(val) && val.length > options.arrayLimit) {
				if (options.throwOnLimitExceeded) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
				val = utils.combine([], val, options.arrayLimit, options.plainObjects);
			}
			if (key !== null) {
				var existing = has.call(obj, key);
				if (existing && options.duplicates === "combine") obj[key] = utils.combine(obj[key], val, options.arrayLimit, options.plainObjects);
				else if (!existing || options.duplicates === "last") obj[key] = val;
			}
		}
		return obj;
	};
	var parseObject = function(chain, val, options, valuesParsed) {
		var currentArrayLength = 0;
		if (chain.length > 0 && chain[chain.length - 1] === "[]") {
			var parentKey = chain.slice(0, -1).join("");
			currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		}
		var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
		for (var i = chain.length - 1; i >= 0; --i) {
			var obj;
			var root = chain[i];
			if (root === "[]" && options.parseArrays) if (utils.isOverflow(leaf)) obj = leaf;
			else obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf, options.arrayLimit, options.plainObjects);
			else {
				obj = options.plainObjects ? { __proto__: null } : {};
				var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index = parseInt(decodedRoot, 10);
				var isValidArrayIndex = !isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays;
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (isValidArrayIndex && index < options.arrayLimit) {
					obj = [];
					obj[index] = leaf;
				} else if (isValidArrayIndex && options.throwOnLimitExceeded) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
				else if (isValidArrayIndex) {
					obj[index] = leaf;
					utils.markOverflow(obj, index);
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var splitKeyIntoSegments = function splitKeyIntoSegments(givenKey, options) {
		var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		if (options.depth <= 0) {
			if (!options.plainObjects && has.call(Object.prototype, key)) {
				if (!options.allowPrototypes) return;
			}
			return [key];
		}
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment = brackets.exec(key);
		var parent = segment ? key.slice(0, segment.index) : key;
		var keys = [];
		if (parent) {
			if (!options.plainObjects && has.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys[keys.length] = parent;
		}
		var i = 0;
		while ((segment = child.exec(key)) !== null && i < options.depth) {
			i += 1;
			var segmentContent = segment[1].slice(1, -1);
			if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
				if (!options.allowPrototypes) return;
			}
			keys[keys.length] = segment[1];
		}
		if (segment) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys[keys.length] = "[" + key.slice(segment.index) + "]";
		}
		return keys;
	};
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var keys = splitKeyIntoSegments(givenKey, options);
		if (!keys) return;
		return parseObject(keys, val, options, valuesParsed);
	};
	var normalizeParseOptions = function normalizeParseOptions(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
		var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
			delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
			throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
		};
	};
	module.exports = function(str, opts) {
		var options = normalizeParseOptions(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? { __proto__: null } : {};
		var tempObj = typeof str === "string" ? parseValues(str, options) : str;
		var obj = options.plainObjects ? { __proto__: null } : {};
		var keys = Object.keys(tempObj);
		for (var i = 0; i < keys.length; ++i) {
			var key = keys[i];
			var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
			obj = utils.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils.compact(obj);
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.2/node_modules/qs/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var stringify = require_stringify();
	var parse = require_parse();
	var formats = require_formats();
	module.exports = {
		formats,
		parse,
		stringify
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/lib/types/urlencoded.js
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_urlencoded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var createError = require_http_errors();
	var debug = require_src()("body-parser:urlencoded");
	var deprecate = require_depd()("body-parser");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = urlencoded;
	/**
	* Cache of parser modules.
	*/
	var parsers = Object.create(null);
	/**
	* Create a middleware to parse urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function urlencoded(options) {
		var opts = options || {};
		if (opts.extended === void 0) deprecate("undefined extended: provide extended option");
		var extended = opts.extended !== false;
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/x-www-form-urlencoded";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(body) {
			return body.length ? queryparse(body) : {};
		}
		return function urlencodedParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			var charset = getCharset(req) || "utf-8";
			if (charset !== "utf-8") {
				debug("invalid charset");
				next(createError(415, "unsupported charset \"" + charset.toUpperCase() + "\"", {
					charset,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse, debug, {
				debug,
				encoding: charset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the extended query parser.
	*
	* @param {object} options
	*/
	function extendedparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var depth = options.depth !== void 0 ? options.depth : 32;
		var parse = parser("qs");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isNaN(depth) || depth < 0) throw new TypeError("option depth must be a zero or a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body) {
			var paramCount = parameterCount(body, parameterLimit);
			if (paramCount === void 0) {
				debug("too many parameters");
				throw createError(413, "too many parameters", { type: "parameters.too.many" });
			}
			var arrayLimit = Math.max(100, paramCount);
			debug("parse extended urlencoding");
			try {
				return parse(body, {
					allowPrototypes: true,
					arrayLimit,
					depth,
					strictDepth: true,
					parameterLimit
				});
			} catch (err) {
				if (err instanceof RangeError) throw createError(400, "The input exceeded the depth", { type: "querystring.parse.rangeError" });
				else throw err;
			}
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Count the number of parameters, stopping once limit reached
	*
	* @param {string} body
	* @param {number} limit
	* @api private
	*/
	function parameterCount(body, limit) {
		var count = 0;
		var index = 0;
		while ((index = body.indexOf("&", index)) !== -1) {
			count++;
			index++;
			if (count === limit) return;
		}
		return count;
	}
	/**
	* Get parser for module name dynamically.
	*
	* @param {string} name
	* @return {function}
	* @api private
	*/
	function parser(name) {
		var mod = parsers[name];
		if (mod !== void 0) return mod.parse;
		switch (name) {
			case "qs":
				mod = require_lib();
				break;
			case "querystring":
				mod = require("querystring");
				break;
		}
		parsers[name] = mod;
		return mod.parse;
	}
	/**
	* Get the simple query parser.
	*
	* @param {object} options
	*/
	function simpleparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var parse = parser("querystring");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body) {
			if (parameterCount(body, parameterLimit) === void 0) {
				debug("too many parameters");
				throw createError(413, "too many parameters", { type: "parameters.too.many" });
			}
			debug("parse urlencoding");
			return parse(body, void 0, void 0, { maxKeys: parameterLimit });
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.4/node_modules/body-parser/index.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_body_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("body-parser");
	/**
	* Cache of loaded parsers.
	* @private
	*/
	var parsers = Object.create(null);
	/**
	* @typedef Parsers
	* @type {function}
	* @property {function} json
	* @property {function} raw
	* @property {function} text
	* @property {function} urlencoded
	*/
	/**
	* Module exports.
	* @type {Parsers}
	*/
	exports = module.exports = deprecate.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
	/**
	* JSON parser.
	* @public
	*/
	Object.defineProperty(exports, "json", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("json")
	});
	/**
	* Raw parser.
	* @public
	*/
	Object.defineProperty(exports, "raw", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("raw")
	});
	/**
	* Text parser.
	* @public
	*/
	Object.defineProperty(exports, "text", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("text")
	});
	/**
	* URL-encoded parser.
	* @public
	*/
	Object.defineProperty(exports, "urlencoded", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("urlencoded")
	});
	/**
	* Create a middleware to parse json and urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @deprecated
	* @public
	*/
	function bodyParser(options) {
		var opts = Object.create(options || null, { type: {
			configurable: true,
			enumerable: true,
			value: void 0,
			writable: true
		} });
		var _urlencoded = exports.urlencoded(opts);
		var _json = exports.json(opts);
		return function bodyParser(req, res, next) {
			_json(req, res, function(err) {
				if (err) return next(err);
				_urlencoded(req, res, next);
			});
		};
	}
	/**
	* Create a getter for loading a parser.
	* @private
	*/
	function createParserGetter(name) {
		return function get() {
			return loadParser(name);
		};
	}
	/**
	* Load a parser module.
	* @private
	*/
	function loadParser(parserName) {
		var parser = parsers[parserName];
		if (parser !== void 0) return parser;
		switch (parserName) {
			case "json":
				parser = require_json();
				break;
			case "raw":
				parser = require_raw();
				break;
			case "text":
				parser = require_text();
				break;
			case "urlencoded":
				parser = require_urlencoded();
				break;
		}
		return parsers[parserName] = parser;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js
/*!
* merge-descriptors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_merge_descriptors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = merge;
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* Merge the property descriptors of `src` into `dest`
	*
	* @param {object} dest Object to add descriptors to
	* @param {object} src Object to clone descriptors from
	* @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	* @returns {object} Reference to dest
	* @public
	*/
	function merge(dest, src, redefine) {
		if (!dest) throw new TypeError("argument dest is required");
		if (!src) throw new TypeError("argument src is required");
		if (redefine === void 0) redefine = true;
		Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
			if (!redefine && hasOwnProperty.call(dest, name)) return;
			var descriptor = Object.getOwnPropertyDescriptor(src, name);
			Object.defineProperty(dest, name, descriptor);
		});
		return dest;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js
/*!
* encodeurl
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_encodeurl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = encodeUrl;
	/**
	* RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	* and including invalid escape sequences.
	* @private
	*/
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	/**
	* RegExp to match unmatched surrogate pair.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	/**
	* String to replace unmatched surrogate pair with.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
	/**
	* Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	*
	* This function will take an already-encoded URL and encode all the non-URL
	* code points. This function will not encode the "%" character unless it is
	* not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	* be encoded as `%25foo`).
	*
	* This encode is meant to be "safe" and does not throw errors. It will try as
	* hard as it can to properly encode the given URL, including replacing any raw,
	* unpaired surrogate pairs with the Unicode replacement character prior to
	* encoding.
	*
	* @param {string} url
	* @return {string}
	* @public
	*/
	function encodeUrl(url) {
		return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js
/*!
* escape-html
* Copyright(c) 2012-2013 TJ Holowaychuk
* Copyright(c) 2015 Andreas Lubbe
* Copyright(c) 2015 Tiancheng "Timothy" Gu
* MIT Licensed
*/
var require_escape_html = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module variables.
	* @private
	*/
	var matchHtmlRegExp = /["'&<>]/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = escapeHtml;
	/**
	* Escape special characters in the given string of html.
	*
	* @param  {string} string The string to escape for inserting into HTML
	* @return {string}
	* @public
	*/
	function escapeHtml(string) {
		var str = "" + string;
		var match = matchHtmlRegExp.exec(str);
		if (!match) return str;
		var escape;
		var html = "";
		var index = 0;
		var lastIndex = 0;
		for (index = match.index; index < str.length; index++) {
			switch (str.charCodeAt(index)) {
				case 34:
					escape = "&quot;";
					break;
				case 38:
					escape = "&amp;";
					break;
				case 39:
					escape = "&#39;";
					break;
				case 60:
					escape = "&lt;";
					break;
				case 62:
					escape = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index) html += str.substring(lastIndex, index);
			lastIndex = index + 1;
			html += escape;
		}
		return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js
/*!
* parseurl
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_parseurl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var url$1 = require("url");
	var parse = url$1.parse;
	var Url = url$1.Url;
	/**
	* Module exports.
	* @public
	*/
	module.exports = parseurl;
	module.exports.original = originalurl;
	/**
	* Parse the `req` url with memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function parseurl(req) {
		var url = req.url;
		if (url === void 0) return;
		var parsed = req._parsedUrl;
		if (fresh(url, parsed)) return parsed;
		parsed = fastparse(url);
		parsed._raw = url;
		return req._parsedUrl = parsed;
	}
	/**
	* Parse the `req` original url with fallback and memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function originalurl(req) {
		var url = req.originalUrl;
		if (typeof url !== "string") return parseurl(req);
		var parsed = req._parsedOriginalUrl;
		if (fresh(url, parsed)) return parsed;
		parsed = fastparse(url);
		parsed._raw = url;
		return req._parsedOriginalUrl = parsed;
	}
	/**
	* Parse the `str` url with fast-path short-cut.
	*
	* @param {string} str
	* @return {Object}
	* @private
	*/
	function fastparse(str) {
		if (typeof str !== "string" || str.charCodeAt(0) !== 47) return parse(str);
		var pathname = str;
		var query = null;
		var search = null;
		for (var i = 1; i < str.length; i++) switch (str.charCodeAt(i)) {
			case 63:
				if (search === null) {
					pathname = str.substring(0, i);
					query = str.substring(i + 1);
					search = str.substring(i);
				}
				break;
			case 9:
			case 10:
			case 12:
			case 13:
			case 32:
			case 35:
			case 160:
			case 65279: return parse(str);
		}
		var url = Url !== void 0 ? new Url() : {};
		url.path = str;
		url.href = str;
		url.pathname = pathname;
		if (search !== null) {
			url.query = query;
			url.search = search;
		}
		return url;
	}
	/**
	* Determine if parsed is still fresh for url.
	*
	* @param {string} url
	* @param {object} parsedUrl
	* @return {boolean}
	* @private
	*/
	function fresh(url, parsedUrl) {
		return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/finalhandler@1.3.2/node_modules/finalhandler/index.js
/*!
* finalhandler
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_finalhandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src()("finalhandler");
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var onFinished = require_on_finished();
	var parseUrl = require_parseurl();
	var statuses = require_statuses();
	var unpipe = require_unpipe();
	/**
	* Module variables.
	* @private
	*/
	var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
	var NEWLINE_REGEXP = /\n/g;
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	var isFinished = onFinished.isFinished;
	/**
	* Create a minimal HTML document.
	*
	* @param {string} message
	* @private
	*/
	function createHtmlDocument(message) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>" + escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;") + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Module exports.
	* @public
	*/
	module.exports = finalhandler;
	/**
	* Create a function to handle the final response.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {Object} [options]
	* @return {Function}
	* @public
	*/
	function finalhandler(req, res, options) {
		var opts = options || {};
		var env = opts.env || process.env.NODE_ENV || "development";
		var onerror = opts.onerror;
		return function(err) {
			var headers;
			var msg;
			var status;
			if (!err && headersSent(res)) {
				debug("cannot 404 after headers sent");
				return;
			}
			if (err) {
				status = getErrorStatusCode(err);
				if (status === void 0) status = getResponseStatusCode(res);
				else headers = getErrorHeaders(err);
				msg = getErrorMessage(err, status, env);
			} else {
				status = 404;
				msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
			}
			debug("default %s", status);
			if (err && onerror) defer(onerror, err, req, res);
			if (headersSent(res)) {
				debug("cannot %d after headers sent", status);
				if (req.socket) req.socket.destroy();
				return;
			}
			send(req, res, status, headers, msg);
		};
	}
	/**
	* Get headers from Error object.
	*
	* @param {Error} err
	* @return {object}
	* @private
	*/
	function getErrorHeaders(err) {
		if (!err.headers || typeof err.headers !== "object") return;
		var headers = Object.create(null);
		var keys = Object.keys(err.headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			headers[key] = err.headers[key];
		}
		return headers;
	}
	/**
	* Get message from Error object, fallback to status message.
	*
	* @param {Error} err
	* @param {number} status
	* @param {string} env
	* @return {string}
	* @private
	*/
	function getErrorMessage(err, status, env) {
		var msg;
		if (env !== "production") {
			msg = err.stack;
			if (!msg && typeof err.toString === "function") msg = err.toString();
		}
		return msg || statuses.message[status];
	}
	/**
	* Get status code from Error object.
	*
	* @param {Error} err
	* @return {number}
	* @private
	*/
	function getErrorStatusCode(err) {
		if (typeof err.status === "number" && err.status >= 400 && err.status < 600) return err.status;
		if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
	}
	/**
	* Get resource name for the request.
	*
	* This is typically just the original pathname of the request
	* but will fallback to "resource" is that cannot be determined.
	*
	* @param {IncomingMessage} req
	* @return {string}
	* @private
	*/
	function getResourceName(req) {
		try {
			return parseUrl.original(req).pathname;
		} catch (e) {
			return "resource";
		}
	}
	/**
	* Get status code from response.
	*
	* @param {OutgoingMessage} res
	* @return {number}
	* @private
	*/
	function getResponseStatusCode(res) {
		var status = res.statusCode;
		if (typeof status !== "number" || status < 400 || status > 599) status = 500;
		return status;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res) {
		return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
	}
	/**
	* Send response.
	*
	* @param {IncomingMessage} req
	* @param {OutgoingMessage} res
	* @param {number} status
	* @param {object} headers
	* @param {string} message
	* @private
	*/
	function send(req, res, status, headers, message) {
		function write() {
			var body = createHtmlDocument(message);
			res.statusCode = status;
			if (req.httpVersionMajor < 2) res.statusMessage = statuses.message[status];
			res.removeHeader("Content-Encoding");
			res.removeHeader("Content-Language");
			res.removeHeader("Content-Range");
			setHeaders(res, headers);
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Content-Type", "text/html; charset=utf-8");
			res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
			if (req.method === "HEAD") {
				res.end();
				return;
			}
			res.end(body, "utf8");
		}
		if (isFinished(req)) {
			write();
			return;
		}
		unpipe(req);
		onFinished(req, write);
		req.resume();
	}
	/**
	* Set response headers from an object.
	*
	* @param {OutgoingMessage} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res, headers) {
		if (!headers) return;
		var keys = Object.keys(headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			res.setHeader(key, headers[key]);
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js
var require_array_flatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Expose `arrayFlatten`.
	*/
	module.exports = arrayFlatten;
	/**
	* Recursive flatten function with depth.
	*
	* @param  {Array}  array
	* @param  {Array}  result
	* @param  {Number} depth
	* @return {Array}
	*/
	function flattenWithDepth(array, result, depth) {
		for (var i = 0; i < array.length; i++) {
			var value = array[i];
			if (depth > 0 && Array.isArray(value)) flattenWithDepth(value, result, depth - 1);
			else result.push(value);
		}
		return result;
	}
	/**
	* Recursive flatten function. Omitting depth is slightly faster.
	*
	* @param  {Array} array
	* @param  {Array} result
	* @return {Array}
	*/
	function flattenForever(array, result) {
		for (var i = 0; i < array.length; i++) {
			var value = array[i];
			if (Array.isArray(value)) flattenForever(value, result);
			else result.push(value);
		}
		return result;
	}
	/**
	* Flatten an array, with the ability to define a depth.
	*
	* @param  {Array}  array
	* @param  {Number} depth
	* @return {Array}
	*/
	function arrayFlatten(array, depth) {
		if (depth == null) return flattenForever(array, []);
		return flattenWithDepth(array, [], depth);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js
var require_path_to_regexp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Expose `pathToRegexp`.
	*/
	module.exports = pathToRegexp;
	/**
	* Match matching groups in a regular expression.
	*/
	var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
	/**
	* Normalize the given path string,
	* returning a regular expression.
	*
	* An empty array should be passed,
	* which will contain the placeholder
	* key names. For example "/user/:id" will
	* then contain ["id"].
	*
	* @param  {String|RegExp|Array} path
	* @param  {Array} keys
	* @param  {Object} options
	* @return {RegExp}
	* @api private
	*/
	function pathToRegexp(path, keys, options) {
		options = options || {};
		keys = keys || [];
		var strict = options.strict;
		var end = options.end !== false;
		var flags = options.sensitive ? "" : "i";
		var lookahead = options.lookahead !== false;
		var extraOffset = 0;
		var keysOffset = keys.length;
		var i = 0;
		var name = 0;
		var pos = 0;
		var backtrack = "";
		var m;
		if (path instanceof RegExp) {
			while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
				if (m[0][0] === "\\") continue;
				keys.push({
					name: m[1] || name++,
					optional: false,
					offset: m.index
				});
			}
			return path;
		}
		if (Array.isArray(path)) {
			path = path.map(function(value) {
				return pathToRegexp(value, keys, options).source;
			});
			return new RegExp(path.join("|"), flags);
		}
		if (typeof path !== "string") throw new TypeError("path must be a string, array of strings, or regular expression");
		path = path.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match, slash, format, key, capture, star, optional, offset) {
			if (match[0] === "\\") {
				backtrack += match;
				pos += 2;
				return match;
			}
			if (match === ".") {
				backtrack += "\\.";
				extraOffset += 1;
				pos += 1;
				return "\\.";
			}
			if (slash || format) backtrack = "";
			else backtrack += path.slice(pos, offset);
			pos = offset + match.length;
			if (match === "*") {
				extraOffset += 3;
				return "(.*)";
			}
			if (match === "/(") {
				backtrack += "/";
				extraOffset += 2;
				return "/(?:";
			}
			slash = slash || "";
			format = format ? "\\." : "";
			optional = optional || "";
			capture = capture ? capture.replace(/\\.|\*/, function(m) {
				return m === "*" ? "(.*)" : m;
			}) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format + "]+?)";
			keys.push({
				name: key,
				optional: !!optional,
				offset: offset + extraOffset
			});
			var result = "(?:" + format + slash + capture + (star ? "((?:[/" + format + "].+?)?)" : "") + ")" + optional;
			extraOffset += result.length - match.length;
			return result;
		});
		while (m = MATCHING_GROUP_REGEXP.exec(path)) {
			if (m[0][0] === "\\") continue;
			if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) keys.splice(keysOffset + i, 0, {
				name: name++,
				optional: false,
				offset: m.index
			});
			i++;
		}
		path += strict ? "" : path[path.length - 1] === "/" ? "?" : "/?";
		if (end) path += "$";
		else if (path[path.length - 1] !== "/") path += lookahead ? "(?=/|$)" : "(?:/|$)";
		return new RegExp("^" + path, flags);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/router/layer.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_layer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var pathRegexp = require_path_to_regexp();
	var debug = require_src()("express:router:layer");
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Layer;
	function Layer(path, options, fn) {
		if (!(this instanceof Layer)) return new Layer(path, options, fn);
		debug("new %o", path);
		var opts = options || {};
		this.handle = fn;
		this.name = fn.name || "<anonymous>";
		this.params = void 0;
		this.path = void 0;
		this.regexp = pathRegexp(path, this.keys = [], opts);
		this.regexp.fast_star = path === "*";
		this.regexp.fast_slash = path === "/" && opts.end === false;
	}
	/**
	* Handle the error for the layer.
	*
	* @param {Error} error
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
		var fn = this.handle;
		if (fn.length !== 4) return next(error);
		try {
			fn(error, req, res, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Handle the request for the layer.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer.prototype.handle_request = function handle(req, res, next) {
		var fn = this.handle;
		if (fn.length > 3) return next();
		try {
			fn(req, res, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Check if this route matches `path`, if so
	* populate `.params`.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	Layer.prototype.match = function match(path) {
		var match;
		if (path != null) {
			if (this.regexp.fast_slash) {
				this.params = {};
				this.path = "";
				return true;
			}
			if (this.regexp.fast_star) {
				this.params = { "0": decode_param(path) };
				this.path = path;
				return true;
			}
			match = this.regexp.exec(path);
		}
		if (!match) {
			this.params = void 0;
			this.path = void 0;
			return false;
		}
		this.params = {};
		this.path = match[0];
		var keys = this.keys;
		var params = this.params;
		for (var i = 1; i < match.length; i++) {
			var prop = keys[i - 1].name;
			var val = decode_param(match[i]);
			if (val !== void 0 || !hasOwnProperty.call(params, prop)) params[prop] = val;
		}
		return true;
	};
	/**
	* Decode param value.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function decode_param(val) {
		if (typeof val !== "string" || val.length === 0) return val;
		try {
			return decodeURIComponent(val);
		} catch (err) {
			if (err instanceof URIError) {
				err.message = "Failed to decode param '" + val + "'";
				err.status = err.statusCode = 400;
			}
			throw err;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js
/*!
* methods
* Copyright(c) 2013-2014 TJ Holowaychuk
* Copyright(c) 2015-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_methods = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var http$5 = require("http");
	/**
	* Module exports.
	* @public
	*/
	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
	/**
	* Get the current Node.js methods.
	* @private
	*/
	function getCurrentNodeMethods() {
		return http$5.METHODS && http$5.METHODS.map(function lowerCaseMethod(method) {
			return method.toLowerCase();
		});
	}
	/**
	* Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	* @private
	*/
	function getBasicNodeMethods() {
		return [
			"get",
			"post",
			"put",
			"head",
			"delete",
			"options",
			"trace",
			"copy",
			"lock",
			"mkcol",
			"move",
			"purge",
			"propfind",
			"proppatch",
			"unlock",
			"report",
			"mkactivity",
			"checkout",
			"merge",
			"m-search",
			"notify",
			"subscribe",
			"unsubscribe",
			"patch",
			"search",
			"connect"
		];
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/router/route.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_route = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src()("express:router:route");
	var flatten = require_array_flatten();
	var Layer = require_layer();
	var methods = require_methods();
	/**
	* Module variables.
	* @private
	*/
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Route;
	/**
	* Initialize `Route` with the given `path`,
	*
	* @param {String} path
	* @public
	*/
	function Route(path) {
		this.path = path;
		this.stack = [];
		debug("new %o", path);
		this.methods = {};
	}
	/**
	* Determine if the route handles a given method.
	* @private
	*/
	Route.prototype._handles_method = function _handles_method(method) {
		if (this.methods._all) return true;
		var name = typeof method === "string" ? method.toLowerCase() : method;
		if (name === "head" && !this.methods["head"]) name = "get";
		return Boolean(this.methods[name]);
	};
	/**
	* @return {Array} supported HTTP methods
	* @private
	*/
	Route.prototype._options = function _options() {
		var methods = Object.keys(this.methods);
		if (this.methods.get && !this.methods.head) methods.push("head");
		for (var i = 0; i < methods.length; i++) methods[i] = methods[i].toUpperCase();
		return methods;
	};
	/**
	* dispatch req, res into this route
	* @private
	*/
	Route.prototype.dispatch = function dispatch(req, res, done) {
		var idx = 0;
		var stack = this.stack;
		var sync = 0;
		if (stack.length === 0) return done();
		var method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
		if (method === "head" && !this.methods["head"]) method = "get";
		req.route = this;
		next();
		function next(err) {
			if (err && err === "route") return done();
			if (err && err === "router") return done(err);
			if (++sync > 100) return setImmediate(next, err);
			var layer = stack[idx++];
			if (!layer) return done(err);
			if (layer.method && layer.method !== method) next(err);
			else if (err) layer.handle_error(err, req, res, next);
			else layer.handle_request(req, res, next);
			sync = 0;
		}
	};
	/**
	* Add a handler for all HTTP verbs to this route.
	*
	* Behaves just like middleware and can respond or call `next`
	* to continue processing.
	*
	* You can use multiple `.all` call to add multiple handlers.
	*
	*   function check_something(req, res, next){
	*     next();
	*   };
	*
	*   function validate_user(req, res, next){
	*     next();
	*   };
	*
	*   route
	*   .all(validate_user)
	*   .all(check_something)
	*   .get(function(req, res, next){
	*     res.send('hello world');
	*   });
	*
	* @param {function} handler
	* @return {Route} for chaining
	* @api public
	*/
	Route.prototype.all = function all() {
		var handles = flatten(slice.call(arguments));
		for (var i = 0; i < handles.length; i++) {
			var handle = handles[i];
			if (typeof handle !== "function") {
				var msg = "Route.all() requires a callback function but got a " + toString.call(handle);
				throw new TypeError(msg);
			}
			var layer = Layer("/", {}, handle);
			layer.method = void 0;
			this.methods._all = true;
			this.stack.push(layer);
		}
		return this;
	};
	methods.forEach(function(method) {
		Route.prototype[method] = function() {
			var handles = flatten(slice.call(arguments));
			for (var i = 0; i < handles.length; i++) {
				var handle = handles[i];
				if (typeof handle !== "function") {
					var type = toString.call(handle);
					var msg = "Route." + method + "() requires a callback function but got a " + type;
					throw new Error(msg);
				}
				debug("%s %o", method, this.path);
				var layer = Layer("/", {}, handle);
				layer.method = method;
				this.methods[method] = true;
				this.stack.push(layer);
			}
			return this;
		};
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js
var require_utils_merge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Merge object b with object a.
	*
	*     var a = { foo: 'bar' }
	*       , b = { bar: 'baz' };
	*
	*     merge(a, b);
	*     // => { foo: 'bar', bar: 'baz' }
	*
	* @param {Object} a
	* @param {Object} b
	* @return {Object}
	* @api public
	*/
	exports = module.exports = function(a, b) {
		if (a && b) for (var key in b) a[key] = b[key];
		return a;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/router/index.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_router = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Route = require_route();
	var Layer = require_layer();
	var methods = require_methods();
	var mixin = require_utils_merge();
	var debug = require_src()("express:router");
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var parseUrl = require_parseurl();
	var setPrototypeOf = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	/**
	* Initialize a new `Router` with the given `options`.
	*
	* @param {Object} [options]
	* @return {Router} which is a callable function
	* @public
	*/
	var proto = module.exports = function(options) {
		var opts = options || {};
		function router(req, res, next) {
			router.handle(req, res, next);
		}
		setPrototypeOf(router, proto);
		router.params = {};
		router._params = [];
		router.caseSensitive = opts.caseSensitive;
		router.mergeParams = opts.mergeParams;
		router.strict = opts.strict;
		router.stack = [];
		return router;
	};
	/**
	* Map the given param placeholder `name`(s) to the given callback.
	*
	* Parameter mapping is used to provide pre-conditions to routes
	* which use normalized placeholders. For example a _:user_id_ parameter
	* could automatically load a user's information from the database without
	* any additional code,
	*
	* The callback uses the same signature as middleware, the only difference
	* being that the value of the placeholder is passed, in this case the _id_
	* of the user. Once the `next()` function is invoked, just like middleware
	* it will continue on to execute the route, or subsequent parameter functions.
	*
	* Just like in middleware, you must either respond to the request or call next
	* to avoid stalling the request.
	*
	*  app.param('user_id', function(req, res, next, id){
	*    User.find(id, function(err, user){
	*      if (err) {
	*        return next(err);
	*      } else if (!user) {
	*        return next(new Error('failed to load user'));
	*      }
	*      req.user = user;
	*      next();
	*    });
	*  });
	*
	* @param {String} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	proto.param = function param(name, fn) {
		if (typeof name === "function") {
			deprecate("router.param(fn): Refactor to use path params");
			this._params.push(name);
			return;
		}
		var params = this._params;
		var len = params.length;
		var ret;
		if (name[0] === ":") {
			deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
			name = name.slice(1);
		}
		for (var i = 0; i < len; ++i) if (ret = params[i](name, fn)) fn = ret;
		if ("function" !== typeof fn) throw new Error("invalid param() call for " + name + ", got " + fn);
		(this.params[name] = this.params[name] || []).push(fn);
		return this;
	};
	/**
	* Dispatch a req, res into the router.
	* @private
	*/
	proto.handle = function handle(req, res, out) {
		var self = this;
		debug("dispatching %s %s", req.method, req.url);
		var idx = 0;
		var protohost = getProtohost(req.url) || "";
		var removed = "";
		var slashAdded = false;
		var sync = 0;
		var paramcalled = {};
		var options = [];
		var stack = self.stack;
		var parentParams = req.params;
		var parentUrl = req.baseUrl || "";
		var done = restore(out, req, "baseUrl", "next", "params");
		req.next = next;
		if (req.method === "OPTIONS") done = wrap(done, function(old, err) {
			if (err || options.length === 0) return old(err);
			sendOptionsResponse(res, options, old);
		});
		req.baseUrl = parentUrl;
		req.originalUrl = req.originalUrl || req.url;
		next();
		function next(err) {
			var layerError = err === "route" ? null : err;
			if (slashAdded) {
				req.url = req.url.slice(1);
				slashAdded = false;
			}
			if (removed.length !== 0) {
				req.baseUrl = parentUrl;
				req.url = protohost + removed + req.url.slice(protohost.length);
				removed = "";
			}
			if (layerError === "router") {
				setImmediate(done, null);
				return;
			}
			if (idx >= stack.length) {
				setImmediate(done, layerError);
				return;
			}
			if (++sync > 100) return setImmediate(next, err);
			var path = getPathname(req);
			if (path == null) return done(layerError);
			var layer;
			var match;
			var route;
			while (match !== true && idx < stack.length) {
				layer = stack[idx++];
				match = matchLayer(layer, path);
				route = layer.route;
				if (typeof match !== "boolean") layerError = layerError || match;
				if (match !== true) continue;
				if (!route) continue;
				if (layerError) {
					match = false;
					continue;
				}
				var method = req.method;
				var has_method = route._handles_method(method);
				if (!has_method && method === "OPTIONS") appendMethods(options, route._options());
				if (!has_method && method !== "HEAD") match = false;
			}
			if (match !== true) return done(layerError);
			if (route) req.route = route;
			req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
			var layerPath = layer.path;
			self.process_params(layer, paramcalled, req, res, function(err) {
				if (err) next(layerError || err);
				else if (route) layer.handle_request(req, res, next);
				else trim_prefix(layer, layerError, layerPath, path);
				sync = 0;
			});
		}
		function trim_prefix(layer, layerError, layerPath, path) {
			if (layerPath.length !== 0) {
				if (layerPath !== path.slice(0, layerPath.length)) {
					next(layerError);
					return;
				}
				var c = path[layerPath.length];
				if (c && c !== "/" && c !== ".") return next(layerError);
				debug("trim prefix (%s) from url %s", layerPath, req.url);
				removed = layerPath;
				req.url = protohost + req.url.slice(protohost.length + removed.length);
				if (!protohost && req.url[0] !== "/") {
					req.url = "/" + req.url;
					slashAdded = true;
				}
				req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
			}
			debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
			if (layerError) layer.handle_error(layerError, req, res, next);
			else layer.handle_request(req, res, next);
		}
	};
	/**
	* Process any parameters for the layer.
	* @private
	*/
	proto.process_params = function process_params(layer, called, req, res, done) {
		var params = this.params;
		var keys = layer.keys;
		if (!keys || keys.length === 0) return done();
		var i = 0;
		var name;
		var paramIndex = 0;
		var key;
		var paramVal;
		var paramCallbacks;
		var paramCalled;
		function param(err) {
			if (err) return done(err);
			if (i >= keys.length) return done();
			paramIndex = 0;
			key = keys[i++];
			name = key.name;
			paramVal = req.params[name];
			paramCallbacks = params[name];
			paramCalled = called[name];
			if (paramVal === void 0 || !paramCallbacks) return param();
			if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
				req.params[name] = paramCalled.value;
				return param(paramCalled.error);
			}
			called[name] = paramCalled = {
				error: null,
				match: paramVal,
				value: paramVal
			};
			paramCallback();
		}
		function paramCallback(err) {
			var fn = paramCallbacks[paramIndex++];
			paramCalled.value = req.params[key.name];
			if (err) {
				paramCalled.error = err;
				param(err);
				return;
			}
			if (!fn) return param();
			try {
				fn(req, res, paramCallback, paramVal, key.name);
			} catch (e) {
				paramCallback(e);
			}
		}
		param();
	};
	/**
	* Use the given middleware function, with optional path, defaulting to "/".
	*
	* Use (like `.all`) will run for any http METHOD, but it will not add
	* handlers for those methods so OPTIONS requests will not consider `.use`
	* functions even if they could respond.
	*
	* The other difference is that _route_ path is stripped and not visible
	* to the handler function. The main effect of this feature is that mounted
	* handlers can operate without any code changes regardless of the "prefix"
	* pathname.
	*
	* @public
	*/
	proto.use = function use(fn) {
		var offset = 0;
		var path = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path = fn;
			}
		}
		var callbacks = flatten(slice.call(arguments, offset));
		if (callbacks.length === 0) throw new TypeError("Router.use() requires a middleware function");
		for (var i = 0; i < callbacks.length; i++) {
			var fn = callbacks[i];
			if (typeof fn !== "function") throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
			debug("use %o %s", path, fn.name || "<anonymous>");
			var layer = new Layer(path, {
				sensitive: this.caseSensitive,
				strict: false,
				end: false
			}, fn);
			layer.route = void 0;
			this.stack.push(layer);
		}
		return this;
	};
	/**
	* Create a new Route for the given path.
	*
	* Each route contains a separate middleware stack and VERB handlers.
	*
	* See the Route api documentation for details on adding handlers
	* and middleware to routes.
	*
	* @param {String} path
	* @return {Route}
	* @public
	*/
	proto.route = function route(path) {
		var route = new Route(path);
		var layer = new Layer(path, {
			sensitive: this.caseSensitive,
			strict: this.strict,
			end: true
		}, route.dispatch.bind(route));
		layer.route = route;
		this.stack.push(layer);
		return route;
	};
	methods.concat("all").forEach(function(method) {
		proto[method] = function(path) {
			var route = this.route(path);
			route[method].apply(route, slice.call(arguments, 1));
			return this;
		};
	});
	function appendMethods(list, addition) {
		for (var i = 0; i < addition.length; i++) {
			var method = addition[i];
			if (list.indexOf(method) === -1) list.push(method);
		}
	}
	function getPathname(req) {
		try {
			return parseUrl(req).pathname;
		} catch (err) {
			return;
		}
	}
	function getProtohost(url) {
		if (typeof url !== "string" || url.length === 0 || url[0] === "/") return;
		var searchIndex = url.indexOf("?");
		var pathLength = searchIndex !== -1 ? searchIndex : url.length;
		var fqdnIndex = url.slice(0, pathLength).indexOf("://");
		return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
	}
	function gettype(obj) {
		var type = typeof obj;
		if (type !== "object") return type;
		return toString.call(obj).replace(objectRegExp, "$1");
	}
	/**
	* Match path to a layer.
	*
	* @param {Layer} layer
	* @param {string} path
	* @private
	*/
	function matchLayer(layer, path) {
		try {
			return layer.match(path);
		} catch (err) {
			return err;
		}
	}
	function mergeParams(params, parent) {
		if (typeof parent !== "object" || !parent) return params;
		var obj = mixin({}, parent);
		if (!(0 in params) || !(0 in parent)) return mixin(obj, params);
		var i = 0;
		var o = 0;
		while (i in params) i++;
		while (o in parent) o++;
		for (i--; i >= 0; i--) {
			params[i + o] = params[i];
			if (i < o) delete params[i];
		}
		return mixin(obj, params);
	}
	function restore(fn, obj) {
		var props = new Array(arguments.length - 2);
		var vals = new Array(arguments.length - 2);
		for (var i = 0; i < props.length; i++) {
			props[i] = arguments[i + 2];
			vals[i] = obj[props[i]];
		}
		return function() {
			for (var i = 0; i < props.length; i++) obj[props[i]] = vals[i];
			return fn.apply(this, arguments);
		};
	}
	function sendOptionsResponse(res, options, next) {
		try {
			var body = options.join(",");
			res.set("Allow", body);
			res.send(body);
		} catch (err) {
			next(err);
		}
	}
	function wrap(old, fn) {
		return function proxy() {
			var args = new Array(arguments.length + 1);
			args[0] = old;
			for (var i = 0, len = arguments.length; i < len; i++) args[i + 1] = arguments[i];
			fn.apply(this, args);
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/middleware/init.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_init$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var setPrototypeOf = require_setprototypeof();
	/**
	* Initialization middleware, exposing the
	* request and response to each other, as well
	* as defaulting the X-Powered-By header field.
	*
	* @param {Function} app
	* @return {Function}
	* @api private
	*/
	exports.init = function(app) {
		return function expressInit(req, res, next) {
			if (app.enabled("x-powered-by")) res.setHeader("X-Powered-By", "Express");
			req.res = res;
			res.req = req;
			req.next = next;
			setPrototypeOf(req, app.request);
			setPrototypeOf(res, app.response);
			res.locals = res.locals || Object.create(null);
			next();
		};
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/middleware/query.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_query = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var merge = require_utils_merge();
	var parseUrl = require_parseurl();
	var qs = require_lib();
	/**
	* @param {Object} options
	* @return {Function}
	* @api public
	*/
	module.exports = function query(options) {
		var opts = merge({}, options);
		var queryparse = qs.parse;
		if (typeof options === "function") {
			queryparse = options;
			opts = void 0;
		}
		if (opts !== void 0 && opts.allowPrototypes === void 0) opts.allowPrototypes = true;
		return function query(req, res, next) {
			if (!req.query) {
				var val = parseUrl(req).query;
				req.query = queryparse(val, opts);
			}
			next();
		};
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/view.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_view = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src()("express:view");
	var path$4 = require("path");
	var fs$9 = require("fs");
	/**
	* Module variables.
	* @private
	*/
	var dirname = path$4.dirname;
	var basename = path$4.basename;
	var extname = path$4.extname;
	var join = path$4.join;
	var resolve = path$4.resolve;
	/**
	* Module exports.
	* @public
	*/
	module.exports = View;
	/**
	* Initialize a new `View` with the given `name`.
	*
	* Options:
	*
	*   - `defaultEngine` the default template engine name
	*   - `engines` template engine require() cache
	*   - `root` root path for view lookup
	*
	* @param {string} name
	* @param {object} options
	* @public
	*/
	function View(name, options) {
		var opts = options || {};
		this.defaultEngine = opts.defaultEngine;
		this.ext = extname(name);
		this.name = name;
		this.root = opts.root;
		if (!this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
		var fileName = name;
		if (!this.ext) {
			this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
			fileName += this.ext;
		}
		if (!opts.engines[this.ext]) {
			var mod = this.ext.slice(1);
			debug("require \"%s\"", mod);
			var fn = require(mod).__express;
			if (typeof fn !== "function") throw new Error("Module \"" + mod + "\" does not provide a view engine.");
			opts.engines[this.ext] = fn;
		}
		this.engine = opts.engines[this.ext];
		this.path = this.lookup(fileName);
	}
	/**
	* Lookup view by the given `name`
	*
	* @param {string} name
	* @private
	*/
	View.prototype.lookup = function lookup(name) {
		var path$56;
		var roots = [].concat(this.root);
		debug("lookup \"%s\"", name);
		for (var i = 0; i < roots.length && !path$56; i++) {
			var root = roots[i];
			var loc = resolve(root, name);
			var dir = dirname(loc);
			var file = basename(loc);
			path$56 = this.resolve(dir, file);
		}
		return path$56;
	};
	/**
	* Render with the given options.
	*
	* @param {object} options
	* @param {function} callback
	* @private
	*/
	View.prototype.render = function render(options, callback) {
		debug("render \"%s\"", this.path);
		this.engine(this.path, options, callback);
	};
	/**
	* Resolve the file within the given directory.
	*
	* @param {string} dir
	* @param {string} file
	* @private
	*/
	View.prototype.resolve = function resolve(dir, file) {
		var ext = this.ext;
		var path$57 = join(dir, file);
		var stat = tryStat(path$57);
		if (stat && stat.isFile()) return path$57;
		path$57 = join(dir, basename(file, ext), "index" + ext);
		stat = tryStat(path$57);
		if (stat && stat.isFile()) return path$57;
	};
	/**
	* Return a stat, maybe.
	*
	* @param {string} path
	* @return {fs.Stats}
	* @private
	*/
	function tryStat(path$58) {
		debug("stat \"%s\"", path$58);
		try {
			return fs$9.statSync(path$58);
		} catch (e) {
			return;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = require("buffer");
	var Buffer = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer.prototype);
	copyProps(Buffer, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js
/*!
* content-disposition
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_content_disposition = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = contentDisposition;
	module.exports.parse = parse;
	/**
	* Module dependencies.
	* @private
	*/
	var basename = require("path").basename;
	var Buffer = require_safe_buffer().Buffer;
	/**
	* RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	* @private
	*/
	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
	/**
	* RegExp to match percent encoding escape.
	* @private
	*/
	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
	/**
	* RegExp to match non-latin1 characters.
	* @private
	*/
	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	* @private
	*/
	var QESC_REGEXP = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	* @private
	*/
	var QUOTE_REGEXP = /([\\"])/g;
	/**
	* RegExp for various RFC 2616 grammar
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* HT            = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	* @private
	*/
	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
	/**
	* RegExp for various RFC 5987 grammar
	*
	* ext-value     = charset  "'" [ language ] "'" value-chars
	* charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	* mime-charset  = 1*mime-charsetc
	* mime-charsetc = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "%" / "&"
	*               / "+" / "-" / "^" / "_" / "`"
	*               / "{" / "}" / "~"
	* language      = ( 2*3ALPHA [ extlang ] )
	*               / 4ALPHA
	*               / 5*8ALPHA
	* extlang       = *3( "-" 3ALPHA )
	* value-chars   = *( pct-encoded / attr-char )
	* pct-encoded   = "%" HEXDIG HEXDIG
	* attr-char     = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	*               / "^" / "_" / "`" / "|" / "~"
	* @private
	*/
	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
	/**
	* RegExp for various RFC 6266 grammar
	*
	* disposition-type = "inline" | "attachment" | disp-ext-type
	* disp-ext-type    = token
	* disposition-parm = filename-parm | disp-ext-parm
	* filename-parm    = "filename" "=" value
	*                  | "filename*" "=" ext-value
	* disp-ext-parm    = token "=" value
	*                  | ext-token "=" ext-value
	* ext-token        = <the characters in token, followed by "*">
	* @private
	*/
	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
	/**
	* Create an attachment Content-Disposition header.
	*
	* @param {string} [filename]
	* @param {object} [options]
	* @param {string} [options.type=attachment]
	* @param {string|boolean} [options.fallback=true]
	* @return {string}
	* @public
	*/
	function contentDisposition(filename, options) {
		var opts = options || {};
		return format(new ContentDisposition(opts.type || "attachment", createparams(filename, opts.fallback)));
	}
	/**
	* Create parameters object from filename and fallback.
	*
	* @param {string} [filename]
	* @param {string|boolean} [fallback=true]
	* @return {object}
	* @private
	*/
	function createparams(filename, fallback) {
		if (filename === void 0) return;
		var params = {};
		if (typeof filename !== "string") throw new TypeError("filename must be a string");
		if (fallback === void 0) fallback = true;
		if (typeof fallback !== "string" && typeof fallback !== "boolean") throw new TypeError("fallback must be a string or boolean");
		if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError("fallback must be ISO-8859-1 string");
		var name = basename(filename);
		var isQuotedString = TEXT_REGEXP.test(name);
		var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
		var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
		if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params["filename*"] = name;
		if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
		return params;
	}
	/**
	* Format object to Content-Disposition header.
	*
	* @param {object} obj
	* @param {string} obj.type
	* @param {object} [obj.parameters]
	* @return {string}
	* @private
	*/
	function format(obj) {
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = String(type).toLowerCase();
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
				string += "; " + param + "=" + val;
			}
		}
		return string;
	}
	/**
	* Decode a RFC 5987 field value (gracefully).
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function decodefield(str) {
		var match = EXT_VALUE_REGEXP.exec(str);
		if (!match) throw new TypeError("invalid extended field value");
		var charset = match[1].toLowerCase();
		var encoded = match[2];
		var value;
		var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
		switch (charset) {
			case "iso-8859-1":
				value = getlatin1(binary);
				break;
			case "utf-8":
				value = Buffer.from(binary, "binary").toString("utf8");
				break;
			default: throw new TypeError("unsupported charset in extended field");
		}
		return value;
	}
	/**
	* Get ISO-8859-1 version of string.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function getlatin1(val) {
		return String(val).replace(NON_LATIN1_REGEXP, "?");
	}
	/**
	* Parse Content-Disposition header string.
	*
	* @param {string} string
	* @return {object}
	* @public
	*/
	function parse(string) {
		if (!string || typeof string !== "string") throw new TypeError("argument string is required");
		var match = DISPOSITION_TYPE_REGEXP.exec(string);
		if (!match) throw new TypeError("invalid type format");
		var index = match[0].length;
		var type = match[1].toLowerCase();
		var key;
		var names = [];
		var params = {};
		var value;
		index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
		while (match = PARAM_REGEXP.exec(string)) {
			if (match.index !== index) throw new TypeError("invalid parameter format");
			index += match[0].length;
			key = match[1].toLowerCase();
			value = match[2];
			if (names.indexOf(key) !== -1) throw new TypeError("invalid duplicate parameter");
			names.push(key);
			if (key.indexOf("*") + 1 === key.length) {
				key = key.slice(0, -1);
				value = decodefield(value);
				params[key] = value;
				continue;
			}
			if (typeof params[key] === "string") continue;
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
			params[key] = value;
		}
		if (index !== -1 && index !== string.length) throw new TypeError("invalid parameter format");
		return new ContentDisposition(type, params);
	}
	/**
	* Percent decode a single character.
	*
	* @param {string} str
	* @param {string} hex
	* @return {string}
	* @private
	*/
	function pdecode(str, hex) {
		return String.fromCharCode(parseInt(hex, 16));
	}
	/**
	* Percent encode a single character.
	*
	* @param {string} char
	* @return {string}
	* @private
	*/
	function pencode(char) {
		return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
	}
	/**
	* Quote a string for HTTP.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring(val) {
		return "\"" + String(val).replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	/**
	* Encode a Unicode string for HTTP (RFC 5987).
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function ustring(val) {
		var str = String(val);
		return "UTF-8''" + encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
	}
	/**
	* Class for parsed Content-Disposition header for v8 optimization
	*
	* @public
	* @param {string} type
	* @param {object} parameters
	* @constructor
	*/
	function ContentDisposition(type, parameters) {
		this.type = type;
		this.parameters = parameters;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js
/*!
* etag
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_etag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = etag;
	/**
	* Module dependencies.
	* @private
	*/
	var crypto$1 = require("crypto");
	var Stats = require("fs").Stats;
	/**
	* Module variables.
	* @private
	*/
	var toString = Object.prototype.toString;
	/**
	* Generate an entity tag.
	*
	* @param {Buffer|string} entity
	* @return {string}
	* @private
	*/
	function entitytag(entity) {
		if (entity.length === 0) return "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"";
		var hash = crypto$1.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
		return "\"" + (typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length).toString(16) + "-" + hash + "\"";
	}
	/**
	* Create a simple ETag.
	*
	* @param {string|Buffer|Stats} entity
	* @param {object} [options]
	* @param {boolean} [options.weak]
	* @return {String}
	* @public
	*/
	function etag(entity, options) {
		if (entity == null) throw new TypeError("argument entity is required");
		var isStats = isstats(entity);
		var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
		if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
		var tag = isStats ? stattag(entity) : entitytag(entity);
		return weak ? "W/" + tag : tag;
	}
	/**
	* Determine if object is a Stats object.
	*
	* @param {object} obj
	* @return {boolean}
	* @api private
	*/
	function isstats(obj) {
		if (typeof Stats === "function" && obj instanceof Stats) return true;
		return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
	}
	/**
	* Generate a tag for a stat.
	*
	* @param {object} stat
	* @return {string}
	* @private
	*/
	function stattag(stat) {
		var mtime = stat.mtime.getTime().toString(16);
		return "\"" + stat.size.toString(16) + "-" + mtime + "\"";
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js
/*!
* fresh
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2016-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_fresh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* RegExp to check for no-cache token in Cache-Control.
	* @private
	*/
	var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = fresh;
	/**
	* Check freshness of the response using request and response headers.
	*
	* @param {Object} reqHeaders
	* @param {Object} resHeaders
	* @return {Boolean}
	* @public
	*/
	function fresh(reqHeaders, resHeaders) {
		var modifiedSince = reqHeaders["if-modified-since"];
		var noneMatch = reqHeaders["if-none-match"];
		if (!modifiedSince && !noneMatch) return false;
		var cacheControl = reqHeaders["cache-control"];
		if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
		if (noneMatch && noneMatch !== "*") {
			var etag = resHeaders["etag"];
			if (!etag) return false;
			var etagStale = true;
			var matches = parseTokenList(noneMatch);
			for (var i = 0; i < matches.length; i++) {
				var match = matches[i];
				if (match === etag || match === "W/" + etag || "W/" + match === etag) {
					etagStale = false;
					break;
				}
			}
			if (etagStale) return false;
		}
		if (modifiedSince) {
			var lastModified = resHeaders["last-modified"];
			if (!lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))) return false;
		}
		return true;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate(date) {
		var timestamp = date && Date.parse(date);
		// istanbul ignore next: guard against date.js Date.parse patching
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(str.substring(start, end));
		return list;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json
var require_types$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"application/andrew-inset": ["ez"],
		"application/applixware": ["aw"],
		"application/atom+xml": ["atom"],
		"application/atomcat+xml": ["atomcat"],
		"application/atomsvc+xml": ["atomsvc"],
		"application/bdoc": ["bdoc"],
		"application/ccxml+xml": ["ccxml"],
		"application/cdmi-capability": ["cdmia"],
		"application/cdmi-container": ["cdmic"],
		"application/cdmi-domain": ["cdmid"],
		"application/cdmi-object": ["cdmio"],
		"application/cdmi-queue": ["cdmiq"],
		"application/cu-seeme": ["cu"],
		"application/dash+xml": ["mpd"],
		"application/davmount+xml": ["davmount"],
		"application/docbook+xml": ["dbk"],
		"application/dssc+der": ["dssc"],
		"application/dssc+xml": ["xdssc"],
		"application/ecmascript": ["ecma"],
		"application/emma+xml": ["emma"],
		"application/epub+zip": ["epub"],
		"application/exi": ["exi"],
		"application/font-tdpfr": ["pfr"],
		"application/font-woff": [],
		"application/font-woff2": [],
		"application/geo+json": ["geojson"],
		"application/gml+xml": ["gml"],
		"application/gpx+xml": ["gpx"],
		"application/gxf": ["gxf"],
		"application/gzip": ["gz"],
		"application/hyperstudio": ["stk"],
		"application/inkml+xml": ["ink", "inkml"],
		"application/ipfix": ["ipfix"],
		"application/java-archive": [
			"jar",
			"war",
			"ear"
		],
		"application/java-serialized-object": ["ser"],
		"application/java-vm": ["class"],
		"application/javascript": ["js", "mjs"],
		"application/json": ["json", "map"],
		"application/json5": ["json5"],
		"application/jsonml+json": ["jsonml"],
		"application/ld+json": ["jsonld"],
		"application/lost+xml": ["lostxml"],
		"application/mac-binhex40": ["hqx"],
		"application/mac-compactpro": ["cpt"],
		"application/mads+xml": ["mads"],
		"application/manifest+json": ["webmanifest"],
		"application/marc": ["mrc"],
		"application/marcxml+xml": ["mrcx"],
		"application/mathematica": [
			"ma",
			"nb",
			"mb"
		],
		"application/mathml+xml": ["mathml"],
		"application/mbox": ["mbox"],
		"application/mediaservercontrol+xml": ["mscml"],
		"application/metalink+xml": ["metalink"],
		"application/metalink4+xml": ["meta4"],
		"application/mets+xml": ["mets"],
		"application/mods+xml": ["mods"],
		"application/mp21": ["m21", "mp21"],
		"application/mp4": ["mp4s", "m4p"],
		"application/msword": ["doc", "dot"],
		"application/mxf": ["mxf"],
		"application/octet-stream": [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"exe",
			"dll",
			"deb",
			"dmg",
			"iso",
			"img",
			"msi",
			"msp",
			"msm",
			"buffer"
		],
		"application/oda": ["oda"],
		"application/oebps-package+xml": ["opf"],
		"application/ogg": ["ogx"],
		"application/omdoc+xml": ["omdoc"],
		"application/onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"application/oxps": ["oxps"],
		"application/patch-ops-error+xml": ["xer"],
		"application/pdf": ["pdf"],
		"application/pgp-encrypted": ["pgp"],
		"application/pgp-signature": ["asc", "sig"],
		"application/pics-rules": ["prf"],
		"application/pkcs10": ["p10"],
		"application/pkcs7-mime": ["p7m", "p7c"],
		"application/pkcs7-signature": ["p7s"],
		"application/pkcs8": ["p8"],
		"application/pkix-attr-cert": ["ac"],
		"application/pkix-cert": ["cer"],
		"application/pkix-crl": ["crl"],
		"application/pkix-pkipath": ["pkipath"],
		"application/pkixcmp": ["pki"],
		"application/pls+xml": ["pls"],
		"application/postscript": [
			"ai",
			"eps",
			"ps"
		],
		"application/prs.cww": ["cww"],
		"application/pskc+xml": ["pskcxml"],
		"application/raml+yaml": ["raml"],
		"application/rdf+xml": ["rdf"],
		"application/reginfo+xml": ["rif"],
		"application/relax-ng-compact-syntax": ["rnc"],
		"application/resource-lists+xml": ["rl"],
		"application/resource-lists-diff+xml": ["rld"],
		"application/rls-services+xml": ["rs"],
		"application/rpki-ghostbusters": ["gbr"],
		"application/rpki-manifest": ["mft"],
		"application/rpki-roa": ["roa"],
		"application/rsd+xml": ["rsd"],
		"application/rss+xml": ["rss"],
		"application/rtf": ["rtf"],
		"application/sbml+xml": ["sbml"],
		"application/scvp-cv-request": ["scq"],
		"application/scvp-cv-response": ["scs"],
		"application/scvp-vp-request": ["spq"],
		"application/scvp-vp-response": ["spp"],
		"application/sdp": ["sdp"],
		"application/set-payment-initiation": ["setpay"],
		"application/set-registration-initiation": ["setreg"],
		"application/shf+xml": ["shf"],
		"application/smil+xml": ["smi", "smil"],
		"application/sparql-query": ["rq"],
		"application/sparql-results+xml": ["srx"],
		"application/srgs": ["gram"],
		"application/srgs+xml": ["grxml"],
		"application/sru+xml": ["sru"],
		"application/ssdl+xml": ["ssdl"],
		"application/ssml+xml": ["ssml"],
		"application/tei+xml": ["tei", "teicorpus"],
		"application/thraud+xml": ["tfi"],
		"application/timestamped-data": ["tsd"],
		"application/vnd.3gpp.pic-bw-large": ["plb"],
		"application/vnd.3gpp.pic-bw-small": ["psb"],
		"application/vnd.3gpp.pic-bw-var": ["pvb"],
		"application/vnd.3gpp2.tcap": ["tcap"],
		"application/vnd.3m.post-it-notes": ["pwn"],
		"application/vnd.accpac.simply.aso": ["aso"],
		"application/vnd.accpac.simply.imp": ["imp"],
		"application/vnd.acucobol": ["acu"],
		"application/vnd.acucorp": ["atc", "acutc"],
		"application/vnd.adobe.air-application-installer-package+zip": ["air"],
		"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
		"application/vnd.adobe.fxp": ["fxp", "fxpl"],
		"application/vnd.adobe.xdp+xml": ["xdp"],
		"application/vnd.adobe.xfdf": ["xfdf"],
		"application/vnd.ahead.space": ["ahead"],
		"application/vnd.airzip.filesecure.azf": ["azf"],
		"application/vnd.airzip.filesecure.azs": ["azs"],
		"application/vnd.amazon.ebook": ["azw"],
		"application/vnd.americandynamics.acc": ["acc"],
		"application/vnd.amiga.ami": ["ami"],
		"application/vnd.android.package-archive": ["apk"],
		"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
		"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
		"application/vnd.antix.game-component": ["atx"],
		"application/vnd.apple.installer+xml": ["mpkg"],
		"application/vnd.apple.mpegurl": ["m3u8"],
		"application/vnd.apple.pkpass": ["pkpass"],
		"application/vnd.aristanetworks.swi": ["swi"],
		"application/vnd.astraea-software.iota": ["iota"],
		"application/vnd.audiograph": ["aep"],
		"application/vnd.blueice.multipass": ["mpm"],
		"application/vnd.bmi": ["bmi"],
		"application/vnd.businessobjects": ["rep"],
		"application/vnd.chemdraw+xml": ["cdxml"],
		"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
		"application/vnd.cinderella": ["cdy"],
		"application/vnd.claymore": ["cla"],
		"application/vnd.cloanto.rp9": ["rp9"],
		"application/vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
		"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
		"application/vnd.commonspace": ["csp"],
		"application/vnd.contact.cmsg": ["cdbcmsg"],
		"application/vnd.cosmocaller": ["cmc"],
		"application/vnd.crick.clicker": ["clkx"],
		"application/vnd.crick.clicker.keyboard": ["clkk"],
		"application/vnd.crick.clicker.palette": ["clkp"],
		"application/vnd.crick.clicker.template": ["clkt"],
		"application/vnd.crick.clicker.wordbank": ["clkw"],
		"application/vnd.criticaltools.wbs+xml": ["wbs"],
		"application/vnd.ctc-posml": ["pml"],
		"application/vnd.cups-ppd": ["ppd"],
		"application/vnd.curl.car": ["car"],
		"application/vnd.curl.pcurl": ["pcurl"],
		"application/vnd.dart": ["dart"],
		"application/vnd.data-vision.rdz": ["rdz"],
		"application/vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
		"application/vnd.dece.unspecified": ["uvx", "uvvx"],
		"application/vnd.dece.zip": ["uvz", "uvvz"],
		"application/vnd.denovo.fcselayout-link": ["fe_launch"],
		"application/vnd.dna": ["dna"],
		"application/vnd.dolby.mlp": ["mlp"],
		"application/vnd.dpgraph": ["dpg"],
		"application/vnd.dreamfactory": ["dfac"],
		"application/vnd.ds-keypoint": ["kpxx"],
		"application/vnd.dvb.ait": ["ait"],
		"application/vnd.dvb.service": ["svc"],
		"application/vnd.dynageo": ["geo"],
		"application/vnd.ecowin.chart": ["mag"],
		"application/vnd.enliven": ["nml"],
		"application/vnd.epson.esf": ["esf"],
		"application/vnd.epson.msf": ["msf"],
		"application/vnd.epson.quickanime": ["qam"],
		"application/vnd.epson.salt": ["slt"],
		"application/vnd.epson.ssf": ["ssf"],
		"application/vnd.eszigno3+xml": ["es3", "et3"],
		"application/vnd.ezpix-album": ["ez2"],
		"application/vnd.ezpix-package": ["ez3"],
		"application/vnd.fdf": ["fdf"],
		"application/vnd.fdsn.mseed": ["mseed"],
		"application/vnd.fdsn.seed": ["seed", "dataless"],
		"application/vnd.flographit": ["gph"],
		"application/vnd.fluxtime.clip": ["ftc"],
		"application/vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"application/vnd.frogans.fnc": ["fnc"],
		"application/vnd.frogans.ltf": ["ltf"],
		"application/vnd.fsc.weblaunch": ["fsc"],
		"application/vnd.fujitsu.oasys": ["oas"],
		"application/vnd.fujitsu.oasys2": ["oa2"],
		"application/vnd.fujitsu.oasys3": ["oa3"],
		"application/vnd.fujitsu.oasysgp": ["fg5"],
		"application/vnd.fujitsu.oasysprs": ["bh2"],
		"application/vnd.fujixerox.ddd": ["ddd"],
		"application/vnd.fujixerox.docuworks": ["xdw"],
		"application/vnd.fujixerox.docuworks.binder": ["xbd"],
		"application/vnd.fuzzysheet": ["fzs"],
		"application/vnd.genomatix.tuxedo": ["txd"],
		"application/vnd.geogebra.file": ["ggb"],
		"application/vnd.geogebra.tool": ["ggt"],
		"application/vnd.geometry-explorer": ["gex", "gre"],
		"application/vnd.geonext": ["gxt"],
		"application/vnd.geoplan": ["g2w"],
		"application/vnd.geospace": ["g3w"],
		"application/vnd.gmx": ["gmx"],
		"application/vnd.google-apps.document": ["gdoc"],
		"application/vnd.google-apps.presentation": ["gslides"],
		"application/vnd.google-apps.spreadsheet": ["gsheet"],
		"application/vnd.google-earth.kml+xml": ["kml"],
		"application/vnd.google-earth.kmz": ["kmz"],
		"application/vnd.grafeq": ["gqf", "gqs"],
		"application/vnd.groove-account": ["gac"],
		"application/vnd.groove-help": ["ghf"],
		"application/vnd.groove-identity-message": ["gim"],
		"application/vnd.groove-injector": ["grv"],
		"application/vnd.groove-tool-message": ["gtm"],
		"application/vnd.groove-tool-template": ["tpl"],
		"application/vnd.groove-vcard": ["vcg"],
		"application/vnd.hal+xml": ["hal"],
		"application/vnd.handheld-entertainment+xml": ["zmm"],
		"application/vnd.hbci": ["hbci"],
		"application/vnd.hhe.lesson-player": ["les"],
		"application/vnd.hp-hpgl": ["hpgl"],
		"application/vnd.hp-hpid": ["hpid"],
		"application/vnd.hp-hps": ["hps"],
		"application/vnd.hp-jlyt": ["jlt"],
		"application/vnd.hp-pcl": ["pcl"],
		"application/vnd.hp-pclxl": ["pclxl"],
		"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
		"application/vnd.ibm.minipay": ["mpy"],
		"application/vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"application/vnd.ibm.rights-management": ["irm"],
		"application/vnd.ibm.secure-container": ["sc"],
		"application/vnd.iccprofile": ["icc", "icm"],
		"application/vnd.igloader": ["igl"],
		"application/vnd.immervision-ivp": ["ivp"],
		"application/vnd.immervision-ivu": ["ivu"],
		"application/vnd.insors.igm": ["igm"],
		"application/vnd.intercon.formnet": ["xpw", "xpx"],
		"application/vnd.intergeo": ["i2g"],
		"application/vnd.intu.qbo": ["qbo"],
		"application/vnd.intu.qfx": ["qfx"],
		"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
		"application/vnd.irepository.package+xml": ["irp"],
		"application/vnd.is-xpr": ["xpr"],
		"application/vnd.isac.fcs": ["fcs"],
		"application/vnd.jam": ["jam"],
		"application/vnd.jcp.javame.midlet-rms": ["rms"],
		"application/vnd.jisp": ["jisp"],
		"application/vnd.joost.joda-archive": ["joda"],
		"application/vnd.kahootz": ["ktz", "ktr"],
		"application/vnd.kde.karbon": ["karbon"],
		"application/vnd.kde.kchart": ["chrt"],
		"application/vnd.kde.kformula": ["kfo"],
		"application/vnd.kde.kivio": ["flw"],
		"application/vnd.kde.kontour": ["kon"],
		"application/vnd.kde.kpresenter": ["kpr", "kpt"],
		"application/vnd.kde.kspread": ["ksp"],
		"application/vnd.kde.kword": ["kwd", "kwt"],
		"application/vnd.kenameaapp": ["htke"],
		"application/vnd.kidspiration": ["kia"],
		"application/vnd.kinar": ["kne", "knp"],
		"application/vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"application/vnd.kodak-descriptor": ["sse"],
		"application/vnd.las.las+xml": ["lasxml"],
		"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
		"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
		"application/vnd.lotus-1-2-3": ["123"],
		"application/vnd.lotus-approach": ["apr"],
		"application/vnd.lotus-freelance": ["pre"],
		"application/vnd.lotus-notes": ["nsf"],
		"application/vnd.lotus-organizer": ["org"],
		"application/vnd.lotus-screencam": ["scm"],
		"application/vnd.lotus-wordpro": ["lwp"],
		"application/vnd.macports.portpkg": ["portpkg"],
		"application/vnd.mcd": ["mcd"],
		"application/vnd.medcalcdata": ["mc1"],
		"application/vnd.mediastation.cdkey": ["cdkey"],
		"application/vnd.mfer": ["mwf"],
		"application/vnd.mfmp": ["mfm"],
		"application/vnd.micrografx.flo": ["flo"],
		"application/vnd.micrografx.igx": ["igx"],
		"application/vnd.mif": ["mif"],
		"application/vnd.mobius.daf": ["daf"],
		"application/vnd.mobius.dis": ["dis"],
		"application/vnd.mobius.mbk": ["mbk"],
		"application/vnd.mobius.mqy": ["mqy"],
		"application/vnd.mobius.msl": ["msl"],
		"application/vnd.mobius.plc": ["plc"],
		"application/vnd.mobius.txf": ["txf"],
		"application/vnd.mophun.application": ["mpn"],
		"application/vnd.mophun.certificate": ["mpc"],
		"application/vnd.mozilla.xul+xml": ["xul"],
		"application/vnd.ms-artgalry": ["cil"],
		"application/vnd.ms-cab-compressed": ["cab"],
		"application/vnd.ms-excel": [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		],
		"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
		"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
		"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
		"application/vnd.ms-fontobject": ["eot"],
		"application/vnd.ms-htmlhelp": ["chm"],
		"application/vnd.ms-ims": ["ims"],
		"application/vnd.ms-lrm": ["lrm"],
		"application/vnd.ms-officetheme": ["thmx"],
		"application/vnd.ms-outlook": ["msg"],
		"application/vnd.ms-pki.seccat": ["cat"],
		"application/vnd.ms-pki.stl": ["stl"],
		"application/vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot"
		],
		"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
		"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
		"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
		"application/vnd.ms-project": ["mpp", "mpt"],
		"application/vnd.ms-word.document.macroenabled.12": ["docm"],
		"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
		"application/vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"application/vnd.ms-wpl": ["wpl"],
		"application/vnd.ms-xpsdocument": ["xps"],
		"application/vnd.mseq": ["mseq"],
		"application/vnd.musician": ["mus"],
		"application/vnd.muvee.style": ["msty"],
		"application/vnd.mynfc": ["taglet"],
		"application/vnd.neurolanguage.nlu": ["nlu"],
		"application/vnd.nitf": ["ntf", "nitf"],
		"application/vnd.noblenet-directory": ["nnd"],
		"application/vnd.noblenet-sealer": ["nns"],
		"application/vnd.noblenet-web": ["nnw"],
		"application/vnd.nokia.n-gage.data": ["ngdat"],
		"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
		"application/vnd.nokia.radio-preset": ["rpst"],
		"application/vnd.nokia.radio-presets": ["rpss"],
		"application/vnd.novadigm.edm": ["edm"],
		"application/vnd.novadigm.edx": ["edx"],
		"application/vnd.novadigm.ext": ["ext"],
		"application/vnd.oasis.opendocument.chart": ["odc"],
		"application/vnd.oasis.opendocument.chart-template": ["otc"],
		"application/vnd.oasis.opendocument.database": ["odb"],
		"application/vnd.oasis.opendocument.formula": ["odf"],
		"application/vnd.oasis.opendocument.formula-template": ["odft"],
		"application/vnd.oasis.opendocument.graphics": ["odg"],
		"application/vnd.oasis.opendocument.graphics-template": ["otg"],
		"application/vnd.oasis.opendocument.image": ["odi"],
		"application/vnd.oasis.opendocument.image-template": ["oti"],
		"application/vnd.oasis.opendocument.presentation": ["odp"],
		"application/vnd.oasis.opendocument.presentation-template": ["otp"],
		"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
		"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
		"application/vnd.oasis.opendocument.text": ["odt"],
		"application/vnd.oasis.opendocument.text-master": ["odm"],
		"application/vnd.oasis.opendocument.text-template": ["ott"],
		"application/vnd.oasis.opendocument.text-web": ["oth"],
		"application/vnd.olpc-sugar": ["xo"],
		"application/vnd.oma.dd2+xml": ["dd2"],
		"application/vnd.openofficeorg.extension": ["oxt"],
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
		"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
		"application/vnd.osgeo.mapguide.package": ["mgp"],
		"application/vnd.osgi.dp": ["dp"],
		"application/vnd.osgi.subsystem": ["esa"],
		"application/vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"application/vnd.pawaafile": ["paw"],
		"application/vnd.pg.format": ["str"],
		"application/vnd.pg.osasli": ["ei6"],
		"application/vnd.picsel": ["efif"],
		"application/vnd.pmi.widget": ["wg"],
		"application/vnd.pocketlearn": ["plf"],
		"application/vnd.powerbuilder6": ["pbd"],
		"application/vnd.previewsystems.box": ["box"],
		"application/vnd.proteus.magazine": ["mgz"],
		"application/vnd.publishare-delta-tree": ["qps"],
		"application/vnd.pvi.ptid1": ["ptid"],
		"application/vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"application/vnd.realvnc.bed": ["bed"],
		"application/vnd.recordare.musicxml": ["mxl"],
		"application/vnd.recordare.musicxml+xml": ["musicxml"],
		"application/vnd.rig.cryptonote": ["cryptonote"],
		"application/vnd.rim.cod": ["cod"],
		"application/vnd.rn-realmedia": ["rm"],
		"application/vnd.rn-realmedia-vbr": ["rmvb"],
		"application/vnd.route66.link66+xml": ["link66"],
		"application/vnd.sailingtracker.track": ["st"],
		"application/vnd.seemail": ["see"],
		"application/vnd.sema": ["sema"],
		"application/vnd.semd": ["semd"],
		"application/vnd.semf": ["semf"],
		"application/vnd.shana.informed.formdata": ["ifm"],
		"application/vnd.shana.informed.formtemplate": ["itp"],
		"application/vnd.shana.informed.interchange": ["iif"],
		"application/vnd.shana.informed.package": ["ipk"],
		"application/vnd.simtech-mindmapper": ["twd", "twds"],
		"application/vnd.smaf": ["mmf"],
		"application/vnd.smart.teacher": ["teacher"],
		"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
		"application/vnd.spotfire.dxp": ["dxp"],
		"application/vnd.spotfire.sfs": ["sfs"],
		"application/vnd.stardivision.calc": ["sdc"],
		"application/vnd.stardivision.draw": ["sda"],
		"application/vnd.stardivision.impress": ["sdd"],
		"application/vnd.stardivision.math": ["smf"],
		"application/vnd.stardivision.writer": ["sdw", "vor"],
		"application/vnd.stardivision.writer-global": ["sgl"],
		"application/vnd.stepmania.package": ["smzip"],
		"application/vnd.stepmania.stepchart": ["sm"],
		"application/vnd.sun.wadl+xml": ["wadl"],
		"application/vnd.sun.xml.calc": ["sxc"],
		"application/vnd.sun.xml.calc.template": ["stc"],
		"application/vnd.sun.xml.draw": ["sxd"],
		"application/vnd.sun.xml.draw.template": ["std"],
		"application/vnd.sun.xml.impress": ["sxi"],
		"application/vnd.sun.xml.impress.template": ["sti"],
		"application/vnd.sun.xml.math": ["sxm"],
		"application/vnd.sun.xml.writer": ["sxw"],
		"application/vnd.sun.xml.writer.global": ["sxg"],
		"application/vnd.sun.xml.writer.template": ["stw"],
		"application/vnd.sus-calendar": ["sus", "susp"],
		"application/vnd.svd": ["svd"],
		"application/vnd.symbian.install": ["sis", "sisx"],
		"application/vnd.syncml+xml": ["xsm"],
		"application/vnd.syncml.dm+wbxml": ["bdm"],
		"application/vnd.syncml.dm+xml": ["xdm"],
		"application/vnd.tao.intent-module-archive": ["tao"],
		"application/vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"application/vnd.tmobile-livetv": ["tmo"],
		"application/vnd.trid.tpt": ["tpt"],
		"application/vnd.triscape.mxs": ["mxs"],
		"application/vnd.trueapp": ["tra"],
		"application/vnd.ufdl": ["ufd", "ufdl"],
		"application/vnd.uiq.theme": ["utz"],
		"application/vnd.umajin": ["umj"],
		"application/vnd.unity": ["unityweb"],
		"application/vnd.uoml+xml": ["uoml"],
		"application/vnd.vcx": ["vcx"],
		"application/vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw"
		],
		"application/vnd.visionary": ["vis"],
		"application/vnd.vsf": ["vsf"],
		"application/vnd.wap.wbxml": ["wbxml"],
		"application/vnd.wap.wmlc": ["wmlc"],
		"application/vnd.wap.wmlscriptc": ["wmlsc"],
		"application/vnd.webturbo": ["wtb"],
		"application/vnd.wolfram.player": ["nbp"],
		"application/vnd.wordperfect": ["wpd"],
		"application/vnd.wqd": ["wqd"],
		"application/vnd.wt.stf": ["stf"],
		"application/vnd.xara": ["xar"],
		"application/vnd.xfdl": ["xfdl"],
		"application/vnd.yamaha.hv-dic": ["hvd"],
		"application/vnd.yamaha.hv-script": ["hvs"],
		"application/vnd.yamaha.hv-voice": ["hvp"],
		"application/vnd.yamaha.openscoreformat": ["osf"],
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
		"application/vnd.yamaha.smaf-audio": ["saf"],
		"application/vnd.yamaha.smaf-phrase": ["spf"],
		"application/vnd.yellowriver-custom-menu": ["cmp"],
		"application/vnd.zul": ["zir", "zirz"],
		"application/vnd.zzazz.deck+xml": ["zaz"],
		"application/voicexml+xml": ["vxml"],
		"application/wasm": ["wasm"],
		"application/widget": ["wgt"],
		"application/winhlp": ["hlp"],
		"application/wsdl+xml": ["wsdl"],
		"application/wspolicy+xml": ["wspolicy"],
		"application/x-7z-compressed": ["7z"],
		"application/x-abiword": ["abw"],
		"application/x-ace-compressed": ["ace"],
		"application/x-apple-diskimage": [],
		"application/x-arj": ["arj"],
		"application/x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"application/x-authorware-map": ["aam"],
		"application/x-authorware-seg": ["aas"],
		"application/x-bcpio": ["bcpio"],
		"application/x-bdoc": [],
		"application/x-bittorrent": ["torrent"],
		"application/x-blorb": ["blb", "blorb"],
		"application/x-bzip": ["bz"],
		"application/x-bzip2": ["bz2", "boz"],
		"application/x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		],
		"application/x-cdlink": ["vcd"],
		"application/x-cfs-compressed": ["cfs"],
		"application/x-chat": ["chat"],
		"application/x-chess-pgn": ["pgn"],
		"application/x-chrome-extension": ["crx"],
		"application/x-cocoa": ["cco"],
		"application/x-conference": ["nsc"],
		"application/x-cpio": ["cpio"],
		"application/x-csh": ["csh"],
		"application/x-debian-package": ["udeb"],
		"application/x-dgc-compressed": ["dgc"],
		"application/x-director": [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"application/x-doom": ["wad"],
		"application/x-dtbncx+xml": ["ncx"],
		"application/x-dtbook+xml": ["dtb"],
		"application/x-dtbresource+xml": ["res"],
		"application/x-dvi": ["dvi"],
		"application/x-envoy": ["evy"],
		"application/x-eva": ["eva"],
		"application/x-font-bdf": ["bdf"],
		"application/x-font-ghostscript": ["gsf"],
		"application/x-font-linux-psf": ["psf"],
		"application/x-font-pcf": ["pcf"],
		"application/x-font-snf": ["snf"],
		"application/x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"application/x-freearc": ["arc"],
		"application/x-futuresplash": ["spl"],
		"application/x-gca-compressed": ["gca"],
		"application/x-glulx": ["ulx"],
		"application/x-gnumeric": ["gnumeric"],
		"application/x-gramps-xml": ["gramps"],
		"application/x-gtar": ["gtar"],
		"application/x-hdf": ["hdf"],
		"application/x-httpd-php": ["php"],
		"application/x-install-instructions": ["install"],
		"application/x-iso9660-image": [],
		"application/x-java-archive-diff": ["jardiff"],
		"application/x-java-jnlp-file": ["jnlp"],
		"application/x-latex": ["latex"],
		"application/x-lua-bytecode": ["luac"],
		"application/x-lzh-compressed": ["lzh", "lha"],
		"application/x-makeself": ["run"],
		"application/x-mie": ["mie"],
		"application/x-mobipocket-ebook": ["prc", "mobi"],
		"application/x-ms-application": ["application"],
		"application/x-ms-shortcut": ["lnk"],
		"application/x-ms-wmd": ["wmd"],
		"application/x-ms-wmz": ["wmz"],
		"application/x-ms-xbap": ["xbap"],
		"application/x-msaccess": ["mdb"],
		"application/x-msbinder": ["obd"],
		"application/x-mscardfile": ["crd"],
		"application/x-msclip": ["clp"],
		"application/x-msdos-program": [],
		"application/x-msdownload": ["com", "bat"],
		"application/x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"application/x-msmetafile": [
			"wmf",
			"emf",
			"emz"
		],
		"application/x-msmoney": ["mny"],
		"application/x-mspublisher": ["pub"],
		"application/x-msschedule": ["scd"],
		"application/x-msterminal": ["trm"],
		"application/x-mswrite": ["wri"],
		"application/x-netcdf": ["nc", "cdf"],
		"application/x-ns-proxy-autoconfig": ["pac"],
		"application/x-nzb": ["nzb"],
		"application/x-perl": ["pl", "pm"],
		"application/x-pilot": [],
		"application/x-pkcs12": ["p12", "pfx"],
		"application/x-pkcs7-certificates": ["p7b", "spc"],
		"application/x-pkcs7-certreqresp": ["p7r"],
		"application/x-rar-compressed": ["rar"],
		"application/x-redhat-package-manager": ["rpm"],
		"application/x-research-info-systems": ["ris"],
		"application/x-sea": ["sea"],
		"application/x-sh": ["sh"],
		"application/x-shar": ["shar"],
		"application/x-shockwave-flash": ["swf"],
		"application/x-silverlight-app": ["xap"],
		"application/x-sql": ["sql"],
		"application/x-stuffit": ["sit"],
		"application/x-stuffitx": ["sitx"],
		"application/x-subrip": ["srt"],
		"application/x-sv4cpio": ["sv4cpio"],
		"application/x-sv4crc": ["sv4crc"],
		"application/x-t3vm-image": ["t3"],
		"application/x-tads": ["gam"],
		"application/x-tar": ["tar"],
		"application/x-tcl": ["tcl", "tk"],
		"application/x-tex": ["tex"],
		"application/x-tex-tfm": ["tfm"],
		"application/x-texinfo": ["texinfo", "texi"],
		"application/x-tgif": ["obj"],
		"application/x-ustar": ["ustar"],
		"application/x-virtualbox-hdd": ["hdd"],
		"application/x-virtualbox-ova": ["ova"],
		"application/x-virtualbox-ovf": ["ovf"],
		"application/x-virtualbox-vbox": ["vbox"],
		"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
		"application/x-virtualbox-vdi": ["vdi"],
		"application/x-virtualbox-vhd": ["vhd"],
		"application/x-virtualbox-vmdk": ["vmdk"],
		"application/x-wais-source": ["src"],
		"application/x-web-app-manifest+json": ["webapp"],
		"application/x-x509-ca-cert": [
			"der",
			"crt",
			"pem"
		],
		"application/x-xfig": ["fig"],
		"application/x-xliff+xml": ["xlf"],
		"application/x-xpinstall": ["xpi"],
		"application/x-xz": ["xz"],
		"application/x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"application/xaml+xml": ["xaml"],
		"application/xcap-diff+xml": ["xdf"],
		"application/xenc+xml": ["xenc"],
		"application/xhtml+xml": ["xhtml", "xht"],
		"application/xml": [
			"xml",
			"xsl",
			"xsd",
			"rng"
		],
		"application/xml-dtd": ["dtd"],
		"application/xop+xml": ["xop"],
		"application/xproc+xml": ["xpl"],
		"application/xslt+xml": ["xslt"],
		"application/xspf+xml": ["xspf"],
		"application/xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"application/yang": ["yang"],
		"application/yin+xml": ["yin"],
		"application/zip": ["zip"],
		"audio/3gpp": [],
		"audio/adpcm": ["adp"],
		"audio/basic": ["au", "snd"],
		"audio/midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"audio/mp3": [],
		"audio/mp4": ["m4a", "mp4a"],
		"audio/mpeg": [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		],
		"audio/ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"audio/s3m": ["s3m"],
		"audio/silk": ["sil"],
		"audio/vnd.dece.audio": ["uva", "uvva"],
		"audio/vnd.digital-winds": ["eol"],
		"audio/vnd.dra": ["dra"],
		"audio/vnd.dts": ["dts"],
		"audio/vnd.dts.hd": ["dtshd"],
		"audio/vnd.lucent.voice": ["lvp"],
		"audio/vnd.ms-playready.media.pya": ["pya"],
		"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
		"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
		"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
		"audio/vnd.rip": ["rip"],
		"audio/wav": ["wav"],
		"audio/wave": [],
		"audio/webm": ["weba"],
		"audio/x-aac": ["aac"],
		"audio/x-aiff": [
			"aif",
			"aiff",
			"aifc"
		],
		"audio/x-caf": ["caf"],
		"audio/x-flac": ["flac"],
		"audio/x-m4a": [],
		"audio/x-matroska": ["mka"],
		"audio/x-mpegurl": ["m3u"],
		"audio/x-ms-wax": ["wax"],
		"audio/x-ms-wma": ["wma"],
		"audio/x-pn-realaudio": ["ram", "ra"],
		"audio/x-pn-realaudio-plugin": ["rmp"],
		"audio/x-realaudio": [],
		"audio/x-wav": [],
		"audio/xm": ["xm"],
		"chemical/x-cdx": ["cdx"],
		"chemical/x-cif": ["cif"],
		"chemical/x-cmdf": ["cmdf"],
		"chemical/x-cml": ["cml"],
		"chemical/x-csml": ["csml"],
		"chemical/x-xyz": ["xyz"],
		"font/collection": ["ttc"],
		"font/otf": ["otf"],
		"font/ttf": ["ttf"],
		"font/woff": ["woff"],
		"font/woff2": ["woff2"],
		"image/apng": ["apng"],
		"image/bmp": ["bmp"],
		"image/cgm": ["cgm"],
		"image/g3fax": ["g3"],
		"image/gif": ["gif"],
		"image/ief": ["ief"],
		"image/jp2": ["jp2", "jpg2"],
		"image/jpeg": [
			"jpeg",
			"jpg",
			"jpe"
		],
		"image/jpm": ["jpm"],
		"image/jpx": ["jpx", "jpf"],
		"image/ktx": ["ktx"],
		"image/png": ["png"],
		"image/prs.btif": ["btif"],
		"image/sgi": ["sgi"],
		"image/svg+xml": ["svg", "svgz"],
		"image/tiff": ["tiff", "tif"],
		"image/vnd.adobe.photoshop": ["psd"],
		"image/vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"image/vnd.djvu": ["djvu", "djv"],
		"image/vnd.dvb.subtitle": [],
		"image/vnd.dwg": ["dwg"],
		"image/vnd.dxf": ["dxf"],
		"image/vnd.fastbidsheet": ["fbs"],
		"image/vnd.fpx": ["fpx"],
		"image/vnd.fst": ["fst"],
		"image/vnd.fujixerox.edmics-mmr": ["mmr"],
		"image/vnd.fujixerox.edmics-rlc": ["rlc"],
		"image/vnd.ms-modi": ["mdi"],
		"image/vnd.ms-photo": ["wdp"],
		"image/vnd.net-fpx": ["npx"],
		"image/vnd.wap.wbmp": ["wbmp"],
		"image/vnd.xiff": ["xif"],
		"image/webp": ["webp"],
		"image/x-3ds": ["3ds"],
		"image/x-cmu-raster": ["ras"],
		"image/x-cmx": ["cmx"],
		"image/x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"image/x-icon": ["ico"],
		"image/x-jng": ["jng"],
		"image/x-mrsid-image": ["sid"],
		"image/x-ms-bmp": [],
		"image/x-pcx": ["pcx"],
		"image/x-pict": ["pic", "pct"],
		"image/x-portable-anymap": ["pnm"],
		"image/x-portable-bitmap": ["pbm"],
		"image/x-portable-graymap": ["pgm"],
		"image/x-portable-pixmap": ["ppm"],
		"image/x-rgb": ["rgb"],
		"image/x-tga": ["tga"],
		"image/x-xbitmap": ["xbm"],
		"image/x-xpixmap": ["xpm"],
		"image/x-xwindowdump": ["xwd"],
		"message/rfc822": ["eml", "mime"],
		"model/gltf+json": ["gltf"],
		"model/gltf-binary": ["glb"],
		"model/iges": ["igs", "iges"],
		"model/mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"model/vnd.collada+xml": ["dae"],
		"model/vnd.dwf": ["dwf"],
		"model/vnd.gdl": ["gdl"],
		"model/vnd.gtw": ["gtw"],
		"model/vnd.mts": ["mts"],
		"model/vnd.vtu": ["vtu"],
		"model/vrml": ["wrl", "vrml"],
		"model/x3d+binary": ["x3db", "x3dbz"],
		"model/x3d+vrml": ["x3dv", "x3dvz"],
		"model/x3d+xml": ["x3d", "x3dz"],
		"text/cache-manifest": ["appcache", "manifest"],
		"text/calendar": ["ics", "ifb"],
		"text/coffeescript": ["coffee", "litcoffee"],
		"text/css": ["css"],
		"text/csv": ["csv"],
		"text/hjson": ["hjson"],
		"text/html": [
			"html",
			"htm",
			"shtml"
		],
		"text/jade": ["jade"],
		"text/jsx": ["jsx"],
		"text/less": ["less"],
		"text/markdown": ["markdown", "md"],
		"text/mathml": ["mml"],
		"text/n3": ["n3"],
		"text/plain": [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		],
		"text/prs.lines.tag": ["dsc"],
		"text/richtext": ["rtx"],
		"text/rtf": [],
		"text/sgml": ["sgml", "sgm"],
		"text/slim": ["slim", "slm"],
		"text/stylus": ["stylus", "styl"],
		"text/tab-separated-values": ["tsv"],
		"text/troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"text/turtle": ["ttl"],
		"text/uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"text/vcard": ["vcard"],
		"text/vnd.curl": ["curl"],
		"text/vnd.curl.dcurl": ["dcurl"],
		"text/vnd.curl.mcurl": ["mcurl"],
		"text/vnd.curl.scurl": ["scurl"],
		"text/vnd.dvb.subtitle": ["sub"],
		"text/vnd.fly": ["fly"],
		"text/vnd.fmi.flexstor": ["flx"],
		"text/vnd.graphviz": ["gv"],
		"text/vnd.in3d.3dml": ["3dml"],
		"text/vnd.in3d.spot": ["spot"],
		"text/vnd.sun.j2me.app-descriptor": ["jad"],
		"text/vnd.wap.wml": ["wml"],
		"text/vnd.wap.wmlscript": ["wmls"],
		"text/vtt": ["vtt"],
		"text/x-asm": ["s", "asm"],
		"text/x-c": [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		],
		"text/x-component": ["htc"],
		"text/x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"text/x-handlebars-template": ["hbs"],
		"text/x-java-source": ["java"],
		"text/x-lua": ["lua"],
		"text/x-markdown": ["mkd"],
		"text/x-nfo": ["nfo"],
		"text/x-opml": ["opml"],
		"text/x-org": [],
		"text/x-pascal": ["p", "pas"],
		"text/x-processing": ["pde"],
		"text/x-sass": ["sass"],
		"text/x-scss": ["scss"],
		"text/x-setext": ["etx"],
		"text/x-sfv": ["sfv"],
		"text/x-suse-ymp": ["ymp"],
		"text/x-uuencode": ["uu"],
		"text/x-vcalendar": ["vcs"],
		"text/x-vcard": ["vcf"],
		"text/xml": [],
		"text/yaml": ["yaml", "yml"],
		"video/3gpp": ["3gp", "3gpp"],
		"video/3gpp2": ["3g2"],
		"video/h261": ["h261"],
		"video/h263": ["h263"],
		"video/h264": ["h264"],
		"video/jpeg": ["jpgv"],
		"video/jpm": ["jpgm"],
		"video/mj2": ["mj2", "mjp2"],
		"video/mp2t": ["ts"],
		"video/mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"video/mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		],
		"video/ogg": ["ogv"],
		"video/quicktime": ["qt", "mov"],
		"video/vnd.dece.hd": ["uvh", "uvvh"],
		"video/vnd.dece.mobile": ["uvm", "uvvm"],
		"video/vnd.dece.pd": ["uvp", "uvvp"],
		"video/vnd.dece.sd": ["uvs", "uvvs"],
		"video/vnd.dece.video": ["uvv", "uvvv"],
		"video/vnd.dvb.file": ["dvb"],
		"video/vnd.fvt": ["fvt"],
		"video/vnd.mpegurl": ["mxu", "m4u"],
		"video/vnd.ms-playready.media.pyv": ["pyv"],
		"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
		"video/vnd.vivo": ["viv"],
		"video/webm": ["webm"],
		"video/x-f4v": ["f4v"],
		"video/x-fli": ["fli"],
		"video/x-flv": ["flv"],
		"video/x-m4v": ["m4v"],
		"video/x-matroska": [
			"mkv",
			"mk3d",
			"mks"
		],
		"video/x-mng": ["mng"],
		"video/x-ms-asf": ["asf", "asx"],
		"video/x-ms-vob": ["vob"],
		"video/x-ms-wm": ["wm"],
		"video/x-ms-wmv": ["wmv"],
		"video/x-ms-wmx": ["wmx"],
		"video/x-ms-wvx": ["wvx"],
		"video/x-msvideo": ["avi"],
		"video/x-sgi-movie": ["movie"],
		"video/x-smv": ["smv"],
		"x-conference/x-cooltalk": ["ice"]
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js
var require_mime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require("path");
	var fs$8 = require("fs");
	function Mime() {
		this.types = Object.create(null);
		this.extensions = Object.create(null);
	}
	/**
	* Define mimetype -> extension mappings.  Each key is a mime-type that maps
	* to an array of extensions associated with the type.  The first extension is
	* used as the default extension for the type.
	*
	* e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	*
	* @param map (Object) type definitions
	*/
	Mime.prototype.define = function(map) {
		for (var type in map) {
			var exts = map[type];
			for (var i = 0; i < exts.length; i++) {
				if (process.env.DEBUG_MIME && this.types[exts[i]]) console.warn((this._loading || "define()").replace(/.*\//, ""), "changes \"" + exts[i] + "\" extension type from " + this.types[exts[i]] + " to " + type);
				this.types[exts[i]] = type;
			}
			if (!this.extensions[type]) this.extensions[type] = exts[0];
		}
	};
	/**
	* Load an Apache2-style ".types" file
	*
	* This may be called multiple times (it's expected).  Where files declare
	* overlapping types/extensions, the last file wins.
	*
	* @param file (String) path of file to load.
	*/
	Mime.prototype.load = function(file) {
		this._loading = file;
		var map = {};
		fs$8.readFileSync(file, "ascii").split(/[\r\n]+/).forEach(function(line) {
			var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
			map[fields.shift()] = fields;
		});
		this.define(map);
		this._loading = null;
	};
	/**
	* Lookup a mime type based on extension
	*/
	Mime.prototype.lookup = function(path$55, fallback) {
		var ext = path$55.replace(/^.*[\.\/\\]/, "").toLowerCase();
		return this.types[ext] || fallback || this.default_type;
	};
	/**
	* Return file extension associated with a mime type
	*/
	Mime.prototype.extension = function(mimeType) {
		var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
		return this.extensions[type];
	};
	var mime = new Mime();
	mime.define(require_types$1());
	mime.default_type = mime.lookup("bin");
	mime.Mime = Mime;
	/**
	* Lookup a charset based on mime type.
	*/
	mime.charsets = { lookup: function(mimeType, fallback) {
		return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
	} };
	module.exports = mime;
}));

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js
/*!
* range-parser
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_range_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = rangeParser;
	/**
	* Parse "Range" header `str` relative to the given file `size`.
	*
	* @param {Number} size
	* @param {String} str
	* @param {Object} [options]
	* @return {Array}
	* @public
	*/
	function rangeParser(size, str, options) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var index = str.indexOf("=");
		if (index === -1) return -2;
		var arr = str.slice(index + 1).split(",");
		var ranges = [];
		ranges.type = str.slice(0, index);
		for (var i = 0; i < arr.length; i++) {
			var range = arr[i].split("-");
			var start = parseInt(range[0], 10);
			var end = parseInt(range[1], 10);
			if (isNaN(start)) {
				start = size - end;
				end = size - 1;
			} else if (isNaN(end)) end = size - 1;
			if (end > size - 1) end = size - 1;
			if (isNaN(start) || isNaN(end) || start > end || start < 0) continue;
			ranges.push({
				start,
				end
			});
		}
		if (ranges.length < 1) return -1;
		return options && options.combine ? combineRanges(ranges) : ranges;
	}
	/**
	* Combine overlapping & adjacent ranges.
	* @private
	*/
	function combineRanges(ranges) {
		var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
		for (var j = 0, i = 1; i < ordered.length; i++) {
			var range = ordered[i];
			var current = ordered[j];
			if (range.start > current.end + 1) ordered[++j] = range;
			else if (range.end > current.end) {
				current.end = range.end;
				current.index = Math.min(current.index, range.index);
			}
		}
		ordered.length = j + 1;
		var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
		combined.type = ranges.type;
		return combined;
	}
	/**
	* Map function to add index value to ranges.
	* @private
	*/
	function mapWithIndex(range, index) {
		return {
			start: range.start,
			end: range.end,
			index
		};
	}
	/**
	* Map function to remove index value from ranges.
	* @private
	*/
	function mapWithoutIndex(range) {
		return {
			start: range.start,
			end: range.end
		};
	}
	/**
	* Sort function to sort ranges by index.
	* @private
	*/
	function sortByRangeIndex(a, b) {
		return a.index - b.index;
	}
	/**
	* Sort function to sort ranges by start position.
	* @private
	*/
	function sortByRangeStart(a, b) {
		return a.start - b.start;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/send@0.19.2/node_modules/send/index.js
/*!
* send
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_send = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError = require_http_errors();
	var debug = require_src()("send");
	var deprecate = require_depd()("send");
	var destroy = require_destroy();
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var etag = require_etag();
	var fresh = require_fresh();
	var fs$7 = require("fs");
	var mime = require_mime();
	var ms = require_ms();
	var onFinished = require_on_finished();
	var parseRange = require_range_parser();
	var path$3 = require("path");
	var statuses = require_statuses();
	var Stream = require("stream");
	var util = require("util");
	/**
	* Path function references.
	* @private
	*/
	var extname = path$3.extname;
	var join = path$3.join;
	var normalize = path$3.normalize;
	var resolve = path$3.resolve;
	var sep = path$3.sep;
	/**
	* Regular expression for identifying a bytes Range header.
	* @private
	*/
	var BYTES_RANGE_REGEXP = /^ *bytes=/;
	/**
	* Maximum value allowed for the max age.
	* @private
	*/
	var MAX_MAXAGE = 3600 * 24 * 365 * 1e3;
	/**
	* Regular expression to match a path with a directory up component.
	* @private
	*/
	var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = send;
	module.exports.mime = mime;
	/**
	* Return a `SendStream` for `req` and `path`.
	*
	* @param {object} req
	* @param {string} path
	* @param {object} [options]
	* @return {SendStream}
	* @public
	*/
	function send(req, path$43, options) {
		return new SendStream(req, path$43, options);
	}
	/**
	* Initialize a `SendStream` with the given `path`.
	*
	* @param {Request} req
	* @param {String} path
	* @param {object} [options]
	* @private
	*/
	function SendStream(req, path$44, options) {
		Stream.call(this);
		var opts = options || {};
		this.options = opts;
		this.path = path$44;
		this.req = req;
		this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
		this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
		this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
		this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
		if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") throw new TypeError("dotfiles option must be \"allow\", \"deny\", or \"ignore\"");
		this._hidden = Boolean(opts.hidden);
		if (opts.hidden !== void 0) deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
		if (opts.dotfiles === void 0) this._dotfiles = void 0;
		this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
		this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
		this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
		this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
		this._maxage = opts.maxAge || opts.maxage;
		this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		this._root = opts.root ? resolve(opts.root) : null;
		if (!this._root && opts.from) this.from(opts.from);
	}
	/**
	* Inherits from `Stream`.
	*/
	util.inherits(SendStream, Stream);
	/**
	* Enable or disable etag generation.
	*
	* @param {Boolean} val
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.etag = deprecate.function(function etag(val) {
		this._etag = Boolean(val);
		debug("etag %s", this._etag);
		return this;
	}, "send.etag: pass etag as option");
	/**
	* Enable or disable "hidden" (dot) files.
	*
	* @param {Boolean} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.hidden = deprecate.function(function hidden(val) {
		this._hidden = Boolean(val);
		this._dotfiles = void 0;
		debug("hidden %s", this._hidden);
		return this;
	}, "send.hidden: use dotfiles option");
	/**
	* Set index `paths`, set to a falsy
	* value to disable index support.
	*
	* @param {String|Boolean|Array} paths
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.index = deprecate.function(function index(paths) {
		var index = !paths ? [] : normalizeList(paths, "paths argument");
		debug("index %o", paths);
		this._index = index;
		return this;
	}, "send.index: pass index as option");
	/**
	* Set root `path`.
	*
	* @param {String} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.root = function root(path$45) {
		this._root = resolve(String(path$45));
		debug("root %s", this._root);
		return this;
	};
	SendStream.prototype.from = deprecate.function(SendStream.prototype.root, "send.from: pass root as option");
	SendStream.prototype.root = deprecate.function(SendStream.prototype.root, "send.root: pass root as option");
	/**
	* Set max-age to `maxAge`.
	*
	* @param {Number} maxAge
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
		this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		debug("max-age %d", this._maxage);
		return this;
	}, "send.maxage: pass maxAge as option");
	/**
	* Emit error with `status`.
	*
	* @param {number} status
	* @param {Error} [err]
	* @private
	*/
	SendStream.prototype.error = function error(status, err) {
		if (hasListeners(this, "error")) return this.emit("error", createHttpError(status, err));
		var res = this.res;
		var doc = createHtmlDocument("Error", escapeHtml(statuses.message[status] || String(status)));
		clearHeaders(res);
		if (err && err.headers) setHeaders(res, err.headers);
		res.statusCode = status;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.end(doc);
	};
	/**
	* Check if the pathname ends with "/".
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
		return this.path[this.path.length - 1] === "/";
	};
	/**
	* Check if this is a conditional GET request.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isConditionalGET = function isConditionalGET() {
		return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
	};
	/**
	* Check if the request preconditions failed.
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
		var req = this.req;
		var res = this.res;
		var match = req.headers["if-match"];
		if (match) {
			var etag = res.getHeader("ETag");
			return !etag || match !== "*" && parseTokenList(match).every(function(match) {
				return match !== etag && match !== "W/" + etag && "W/" + match !== etag;
			});
		}
		var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
		if (!isNaN(unmodifiedSince)) {
			var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
			return isNaN(lastModified) || lastModified > unmodifiedSince;
		}
		return false;
	};
	/**
	* Strip various content header fields for a change in entity.
	*
	* @private
	*/
	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
		var res = this.res;
		res.removeHeader("Content-Encoding");
		res.removeHeader("Content-Language");
		res.removeHeader("Content-Length");
		res.removeHeader("Content-Range");
		res.removeHeader("Content-Type");
	};
	/**
	* Respond with 304 not modified.
	*
	* @api private
	*/
	SendStream.prototype.notModified = function notModified() {
		var res = this.res;
		debug("not modified");
		this.removeContentHeaderFields();
		res.statusCode = 304;
		res.end();
	};
	/**
	* Raise error that headers already sent.
	*
	* @api private
	*/
	SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
		var err = /* @__PURE__ */ new Error("Can't set headers after they are sent.");
		debug("headers already sent");
		this.error(500, err);
	};
	/**
	* Check if the request is cacheable, aka
	* responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isCachable = function isCachable() {
		var statusCode = this.res.statusCode;
		return statusCode >= 200 && statusCode < 300 || statusCode === 304;
	};
	/**
	* Handle stat() error.
	*
	* @param {Error} error
	* @private
	*/
	SendStream.prototype.onStatError = function onStatError(error) {
		switch (error.code) {
			case "ENAMETOOLONG":
			case "ENOENT":
			case "ENOTDIR":
				this.error(404, error);
				break;
			default:
				this.error(500, error);
				break;
		}
	};
	/**
	* Check if the cache is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isFresh = function isFresh() {
		return fresh(this.req.headers, {
			etag: this.res.getHeader("ETag"),
			"last-modified": this.res.getHeader("Last-Modified")
		});
	};
	/**
	* Check if the range is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isRangeFresh = function isRangeFresh() {
		var ifRange = this.req.headers["if-range"];
		if (!ifRange) return true;
		if (ifRange.indexOf("\"") !== -1) {
			var etag = this.res.getHeader("ETag");
			return Boolean(etag && ifRange.indexOf(etag) !== -1);
		}
		return parseHttpDate(this.res.getHeader("Last-Modified")) <= parseHttpDate(ifRange);
	};
	/**
	* Redirect to path.
	*
	* @param {string} path
	* @private
	*/
	SendStream.prototype.redirect = function redirect(path$46) {
		var res = this.res;
		if (hasListeners(this, "directory")) {
			this.emit("directory", res, path$46);
			return;
		}
		if (this.hasTrailingSlash()) {
			this.error(403);
			return;
		}
		var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
		var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
		res.statusCode = 301;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.setHeader("Location", loc);
		res.end(doc);
	};
	/**
	* Pipe to `res.
	*
	* @param {Stream} res
	* @return {Stream} res
	* @api public
	*/
	SendStream.prototype.pipe = function pipe(res) {
		var root = this._root;
		this.res = res;
		var path$47 = decode(this.path);
		if (path$47 === -1) {
			this.error(400);
			return res;
		}
		if (~path$47.indexOf("\0")) {
			this.error(400);
			return res;
		}
		var parts;
		if (root !== null) {
			if (path$47) path$47 = normalize("." + sep + path$47);
			if (UP_PATH_REGEXP.test(path$47)) {
				debug("malicious path \"%s\"", path$47);
				this.error(403);
				return res;
			}
			parts = path$47.split(sep);
			path$47 = normalize(join(root, path$47));
		} else {
			if (UP_PATH_REGEXP.test(path$47)) {
				debug("malicious path \"%s\"", path$47);
				this.error(403);
				return res;
			}
			parts = normalize(path$47).split(sep);
			path$47 = resolve(path$47);
		}
		if (containsDotFile(parts)) {
			var access = this._dotfiles;
			if (access === void 0) access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
			debug("%s dotfile \"%s\"", access, path$47);
			switch (access) {
				case "allow": break;
				case "deny":
					this.error(403);
					return res;
				default:
					this.error(404);
					return res;
			}
		}
		if (this._index.length && this.hasTrailingSlash()) {
			this.sendIndex(path$47);
			return res;
		}
		this.sendFile(path$47);
		return res;
	};
	/**
	* Transfer `path`.
	*
	* @param {String} path
	* @api public
	*/
	SendStream.prototype.send = function send(path$48, stat) {
		var len = stat.size;
		var options = this.options;
		var opts = {};
		var res = this.res;
		var req = this.req;
		var ranges = req.headers.range;
		var offset = options.start || 0;
		if (headersSent(res)) {
			this.headersAlreadySent();
			return;
		}
		debug("pipe \"%s\"", path$48);
		this.setHeader(path$48, stat);
		this.type(path$48);
		if (this.isConditionalGET()) {
			if (this.isPreconditionFailure()) {
				this.error(412);
				return;
			}
			if (this.isCachable() && this.isFresh()) {
				this.notModified();
				return;
			}
		}
		len = Math.max(0, len - offset);
		if (options.end !== void 0) {
			var bytes = options.end - offset + 1;
			if (len > bytes) len = bytes;
		}
		if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
			ranges = parseRange(len, ranges, { combine: true });
			if (!this.isRangeFresh()) {
				debug("range stale");
				ranges = -2;
			}
			if (ranges === -1) {
				debug("range unsatisfiable");
				res.setHeader("Content-Range", contentRange("bytes", len));
				return this.error(416, { headers: { "Content-Range": res.getHeader("Content-Range") } });
			}
			if (ranges !== -2 && ranges.length === 1) {
				debug("range %j", ranges);
				res.statusCode = 206;
				res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
				offset += ranges[0].start;
				len = ranges[0].end - ranges[0].start + 1;
			}
		}
		for (var prop in options) opts[prop] = options[prop];
		opts.start = offset;
		opts.end = Math.max(offset, offset + len - 1);
		res.setHeader("Content-Length", len);
		if (req.method === "HEAD") {
			res.end();
			return;
		}
		this.stream(path$48, opts);
	};
	/**
	* Transfer file for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendFile = function sendFile(path$49) {
		var i = 0;
		var self = this;
		debug("stat \"%s\"", path$49);
		fs$7.stat(path$49, function onstat(err, stat) {
			if (err && err.code === "ENOENT" && !extname(path$49) && path$49[path$49.length - 1] !== sep) return next(err);
			if (err) return self.onStatError(err);
			if (stat.isDirectory()) return self.redirect(path$49);
			self.emit("file", path$49, stat);
			self.send(path$49, stat);
		});
		function next(err) {
			if (self._extensions.length <= i) return err ? self.onStatError(err) : self.error(404);
			var p = path$49 + "." + self._extensions[i++];
			debug("stat \"%s\"", p);
			fs$7.stat(p, function(err, stat) {
				if (err) return next(err);
				if (stat.isDirectory()) return next();
				self.emit("file", p, stat);
				self.send(p, stat);
			});
		}
	};
	/**
	* Transfer index for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendIndex = function sendIndex(path$50) {
		var i = -1;
		var self = this;
		function next(err) {
			if (++i >= self._index.length) {
				if (err) return self.onStatError(err);
				return self.error(404);
			}
			var p = join(path$50, self._index[i]);
			debug("stat \"%s\"", p);
			fs$7.stat(p, function(err, stat) {
				if (err) return next(err);
				if (stat.isDirectory()) return next();
				self.emit("file", p, stat);
				self.send(p, stat);
			});
		}
		next();
	};
	/**
	* Stream `path` to the response.
	*
	* @param {String} path
	* @param {Object} options
	* @api private
	*/
	SendStream.prototype.stream = function stream(path$51, options) {
		var self = this;
		var res = this.res;
		var stream = fs$7.createReadStream(path$51, options);
		this.emit("stream", stream);
		stream.pipe(res);
		function cleanup() {
			destroy(stream, true);
		}
		onFinished(res, cleanup);
		stream.on("error", function onerror(err) {
			cleanup();
			self.onStatError(err);
		});
		stream.on("end", function onend() {
			self.emit("end");
		});
	};
	/**
	* Set content-type based on `path`
	* if it hasn't been explicitly set.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.type = function type(path$52) {
		var res = this.res;
		if (res.getHeader("Content-Type")) return;
		var type = mime.lookup(path$52);
		if (!type) {
			debug("no content-type");
			return;
		}
		var charset = mime.charsets.lookup(type);
		debug("content-type %s", type);
		res.setHeader("Content-Type", type + (charset ? "; charset=" + charset : ""));
	};
	/**
	* Set response header fields, most
	* fields may be pre-defined.
	*
	* @param {String} path
	* @param {Object} stat
	* @api private
	*/
	SendStream.prototype.setHeader = function setHeader(path$53, stat) {
		var res = this.res;
		this.emit("headers", res, path$53, stat);
		if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
			debug("accept ranges");
			res.setHeader("Accept-Ranges", "bytes");
		}
		if (this._cacheControl && !res.getHeader("Cache-Control")) {
			var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
			if (this._immutable) cacheControl += ", immutable";
			debug("cache-control %s", cacheControl);
			res.setHeader("Cache-Control", cacheControl);
		}
		if (this._lastModified && !res.getHeader("Last-Modified")) {
			var modified = stat.mtime.toUTCString();
			debug("modified %s", modified);
			res.setHeader("Last-Modified", modified);
		}
		if (this._etag && !res.getHeader("ETag")) {
			var val = etag(stat);
			debug("etag %s", val);
			res.setHeader("ETag", val);
		}
	};
	/**
	* Clear all headers from a response.
	*
	* @param {object} res
	* @private
	*/
	function clearHeaders(res) {
		var headers = getHeaderNames(res);
		for (var i = 0; i < headers.length; i++) res.removeHeader(headers[i]);
	}
	/**
	* Collapse all leading slashes into a single slash
	*
	* @param {string} str
	* @private
	*/
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str[i] !== "/") break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	/**
	* Determine if path parts contain a dotfile.
	*
	* @api private
	*/
	function containsDotFile(parts) {
		for (var i = 0; i < parts.length; i++) {
			var part = parts[i];
			if (part.length > 1 && part[0] === ".") return true;
		}
		return false;
	}
	/**
	* Create a Content-Range header.
	*
	* @param {string} type
	* @param {number} size
	* @param {array} [range]
	*/
	function contentRange(type, size, range) {
		return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a HttpError object from simple arguments.
	*
	* @param {number} status
	* @param {Error|object} err
	* @private
	*/
	function createHttpError(status, err) {
		if (!err) return createError(status);
		return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
	}
	/**
	* decodeURIComponent.
	*
	* Allows V8 to only deoptimize this fn instead of all
	* of send().
	*
	* @param {String} path
	* @api private
	*/
	function decode(path$54) {
		try {
			return decodeURIComponent(path$54);
		} catch (err) {
			return -1;
		}
	}
	/**
	* Get the header names on a respnse.
	*
	* @param {object} res
	* @returns {array[string]}
	* @private
	*/
	function getHeaderNames(res) {
		return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
	}
	/**
	* Determine if emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function hasListeners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res) {
		return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
	}
	/**
	* Normalize the index option into an array.
	*
	* @param {boolean|string|array} val
	* @param {string} name
	* @private
	*/
	function normalizeList(val, name) {
		var list = [].concat(val || []);
		for (var i = 0; i < list.length; i++) if (typeof list[i] !== "string") throw new TypeError(name + " must be array of strings or false");
		return list;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate(date) {
		var timestamp = date && Date.parse(date);
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				if (start !== end) list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		if (start !== end) list.push(str.substring(start, end));
		return list;
	}
	/**
	* Set an object of headers on a response.
	*
	* @param {object} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res, headers) {
		var keys = Object.keys(headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			res.setHeader(key, headers[key]);
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js
/*!
* forwarded
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_forwarded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = forwarded;
	/**
	* Get all addresses in the request, using the `X-Forwarded-For` header.
	*
	* @param {object} req
	* @return {array}
	* @public
	*/
	function forwarded(req) {
		if (!req) throw new TypeError("argument req is required");
		var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
		return [getSocketAddr(req)].concat(proxyAddrs);
	}
	/**
	* Get the socket address for a request.
	*
	* @param {object} req
	* @return {string}
	* @private
	*/
	function getSocketAddr(req) {
		return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
	}
	/**
	* Parse the X-Forwarded-For header.
	*
	* @param {string} header
	* @private
	*/
	function parse(header) {
		var end = header.length;
		var list = [];
		var start = header.length;
		for (var i = header.length - 1; i >= 0; i--) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i;
				break;
			case 44:
				if (start !== end) list.push(header.substring(start, end));
				start = end = i;
				break;
			default:
				start = i;
				break;
		}
		if (start !== end) list.push(header.substring(start, end));
		return list;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var expandIPv6, ipaddr = {}, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root = this, zoneIndex;
		if (typeof module !== "undefined" && module !== null && module.exports) module.exports = ipaddr;
		else root["ipaddr"] = ipaddr;
		matchCIDR = function(first, second, partSize, cidrBits) {
			var part, shift;
			if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
			part = 0;
			while (cidrBits > 0) {
				shift = partSize - cidrBits;
				if (shift < 0) shift = 0;
				if (first[part] >> shift !== second[part] >> shift) return false;
				cidrBits -= partSize;
				part += 1;
			}
			return true;
		};
		ipaddr.subnetMatch = function(address, rangeList, defaultName) {
			var k, len, rangeName, rangeSubnets, subnet;
			if (defaultName == null) defaultName = "unicast";
			for (rangeName in rangeList) {
				rangeSubnets = rangeList[rangeName];
				if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [rangeSubnets];
				for (k = 0, len = rangeSubnets.length; k < len; k++) {
					subnet = rangeSubnets[k];
					if (address.kind() === subnet[0].kind()) {
						if (address.match.apply(address, subnet)) return rangeName;
					}
				}
			}
			return defaultName;
		};
		ipaddr.IPv4 = (function() {
			function IPv4(octets) {
				var k, len, octet;
				if (octets.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
				for (k = 0, len = octets.length; k < len; k++) {
					octet = octets[k];
					if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
				}
				this.octets = octets;
			}
			IPv4.prototype.kind = function() {
				return "ipv4";
			};
			IPv4.prototype.toString = function() {
				return this.octets.join(".");
			};
			IPv4.prototype.toNormalizedString = function() {
				return this.toString();
			};
			IPv4.prototype.toByteArray = function() {
				return this.octets.slice(0);
			};
			IPv4.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv4") throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
				return matchCIDR(this.octets, other.octets, 8, cidrRange);
			};
			IPv4.prototype.SpecialRanges = {
				unspecified: [[new IPv4([
					0,
					0,
					0,
					0
				]), 8]],
				broadcast: [[new IPv4([
					255,
					255,
					255,
					255
				]), 32]],
				multicast: [[new IPv4([
					224,
					0,
					0,
					0
				]), 4]],
				linkLocal: [[new IPv4([
					169,
					254,
					0,
					0
				]), 16]],
				loopback: [[new IPv4([
					127,
					0,
					0,
					0
				]), 8]],
				carrierGradeNat: [[new IPv4([
					100,
					64,
					0,
					0
				]), 10]],
				"private": [
					[new IPv4([
						10,
						0,
						0,
						0
					]), 8],
					[new IPv4([
						172,
						16,
						0,
						0
					]), 12],
					[new IPv4([
						192,
						168,
						0,
						0
					]), 16]
				],
				reserved: [
					[new IPv4([
						192,
						0,
						0,
						0
					]), 24],
					[new IPv4([
						192,
						0,
						2,
						0
					]), 24],
					[new IPv4([
						192,
						88,
						99,
						0
					]), 24],
					[new IPv4([
						198,
						51,
						100,
						0
					]), 24],
					[new IPv4([
						203,
						0,
						113,
						0
					]), 24],
					[new IPv4([
						240,
						0,
						0,
						0
					]), 4]
				]
			};
			IPv4.prototype.range = function() {
				return ipaddr.subnetMatch(this, this.SpecialRanges);
			};
			IPv4.prototype.toIPv4MappedAddress = function() {
				return ipaddr.IPv6.parse("::ffff:" + this.toString());
			};
			IPv4.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i, k, octet, stop, zeros, zerotable = {
					0: 8,
					128: 7,
					192: 6,
					224: 5,
					240: 4,
					248: 3,
					252: 2,
					254: 1,
					255: 0
				};
				cidr = 0;
				stop = false;
				for (i = k = 3; k >= 0; i = k += -1) {
					octet = this.octets[i];
					if (octet in zerotable) {
						zeros = zerotable[octet];
						if (stop && zeros !== 0) return null;
						if (zeros !== 8) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 32 - cidr;
			};
			return IPv4;
		})();
		ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
		ipv4Regexes = {
			fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
			longValue: new RegExp("^" + ipv4Part + "$", "i")
		};
		ipaddr.IPv4.parser = function(string) {
			var match, parseIntAuto = function(string) {
				if (string[0] === "0" && string[1] !== "x") return parseInt(string, 8);
				else return parseInt(string);
			}, part, shift, value;
			if (match = string.match(ipv4Regexes.fourOctet)) return (function() {
				var k, len, ref = match.slice(1, 6), results = [];
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					results.push(parseIntAuto(part));
				}
				return results;
			})();
			else if (match = string.match(ipv4Regexes.longValue)) {
				value = parseIntAuto(match[1]);
				if (value > 4294967295 || value < 0) throw new Error("ipaddr: address outside defined range");
				return (function() {
					var k, results = [];
					for (shift = k = 0; k <= 24; shift = k += 8) results.push(value >> shift & 255);
					return results;
				})().reverse();
			} else return null;
		};
		ipaddr.IPv6 = (function() {
			function IPv6(parts, zoneId) {
				var i, k, l, len, part, ref;
				if (parts.length === 16) {
					this.parts = [];
					for (i = k = 0; k <= 14; i = k += 2) this.parts.push(parts[i] << 8 | parts[i + 1]);
				} else if (parts.length === 8) this.parts = parts;
				else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
				ref = this.parts;
				for (l = 0, len = ref.length; l < len; l++) {
					part = ref[l];
					if (!(0 <= part && part <= 65535)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
				}
				if (zoneId) this.zoneId = zoneId;
			}
			IPv6.prototype.kind = function() {
				return "ipv6";
			};
			IPv6.prototype.toString = function() {
				return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
			};
			IPv6.prototype.toRFC5952String = function() {
				var bestMatchIndex, bestMatchLength, match, regex = /((^|:)(0(:|$)){2,})/g, string = this.toNormalizedString();
				bestMatchIndex = 0;
				bestMatchLength = -1;
				while (match = regex.exec(string)) if (match[0].length > bestMatchLength) {
					bestMatchIndex = match.index;
					bestMatchLength = match[0].length;
				}
				if (bestMatchLength < 0) return string;
				return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
			};
			IPv6.prototype.toByteArray = function() {
				var bytes = [], k, len, part, ref = this.parts;
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					bytes.push(part >> 8);
					bytes.push(part & 255);
				}
				return bytes;
			};
			IPv6.prototype.toNormalizedString = function() {
				var addr = (function() {
					var k, len, ref = this.parts, results = [];
					for (k = 0, len = ref.length; k < len; k++) {
						part = ref[k];
						results.push(part.toString(16));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.toFixedLengthString = function() {
				var addr = (function() {
					var k, len, ref = this.parts, results = [];
					for (k = 0, len = ref.length; k < len; k++) {
						part = ref[k];
						results.push(part.toString(16).padStart(4, "0"));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv6") throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
				return matchCIDR(this.parts, other.parts, 16, cidrRange);
			};
			IPv6.prototype.SpecialRanges = {
				unspecified: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 128],
				linkLocal: [new IPv6([
					65152,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 10],
				multicast: [new IPv6([
					65280,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 8],
				loopback: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					1
				]), 128],
				uniqueLocal: [new IPv6([
					64512,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 7],
				ipv4Mapped: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					65535,
					0,
					0
				]), 96],
				rfc6145: [new IPv6([
					0,
					0,
					0,
					0,
					65535,
					0,
					0,
					0
				]), 96],
				rfc6052: [new IPv6([
					100,
					65435,
					0,
					0,
					0,
					0,
					0,
					0
				]), 96],
				"6to4": [new IPv6([
					8194,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 16],
				teredo: [new IPv6([
					8193,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32],
				reserved: [[new IPv6([
					8193,
					3512,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32]]
			};
			IPv6.prototype.range = function() {
				return ipaddr.subnetMatch(this, this.SpecialRanges);
			};
			IPv6.prototype.isIPv4MappedAddress = function() {
				return this.range() === "ipv4Mapped";
			};
			IPv6.prototype.toIPv4Address = function() {
				var high, low, ref;
				if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
				ref = this.parts.slice(-2), high = ref[0], low = ref[1];
				return new ipaddr.IPv4([
					high >> 8,
					high & 255,
					low >> 8,
					low & 255
				]);
			};
			IPv6.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i, k, part, stop, zeros, zerotable = {
					0: 16,
					32768: 15,
					49152: 14,
					57344: 13,
					61440: 12,
					63488: 11,
					64512: 10,
					65024: 9,
					65280: 8,
					65408: 7,
					65472: 6,
					65504: 5,
					65520: 4,
					65528: 3,
					65532: 2,
					65534: 1,
					65535: 0
				};
				cidr = 0;
				stop = false;
				for (i = k = 7; k >= 0; i = k += -1) {
					part = this.parts[i];
					if (part in zerotable) {
						zeros = zerotable[part];
						if (stop && zeros !== 0) return null;
						if (zeros !== 16) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 128 - cidr;
			};
			return IPv6;
		})();
		ipv6Part = "(?:[0-9a-f]+::?)+";
		zoneIndex = "%[0-9a-z]{1,}";
		ipv6Regexes = {
			zoneIndex: new RegExp(zoneIndex, "i"),
			"native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
			transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
		};
		expandIPv6 = function(string, parts) {
			var colonCount, lastColon, part, replacement, replacementCount, zoneId;
			if (string.indexOf("::") !== string.lastIndexOf("::")) return null;
			zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
			if (zoneId) {
				zoneId = zoneId.substring(1);
				string = string.replace(/%.+$/, "");
			}
			colonCount = 0;
			lastColon = -1;
			while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) colonCount++;
			if (string.substr(0, 2) === "::") colonCount--;
			if (string.substr(-2, 2) === "::") colonCount--;
			if (colonCount > parts) return null;
			replacementCount = parts - colonCount;
			replacement = ":";
			while (replacementCount--) replacement += "0:";
			string = string.replace("::", replacement);
			if (string[0] === ":") string = string.slice(1);
			if (string[string.length - 1] === ":") string = string.slice(0, -1);
			parts = (function() {
				var k, len, ref = string.split(":"), results = [];
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					results.push(parseInt(part, 16));
				}
				return results;
			})();
			return {
				parts,
				zoneId
			};
		};
		ipaddr.IPv6.parser = function(string) {
			var addr, k, len, match, octet, octets, zoneId;
			if (ipv6Regexes["native"].test(string)) return expandIPv6(string, 8);
			else if (match = string.match(ipv6Regexes["transitional"])) {
				zoneId = match[6] || "";
				addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
				if (addr.parts) {
					octets = [
						parseInt(match[2]),
						parseInt(match[3]),
						parseInt(match[4]),
						parseInt(match[5])
					];
					for (k = 0, len = octets.length; k < len; k++) {
						octet = octets[k];
						if (!(0 <= octet && octet <= 255)) return null;
					}
					addr.parts.push(octets[0] << 8 | octets[1]);
					addr.parts.push(octets[2] << 8 | octets[3]);
					return {
						parts: addr.parts,
						zoneId: addr.zoneId
					};
				}
			}
			return null;
		};
		ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
			return this.parser(string) !== null;
		};
		ipaddr.IPv4.isValid = function(string) {
			try {
				new this(this.parser(string));
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr.IPv4.isValidFourPartDecimal = function(string) {
			if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
			else return false;
		};
		ipaddr.IPv6.isValid = function(string) {
			var addr;
			if (typeof string === "string" && string.indexOf(":") === -1) return false;
			try {
				addr = this.parser(string);
				new this(addr.parts, addr.zoneId);
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr.IPv4.parse = function(string) {
			var parts = this.parser(string);
			if (parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(parts);
		};
		ipaddr.IPv6.parse = function(string) {
			var addr = this.parser(string);
			if (addr.parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(addr.parts, addr.zoneId);
		};
		ipaddr.IPv4.parseCIDR = function(string) {
			var maskLength, match, parsed;
			if (match = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match[2]);
				if (maskLength >= 0 && maskLength <= 32) {
					parsed = [this.parse(match[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
		};
		ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
			var filledOctetCount, j, octets;
			prefix = parseInt(prefix);
			if (prefix < 0 || prefix > 32) throw new Error("ipaddr: invalid IPv4 prefix length");
			octets = [
				0,
				0,
				0,
				0
			];
			j = 0;
			filledOctetCount = Math.floor(prefix / 8);
			while (j < filledOctetCount) {
				octets[j] = 255;
				j++;
			}
			if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
			return new this(octets);
		};
		ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
			var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i = 0;
				while (i < 4) {
					octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
					i++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr.IPv4.networkAddressFromCIDR = function(string) {
			var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i = 0;
				while (i < 4) {
					octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
					i++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr.IPv6.parseCIDR = function(string) {
			var maskLength, match, parsed;
			if (match = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match[2]);
				if (maskLength >= 0 && maskLength <= 128) {
					parsed = [this.parse(match[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
		};
		ipaddr.isValid = function(string) {
			return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
		};
		ipaddr.parse = function(string) {
			if (ipaddr.IPv6.isValid(string)) return ipaddr.IPv6.parse(string);
			else if (ipaddr.IPv4.isValid(string)) return ipaddr.IPv4.parse(string);
			else throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
		};
		ipaddr.parseCIDR = function(string) {
			try {
				return ipaddr.IPv6.parseCIDR(string);
			} catch (error1) {
				try {
					return ipaddr.IPv4.parseCIDR(string);
				} catch (error1) {
					throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
				}
			}
		};
		ipaddr.fromByteArray = function(bytes) {
			var length = bytes.length;
			if (length === 4) return new ipaddr.IPv4(bytes);
			else if (length === 16) return new ipaddr.IPv6(bytes);
			else throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
		};
		ipaddr.process = function(string) {
			var addr = this.parse(string);
			if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
			else return addr;
		};
	}).call(exports);
}));

//#endregion
//#region ../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js
/*!
* proxy-addr
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_proxy_addr = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = proxyaddr;
	module.exports.all = alladdrs;
	module.exports.compile = compile;
	/**
	* Module dependencies.
	* @private
	*/
	var forwarded = require_forwarded();
	var ipaddr = require_ipaddr();
	/**
	* Variables.
	* @private
	*/
	var DIGIT_REGEXP = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;
	/**
	* Pre-defined IP ranges.
	* @private
	*/
	var IP_RANGES = {
		linklocal: ["169.254.0.0/16", "fe80::/10"],
		loopback: ["127.0.0.1/8", "::1/128"],
		uniquelocal: [
			"10.0.0.0/8",
			"172.16.0.0/12",
			"192.168.0.0/16",
			"fc00::/7"
		]
	};
	/**
	* Get all addresses in the request, optionally stopping
	* at the first untrusted.
	*
	* @param {Object} request
	* @param {Function|Array|String} [trust]
	* @public
	*/
	function alladdrs(req, trust) {
		var addrs = forwarded(req);
		if (!trust) return addrs;
		if (typeof trust !== "function") trust = compile(trust);
		for (var i = 0; i < addrs.length - 1; i++) {
			if (trust(addrs[i], i)) continue;
			addrs.length = i + 1;
		}
		return addrs;
	}
	/**
	* Compile argument into trust function.
	*
	* @param {Array|String} val
	* @private
	*/
	function compile(val) {
		if (!val) throw new TypeError("argument is required");
		var trust;
		if (typeof val === "string") trust = [val];
		else if (Array.isArray(val)) trust = val.slice();
		else throw new TypeError("unsupported trust argument");
		for (var i = 0; i < trust.length; i++) {
			val = trust[i];
			if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) continue;
			val = IP_RANGES[val];
			trust.splice.apply(trust, [i, 1].concat(val));
			i += val.length - 1;
		}
		return compileTrust(compileRangeSubnets(trust));
	}
	/**
	* Compile `arr` elements into range subnets.
	*
	* @param {Array} arr
	* @private
	*/
	function compileRangeSubnets(arr) {
		var rangeSubnets = new Array(arr.length);
		for (var i = 0; i < arr.length; i++) rangeSubnets[i] = parseipNotation(arr[i]);
		return rangeSubnets;
	}
	/**
	* Compile range subnet array into trust function.
	*
	* @param {Array} rangeSubnets
	* @private
	*/
	function compileTrust(rangeSubnets) {
		var len = rangeSubnets.length;
		return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
	}
	/**
	* Parse IP notation string into range subnet.
	*
	* @param {String} note
	* @private
	*/
	function parseipNotation(note) {
		var pos = note.lastIndexOf("/");
		var str = pos !== -1 ? note.substring(0, pos) : note;
		if (!isip(str)) throw new TypeError("invalid IP address: " + str);
		var ip = parseip(str);
		if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
		var max = ip.kind() === "ipv6" ? 128 : 32;
		var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
		if (range === null) range = max;
		else if (DIGIT_REGEXP.test(range)) range = parseInt(range, 10);
		else if (ip.kind() === "ipv4" && isip(range)) range = parseNetmask(range);
		else range = null;
		if (range <= 0 || range > max) throw new TypeError("invalid range on address: " + note);
		return [ip, range];
	}
	/**
	* Parse netmask string into CIDR range.
	*
	* @param {String} netmask
	* @private
	*/
	function parseNetmask(netmask) {
		var ip = parseip(netmask);
		return ip.kind() === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
	}
	/**
	* Determine address of proxied request.
	*
	* @param {Object} request
	* @param {Function|Array|String} trust
	* @public
	*/
	function proxyaddr(req, trust) {
		if (!req) throw new TypeError("req argument is required");
		if (!trust) throw new TypeError("trust argument is required");
		var addrs = alladdrs(req, trust);
		return addrs[addrs.length - 1];
	}
	/**
	* Static trust function to trust nothing.
	*
	* @private
	*/
	function trustNone() {
		return false;
	}
	/**
	* Compile trust function for multiple subnets.
	*
	* @param {Array} subnets
	* @private
	*/
	function trustMulti(subnets) {
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			var ipconv;
			var kind = ip.kind();
			for (var i = 0; i < subnets.length; i++) {
				var subnet = subnets[i];
				var subnetip = subnet[0];
				var subnetkind = subnetip.kind();
				var subnetrange = subnet[1];
				var trusted = ip;
				if (kind !== subnetkind) {
					if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) continue;
					if (!ipconv) ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
					trusted = ipconv;
				}
				if (trusted.match(subnetip, subnetrange)) return true;
			}
			return false;
		};
	}
	/**
	* Compile trust function for single subnet.
	*
	* @param {Object} subnet
	* @private
	*/
	function trustSingle(subnet) {
		var subnetip = subnet[0];
		var subnetkind = subnetip.kind();
		var subnetisipv4 = subnetkind === "ipv4";
		var subnetrange = subnet[1];
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			if (ip.kind() !== subnetkind) {
				if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
				ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
			}
			return ip.match(subnetip, subnetrange);
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/utils.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @api private
	*/
	var Buffer = require_safe_buffer().Buffer;
	var contentDisposition = require_content_disposition();
	var contentType = require_content_type();
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var mime = require_send().mime;
	var etag = require_etag();
	var proxyaddr = require_proxy_addr();
	var qs = require_lib();
	var querystring = require("querystring");
	/**
	* Return strong ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.etag = createETagGenerator({ weak: false });
	/**
	* Return weak ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.wetag = createETagGenerator({ weak: true });
	/**
	* Check if `path` looks absolute.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	exports.isAbsolute = function(path) {
		if ("/" === path[0]) return true;
		if (":" === path[1] && ("\\" === path[2] || "/" === path[2])) return true;
		if ("\\\\" === path.substring(0, 2)) return true;
	};
	/**
	* Flatten the given `arr`.
	*
	* @param {Array} arr
	* @return {Array}
	* @api private
	*/
	exports.flatten = deprecate.function(flatten, "utils.flatten: use array-flatten npm module instead");
	/**
	* Normalize the given `type`, for example "html" becomes "text/html".
	*
	* @param {String} type
	* @return {Object}
	* @api private
	*/
	exports.normalizeType = function(type) {
		return ~type.indexOf("/") ? acceptParams(type) : {
			value: mime.lookup(type),
			params: {}
		};
	};
	/**
	* Normalize `types`, for example "html" becomes "text/html".
	*
	* @param {Array} types
	* @return {Array}
	* @api private
	*/
	exports.normalizeTypes = function(types) {
		var ret = [];
		for (var i = 0; i < types.length; ++i) ret.push(exports.normalizeType(types[i]));
		return ret;
	};
	/**
	* Generate Content-Disposition header appropriate for the filename.
	* non-ascii filenames are urlencoded and a filename* parameter is added
	*
	* @param {String} filename
	* @return {String}
	* @api private
	*/
	exports.contentDisposition = deprecate.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
	/**
	* Parse accept params `str` returning an
	* object with `.value`, `.quality` and `.params`.
	*
	* @param {String} str
	* @return {Object}
	* @api private
	*/
	function acceptParams(str) {
		var parts = str.split(/ *; */);
		var ret = {
			value: parts[0],
			quality: 1,
			params: {}
		};
		for (var i = 1; i < parts.length; ++i) {
			var pms = parts[i].split(/ *= */);
			if ("q" === pms[0]) ret.quality = parseFloat(pms[1]);
			else ret.params[pms[0]] = pms[1];
		}
		return ret;
	}
	/**
	* Compile "etag" value to function.
	*
	* @param  {Boolean|String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileETag = function(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "weak":
				fn = exports.wetag;
				break;
			case false: break;
			case "strong":
				fn = exports.etag;
				break;
			default: throw new TypeError("unknown value for etag function: " + val);
		}
		return fn;
	};
	/**
	* Compile "query parser" value to function.
	*
	* @param  {String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileQueryParser = function compileQueryParser(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "simple":
				fn = querystring.parse;
				break;
			case false:
				fn = newObject;
				break;
			case "extended":
				fn = parseExtendedQueryString;
				break;
			default: throw new TypeError("unknown value for query parser function: " + val);
		}
		return fn;
	};
	/**
	* Compile "proxy trust" value to function.
	*
	* @param  {Boolean|String|Number|Array|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileTrust = function(val) {
		if (typeof val === "function") return val;
		if (val === true) return function() {
			return true;
		};
		if (typeof val === "number") return function(a, i) {
			return i < val;
		};
		if (typeof val === "string") val = val.split(",").map(function(v) {
			return v.trim();
		});
		return proxyaddr.compile(val || []);
	};
	/**
	* Set the charset in a given Content-Type string.
	*
	* @param {String} type
	* @param {String} charset
	* @return {String}
	* @api private
	*/
	exports.setCharset = function setCharset(type, charset) {
		if (!type || !charset) return type;
		var parsed = contentType.parse(type);
		parsed.parameters.charset = charset;
		return contentType.format(parsed);
	};
	/**
	* Create an ETag generator function, generating ETags with
	* the given options.
	*
	* @param {object} options
	* @return {function}
	* @private
	*/
	function createETagGenerator(options) {
		return function generateETag(body, encoding) {
			return etag(!Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body, options);
		};
	}
	/**
	* Parse an extended query string with qs.
	*
	* @param {String} str
	* @return {Object}
	* @private
	*/
	function parseExtendedQueryString(str) {
		return qs.parse(str, { allowPrototypes: true });
	}
	/**
	* Return new empty object.
	*
	* @return {Object}
	* @api private
	*/
	function newObject() {
		return {};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/application.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_application = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var finalhandler = require_finalhandler();
	var Router = require_router();
	var methods = require_methods();
	var middleware = require_init$1();
	var query = require_query();
	var debug = require_src()("express:application");
	var View = require_view();
	var http$4 = require("http");
	var compileETag = require_utils().compileETag;
	var compileQueryParser = require_utils().compileQueryParser;
	var compileTrust = require_utils().compileTrust;
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var merge = require_utils_merge();
	var resolve$3 = require("path").resolve;
	var setPrototypeOf = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var slice = Array.prototype.slice;
	/**
	* Application prototype.
	*/
	var app = exports = module.exports = {};
	/**
	* Variable for trust proxy inheritance back-compat
	* @private
	*/
	var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
	/**
	* Initialize the server.
	*
	*   - setup default configuration
	*   - setup default middleware
	*   - setup route reflection methods
	*
	* @private
	*/
	app.init = function init() {
		this.cache = {};
		this.engines = {};
		this.settings = {};
		this.defaultConfiguration();
	};
	/**
	* Initialize application configuration.
	* @private
	*/
	app.defaultConfiguration = function defaultConfiguration() {
		var env = process.env.NODE_ENV || "development";
		this.enable("x-powered-by");
		this.set("etag", "weak");
		this.set("env", env);
		this.set("query parser", "extended");
		this.set("subdomain offset", 2);
		this.set("trust proxy", false);
		Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
			configurable: true,
			value: true
		});
		debug("booting in %s mode", env);
		this.on("mount", function onmount(parent) {
			if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
				delete this.settings["trust proxy"];
				delete this.settings["trust proxy fn"];
			}
			setPrototypeOf(this.request, parent.request);
			setPrototypeOf(this.response, parent.response);
			setPrototypeOf(this.engines, parent.engines);
			setPrototypeOf(this.settings, parent.settings);
		});
		this.locals = Object.create(null);
		this.mountpath = "/";
		this.locals.settings = this.settings;
		this.set("view", View);
		this.set("views", resolve$3("views"));
		this.set("jsonp callback name", "callback");
		if (env === "production") this.enable("view cache");
		Object.defineProperty(this, "router", { get: function() {
			throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
		} });
	};
	/**
	* lazily adds the base router if it has not yet been added.
	*
	* We cannot add the base router in the defaultConfiguration because
	* it reads app settings which might be set after that has run.
	*
	* @private
	*/
	app.lazyrouter = function lazyrouter() {
		if (!this._router) {
			this._router = new Router({
				caseSensitive: this.enabled("case sensitive routing"),
				strict: this.enabled("strict routing")
			});
			this._router.use(query(this.get("query parser fn")));
			this._router.use(middleware.init(this));
		}
	};
	/**
	* Dispatch a req, res pair into the application. Starts pipeline processing.
	*
	* If no callback is provided, then default error handlers will respond
	* in the event of an error bubbling through the stack.
	*
	* @private
	*/
	app.handle = function handle(req, res, callback) {
		var router = this._router;
		var done = callback || finalhandler(req, res, {
			env: this.get("env"),
			onerror: logerror.bind(this)
		});
		if (!router) {
			debug("no routes defined on app");
			done();
			return;
		}
		router.handle(req, res, done);
	};
	/**
	* Proxy `Router#use()` to add middleware to the app router.
	* See Router#use() documentation for details.
	*
	* If the _fn_ parameter is an express app, then it will be
	* mounted at the _route_ specified.
	*
	* @public
	*/
	app.use = function use(fn) {
		var offset = 0;
		var path$38 = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path$38 = fn;
			}
		}
		var fns = flatten(slice.call(arguments, offset));
		if (fns.length === 0) throw new TypeError("app.use() requires a middleware function");
		this.lazyrouter();
		var router = this._router;
		fns.forEach(function(fn) {
			if (!fn || !fn.handle || !fn.set) return router.use(path$38, fn);
			debug(".use app under %s", path$38);
			fn.mountpath = path$38;
			fn.parent = this;
			router.use(path$38, function mounted_app(req, res, next) {
				var orig = req.app;
				fn.handle(req, res, function(err) {
					setPrototypeOf(req, orig.request);
					setPrototypeOf(res, orig.response);
					next(err);
				});
			});
			fn.emit("mount", this);
		}, this);
		return this;
	};
	/**
	* Proxy to the app `Router#route()`
	* Returns a new `Route` instance for the _path_.
	*
	* Routes are isolated middleware stacks for specific paths.
	* See the Route api docs for details.
	*
	* @public
	*/
	app.route = function route(path$39) {
		this.lazyrouter();
		return this._router.route(path$39);
	};
	/**
	* Register the given template engine callback `fn`
	* as `ext`.
	*
	* By default will `require()` the engine based on the
	* file extension. For example if you try to render
	* a "foo.ejs" file Express will invoke the following internally:
	*
	*     app.engine('ejs', require('ejs').__express);
	*
	* For engines that do not provide `.__express` out of the box,
	* or if you wish to "map" a different extension to the template engine
	* you may use this method. For example mapping the EJS template engine to
	* ".html" files:
	*
	*     app.engine('html', require('ejs').renderFile);
	*
	* In this case EJS provides a `.renderFile()` method with
	* the same signature that Express expects: `(path, options, callback)`,
	* though note that it aliases this method as `ejs.__express` internally
	* so if you're using ".ejs" extensions you don't need to do anything.
	*
	* Some template engines do not follow this convention, the
	* [Consolidate.js](https://github.com/tj/consolidate.js)
	* library was created to map all of node's popular template
	* engines to follow this convention, thus allowing them to
	* work seamlessly within Express.
	*
	* @param {String} ext
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.engine = function engine(ext, fn) {
		if (typeof fn !== "function") throw new Error("callback function required");
		var extension = ext[0] !== "." ? "." + ext : ext;
		this.engines[extension] = fn;
		return this;
	};
	/**
	* Proxy to `Router#param()` with one added api feature. The _name_ parameter
	* can be an array of names.
	*
	* See the Router#param() docs for more details.
	*
	* @param {String|Array} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.param = function param(name, fn) {
		this.lazyrouter();
		if (Array.isArray(name)) {
			for (var i = 0; i < name.length; i++) this.param(name[i], fn);
			return this;
		}
		this._router.param(name, fn);
		return this;
	};
	/**
	* Assign `setting` to `val`, or return `setting`'s value.
	*
	*    app.set('foo', 'bar');
	*    app.set('foo');
	*    // => "bar"
	*
	* Mounted servers inherit their parent server's settings.
	*
	* @param {String} setting
	* @param {*} [val]
	* @return {Server} for chaining
	* @public
	*/
	app.set = function set(setting, val) {
		if (arguments.length === 1) {
			var settings = this.settings;
			while (settings && settings !== Object.prototype) {
				if (hasOwnProperty.call(settings, setting)) return settings[setting];
				settings = Object.getPrototypeOf(settings);
			}
			return;
		}
		debug("set \"%s\" to %o", setting, val);
		this.settings[setting] = val;
		switch (setting) {
			case "etag":
				this.set("etag fn", compileETag(val));
				break;
			case "query parser":
				this.set("query parser fn", compileQueryParser(val));
				break;
			case "trust proxy":
				this.set("trust proxy fn", compileTrust(val));
				Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
					configurable: true,
					value: false
				});
				break;
		}
		return this;
	};
	/**
	* Return the app's absolute pathname
	* based on the parent(s) that have
	* mounted it.
	*
	* For example if the application was
	* mounted as "/admin", which itself
	* was mounted as "/blog" then the
	* return value would be "/blog/admin".
	*
	* @return {String}
	* @private
	*/
	app.path = function path$40() {
		return this.parent ? this.parent.path() + this.mountpath : "";
	};
	/**
	* Check if `setting` is enabled (truthy).
	*
	*    app.enabled('foo')
	*    // => false
	*
	*    app.enable('foo')
	*    app.enabled('foo')
	*    // => true
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.enabled = function enabled(setting) {
		return Boolean(this.set(setting));
	};
	/**
	* Check if `setting` is disabled.
	*
	*    app.disabled('foo')
	*    // => true
	*
	*    app.enable('foo')
	*    app.disabled('foo')
	*    // => false
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.disabled = function disabled(setting) {
		return !this.set(setting);
	};
	/**
	* Enable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.enable = function enable(setting) {
		return this.set(setting, true);
	};
	/**
	* Disable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.disable = function disable(setting) {
		return this.set(setting, false);
	};
	/**
	* Delegate `.VERB(...)` calls to `router.VERB(...)`.
	*/
	methods.forEach(function(method) {
		app[method] = function(path$41) {
			if (method === "get" && arguments.length === 1) return this.set(path$41);
			this.lazyrouter();
			var route = this._router.route(path$41);
			route[method].apply(route, slice.call(arguments, 1));
			return this;
		};
	});
	/**
	* Special-cased "all" method, applying the given route `path`,
	* middleware, and callback to _every_ HTTP method.
	*
	* @param {String} path
	* @param {Function} ...
	* @return {app} for chaining
	* @public
	*/
	app.all = function all(path$42) {
		this.lazyrouter();
		var route = this._router.route(path$42);
		var args = slice.call(arguments, 1);
		for (var i = 0; i < methods.length; i++) route[methods[i]].apply(route, args);
		return this;
	};
	app.del = deprecate.function(app.delete, "app.del: Use app.delete instead");
	/**
	* Render the given view `name` name with `options`
	* and a callback accepting an error and the
	* rendered template string.
	*
	* Example:
	*
	*    app.render('email', { name: 'Tobi' }, function(err, html){
	*      // ...
	*    })
	*
	* @param {String} name
	* @param {Object|Function} options or fn
	* @param {Function} callback
	* @public
	*/
	app.render = function render(name, options, callback) {
		var cache = this.cache;
		var done = callback;
		var engines = this.engines;
		var opts = options;
		var renderOptions = {};
		var view;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		merge(renderOptions, this.locals);
		if (opts._locals) merge(renderOptions, opts._locals);
		merge(renderOptions, opts);
		if (renderOptions.cache == null) renderOptions.cache = this.enabled("view cache");
		if (renderOptions.cache) view = cache[name];
		if (!view) {
			view = new (this.get("view"))(name, {
				defaultEngine: this.get("view engine"),
				root: this.get("views"),
				engines
			});
			if (!view.path) {
				var dirs = Array.isArray(view.root) && view.root.length > 1 ? "directories \"" + view.root.slice(0, -1).join("\", \"") + "\" or \"" + view.root[view.root.length - 1] + "\"" : "directory \"" + view.root + "\"";
				var err = /* @__PURE__ */ new Error("Failed to lookup view \"" + name + "\" in views " + dirs);
				err.view = view;
				return done(err);
			}
			if (renderOptions.cache) cache[name] = view;
		}
		tryRender(view, renderOptions, done);
	};
	/**
	* Listen for connections.
	*
	* A node `http.Server` is returned, with this
	* application (which is a `Function`) as its
	* callback. If you wish to create both an HTTP
	* and HTTPS server you may do so with the "http"
	* and "https" modules as shown here:
	*
	*    var http = require('http')
	*      , https = require('https')
	*      , express = require('express')
	*      , app = express();
	*
	*    http.createServer(app).listen(80);
	*    https.createServer({ ... }, app).listen(443);
	*
	* @return {http.Server}
	* @public
	*/
	app.listen = function listen() {
		var server = http$4.createServer(this);
		return server.listen.apply(server, arguments);
	};
	/**
	* Log error using console.error.
	*
	* @param {Error} err
	* @private
	*/
	function logerror(err) {
		/* istanbul ignore next */
		if (this.get("env") !== "test") console.error(err.stack || err.toString());
	}
	/**
	* Try rendering a view.
	* @private
	*/
	function tryRender(view, options, callback) {
		try {
			view.render(options, callback);
		} catch (err) {
			callback(err);
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_charset = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;
	/**
	* Module variables.
	* @private
	*/
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Charset header.
	* @private
	*/
	function parseAcceptCharset(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var charset = parseCharset(accepts[i].trim(), i);
			if (charset) accepts[j++] = charset;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a charset from the Accept-Charset header.
	* @private
	*/
	function parseCharset(str, i) {
		var match = simpleCharsetRegExp.exec(str);
		if (!match) return null;
		var charset = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			charset,
			q,
			i
		};
	}
	/**
	* Get the priority of a charset.
	* @private
	*/
	function getCharsetPriority(charset, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(charset, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the charset.
	* @private
	*/
	function specify(charset, spec, index) {
		var s = 0;
		if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
		else if (spec.charset !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred charsets from an Accept-Charset header.
	* @public
	*/
	function preferredCharsets(accept, provided) {
		var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
		var priorities = provided.map(function getPriority(type, index) {
			return getCharsetPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full charset string.
	* @private
	*/
	function getFullCharset(spec) {
		return spec.charset;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;
	/**
	* Module variables.
	* @private
	*/
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Encoding header.
	* @private
	*/
	function parseAcceptEncoding(accept) {
		var accepts = accept.split(",");
		var hasIdentity = false;
		var minQuality = 1;
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var encoding = parseEncoding(accepts[i].trim(), i);
			if (encoding) {
				accepts[j++] = encoding;
				hasIdentity = hasIdentity || specify("identity", encoding);
				minQuality = Math.min(minQuality, encoding.q || 1);
			}
		}
		if (!hasIdentity) accepts[j++] = {
			encoding: "identity",
			q: minQuality,
			i
		};
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse an encoding from the Accept-Encoding header.
	* @private
	*/
	function parseEncoding(str, i) {
		var match = simpleEncodingRegExp.exec(str);
		if (!match) return null;
		var encoding = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			encoding,
			q,
			i
		};
	}
	/**
	* Get the priority of an encoding.
	* @private
	*/
	function getEncodingPriority(encoding, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(encoding, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the encoding.
	* @private
	*/
	function specify(encoding, spec, index) {
		var s = 0;
		if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
		else if (spec.encoding !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred encodings from an Accept-Encoding header.
	* @public
	*/
	function preferredEncodings(accept, provided) {
		var accepts = parseAcceptEncoding(accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
		var priorities = provided.map(function getPriority(type, index) {
			return getEncodingPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full encoding string.
	* @private
	*/
	function getFullEncoding(spec) {
		return spec.encoding;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_language = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;
	/**
	* Module variables.
	* @private
	*/
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Language header.
	* @private
	*/
	function parseAcceptLanguage(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var language = parseLanguage(accepts[i].trim(), i);
			if (language) accepts[j++] = language;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a language from the Accept-Language header.
	* @private
	*/
	function parseLanguage(str, i) {
		var match = simpleLanguageRegExp.exec(str);
		if (!match) return null;
		var prefix = match[1];
		var suffix = match[2];
		var full = prefix;
		if (suffix) full += "-" + suffix;
		var q = 1;
		if (match[3]) {
			var params = match[3].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].split("=");
				if (p[0] === "q") q = parseFloat(p[1]);
			}
		}
		return {
			prefix,
			suffix,
			q,
			i,
			full
		};
	}
	/**
	* Get the priority of a language.
	* @private
	*/
	function getLanguagePriority(language, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(language, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the language.
	* @private
	*/
	function specify(language, spec, index) {
		var p = parseLanguage(language);
		if (!p) return null;
		var s = 0;
		if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
		else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
		else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
		else if (spec.full !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred languages from an Accept-Language header.
	* @public
	*/
	function preferredLanguages(accept, provided) {
		var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
		var priorities = provided.map(function getPriority(type, index) {
			return getLanguagePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full language string.
	* @private
	*/
	function getFullLanguage(spec) {
		return spec.full;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_mediaType = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;
	/**
	* Module variables.
	* @private
	*/
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept header.
	* @private
	*/
	function parseAccept(accept) {
		var accepts = splitMediaTypes(accept);
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var mediaType = parseMediaType(accepts[i].trim(), i);
			if (mediaType) accepts[j++] = mediaType;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a media type from the Accept header.
	* @private
	*/
	function parseMediaType(str, i) {
		var match = simpleMediaTypeRegExp.exec(str);
		if (!match) return null;
		var params = Object.create(null);
		var q = 1;
		var subtype = match[2];
		var type = match[1];
		if (match[3]) {
			var kvps = splitParameters(match[3]).map(splitKeyValuePair);
			for (var j = 0; j < kvps.length; j++) {
				var pair = kvps[j];
				var key = pair[0].toLowerCase();
				var val = pair[1];
				var value = val && val[0] === "\"" && val[val.length - 1] === "\"" ? val.substr(1, val.length - 2) : val;
				if (key === "q") {
					q = parseFloat(value);
					break;
				}
				params[key] = value;
			}
		}
		return {
			type,
			subtype,
			params,
			q,
			i
		};
	}
	/**
	* Get the priority of a media type.
	* @private
	*/
	function getMediaTypePriority(type, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(type, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the media type.
	* @private
	*/
	function specify(type, spec, index) {
		var p = parseMediaType(type);
		var s = 0;
		if (!p) return null;
		if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
		else if (spec.type != "*") return null;
		if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
		else if (spec.subtype != "*") return null;
		var keys = Object.keys(spec.params);
		if (keys.length > 0) if (keys.every(function(k) {
			return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
		})) s |= 1;
		else return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred media types from an Accept header.
	* @public
	*/
	function preferredMediaTypes(accept, provided) {
		var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
		var priorities = provided.map(function getPriority(type, index) {
			return getMediaTypePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full type string.
	* @private
	*/
	function getFullType(spec) {
		return spec.type + "/" + spec.subtype;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
	/**
	* Count the number of quotes in a string.
	* @private
	*/
	function quoteCount(string) {
		var count = 0;
		var index = 0;
		while ((index = string.indexOf("\"", index)) !== -1) {
			count++;
			index++;
		}
		return count;
	}
	/**
	* Split a key value pair.
	* @private
	*/
	function splitKeyValuePair(str) {
		var index = str.indexOf("=");
		var key;
		var val;
		if (index === -1) key = str;
		else {
			key = str.substr(0, index);
			val = str.substr(index + 1);
		}
		return [key, val];
	}
	/**
	* Split an Accept header into media types.
	* @private
	*/
	function splitMediaTypes(accept) {
		var accepts = accept.split(",");
		for (var i = 1, j = 0; i < accepts.length; i++) if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
		else accepts[j] += "," + accepts[i];
		accepts.length = j + 1;
		return accepts;
	}
	/**
	* Split a string of parameters.
	* @private
	*/
	function splitParameters(str) {
		var parameters = str.split(";");
		for (var i = 1, j = 0; i < parameters.length; i++) if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
		else parameters[j] += ";" + parameters[i];
		parameters.length = j + 1;
		for (var i = 0; i < parameters.length; i++) parameters[i] = parameters[i].trim();
		return parameters;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js
/*!
* negotiator
* Copyright(c) 2012 Federico Romero
* Copyright(c) 2012-2014 Isaac Z. Schlueter
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_negotiator = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var preferredCharsets = require_charset();
	var preferredEncodings = require_encoding();
	var preferredLanguages = require_language();
	var preferredMediaTypes = require_mediaType();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;
	/**
	* Create a Negotiator instance from a request.
	* @param {object} request
	* @public
	*/
	function Negotiator(request) {
		if (!(this instanceof Negotiator)) return new Negotiator(request);
		this.request = request;
	}
	Negotiator.prototype.charset = function charset(available) {
		var set = this.charsets(available);
		return set && set[0];
	};
	Negotiator.prototype.charsets = function charsets(available) {
		return preferredCharsets(this.request.headers["accept-charset"], available);
	};
	Negotiator.prototype.encoding = function encoding(available) {
		var set = this.encodings(available);
		return set && set[0];
	};
	Negotiator.prototype.encodings = function encodings(available) {
		return preferredEncodings(this.request.headers["accept-encoding"], available);
	};
	Negotiator.prototype.language = function language(available) {
		var set = this.languages(available);
		return set && set[0];
	};
	Negotiator.prototype.languages = function languages(available) {
		return preferredLanguages(this.request.headers["accept-language"], available);
	};
	Negotiator.prototype.mediaType = function mediaType(available) {
		var set = this.mediaTypes(available);
		return set && set[0];
	};
	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
		return preferredMediaTypes(this.request.headers.accept, available);
	};
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}));

//#endregion
//#region ../../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js
/*!
* accepts
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_accepts = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Negotiator = require_negotiator();
	var mime = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Accepts;
	/**
	* Create a new Accepts object for the given req.
	*
	* @param {object} req
	* @public
	*/
	function Accepts(req) {
		if (!(this instanceof Accepts)) return new Accepts(req);
		this.headers = req.headers;
		this.negotiator = new Negotiator(req);
	}
	/**
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single mime type string
	* such as "application/json", the extension name
	* such as "json" or an array `["json", "html", "text/plain"]`. When a list
	* or array is given the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     this.types('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     this.types('html');
	*     // => "html"
	*     this.types('text/html');
	*     // => "text/html"
	*     this.types('json', 'text');
	*     // => "json"
	*     this.types('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     this.types('image/png');
	*     this.types('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     this.types(['html', 'json']);
	*     this.types('html', 'json');
	*     // => "json"
	*
	* @param {String|Array} types...
	* @return {String|Array|Boolean}
	* @public
	*/
	Accepts.prototype.type = Accepts.prototype.types = function(types_) {
		var types = types_;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i];
		}
		if (!types || types.length === 0) return this.negotiator.mediaTypes();
		if (!this.headers.accept) return types[0];
		var mimes = types.map(extToMime);
		var first = this.negotiator.mediaTypes(mimes.filter(validMime))[0];
		return first ? types[mimes.indexOf(first)] : false;
	};
	/**
	* Return accepted encodings or best fit based on `encodings`.
	*
	* Given `Accept-Encoding: gzip, deflate`
	* an array sorted by quality is returned:
	*
	*     ['gzip', 'deflate']
	*
	* @param {String|Array} encodings...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
		var encodings = encodings_;
		if (encodings && !Array.isArray(encodings)) {
			encodings = new Array(arguments.length);
			for (var i = 0; i < encodings.length; i++) encodings[i] = arguments[i];
		}
		if (!encodings || encodings.length === 0) return this.negotiator.encodings();
		return this.negotiator.encodings(encodings)[0] || false;
	};
	/**
	* Return accepted charsets or best fit based on `charsets`.
	*
	* Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	* an array sorted by quality is returned:
	*
	*     ['utf-8', 'utf-7', 'iso-8859-1']
	*
	* @param {String|Array} charsets...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
		var charsets = charsets_;
		if (charsets && !Array.isArray(charsets)) {
			charsets = new Array(arguments.length);
			for (var i = 0; i < charsets.length; i++) charsets[i] = arguments[i];
		}
		if (!charsets || charsets.length === 0) return this.negotiator.charsets();
		return this.negotiator.charsets(charsets)[0] || false;
	};
	/**
	* Return accepted languages or best fit based on `langs`.
	*
	* Given `Accept-Language: en;q=0.8, es, pt`
	* an array sorted by quality is returned:
	*
	*     ['es', 'pt', 'en']
	*
	* @param {String|Array} langs...
	* @return {Array|String}
	* @public
	*/
	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
		var languages = languages_;
		if (languages && !Array.isArray(languages)) {
			languages = new Array(arguments.length);
			for (var i = 0; i < languages.length; i++) languages[i] = arguments[i];
		}
		if (!languages || languages.length === 0) return this.negotiator.languages();
		return this.negotiator.languages(languages)[0] || false;
	};
	/**
	* Convert extnames to mime.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function extToMime(type) {
		return type.indexOf("/") === -1 ? mime.lookup(type) : type;
	}
	/**
	* Check if mime is valid.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function validMime(type) {
		return typeof type === "string";
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/request.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var accepts = require_accepts();
	var deprecate = require_depd()("express");
	var isIP = require("net").isIP;
	var typeis = require_type_is();
	var http$3 = require("http");
	var fresh = require_fresh();
	var parseRange = require_range_parser();
	var parse = require_parseurl();
	var proxyaddr = require_proxy_addr();
	/**
	* Request prototype.
	* @public
	*/
	var req = Object.create(http$3.IncomingMessage.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = req;
	/**
	* Return request header.
	*
	* The `Referrer` header field is special-cased,
	* both `Referrer` and `Referer` are interchangeable.
	*
	* Examples:
	*
	*     req.get('Content-Type');
	*     // => "text/plain"
	*
	*     req.get('content-type');
	*     // => "text/plain"
	*
	*     req.get('Something');
	*     // => undefined
	*
	* Aliased as `req.header()`.
	*
	* @param {String} name
	* @return {String}
	* @public
	*/
	req.get = req.header = function header(name) {
		if (!name) throw new TypeError("name argument is required to req.get");
		if (typeof name !== "string") throw new TypeError("name must be a string to req.get");
		var lc = name.toLowerCase();
		switch (lc) {
			case "referer":
			case "referrer": return this.headers.referrer || this.headers.referer;
			default: return this.headers[lc];
		}
	};
	/**
	* To do: update docs.
	*
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single MIME type string
	* such as "application/json", an extension name
	* such as "json", a comma-delimited list such as "json, html, text/plain",
	* an argument list such as `"json", "html", "text/plain"`,
	* or an array `["json", "html", "text/plain"]`. When a list
	* or array is given, the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     req.accepts('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('html');
	*     // => "html"
	*     req.accepts('text/html');
	*     // => "text/html"
	*     req.accepts('json, text');
	*     // => "json"
	*     req.accepts('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('image/png');
	*     req.accepts('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     req.accepts(['html', 'json']);
	*     req.accepts('html', 'json');
	*     req.accepts('html, json');
	*     // => "json"
	*
	* @param {String|Array} type(s)
	* @return {String|Array|Boolean}
	* @public
	*/
	req.accepts = function() {
		var accept = accepts(this);
		return accept.types.apply(accept, arguments);
	};
	/**
	* Check if the given `encoding`s are accepted.
	*
	* @param {String} ...encoding
	* @return {String|Array}
	* @public
	*/
	req.acceptsEncodings = function() {
		var accept = accepts(this);
		return accept.encodings.apply(accept, arguments);
	};
	req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
	/**
	* Check if the given `charset`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...charset
	* @return {String|Array}
	* @public
	*/
	req.acceptsCharsets = function() {
		var accept = accepts(this);
		return accept.charsets.apply(accept, arguments);
	};
	req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
	/**
	* Check if the given `lang`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...lang
	* @return {String|Array}
	* @public
	*/
	req.acceptsLanguages = function() {
		var accept = accepts(this);
		return accept.languages.apply(accept, arguments);
	};
	req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
	/**
	* Parse Range header field, capping to the given `size`.
	*
	* Unspecified ranges such as "0-" require knowledge of your resource length. In
	* the case of a byte range this is of course the total number of bytes. If the
	* Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	* and `-2` when syntactically invalid.
	*
	* When ranges are returned, the array has a "type" property which is the type of
	* range that is required (most commonly, "bytes"). Each array element is an object
	* with a "start" and "end" property for the portion of the range.
	*
	* The "combine" option can be set to `true` and overlapping & adjacent ranges
	* will be combined into a single range.
	*
	* NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	* should respond with 4 users when available, not 3.
	*
	* @param {number} size
	* @param {object} [options]
	* @param {boolean} [options.combine=false]
	* @return {number|array}
	* @public
	*/
	req.range = function range(size, options) {
		var range = this.get("Range");
		if (!range) return;
		return parseRange(size, range, options);
	};
	/**
	* Return the value of param `name` when present or `defaultValue`.
	*
	*  - Checks route placeholders, ex: _/user/:id_
	*  - Checks body params, ex: id=12, {"id":12}
	*  - Checks query string params, ex: ?id=12
	*
	* To utilize request bodies, `req.body`
	* should be an object. This can be done by using
	* the `bodyParser()` middleware.
	*
	* @param {String} name
	* @param {Mixed} [defaultValue]
	* @return {String}
	* @public
	*/
	req.param = function param(name, defaultValue) {
		var params = this.params || {};
		var body = this.body || {};
		var query = this.query || {};
		deprecate("req.param(" + (arguments.length === 1 ? "name" : "name, default") + "): Use req.params, req.body, or req.query instead");
		if (null != params[name] && params.hasOwnProperty(name)) return params[name];
		if (null != body[name]) return body[name];
		if (null != query[name]) return query[name];
		return defaultValue;
	};
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains the given mime `type`.
	*
	* Examples:
	*
	*      // With Content-Type: text/html; charset=utf-8
	*      req.is('html');
	*      req.is('text/html');
	*      req.is('text/*');
	*      // => true
	*
	*      // When Content-Type is application/json
	*      req.is('json');
	*      req.is('application/json');
	*      req.is('application/*');
	*      // => true
	*
	*      req.is('html');
	*      // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	req.is = function is(types) {
		var arr = types;
		if (!Array.isArray(types)) {
			arr = new Array(arguments.length);
			for (var i = 0; i < arr.length; i++) arr[i] = arguments[i];
		}
		return typeis(this, arr);
	};
	/**
	* Return the protocol string "http" or "https"
	* when requested with TLS. When the "trust proxy"
	* setting trusts the socket address, the
	* "X-Forwarded-Proto" header field will be trusted
	* and used if present.
	*
	* If you're running behind a reverse proxy that
	* supplies https for you this may be enabled.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "protocol", function protocol() {
		var proto = this.connection.encrypted ? "https" : "http";
		if (!this.app.get("trust proxy fn")(this.connection.remoteAddress, 0)) return proto;
		var header = this.get("X-Forwarded-Proto") || proto;
		var index = header.indexOf(",");
		return index !== -1 ? header.substring(0, index).trim() : header.trim();
	});
	/**
	* Short-hand for:
	*
	*    req.protocol === 'https'
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "secure", function secure() {
		return this.protocol === "https";
	});
	/**
	* Return the remote address from the trusted proxy.
	*
	* The is the remote address on the socket unless
	* "trust proxy" is set.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "ip", function ip() {
		var trust = this.app.get("trust proxy fn");
		return proxyaddr(this, trust);
	});
	/**
	* When "trust proxy" is set, trusted proxy addresses + client.
	*
	* For example if the value were "client, proxy1, proxy2"
	* you would receive the array `["client", "proxy1", "proxy2"]`
	* where "proxy2" is the furthest down-stream and "proxy1" and
	* "proxy2" were trusted.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req, "ips", function ips() {
		var trust = this.app.get("trust proxy fn");
		var addrs = proxyaddr.all(this, trust);
		addrs.reverse().pop();
		return addrs;
	});
	/**
	* Return subdomains as an array.
	*
	* Subdomains are the dot-separated parts of the host before the main domain of
	* the app. By default, the domain of the app is assumed to be the last two
	* parts of the host. This can be changed by setting "subdomain offset".
	*
	* For example, if the domain is "tobi.ferrets.example.com":
	* If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	* If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req, "subdomains", function subdomains() {
		var hostname = this.hostname;
		if (!hostname) return [];
		var offset = this.app.get("subdomain offset");
		return (!isIP(hostname) ? hostname.split(".").reverse() : [hostname]).slice(offset);
	});
	/**
	* Short-hand for `url.parse(req.url).pathname`.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "path", function path() {
		return parse(this).pathname;
	});
	/**
	* Parse the "Host" header field to a hostname.
	*
	* When the "trust proxy" setting trusts the socket
	* address, the "X-Forwarded-Host" header field will
	* be trusted.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "hostname", function hostname() {
		var trust = this.app.get("trust proxy fn");
		var host = this.get("X-Forwarded-Host");
		if (!host || !trust(this.connection.remoteAddress, 0)) host = this.get("Host");
		else if (host.indexOf(",") !== -1) host = host.substring(0, host.indexOf(",")).trimRight();
		if (!host) return;
		var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
		var index = host.indexOf(":", offset);
		return index !== -1 ? host.substring(0, index) : host;
	});
	defineGetter(req, "host", deprecate.function(function host() {
		return this.hostname;
	}, "req.host: Use req.hostname instead"));
	/**
	* Check if the request is fresh, aka
	* Last-Modified and/or the ETag
	* still match.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "fresh", function() {
		var method = this.method;
		var res = this.res;
		var status = res.statusCode;
		if ("GET" !== method && "HEAD" !== method) return false;
		if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
			"etag": res.get("ETag"),
			"last-modified": res.get("Last-Modified")
		});
		return false;
	});
	/**
	* Check if the request is stale, aka
	* "Last-Modified" and / or the "ETag" for the
	* resource has changed.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "stale", function stale() {
		return !this.fresh;
	});
	/**
	* Check if the request was an _XMLHttpRequest_.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "xhr", function xhr() {
		return (this.get("X-Requested-With") || "").toLowerCase() === "xmlhttprequest";
	});
	/**
	* Helper function for creating a getter on an object.
	*
	* @param {Object} obj
	* @param {String} name
	* @param {Function} getter
	* @private
	*/
	function defineGetter(obj, name, getter) {
		Object.defineProperty(obj, name, {
			configurable: true,
			enumerable: true,
			get: getter
		});
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/cookie-signature@1.0.7/node_modules/cookie-signature/index.js
var require_cookie_signature = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	*/
	var crypto = require("crypto");
	/**
	* Sign the given `val` with `secret`.
	*
	* @param {String} val
	* @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
	* @return {String}
	* @api private
	*/
	exports.sign = function(val, secret) {
		if ("string" !== typeof val) throw new TypeError("Cookie value must be provided as a string.");
		if (null == secret) throw new TypeError("Secret key must be provided.");
		return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
	};
	/**
	* Unsign and decode the given `val` with `secret`,
	* returning `false` if the signature is invalid.
	*
	* @param {String} val
	* @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
	* @return {String|Boolean}
	* @api private
	*/
	exports.unsign = function(val, secret) {
		if ("string" !== typeof val) throw new TypeError("Signed cookie string must be provided.");
		if (null == secret) throw new TypeError("Secret key must be provided.");
		var str = val.slice(0, val.lastIndexOf("."));
		return sha1(exports.sign(str, secret)) == sha1(val) ? str : false;
	};
	/**
	* Private
	*/
	function sha1(str) {
		return crypto.createHash("sha1").update(str).digest("hex");
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js
/*!
* cookie
* Copyright(c) 2012-2014 Roman Shtylman
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_cookie = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module exports.
	* @public
	*/
	exports.parse = parse;
	exports.serialize = serialize;
	/**
	* Module variables.
	* @private
	*/
	var __toString = Object.prototype.toString;
	var __hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* RegExp to match cookie-name in RFC 6265 sec 4.1.1
	* This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	* which has been replaced by the token definition in RFC 7230 appendix B.
	*
	* cookie-name       = token
	* token             = 1*tchar
	* tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	*                     "*" / "+" / "-" / "." / "^" / "_" /
	*                     "`" / "|" / "~" / DIGIT / ALPHA
	*/
	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* RegExp to match cookie-value in RFC 6265 sec 4.1.1
	*
	* cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	* cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	*                     ; US-ASCII characters excluding CTLs,
	*                     ; whitespace DQUOTE, comma, semicolon,
	*                     ; and backslash
	*/
	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
	/**
	* RegExp to match domain-value in RFC 6265 sec 4.1.1
	*
	* domain-value      = <subdomain>
	*                     ; defined in [RFC1034], Section 3.5, as
	*                     ; enhanced by [RFC1123], Section 2.1
	* <subdomain>       = <label> | <subdomain> "." <label>
	* <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	*                     Labels must be 63 characters or less.
	*                     'let-dig' not 'letter' in the first char, per RFC1123
	* <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	* <let-dig-hyp>     = <let-dig> | "-"
	* <let-dig>         = <letter> | <digit>
	* <letter>          = any one of the 52 alphabetic characters A through Z in
	*                     upper case and a through z in lower case
	* <digit>           = any one of the ten digits 0 through 9
	*
	* Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	*
	* > (Note that a leading %x2E ("."), if present, is ignored even though that
	* character is not permitted, but a trailing %x2E ("."), if present, will
	* cause the user agent to ignore the attribute.)
	*/
	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	* RegExp to match path-value in RFC 6265 sec 4.1.1
	*
	* path-value        = <any CHAR except CTLs or ";">
	* CHAR              = %x01-7F
	*                     ; defined in RFC 5234 appendix B.1
	*/
	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	/**
	* Parse a cookie header.
	*
	* Parse the given cookie header string into an object
	* The object has the various cookies as keys(names) => values
	*
	* @param {string} str
	* @param {object} [opt]
	* @return {object}
	* @public
	*/
	function parse(str, opt) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var obj = {};
		var len = str.length;
		if (len < 2) return obj;
		var dec = opt && opt.decode || decode;
		var index = 0;
		var eqIdx = 0;
		var endIdx = 0;
		do {
			eqIdx = str.indexOf("=", index);
			if (eqIdx === -1) break;
			endIdx = str.indexOf(";", index);
			if (endIdx === -1) endIdx = len;
			else if (eqIdx > endIdx) {
				index = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			var keyStartIdx = startIndex(str, index, eqIdx);
			var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
			var key = str.slice(keyStartIdx, keyEndIdx);
			if (!__hasOwnProperty.call(obj, key)) {
				var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
				var valEndIdx = endIndex(str, endIdx, valStartIdx);
				if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
					valStartIdx++;
					valEndIdx--;
				}
				obj[key] = tryDecode(str.slice(valStartIdx, valEndIdx), dec);
			}
			index = endIdx + 1;
		} while (index < len);
		return obj;
	}
	function startIndex(str, index, max) {
		do {
			var code = str.charCodeAt(index);
			if (code !== 32 && code !== 9) return index;
		} while (++index < max);
		return max;
	}
	function endIndex(str, index, min) {
		while (index > min) {
			var code = str.charCodeAt(--index);
			if (code !== 32 && code !== 9) return index + 1;
		}
		return min;
	}
	/**
	* Serialize data into a cookie header.
	*
	* Serialize a name value pair into a cookie string suitable for
	* http headers. An optional options object specifies cookie parameters.
	*
	* serialize('foo', 'bar', { httpOnly: true })
	*   => "foo=bar; httpOnly"
	*
	* @param {string} name
	* @param {string} val
	* @param {object} [opt]
	* @return {string}
	* @public
	*/
	function serialize(name, val, opt) {
		var enc = opt && opt.encode || encodeURIComponent;
		if (typeof enc !== "function") throw new TypeError("option encode is invalid");
		if (!cookieNameRegExp.test(name)) throw new TypeError("argument name is invalid");
		var value = enc(val);
		if (!cookieValueRegExp.test(value)) throw new TypeError("argument val is invalid");
		var str = name + "=" + value;
		if (!opt) return str;
		if (null != opt.maxAge) {
			var maxAge = Math.floor(opt.maxAge);
			if (!isFinite(maxAge)) throw new TypeError("option maxAge is invalid");
			str += "; Max-Age=" + maxAge;
		}
		if (opt.domain) {
			if (!domainValueRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
			str += "; Domain=" + opt.domain;
		}
		if (opt.path) {
			if (!pathValueRegExp.test(opt.path)) throw new TypeError("option path is invalid");
			str += "; Path=" + opt.path;
		}
		if (opt.expires) {
			var expires = opt.expires;
			if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError("option expires is invalid");
			str += "; Expires=" + expires.toUTCString();
		}
		if (opt.httpOnly) str += "; HttpOnly";
		if (opt.secure) str += "; Secure";
		if (opt.partitioned) str += "; Partitioned";
		if (opt.priority) switch (typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority) {
			case "low":
				str += "; Priority=Low";
				break;
			case "medium":
				str += "; Priority=Medium";
				break;
			case "high":
				str += "; Priority=High";
				break;
			default: throw new TypeError("option priority is invalid");
		}
		if (opt.sameSite) switch (typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
			case true:
				str += "; SameSite=Strict";
				break;
			case "lax":
				str += "; SameSite=Lax";
				break;
			case "strict":
				str += "; SameSite=Strict";
				break;
			case "none":
				str += "; SameSite=None";
				break;
			default: throw new TypeError("option sameSite is invalid");
		}
		return str;
	}
	/**
	* URL-decode string value. Optimized to skip native call when no %.
	*
	* @param {string} str
	* @returns {string}
	*/
	function decode(str) {
		return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
	}
	/**
	* Determine if value is a Date.
	*
	* @param {*} val
	* @private
	*/
	function isDate(val) {
		return __toString.call(val) === "[object Date]";
	}
	/**
	* Try decoding a string using a decoding function.
	*
	* @param {string} str
	* @param {function} decode
	* @private
	*/
	function tryDecode(str, decode) {
		try {
			return decode(str);
		} catch (e) {
			return str;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js
/*!
* vary
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_vary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	*/
	module.exports = vary;
	module.exports.append = append;
	/**
	* RegExp to match field-name in RFC 7230 sec 3.2
	*
	* field-name    = token
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	*/
	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* Append a field to a vary header.
	*
	* @param {String} header
	* @param {String|Array} field
	* @return {String}
	* @public
	*/
	function append(header, field) {
		if (typeof header !== "string") throw new TypeError("header argument is required");
		if (!field) throw new TypeError("field argument is required");
		var fields = !Array.isArray(field) ? parse(String(field)) : field;
		for (var j = 0; j < fields.length; j++) if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError("field argument contains an invalid header name");
		if (header === "*") return header;
		var val = header;
		var vals = parse(header.toLowerCase());
		if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) return "*";
		for (var i = 0; i < fields.length; i++) {
			var fld = fields[i].toLowerCase();
			if (vals.indexOf(fld) === -1) {
				vals.push(fld);
				val = val ? val + ", " + fields[i] : fields[i];
			}
		}
		return val;
	}
	/**
	* Parse a vary header into an array.
	*
	* @param {String} header
	* @return {Array}
	* @private
	*/
	function parse(header) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = header.length; i < len; i++) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(header.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(header.substring(start, end));
		return list;
	}
	/**
	* Mark that a request is varied on a header field.
	*
	* @param {Object} res
	* @param {String|Array} field
	* @public
	*/
	function vary(res, field) {
		if (!res || !res.getHeader || !res.setHeader) throw new TypeError("res argument is required");
		var val = res.getHeader("Vary") || "";
		if (val = append(Array.isArray(val) ? val.join(", ") : String(val), field)) res.setHeader("Vary", val);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/response.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_response = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Buffer = require_safe_buffer().Buffer;
	var contentDisposition = require_content_disposition();
	var createError = require_http_errors();
	var deprecate = require_depd()("express");
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var http$2 = require("http");
	var isAbsolute = require_utils().isAbsolute;
	var onFinished = require_on_finished();
	var path$2 = require("path");
	var statuses = require_statuses();
	var merge = require_utils_merge();
	var sign = require_cookie_signature().sign;
	var normalizeType = require_utils().normalizeType;
	var normalizeTypes = require_utils().normalizeTypes;
	var setCharset = require_utils().setCharset;
	var cookie = require_cookie();
	var send = require_send();
	var extname = path$2.extname;
	var mime = send.mime;
	var resolve = path$2.resolve;
	var vary = require_vary();
	/**
	* Response prototype.
	* @public
	*/
	var res = Object.create(http$2.ServerResponse.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = res;
	/**
	* Module variables.
	* @private
	*/
	var charsetRegExp = /;\s*charset\s*=/;
	/**
	* Set status `code`.
	*
	* @param {Number} code
	* @return {ServerResponse}
	* @public
	*/
	res.status = function status(code) {
		if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
		this.statusCode = code;
		return this;
	};
	/**
	* Set Link header field with the given `links`.
	*
	* Examples:
	*
	*    res.links({
	*      next: 'http://api.example.com/users?page=2',
	*      last: 'http://api.example.com/users?page=5'
	*    });
	*
	* @param {Object} links
	* @return {ServerResponse}
	* @public
	*/
	res.links = function(links) {
		var link = this.get("Link") || "";
		if (link) link += ", ";
		return this.set("Link", link + Object.keys(links).map(function(rel) {
			return "<" + links[rel] + ">; rel=\"" + rel + "\"";
		}).join(", "));
	};
	/**
	* Send a response.
	*
	* Examples:
	*
	*     res.send(Buffer.from('wahoo'));
	*     res.send({ some: 'json' });
	*     res.send('<p>some html</p>');
	*
	* @param {string|number|boolean|object|Buffer} body
	* @public
	*/
	res.send = function send(body) {
		var chunk = body;
		var encoding;
		var req = this.req;
		var type;
		var app = this.app;
		if (arguments.length === 2) if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
			deprecate("res.send(body, status): Use res.status(status).send(body) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.send(status, body): Use res.status(status).send(body) instead");
			this.statusCode = arguments[0];
			chunk = arguments[1];
		}
		if (typeof chunk === "number" && arguments.length === 1) {
			if (!this.get("Content-Type")) this.type("txt");
			deprecate("res.send(status): Use res.sendStatus(status) instead");
			this.statusCode = chunk;
			chunk = statuses.message[chunk];
		}
		switch (typeof chunk) {
			case "string":
				if (!this.get("Content-Type")) this.type("html");
				break;
			case "boolean":
			case "number":
			case "object":
				if (chunk === null) chunk = "";
				else if (Buffer.isBuffer(chunk)) {
					if (!this.get("Content-Type")) this.type("bin");
				} else return this.json(chunk);
				break;
		}
		if (typeof chunk === "string") {
			encoding = "utf8";
			type = this.get("Content-Type");
			if (typeof type === "string") this.set("Content-Type", setCharset(type, "utf-8"));
		}
		var etagFn = app.get("etag fn");
		var generateETag = !this.get("ETag") && typeof etagFn === "function";
		var len;
		if (chunk !== void 0) {
			if (Buffer.isBuffer(chunk)) len = chunk.length;
			else if (!generateETag && chunk.length < 1e3) len = Buffer.byteLength(chunk, encoding);
			else {
				chunk = Buffer.from(chunk, encoding);
				encoding = void 0;
				len = chunk.length;
			}
			this.set("Content-Length", len);
		}
		var etag;
		if (generateETag && len !== void 0) {
			if (etag = etagFn(chunk, encoding)) this.set("ETag", etag);
		}
		if (req.fresh) this.statusCode = 304;
		if (204 === this.statusCode || 304 === this.statusCode) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (this.statusCode === 205) {
			this.set("Content-Length", "0");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (req.method === "HEAD") this.end();
		else this.end(chunk, encoding);
		return this;
	};
	/**
	* Send JSON response.
	*
	* Examples:
	*
	*     res.json(null);
	*     res.json({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res.json = function json(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app = this.app;
		var escape = app.get("json escape");
		var replacer = app.get("json replacer");
		var spaces = app.get("json spaces");
		var body = stringify(val, replacer, spaces, escape);
		if (!this.get("Content-Type")) this.set("Content-Type", "application/json");
		return this.send(body);
	};
	/**
	* Send JSON response with JSONP callback support.
	*
	* Examples:
	*
	*     res.jsonp(null);
	*     res.jsonp({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res.jsonp = function jsonp(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app = this.app;
		var escape = app.get("json escape");
		var replacer = app.get("json replacer");
		var spaces = app.get("json spaces");
		var body = stringify(val, replacer, spaces, escape);
		var callback = this.req.query[app.get("jsonp callback name")];
		if (!this.get("Content-Type")) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "application/json");
		}
		if (Array.isArray(callback)) callback = callback[0];
		if (typeof callback === "string" && callback.length !== 0) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "text/javascript");
			callback = callback.replace(/[^\[\]\w$.]/g, "");
			if (body === void 0) body = "";
			else if (typeof body === "string") body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
			body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
		}
		return this.send(body);
	};
	/**
	* Send given HTTP status code.
	*
	* Sets the response status to `statusCode` and the body of the
	* response to the standard description from node's http.STATUS_CODES
	* or the statusCode number if no description.
	*
	* Examples:
	*
	*     res.sendStatus(200);
	*
	* @param {number} statusCode
	* @public
	*/
	res.sendStatus = function sendStatus(statusCode) {
		var body = statuses.message[statusCode] || String(statusCode);
		this.statusCode = statusCode;
		this.type("txt");
		return this.send(body);
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendFile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendFile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendFile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res.sendFile = function sendFile(path$35, options, callback) {
		var done = callback;
		var req = this.req;
		var res = this;
		var next = req.next;
		var opts = options || {};
		if (!path$35) throw new TypeError("path argument is required to res.sendFile");
		if (typeof path$35 !== "string") throw new TypeError("path must be a string to res.sendFile");
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (!opts.root && !isAbsolute(path$35)) throw new TypeError("path must be absolute or specify root to res.sendFile");
		sendfile(res, send(req, encodeURI(path$35), opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendfile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendfile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendfile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res.sendfile = function(path$36, options, callback) {
		var done = callback;
		var req = this.req;
		var res = this;
		var next = req.next;
		var opts = options || {};
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		sendfile(res, send(req, path$36, opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
	/**
	* Transfer the file at the given `path` as an attachment.
	*
	* Optionally providing an alternate attachment `filename`,
	* and optional callback `callback(err)`. The callback is invoked
	* when the data transfer is complete, or when an error has
	* occurred. Be sure to check `res.headersSent` if you plan to respond.
	*
	* Optionally providing an `options` object to use with `res.sendFile()`.
	* This function will set the `Content-Disposition` header, overriding
	* any `Content-Disposition` header passed as header options in order
	* to set the attachment and filename.
	*
	* This method uses `res.sendFile()`.
	*
	* @public
	*/
	res.download = function download(path$37, filename, options, callback) {
		var done = callback;
		var name = filename;
		var opts = options || null;
		if (typeof filename === "function") {
			done = filename;
			name = null;
			opts = null;
		} else if (typeof options === "function") {
			done = options;
			opts = null;
		}
		if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
			name = null;
			opts = filename;
		}
		var headers = { "Content-Disposition": contentDisposition(name || path$37) };
		if (opts && opts.headers) {
			var keys = Object.keys(opts.headers);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (key.toLowerCase() !== "content-disposition") headers[key] = opts.headers[key];
			}
		}
		opts = Object.create(opts);
		opts.headers = headers;
		var fullPath = !opts.root ? resolve(path$37) : path$37;
		return this.sendFile(fullPath, opts, done);
	};
	/**
	* Set _Content-Type_ response header with `type` through `mime.lookup()`
	* when it does not contain "/", or set the Content-Type to `type` otherwise.
	*
	* Examples:
	*
	*     res.type('.html');
	*     res.type('html');
	*     res.type('json');
	*     res.type('application/json');
	*     res.type('png');
	*
	* @param {String} type
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.contentType = res.type = function contentType(type) {
		var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
		return this.set("Content-Type", ct);
	};
	/**
	* Respond to the Acceptable formats using an `obj`
	* of mime-type callbacks.
	*
	* This method uses `req.accepted`, an array of
	* acceptable types ordered by their quality values.
	* When "Accept" is not present the _first_ callback
	* is invoked, otherwise the first match is used. When
	* no match is performed the server responds with
	* 406 "Not Acceptable".
	*
	* Content-Type is set for you, however if you choose
	* you may alter this within the callback using `res.type()`
	* or `res.set('Content-Type', ...)`.
	*
	*    res.format({
	*      'text/plain': function(){
	*        res.send('hey');
	*      },
	*
	*      'text/html': function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      'application/json': function () {
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* In addition to canonicalized MIME types you may
	* also use extnames mapped to these types:
	*
	*    res.format({
	*      text: function(){
	*        res.send('hey');
	*      },
	*
	*      html: function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      json: function(){
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* By default Express passes an `Error`
	* with a `.status` of 406 to `next(err)`
	* if a match is not made. If you provide
	* a `.default` callback it will be invoked
	* instead.
	*
	* @param {Object} obj
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.format = function(obj) {
		var req = this.req;
		var next = req.next;
		var keys = Object.keys(obj).filter(function(v) {
			return v !== "default";
		});
		var key = keys.length > 0 ? req.accepts(keys) : false;
		this.vary("Accept");
		if (key) {
			this.set("Content-Type", normalizeType(key).value);
			obj[key](req, this, next);
		} else if (obj.default) obj.default(req, this, next);
		else next(createError(406, { types: normalizeTypes(keys).map(function(o) {
			return o.value;
		}) }));
		return this;
	};
	/**
	* Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	*
	* @param {String} filename
	* @return {ServerResponse}
	* @public
	*/
	res.attachment = function attachment(filename) {
		if (filename) this.type(extname(filename));
		this.set("Content-Disposition", contentDisposition(filename));
		return this;
	};
	/**
	* Append additional header `field` with value `val`.
	*
	* Example:
	*
	*    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	*    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	*    res.append('Warning', '199 Miscellaneous warning');
	*
	* @param {String} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.append = function append(field, val) {
		var prev = this.get(field);
		var value = val;
		if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
		return this.set(field, value);
	};
	/**
	* Set header `field` to `val`, or pass
	* an object of header fields.
	*
	* Examples:
	*
	*    res.set('Foo', ['bar', 'baz']);
	*    res.set('Accept', 'application/json');
	*    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	*
	* Aliased as `res.header()`.
	*
	* @param {String|Object} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.set = res.header = function header(field, val) {
		if (arguments.length === 2) {
			var value = Array.isArray(val) ? val.map(String) : String(val);
			if (field.toLowerCase() === "content-type") {
				if (Array.isArray(value)) throw new TypeError("Content-Type cannot be set to an Array");
				if (!charsetRegExp.test(value)) {
					var charset = mime.charsets.lookup(value.split(";")[0]);
					if (charset) value += "; charset=" + charset.toLowerCase();
				}
			}
			this.setHeader(field, value);
		} else for (var key in field) this.set(key, field[key]);
		return this;
	};
	/**
	* Get value for header `field`.
	*
	* @param {String} field
	* @return {String}
	* @public
	*/
	res.get = function(field) {
		return this.getHeader(field);
	};
	/**
	* Clear cookie `name`.
	*
	* @param {String} name
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.clearCookie = function clearCookie(name, options) {
		if (options) {
			if (options.maxAge) deprecate("res.clearCookie: Passing \"options.maxAge\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
			if (options.expires) deprecate("res.clearCookie: Passing \"options.expires\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
		}
		var opts = merge({
			expires: /* @__PURE__ */ new Date(1),
			path: "/"
		}, options);
		return this.cookie(name, "", opts);
	};
	/**
	* Set cookie `name` to `value`, with the given `options`.
	*
	* Options:
	*
	*    - `maxAge`   max-age in milliseconds, converted to `expires`
	*    - `signed`   sign the cookie
	*    - `path`     defaults to "/"
	*
	* Examples:
	*
	*    // "Remember Me" for 15 minutes
	*    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	*
	*    // same as above
	*    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	*
	* @param {String} name
	* @param {String|Object} value
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.cookie = function(name, value, options) {
		var opts = merge({}, options);
		var secret = this.req.secret;
		var signed = opts.signed;
		if (signed && !secret) throw new Error("cookieParser(\"secret\") required for signed cookies");
		var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
		if (signed) val = "s:" + sign(val, secret);
		if (opts.maxAge != null) {
			var maxAge = opts.maxAge - 0;
			if (!isNaN(maxAge)) {
				opts.expires = new Date(Date.now() + maxAge);
				opts.maxAge = Math.floor(maxAge / 1e3);
			}
		}
		if (opts.path == null) opts.path = "/";
		this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
		return this;
	};
	/**
	* Set the location header to `url`.
	*
	* The given `url` can also be "back", which redirects
	* to the _Referrer_ or _Referer_ headers or "/".
	*
	* Examples:
	*
	*    res.location('/foo/bar').;
	*    res.location('http://example.com');
	*    res.location('../login');
	*
	* @param {String} url
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.location = function location(url) {
		var loc;
		if (url === "back") {
			deprecate("res.location(\"back\"): use res.location(req.get(\"Referrer\") || \"/\") and refer to https://dub.sh/security-redirect for best practices");
			loc = this.req.get("Referrer") || "/";
		} else loc = String(url);
		return this.set("Location", encodeUrl(loc));
	};
	/**
	* Redirect to the given `url` with optional response `status`
	* defaulting to 302.
	*
	* The resulting `url` is determined by `res.location()`, so
	* it will play nicely with mounted apps, relative paths,
	* `"back"` etc.
	*
	* Examples:
	*
	*    res.redirect('/foo/bar');
	*    res.redirect('http://example.com');
	*    res.redirect(301, 'http://example.com');
	*    res.redirect('../login'); // /blog/post/1 -> /blog/login
	*
	* @public
	*/
	res.redirect = function redirect(url) {
		var address = url;
		var body;
		var status = 302;
		if (arguments.length === 2) if (typeof arguments[0] === "number") {
			status = arguments[0];
			address = arguments[1];
		} else {
			deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
			status = arguments[1];
		}
		address = this.location(address).get("Location");
		this.format({
			text: function() {
				body = statuses.message[status] + ". Redirecting to " + address;
			},
			html: function() {
				var u = escapeHtml(address);
				body = "<p>" + statuses.message[status] + ". Redirecting to " + u + "</p>";
			},
			default: function() {
				body = "";
			}
		});
		this.statusCode = status;
		this.set("Content-Length", Buffer.byteLength(body));
		if (this.req.method === "HEAD") this.end();
		else this.end(body);
	};
	/**
	* Add `field` to Vary. If already present in the Vary set, then
	* this call is simply ignored.
	*
	* @param {Array|String} field
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.vary = function(field) {
		if (!field || Array.isArray(field) && !field.length) {
			deprecate("res.vary(): Provide a field name");
			return this;
		}
		vary(this, field);
		return this;
	};
	/**
	* Render `view` with the given `options` and optional callback `fn`.
	* When a callback function is given a response will _not_ be made
	* automatically, otherwise a response of _200_ and _text/html_ is given.
	*
	* Options:
	*
	*  - `cache`     boolean hinting to the engine it should cache
	*  - `filename`  filename of the view being rendered
	*
	* @public
	*/
	res.render = function render(view, options, callback) {
		var app = this.req.app;
		var done = callback;
		var opts = options || {};
		var req = this.req;
		var self = this;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		opts._locals = self.locals;
		done = done || function(err, str) {
			if (err) return req.next(err);
			self.send(str);
		};
		app.render(view, opts, done);
	};
	function sendfile(res, file, options, callback) {
		var done = false;
		var streaming;
		function onaborted() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("Request aborted");
			err.code = "ECONNABORTED";
			callback(err);
		}
		function ondirectory() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("EISDIR, read");
			err.code = "EISDIR";
			callback(err);
		}
		function onerror(err) {
			if (done) return;
			done = true;
			callback(err);
		}
		function onend() {
			if (done) return;
			done = true;
			callback();
		}
		function onfile() {
			streaming = false;
		}
		function onfinish(err) {
			if (err && err.code === "ECONNRESET") return onaborted();
			if (err) return onerror(err);
			if (done) return;
			setImmediate(function() {
				if (streaming !== false && !done) {
					onaborted();
					return;
				}
				if (done) return;
				done = true;
				callback();
			});
		}
		function onstream() {
			streaming = true;
		}
		file.on("directory", ondirectory);
		file.on("end", onend);
		file.on("error", onerror);
		file.on("file", onfile);
		file.on("stream", onstream);
		onFinished(res, onfinish);
		if (options.headers) file.on("headers", function headers(res) {
			var obj = options.headers;
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				var k = keys[i];
				res.setHeader(k, obj[k]);
			}
		});
		file.pipe(res);
	}
	/**
	* Stringify JSON, like JSON.stringify, but v8 optimized, with the
	* ability to escape characters that can trigger HTML sniffing.
	*
	* @param {*} value
	* @param {function} replacer
	* @param {number} spaces
	* @param {boolean} escape
	* @returns {string}
	* @private
	*/
	function stringify(value, replacer, spaces, escape) {
		var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
		if (escape && typeof json === "string") json = json.replace(/[<>&]/g, function(c) {
			switch (c.charCodeAt(0)) {
				case 60: return "\\u003c";
				case 62: return "\\u003e";
				case 38: return "\\u0026";
				default: return c;
			}
		});
		return json;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/serve-static@1.16.3/node_modules/serve-static/index.js
/*!
* serve-static
* Copyright(c) 2010 Sencha Inc.
* Copyright(c) 2011 TJ Holowaychuk
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_serve_static = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var parseUrl = require_parseurl();
	var resolve$2 = require("path").resolve;
	var send = require_send();
	var url = require("url");
	/**
	* Module exports.
	* @public
	*/
	module.exports = serveStatic;
	module.exports.mime = send.mime;
	/**
	* @param {string} root
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function serveStatic(root, options) {
		if (!root) throw new TypeError("root path required");
		if (typeof root !== "string") throw new TypeError("root path must be a string");
		var opts = Object.create(options || null);
		var fallthrough = opts.fallthrough !== false;
		var redirect = opts.redirect !== false;
		var setHeaders = opts.setHeaders;
		if (setHeaders && typeof setHeaders !== "function") throw new TypeError("option setHeaders must be function");
		opts.maxage = opts.maxage || opts.maxAge || 0;
		opts.root = resolve$2(root);
		var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
		return function serveStatic(req, res, next) {
			if (req.method !== "GET" && req.method !== "HEAD") {
				if (fallthrough) return next();
				res.statusCode = 405;
				res.setHeader("Allow", "GET, HEAD");
				res.setHeader("Content-Length", "0");
				res.end();
				return;
			}
			var forwardError = !fallthrough;
			var originalUrl = parseUrl.original(req);
			var path$34 = parseUrl(req).pathname;
			if (path$34 === "/" && originalUrl.pathname.substr(-1) !== "/") path$34 = "";
			var stream = send(req, path$34, opts);
			stream.on("directory", onDirectory);
			if (setHeaders) stream.on("headers", setHeaders);
			if (fallthrough) stream.on("file", function onFile() {
				forwardError = true;
			});
			stream.on("error", function error(err) {
				if (forwardError || !(err.statusCode < 500)) {
					next(err);
					return;
				}
				next();
			});
			stream.pipe(res);
		};
	}
	/**
	* Collapse all leading slashes into a single slash
	* @private
	*/
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str.charCodeAt(i) !== 47) break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a directory listener that just 404s.
	* @private
	*/
	function createNotFoundDirectoryListener() {
		return function notFound() {
			this.error(404);
		};
	}
	/**
	* Create a directory listener that performs a redirect.
	* @private
	*/
	function createRedirectDirectoryListener() {
		return function redirect(res) {
			if (this.hasTrailingSlash()) {
				this.error(404);
				return;
			}
			var originalUrl = parseUrl.original(this.req);
			originalUrl.path = null;
			originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
			var loc = encodeUrl(url.format(originalUrl));
			var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
			res.statusCode = 301;
			res.setHeader("Content-Type", "text/html; charset=UTF-8");
			res.setHeader("Content-Length", Buffer.byteLength(doc));
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Location", loc);
			res.end(doc);
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/lib/express.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_express$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bodyParser = require_body_parser();
	var EventEmitter$3 = require("events").EventEmitter;
	var mixin = require_merge_descriptors();
	var proto = require_application();
	var Route = require_route();
	var Router = require_router();
	var req = require_request();
	var res = require_response();
	/**
	* Expose `createApplication()`.
	*/
	exports = module.exports = createApplication;
	/**
	* Create an express application.
	*
	* @return {Function}
	* @api public
	*/
	function createApplication() {
		var app = function(req, res, next) {
			app.handle(req, res, next);
		};
		mixin(app, EventEmitter$3.prototype, false);
		mixin(app, proto, false);
		app.request = Object.create(req, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app
		} });
		app.response = Object.create(res, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app
		} });
		app.init();
		return app;
	}
	/**
	* Expose the prototypes.
	*/
	exports.application = proto;
	exports.request = req;
	exports.response = res;
	/**
	* Expose constructors.
	*/
	exports.Route = Route;
	exports.Router = Router;
	/**
	* Expose middleware
	*/
	exports.json = bodyParser.json;
	exports.query = require_query();
	exports.raw = bodyParser.raw;
	exports.static = require_serve_static();
	exports.text = bodyParser.text;
	exports.urlencoded = bodyParser.urlencoded;
	[
		"bodyParser",
		"compress",
		"cookieSession",
		"session",
		"logger",
		"cookieParser",
		"favicon",
		"responseTime",
		"errorHandler",
		"timeout",
		"methodOverride",
		"vhost",
		"csrf",
		"directory",
		"limit",
		"multipart",
		"staticCache"
	].forEach(function(name) {
		Object.defineProperty(exports, name, {
			get: function() {
				throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
			},
			configurable: true
		});
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/express@4.22.1/node_modules/express/index.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_express = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_express$1();
}));

//#endregion
//#region ../../node_modules/.pnpm/totalist@3.0.1/node_modules/totalist/sync/index.mjs
var import_express = /* @__PURE__ */ __toESM(require_express());
function totalist(dir, callback, pre = "") {
	dir = (0, path.resolve)(".", dir);
	let arr = (0, fs.readdirSync)(dir);
	let i = 0, abs, stats;
	for (; i < arr.length; i++) {
		abs = (0, path.join)(dir, arr[i]);
		stats = (0, fs.statSync)(abs);
		stats.isDirectory() ? totalist(abs, callback, (0, path.join)(pre, arr[i])) : callback((0, path.join)(pre, arr[i]), abs, stats);
	}
}

//#endregion
//#region ../../node_modules/.pnpm/@polka+url@1.0.0-next.29/node_modules/@polka/url/build.mjs
/**
* @typedef ParsedURL
* @type {import('.').ParsedURL}
*/
/**
* @typedef Request
* @property {string} url
* @property {ParsedURL} _parsedUrl
*/
/**
* @param {Request} req
* @returns {ParsedURL|void}
*/
function parse(req) {
	let raw = req.url;
	if (raw == null) return;
	let prev = req._parsedUrl;
	if (prev && prev.raw === raw) return prev;
	let pathname = raw, search = "", query, hash;
	if (raw.length > 1) {
		let idx = raw.indexOf("#", 1);
		if (idx !== -1) {
			hash = raw.substring(idx);
			pathname = raw.substring(0, idx);
		}
		idx = pathname.indexOf("?", 1);
		if (idx !== -1) {
			search = pathname.substring(idx);
			pathname = pathname.substring(0, idx);
			if (search.length > 1) query = node_querystring.parse(search.substring(1));
		}
	}
	return req._parsedUrl = {
		pathname,
		search,
		query,
		hash,
		raw
	};
}

//#endregion
//#region ../../node_modules/.pnpm/mrmime@2.0.1/node_modules/mrmime/index.mjs
const mimes = {
	"3g2": "video/3gpp2",
	"3gp": "video/3gpp",
	"3gpp": "video/3gpp",
	"3mf": "model/3mf",
	"aac": "audio/aac",
	"ac": "application/pkix-attr-cert",
	"adp": "audio/adpcm",
	"adts": "audio/aac",
	"ai": "application/postscript",
	"aml": "application/automationml-aml+xml",
	"amlx": "application/automationml-amlx+zip",
	"amr": "audio/amr",
	"apng": "image/apng",
	"appcache": "text/cache-manifest",
	"appinstaller": "application/appinstaller",
	"appx": "application/appx",
	"appxbundle": "application/appxbundle",
	"asc": "application/pgp-keys",
	"atom": "application/atom+xml",
	"atomcat": "application/atomcat+xml",
	"atomdeleted": "application/atomdeleted+xml",
	"atomsvc": "application/atomsvc+xml",
	"au": "audio/basic",
	"avci": "image/avci",
	"avcs": "image/avcs",
	"avif": "image/avif",
	"aw": "application/applixware",
	"bdoc": "application/bdoc",
	"bin": "application/octet-stream",
	"bmp": "image/bmp",
	"bpk": "application/octet-stream",
	"btf": "image/prs.btif",
	"btif": "image/prs.btif",
	"buffer": "application/octet-stream",
	"ccxml": "application/ccxml+xml",
	"cdfx": "application/cdfx+xml",
	"cdmia": "application/cdmi-capability",
	"cdmic": "application/cdmi-container",
	"cdmid": "application/cdmi-domain",
	"cdmio": "application/cdmi-object",
	"cdmiq": "application/cdmi-queue",
	"cer": "application/pkix-cert",
	"cgm": "image/cgm",
	"cjs": "application/node",
	"class": "application/java-vm",
	"coffee": "text/coffeescript",
	"conf": "text/plain",
	"cpl": "application/cpl+xml",
	"cpt": "application/mac-compactpro",
	"crl": "application/pkix-crl",
	"css": "text/css",
	"csv": "text/csv",
	"cu": "application/cu-seeme",
	"cwl": "application/cwl",
	"cww": "application/prs.cww",
	"davmount": "application/davmount+xml",
	"dbk": "application/docbook+xml",
	"deb": "application/octet-stream",
	"def": "text/plain",
	"deploy": "application/octet-stream",
	"dib": "image/bmp",
	"disposition-notification": "message/disposition-notification",
	"dist": "application/octet-stream",
	"distz": "application/octet-stream",
	"dll": "application/octet-stream",
	"dmg": "application/octet-stream",
	"dms": "application/octet-stream",
	"doc": "application/msword",
	"dot": "application/msword",
	"dpx": "image/dpx",
	"drle": "image/dicom-rle",
	"dsc": "text/prs.lines.tag",
	"dssc": "application/dssc+der",
	"dtd": "application/xml-dtd",
	"dump": "application/octet-stream",
	"dwd": "application/atsc-dwd+xml",
	"ear": "application/java-archive",
	"ecma": "application/ecmascript",
	"elc": "application/octet-stream",
	"emf": "image/emf",
	"eml": "message/rfc822",
	"emma": "application/emma+xml",
	"emotionml": "application/emotionml+xml",
	"eps": "application/postscript",
	"epub": "application/epub+zip",
	"exe": "application/octet-stream",
	"exi": "application/exi",
	"exp": "application/express",
	"exr": "image/aces",
	"ez": "application/andrew-inset",
	"fdf": "application/fdf",
	"fdt": "application/fdt+xml",
	"fits": "image/fits",
	"g3": "image/g3fax",
	"gbr": "application/rpki-ghostbusters",
	"geojson": "application/geo+json",
	"gif": "image/gif",
	"glb": "model/gltf-binary",
	"gltf": "model/gltf+json",
	"gml": "application/gml+xml",
	"gpx": "application/gpx+xml",
	"gram": "application/srgs",
	"grxml": "application/srgs+xml",
	"gxf": "application/gxf",
	"gz": "application/gzip",
	"h261": "video/h261",
	"h263": "video/h263",
	"h264": "video/h264",
	"heic": "image/heic",
	"heics": "image/heic-sequence",
	"heif": "image/heif",
	"heifs": "image/heif-sequence",
	"hej2": "image/hej2k",
	"held": "application/atsc-held+xml",
	"hjson": "application/hjson",
	"hlp": "application/winhlp",
	"hqx": "application/mac-binhex40",
	"hsj2": "image/hsj2",
	"htm": "text/html",
	"html": "text/html",
	"ics": "text/calendar",
	"ief": "image/ief",
	"ifb": "text/calendar",
	"iges": "model/iges",
	"igs": "model/iges",
	"img": "application/octet-stream",
	"in": "text/plain",
	"ini": "text/plain",
	"ink": "application/inkml+xml",
	"inkml": "application/inkml+xml",
	"ipfix": "application/ipfix",
	"iso": "application/octet-stream",
	"its": "application/its+xml",
	"jade": "text/jade",
	"jar": "application/java-archive",
	"jhc": "image/jphc",
	"jls": "image/jls",
	"jp2": "image/jp2",
	"jpe": "image/jpeg",
	"jpeg": "image/jpeg",
	"jpf": "image/jpx",
	"jpg": "image/jpeg",
	"jpg2": "image/jp2",
	"jpgm": "image/jpm",
	"jpgv": "video/jpeg",
	"jph": "image/jph",
	"jpm": "image/jpm",
	"jpx": "image/jpx",
	"js": "text/javascript",
	"json": "application/json",
	"json5": "application/json5",
	"jsonld": "application/ld+json",
	"jsonml": "application/jsonml+json",
	"jsx": "text/jsx",
	"jt": "model/jt",
	"jxl": "image/jxl",
	"jxr": "image/jxr",
	"jxra": "image/jxra",
	"jxrs": "image/jxrs",
	"jxs": "image/jxs",
	"jxsc": "image/jxsc",
	"jxsi": "image/jxsi",
	"jxss": "image/jxss",
	"kar": "audio/midi",
	"ktx": "image/ktx",
	"ktx2": "image/ktx2",
	"less": "text/less",
	"lgr": "application/lgr+xml",
	"list": "text/plain",
	"litcoffee": "text/coffeescript",
	"log": "text/plain",
	"lostxml": "application/lost+xml",
	"lrf": "application/octet-stream",
	"m1v": "video/mpeg",
	"m21": "application/mp21",
	"m2a": "audio/mpeg",
	"m2t": "video/mp2t",
	"m2ts": "video/mp2t",
	"m2v": "video/mpeg",
	"m3a": "audio/mpeg",
	"m4a": "audio/mp4",
	"m4p": "application/mp4",
	"m4s": "video/iso.segment",
	"ma": "application/mathematica",
	"mads": "application/mads+xml",
	"maei": "application/mmt-aei+xml",
	"man": "text/troff",
	"manifest": "text/cache-manifest",
	"map": "application/json",
	"mar": "application/octet-stream",
	"markdown": "text/markdown",
	"mathml": "application/mathml+xml",
	"mb": "application/mathematica",
	"mbox": "application/mbox",
	"md": "text/markdown",
	"mdx": "text/mdx",
	"me": "text/troff",
	"mesh": "model/mesh",
	"meta4": "application/metalink4+xml",
	"metalink": "application/metalink+xml",
	"mets": "application/mets+xml",
	"mft": "application/rpki-manifest",
	"mid": "audio/midi",
	"midi": "audio/midi",
	"mime": "message/rfc822",
	"mj2": "video/mj2",
	"mjp2": "video/mj2",
	"mjs": "text/javascript",
	"mml": "text/mathml",
	"mods": "application/mods+xml",
	"mov": "video/quicktime",
	"mp2": "audio/mpeg",
	"mp21": "application/mp21",
	"mp2a": "audio/mpeg",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mp4a": "audio/mp4",
	"mp4s": "application/mp4",
	"mp4v": "video/mp4",
	"mpd": "application/dash+xml",
	"mpe": "video/mpeg",
	"mpeg": "video/mpeg",
	"mpf": "application/media-policy-dataset+xml",
	"mpg": "video/mpeg",
	"mpg4": "video/mp4",
	"mpga": "audio/mpeg",
	"mpp": "application/dash-patch+xml",
	"mrc": "application/marc",
	"mrcx": "application/marcxml+xml",
	"ms": "text/troff",
	"mscml": "application/mediaservercontrol+xml",
	"msh": "model/mesh",
	"msi": "application/octet-stream",
	"msix": "application/msix",
	"msixbundle": "application/msixbundle",
	"msm": "application/octet-stream",
	"msp": "application/octet-stream",
	"mtl": "model/mtl",
	"mts": "video/mp2t",
	"musd": "application/mmt-usd+xml",
	"mxf": "application/mxf",
	"mxmf": "audio/mobile-xmf",
	"mxml": "application/xv+xml",
	"n3": "text/n3",
	"nb": "application/mathematica",
	"nq": "application/n-quads",
	"nt": "application/n-triples",
	"obj": "model/obj",
	"oda": "application/oda",
	"oga": "audio/ogg",
	"ogg": "audio/ogg",
	"ogv": "video/ogg",
	"ogx": "application/ogg",
	"omdoc": "application/omdoc+xml",
	"onepkg": "application/onenote",
	"onetmp": "application/onenote",
	"onetoc": "application/onenote",
	"onetoc2": "application/onenote",
	"opf": "application/oebps-package+xml",
	"opus": "audio/ogg",
	"otf": "font/otf",
	"owl": "application/rdf+xml",
	"oxps": "application/oxps",
	"p10": "application/pkcs10",
	"p7c": "application/pkcs7-mime",
	"p7m": "application/pkcs7-mime",
	"p7s": "application/pkcs7-signature",
	"p8": "application/pkcs8",
	"pdf": "application/pdf",
	"pfr": "application/font-tdpfr",
	"pgp": "application/pgp-encrypted",
	"pkg": "application/octet-stream",
	"pki": "application/pkixcmp",
	"pkipath": "application/pkix-pkipath",
	"pls": "application/pls+xml",
	"png": "image/png",
	"prc": "model/prc",
	"prf": "application/pics-rules",
	"provx": "application/provenance+xml",
	"ps": "application/postscript",
	"pskcxml": "application/pskc+xml",
	"pti": "image/prs.pti",
	"qt": "video/quicktime",
	"raml": "application/raml+yaml",
	"rapd": "application/route-apd+xml",
	"rdf": "application/rdf+xml",
	"relo": "application/p2p-overlay+xml",
	"rif": "application/reginfo+xml",
	"rl": "application/resource-lists+xml",
	"rld": "application/resource-lists-diff+xml",
	"rmi": "audio/midi",
	"rnc": "application/relax-ng-compact-syntax",
	"rng": "application/xml",
	"roa": "application/rpki-roa",
	"roff": "text/troff",
	"rq": "application/sparql-query",
	"rs": "application/rls-services+xml",
	"rsat": "application/atsc-rsat+xml",
	"rsd": "application/rsd+xml",
	"rsheet": "application/urc-ressheet+xml",
	"rss": "application/rss+xml",
	"rtf": "text/rtf",
	"rtx": "text/richtext",
	"rusd": "application/route-usd+xml",
	"s3m": "audio/s3m",
	"sbml": "application/sbml+xml",
	"scq": "application/scvp-cv-request",
	"scs": "application/scvp-cv-response",
	"sdp": "application/sdp",
	"senmlx": "application/senml+xml",
	"sensmlx": "application/sensml+xml",
	"ser": "application/java-serialized-object",
	"setpay": "application/set-payment-initiation",
	"setreg": "application/set-registration-initiation",
	"sgi": "image/sgi",
	"sgm": "text/sgml",
	"sgml": "text/sgml",
	"shex": "text/shex",
	"shf": "application/shf+xml",
	"shtml": "text/html",
	"sieve": "application/sieve",
	"sig": "application/pgp-signature",
	"sil": "audio/silk",
	"silo": "model/mesh",
	"siv": "application/sieve",
	"slim": "text/slim",
	"slm": "text/slim",
	"sls": "application/route-s-tsid+xml",
	"smi": "application/smil+xml",
	"smil": "application/smil+xml",
	"snd": "audio/basic",
	"so": "application/octet-stream",
	"spdx": "text/spdx",
	"spp": "application/scvp-vp-response",
	"spq": "application/scvp-vp-request",
	"spx": "audio/ogg",
	"sql": "application/sql",
	"sru": "application/sru+xml",
	"srx": "application/sparql-results+xml",
	"ssdl": "application/ssdl+xml",
	"ssml": "application/ssml+xml",
	"stk": "application/hyperstudio",
	"stl": "model/stl",
	"stpx": "model/step+xml",
	"stpxz": "model/step-xml+zip",
	"stpz": "model/step+zip",
	"styl": "text/stylus",
	"stylus": "text/stylus",
	"svg": "image/svg+xml",
	"svgz": "image/svg+xml",
	"swidtag": "application/swid+xml",
	"t": "text/troff",
	"t38": "image/t38",
	"td": "application/urc-targetdesc+xml",
	"tei": "application/tei+xml",
	"teicorpus": "application/tei+xml",
	"text": "text/plain",
	"tfi": "application/thraud+xml",
	"tfx": "image/tiff-fx",
	"tif": "image/tiff",
	"tiff": "image/tiff",
	"toml": "application/toml",
	"tr": "text/troff",
	"trig": "application/trig",
	"ts": "video/mp2t",
	"tsd": "application/timestamped-data",
	"tsv": "text/tab-separated-values",
	"ttc": "font/collection",
	"ttf": "font/ttf",
	"ttl": "text/turtle",
	"ttml": "application/ttml+xml",
	"txt": "text/plain",
	"u3d": "model/u3d",
	"u8dsn": "message/global-delivery-status",
	"u8hdr": "message/global-headers",
	"u8mdn": "message/global-disposition-notification",
	"u8msg": "message/global",
	"ubj": "application/ubjson",
	"uri": "text/uri-list",
	"uris": "text/uri-list",
	"urls": "text/uri-list",
	"vcard": "text/vcard",
	"vrml": "model/vrml",
	"vtt": "text/vtt",
	"vxml": "application/voicexml+xml",
	"war": "application/java-archive",
	"wasm": "application/wasm",
	"wav": "audio/wav",
	"weba": "audio/webm",
	"webm": "video/webm",
	"webmanifest": "application/manifest+json",
	"webp": "image/webp",
	"wgsl": "text/wgsl",
	"wgt": "application/widget",
	"wif": "application/watcherinfo+xml",
	"wmf": "image/wmf",
	"woff": "font/woff",
	"woff2": "font/woff2",
	"wrl": "model/vrml",
	"wsdl": "application/wsdl+xml",
	"wspolicy": "application/wspolicy+xml",
	"x3d": "model/x3d+xml",
	"x3db": "model/x3d+fastinfoset",
	"x3dbz": "model/x3d+binary",
	"x3dv": "model/x3d-vrml",
	"x3dvz": "model/x3d+vrml",
	"x3dz": "model/x3d+xml",
	"xaml": "application/xaml+xml",
	"xav": "application/xcap-att+xml",
	"xca": "application/xcap-caps+xml",
	"xcs": "application/calendar+xml",
	"xdf": "application/xcap-diff+xml",
	"xdssc": "application/dssc+xml",
	"xel": "application/xcap-el+xml",
	"xenc": "application/xenc+xml",
	"xer": "application/patch-ops-error+xml",
	"xfdf": "application/xfdf",
	"xht": "application/xhtml+xml",
	"xhtml": "application/xhtml+xml",
	"xhvml": "application/xv+xml",
	"xlf": "application/xliff+xml",
	"xm": "audio/xm",
	"xml": "text/xml",
	"xns": "application/xcap-ns+xml",
	"xop": "application/xop+xml",
	"xpl": "application/xproc+xml",
	"xsd": "application/xml",
	"xsf": "application/prs.xsf+xml",
	"xsl": "application/xml",
	"xslt": "application/xml",
	"xspf": "application/xspf+xml",
	"xvm": "application/xv+xml",
	"xvml": "application/xv+xml",
	"yaml": "text/yaml",
	"yang": "application/yang",
	"yin": "application/yin+xml",
	"yml": "text/yaml",
	"zip": "application/zip"
};
function lookup(extn) {
	let tmp = ("" + extn).trim().toLowerCase();
	let idx = tmp.lastIndexOf(".");
	return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

//#endregion
//#region ../../node_modules/.pnpm/sirv@3.0.2/node_modules/sirv/build.mjs
const noop = () => {};
function isMatch(uri, arr) {
	for (let i = 0; i < arr.length; i++) if (arr[i].test(uri)) return true;
}
function toAssume(uri, extns) {
	let i = 0, x, len = uri.length - 1;
	if (uri.charCodeAt(len) === 47) uri = uri.substring(0, len);
	let arr = [], tmp = `${uri}/index`;
	for (; i < extns.length; i++) {
		x = extns[i] ? `.${extns[i]}` : "";
		if (uri) arr.push(uri + x);
		arr.push(tmp + x);
	}
	return arr;
}
function viaCache(cache, uri, extns) {
	let i = 0, data, arr = toAssume(uri, extns);
	for (; i < arr.length; i++) if (data = cache[arr[i]]) return data;
}
function viaLocal(dir, isEtag, uri, extns) {
	let i = 0, arr = toAssume(uri, extns);
	let abs, stats, name, headers;
	for (; i < arr.length; i++) {
		abs = (0, node_path.normalize)((0, node_path.join)(dir, name = arr[i]));
		if (abs.startsWith(dir) && node_fs.existsSync(abs)) {
			stats = node_fs.statSync(abs);
			if (stats.isDirectory()) continue;
			headers = toHeaders(name, stats, isEtag);
			headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
			return {
				abs,
				stats,
				headers
			};
		}
	}
}
function is404(req, res) {
	return res.statusCode = 404, res.end();
}
function send(req, res, file, stats, headers) {
	let code = 200, tmp, opts = {};
	headers = { ...headers };
	for (let key in headers) {
		tmp = res.getHeader(key);
		if (tmp) headers[key] = tmp;
	}
	if (tmp = res.getHeader("content-type")) headers["Content-Type"] = tmp;
	if (req.headers.range) {
		code = 206;
		let [x, y] = req.headers.range.replace("bytes=", "").split("-");
		let end = opts.end = parseInt(y, 10) || stats.size - 1;
		let start = opts.start = parseInt(x, 10) || 0;
		if (end >= stats.size) end = stats.size - 1;
		if (start >= stats.size) {
			res.setHeader("Content-Range", `bytes */${stats.size}`);
			res.statusCode = 416;
			return res.end();
		}
		headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
		headers["Content-Length"] = end - start + 1;
		headers["Accept-Ranges"] = "bytes";
	}
	res.writeHead(code, headers);
	node_fs.createReadStream(file, opts).pipe(res);
}
const ENCODING = {
	".br": "br",
	".gz": "gzip"
};
function toHeaders(name, stats, isEtag) {
	let enc = ENCODING[name.slice(-3)];
	let ctype = lookup(name.slice(0, enc && -3)) || "";
	if (ctype === "text/html") ctype += ";charset=utf-8";
	let headers = {
		"Content-Length": stats.size,
		"Content-Type": ctype,
		"Last-Modified": stats.mtime.toUTCString()
	};
	if (enc) headers["Content-Encoding"] = enc;
	if (isEtag) headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
	return headers;
}
function build_default(dir, opts = {}) {
	dir = (0, node_path.resolve)(dir || ".");
	let isNotFound = opts.onNoMatch || is404;
	let setHeaders = opts.setHeaders || noop;
	let extensions = opts.extensions || ["html", "htm"];
	let gzips = opts.gzip && extensions.map((x) => `${x}.gz`).concat("gz");
	let brots = opts.brotli && extensions.map((x) => `${x}.br`).concat("br");
	const FILES = {};
	let fallback = "/";
	let isEtag = !!opts.etag;
	let isSPA = !!opts.single;
	if (typeof opts.single === "string") {
		let idx = opts.single.lastIndexOf(".");
		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
	}
	let ignores = [];
	if (opts.ignores !== false) {
		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
		if (opts.dotfiles) ignores.push(/\/\.\w/);
		else ignores.push(/\/\.well-known/);
		[].concat(opts.ignores || []).forEach((x) => {
			ignores.push(new RegExp(x, "i"));
		});
	}
	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
	if (cc && opts.immutable) cc += ",immutable";
	else if (cc && opts.maxAge === 0) cc += ",must-revalidate";
	if (!opts.dev) totalist(dir, (name, abs, stats) => {
		if (/\.well-known[\\+\/]/.test(name)) {} else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;
		let headers = toHeaders(name, stats, isEtag);
		if (cc) headers["Cache-Control"] = cc;
		FILES["/" + name.normalize().replace(/\\+/g, "/")] = {
			abs,
			stats,
			headers
		};
	});
	let lookup = opts.dev ? viaLocal.bind(0, dir + node_path.sep, isEtag) : viaCache.bind(0, FILES);
	return function(req, res, next) {
		let extns = [""];
		let pathname = parse(req).pathname;
		let val = req.headers["accept-encoding"] || "";
		if (gzips && val.includes("gzip")) extns.unshift(...gzips);
		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
		extns.push(...extensions);
		if (pathname.indexOf("%") !== -1) try {
			pathname = decodeURI(pathname);
		} catch (err) {}
		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
		if (!data) return next ? next() : isNotFound(req, res);
		if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
			res.writeHead(304);
			return res.end();
		}
		if (gzips || brots) res.setHeader("Vary", "Accept-Encoding");
		setHeaders(res, pathname, data.stats);
		send(req, res, data.abs, data.stats, data.headers);
	};
}

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const BINARY_TYPES = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob = typeof Blob !== "undefined";
	if (hasBlob) BINARY_TYPES.push("blob");
	module.exports = {
		BINARY_TYPES,
		CLOSE_TIMEOUT: 3e4,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { EMPTY_BUFFER } = require_constants();
	const FastBuffer = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i = 0; i < list.length; i++) {
			const buf = list[i];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[i & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer, mask) {
		for (let i = 0; i < buffer.length; i++) buffer[i] ^= mask[i & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer(data) {
		toBuffer.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat,
		mask: _mask,
		toArrayBuffer,
		toBuffer,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil = require("bufferutil");
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer, mask) {
			if (buffer.length < 32) _unmask(buffer, mask);
			else bufferUtil.unmask(buffer, mask);
		};
	} catch (e) {}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter;
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const zlib = require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode } = require_constants();
	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err = this._inflate[kError];
				if (err) {
					this._inflate.close();
					this._inflate = null;
					callback(err);
					return;
				}
				const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
				callback(null, data);
			});
		}
	};
	module.exports = PerMessageDeflate;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError][kStatusCode] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError]) {
			this[kCallback](this[kError]);
			return;
		}
		err[kStatusCode] = 1007;
		this[kCallback](err);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isUtf8 } = require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode(code) {
		return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len = buf.length;
		let i = 0;
		while (i < len) if ((buf[i] & 128) === 0) i++;
		else if ((buf[i] & 224) === 192) {
			if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) return false;
			i += 2;
		} else if ((buf[i] & 240) === 224) {
			if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) return false;
			i += 3;
		} else if ((buf[i] & 248) === 240) {
			if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) return false;
			i += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob,
		isValidStatusCode,
		isValidUTF8: _isValidUTF8,
		tokenChars
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8 = require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
		};
	} catch (e) {}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Writable } = require("stream");
	const PerMessageDeflate = require_permessage_deflate();
	const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate.extensionName].decompress(data, this._fin, (err, buf) => {
				if (err) return cb(err);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER);
					this.end();
				} else {
					const code = data.readUInt16BE(0);
					if (!isValidStatusCode(code)) {
						cb(this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err, this.createError);
			err.code = errorCode;
			err[kStatusCode] = statusCode;
			return err;
		}
	};
	module.exports = Receiver;
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Duplex: Duplex$3 } = require("stream");
	const { randomFillSync } = require("crypto");
	const PerMessageDeflate = require_permessage_deflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
	const { isBlob, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender = class Sender {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP;
			this[kWebSocket] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code, data, mask, cb) {
			let buf;
			if (code === void 0) buf = EMPTY_BUFFER;
			else if (typeof code !== "number" || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err) => {
				process.nextTick(onError, this, err, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err, cb) {
		if (typeof cb === "function") cb(err);
		for (let i = 0; i < sender._queue.length; i++) {
			const params = sender._queue[i];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err, cb) {
		callCallbacks(sender, err, cb);
		sender.onerror(err);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kForOnEventAttribute, kListener } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event.prototype, "target", { enumerable: true });
	Object.defineProperty(Event.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget = {
		addEventListener(type, handler, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "close") wrapper = function onClose(code, message) {
				const event = new CloseEvent("close", {
					code,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "error") wrapper = function onError(error) {
				const event = new ErrorEvent("error", {
					error,
					message: error.message
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event("open");
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
			wrapper[kListener] = handler;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler) {
			for (const listener of this.listeners(type)) if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event,
		EventTarget,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			code = header.charCodeAt(i);
			if (extensionName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const name = header.slice(start, end);
				if (code === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (paramName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 32 || code === 9) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				push(params, header.slice(start, end), true);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (isEscaping) {
				if (tokenChars[code] !== 1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (start === -1) start = i;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 34 && start !== -1) {
				inQuotes = false;
				end = i;
			} else if (code === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (code === 34 && header.charCodeAt(i - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (start !== -1 && (code === 32 || code === 9)) {
				if (end === -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || inQuotes || code === 32 || code === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format(extensions) {
		return Object.keys(extensions).map((extension) => {
			let configurations = extensions[extension];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format,
		parse
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$2 = require("events");
	const https = require("https");
	const http$1 = require("http");
	const net = require("net");
	const tls = require("tls");
	const { randomBytes, createHash: createHash$1 } = require("crypto");
	const { Duplex: Duplex$2, Readable: Readable$1 } = require("stream");
	const { URL } = require("url");
	const PerMessageDeflate = require_permessage_deflate();
	const Receiver = require_receiver();
	const Sender = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, CLOSE_TIMEOUT, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format, parse } = require_extension();
	const { toBuffer } = require_buffer_util();
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket = class WebSocket extends EventEmitter$2 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._closeTimeout = options.closeTimeout;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket] = this;
			sender[kWebSocket] = this;
			socket[kWebSocket] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError);
			this._readyState = WebSocket.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate.extensionName]) this._extensions[PerMessageDeflate.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code, data) {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket.CLOSING;
			this._sender.close(code, data, !this._isServer, (err) => {
				if (err) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler !== "function") return;
				this.addEventListener(method, handler, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Number} [options.closeTimeout=30000] Duration in milliseconds to wait
	*     for the closing handshake to finish after `websocket.close()` is called
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			closeTimeout: CLOSE_TIMEOUT,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		websocket._closeTimeout = opts.closeTimeout;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL) parsedUrl = address;
		else try {
			parsedUrl = new URL(address);
		} catch (e) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err;
			else {
				emitErrorAndClose(websocket, err);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request = isSecure ? https.request : http$1.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format({ [PerMessageDeflate.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key, value] of Object.entries(headers)) options.headers[key.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req = websocket._req = request(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req);
		} else req = websocket._req = request(opts);
		if (opts.timeout) req.on("timeout", () => {
			abortHandshake(websocket, req, "Opening handshake has timed out");
		});
		req.on("error", (err) => {
			if (req === null || req[kAborted]) return;
			req = websocket._req = null;
			emitErrorAndClose(websocket, err);
		});
		req.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake(websocket, req, "Maximum redirects exceeded");
					return;
				}
				req.abort();
				let addr;
				try {
					addr = new URL(location, address);
				} catch (e) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req, res)) abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
		});
		req.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket.CONNECTING) return;
			req = websocket._req = null;
			const upgrade = res.headers.upgrade;
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshake(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions;
				try {
					extensions = parse(secWebSocketExtensions);
				} catch (err) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
					abortHandshake(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
				} catch (err) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req, websocket);
		else req.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err) {
		websocket._readyState = WebSocket.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake(websocket, stream, message) {
		websocket._readyState = WebSocket.CLOSING;
		const err = new Error(message);
		Error.captureStackTrace(err, abortHandshake);
		if (stream.setHeader) {
			stream[kAborted] = true;
			stream.abort();
			if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err);
		} else {
			stream.destroy(err);
			stream.once("error", websocket.emit.bind(websocket, "error"));
			stream.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code, reason) {
		const websocket = this[kWebSocket];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code;
		if (websocket._socket[kWebSocket] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code === 1005) websocket.close();
		else websocket.close(code, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err) {
		const websocket = this[kWebSocket];
		if (websocket._socket[kWebSocket] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream) {
		stream.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err) {
		const websocket = this[kWebSocket];
		if (websocket.readyState === WebSocket.CLOSED) return;
		if (websocket.readyState === WebSocket.OPEN) {
			websocket._readyState = WebSocket.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), websocket._closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket.CLOSING;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
			const chunk = this.read(this._readableState.length);
			websocket._receiver.write(chunk);
		}
		websocket._receiver.end();
		this[kWebSocket] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket];
		websocket._readyState = WebSocket.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError() {
		const websocket = this[kWebSocket];
		this.removeListener("error", socketOnError);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket.CLOSING;
			this.destroy();
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose(stream) {
		stream.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error(err) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err);
				process.nextTick(emitClose, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error(err) {
				called = true;
				callback(err);
			});
			ws.once("close", function close() {
				if (!called) callback(err);
				process.nextTick(emitClose, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream;
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			const code = header.charCodeAt(i);
			if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const protocol = header.slice(start, end);
				if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
				protocols.add(protocol);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse };
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$1 = require("events");
	const http = require("http");
	const { Duplex } = require("stream");
	const { createHash } = require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket = require_websocket();
	const { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer = class extends EventEmitter$1 {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Number} [options.closeTimeout=30000] Duration in milliseconds to
		*     wait for the closing handshake to finish after `websocket.close()` is
		*     called
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				closeTimeout: CLOSE_TIMEOUT,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req, socket, head) => {
						this.handleUpgrade(req, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req) {
			if (this.options.path) {
				const index = req.url.indexOf("?");
				if ((index !== -1 ? req.url.slice(0, index) : req.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req.headers["sec-websocket-key"];
			const upgrade = req.headers.upgrade;
			const version = +req.headers["sec-websocket-version"];
			if (req.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version !== 13 && version !== 8) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err) {
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info = {
					origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req.socket.authorized || req.socket.encrypted),
					req
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info, (verified, code, message, headers) => {
						if (!verified) return abortHandshake(socket, code || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req);
		}
	};
	module.exports = WebSocketServer;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code, message, headers) {
		message = message || http.STATUS_CODES[code];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err, socket, req);
		} else abortHandshake(socket, code, message, headers);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/ws@8.19.0/node_modules/ws/wrapper.mjs
var import_stream = /* @__PURE__ */ __toESM(require_stream(), 1);
var import_receiver = /* @__PURE__ */ __toESM(require_receiver(), 1);
var import_sender = /* @__PURE__ */ __toESM(require_sender(), 1);
var import_websocket = /* @__PURE__ */ __toESM(require_websocket(), 1);
var import_websocket_server = /* @__PURE__ */ __toESM(require_websocket_server(), 1);

//#endregion
//#region ../../node_modules/.pnpm/address@2.0.3/node_modules/address/dist/esm/address.js
function getDefaultInterfaceName() {
	let val = "eth";
	const platform = node_os.default.platform();
	if (platform === "darwin") val = "en";
	else if (platform === "win32") val = void 0;
	return val;
}
function matchName(actualFamily, expectedFamily) {
	if (expectedFamily === "IPv4") return actualFamily === "IPv4" || actualFamily === 4;
	if (expectedFamily === "IPv6") return actualFamily === "IPv6" || actualFamily === 6;
	return actualFamily === expectedFamily;
}
function findAddressFromInterface(items, expectedFamily, ignoreLoAddress = false) {
	let firstMatchItem;
	for (const item of items) if (matchName(item.family, expectedFamily)) {
		if (ignoreLoAddress && item.address.startsWith("127.")) continue;
		if (expectedFamily === "IPv6") {
			if (item.scopeid === 0) return item;
			if (!firstMatchItem) firstMatchItem = item;
		} else return item;
	}
	return firstMatchItem;
}
function getInterfaceAddress(family, name) {
	const interfaces = node_os.default.networkInterfaces();
	const noName = !name;
	name = name || getDefaultInterfaceName();
	family = family || "IPv4";
	if (name) for (let i = -1; i < 8; i++) {
		const items = interfaces[name + (i >= 0 ? i : "")];
		if (items) {
			const item = findAddressFromInterface(items, family);
			if (item) return item;
		}
	}
	if (noName) for (const k in interfaces) {
		const items = interfaces[k];
		if (items) {
			const item = findAddressFromInterface(items, family, true);
			if (item) return item;
		}
	}
}
/**
* Get current machine IPv4
*
* interfaceName: interface name, default is 'eth' on linux, 'en' on mac os.
*/
function ip(interfaceName) {
	return getInterfaceAddress("IPv4", interfaceName)?.address;
}

//#endregion
//#region ../../node_modules/.pnpm/detect-port@2.1.0/node_modules/detect-port/dist/esm/detect-port.js
const debug$1 = (0, node_util.debuglog)("detect-port");
var IPAddressNotAvailableError = class extends Error {
	constructor(options) {
		super("The IP address is not available on this machine", options);
		this.name = this.constructor.name;
		Error.captureStackTrace(this, this.constructor);
	}
};
function detectPort(port, callback) {
	let hostname = "";
	if (port && typeof port === "object") {
		hostname = port.hostname;
		callback = port.callback;
		port = port.port;
	} else if (typeof port === "function") {
		callback = port;
		port = void 0;
	}
	port = parseInt(port) || 0;
	let maxPort = port + 10;
	if (maxPort > 65535) maxPort = 65535;
	debug$1("detect free port between [%s, %s)", port, maxPort);
	if (typeof callback === "function") return tryListen(port, maxPort, hostname).then((port) => callback(null, port)).catch(callback);
	return tryListen(port, maxPort, hostname);
}
async function handleError(port, maxPort, hostname) {
	if (port >= maxPort) {
		debug$1("port: %s >= maxPort: %s, give up and use random port", port, maxPort);
		port = 0;
		maxPort = 0;
	}
	return await tryListen(port, maxPort, hostname);
}
async function tryListen(port, maxPort, hostname) {
	if (hostname) try {
		return await listen(port, hostname);
	} catch (err) {
		if (err.code === "EADDRNOTAVAIL") throw new IPAddressNotAvailableError({ cause: err });
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port);
	} catch (err) {
		if (port === 0) throw err;
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "0.0.0.0");
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "127.0.0.1");
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "localhost");
	} catch (err) {
		if (err.code !== "EADDRNOTAVAIL") return await handleError(++port, maxPort, hostname);
	}
	try {
		return await listen(port, ip());
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
}
function listen(port, hostname) {
	const server = (0, node_net.createServer)();
	return new Promise((resolve, reject) => {
		server.once("error", (err) => {
			debug$1("listen %s:%s error: %s", hostname, port, err);
			server.close();
			if (err.code === "ENOTFOUND") {
				debug$1("ignore dns ENOTFOUND error, get free %s:%s", hostname, port);
				return resolve(port);
			}
			return reject(err);
		});
		debug$1("try listen %d on %s", port, hostname);
		server.listen(port, hostname, () => {
			port = server.address().port;
			debug$1("get free %s:%s", hostname, port);
			server.close();
			return resolve(port);
		});
	});
}

//#endregion
//#region ../../node_modules/.pnpm/detect-port@2.1.0/node_modules/detect-port/dist/esm/wait-port.js
const debug = (0, node_util.debuglog)("detect-port:wait-port");

//#endregion
//#region ../../node_modules/.pnpm/detect-port@2.1.0/node_modules/detect-port/dist/esm/index.js
var esm_default = detectPort;

//#endregion
//#region ../../node_modules/.pnpm/is-docker@3.0.0/node_modules/is-docker/index.js
let isDockerCached;
function hasDockerEnv() {
	try {
		node_fs.default.statSync("/.dockerenv");
		return true;
	} catch {
		return false;
	}
}
function hasDockerCGroup() {
	try {
		return node_fs.default.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
	} catch {
		return false;
	}
}
function isDocker() {
	if (isDockerCached === void 0) isDockerCached = hasDockerEnv() || hasDockerCGroup();
	return isDockerCached;
}

//#endregion
//#region ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
let cachedResult;
const hasContainerEnv = () => {
	try {
		node_fs.default.statSync("/run/.containerenv");
		return true;
	} catch {
		return false;
	}
};
function isInsideContainer() {
	if (cachedResult === void 0) cachedResult = hasContainerEnv() || isDocker();
	return cachedResult;
}

//#endregion
//#region ../../node_modules/.pnpm/is-wsl@3.1.1/node_modules/is-wsl/index.js
const isWsl = () => {
	if (node_process.default.platform !== "linux") return false;
	if (node_os.default.release().toLowerCase().includes("microsoft")) {
		if (isInsideContainer()) return false;
		return true;
	}
	try {
		if (node_fs.default.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft")) return !isInsideContainer();
	} catch {}
	if (node_fs.default.existsSync("/proc/sys/fs/binfmt_misc/WSLInterop") || node_fs.default.existsSync("/run/WSL")) return !isInsideContainer();
	return false;
};
var is_wsl_default = node_process.default.env.__IS_WSL_TEST__ ? isWsl : isWsl();

//#endregion
//#region ../../node_modules/.pnpm/wsl-utils@0.1.0/node_modules/wsl-utils/index.js
const wslDrivesMountPoint = (() => {
	const defaultMountPoint = "/mnt/";
	let mountPoint;
	return async function() {
		if (mountPoint) return mountPoint;
		const configFilePath = "/etc/wsl.conf";
		let isConfigFileExists = false;
		try {
			await node_fs_promises.default.access(configFilePath, node_fs_promises.constants.F_OK);
			isConfigFileExists = true;
		} catch {}
		if (!isConfigFileExists) return defaultMountPoint;
		const configContent = await node_fs_promises.default.readFile(configFilePath, { encoding: "utf8" });
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
		if (!configMountPoint) return defaultMountPoint;
		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
		return mountPoint;
	};
})();
const powerShellPathFromWsl = async () => {
	return `${await wslDrivesMountPoint()}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
const powerShellPath = async () => {
	if (is_wsl_default) return powerShellPathFromWsl();
	return `${node_process.default.env.SYSTEMROOT || node_process.default.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
};

//#endregion
//#region ../../node_modules/.pnpm/define-lazy-prop@3.0.0/node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
	const define = (value) => Object.defineProperty(object, propertyName, {
		value,
		enumerable: true,
		writable: true
	});
	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = valueGetter();
			define(result);
			return result;
		},
		set(value) {
			define(value);
		}
	});
	return object;
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser-id@5.0.1/node_modules/default-browser-id/index.js
const execFileAsync$3 = (0, node_util.promisify)(node_child_process.execFile);
async function defaultBrowserId() {
	if (node_process.default.platform !== "darwin") throw new Error("macOS only");
	const { stdout } = await execFileAsync$3("defaults", [
		"read",
		"com.apple.LaunchServices/com.apple.launchservices.secure",
		"LSHandlers"
	]);
	const browserId = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout)?.groups.id ?? "com.apple.Safari";
	if (browserId === "com.apple.safari") return "com.apple.Safari";
	return browserId;
}

//#endregion
//#region ../../node_modules/.pnpm/run-applescript@7.1.0/node_modules/run-applescript/index.js
const execFileAsync$2 = (0, node_util.promisify)(node_child_process.execFile);
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
	if (node_process.default.platform !== "darwin") throw new Error("macOS only");
	const outputArguments = humanReadableOutput ? [] : ["-ss"];
	const execOptions = {};
	if (signal) execOptions.signal = signal;
	const { stdout } = await execFileAsync$2("osascript", [
		"-e",
		script,
		outputArguments
	], execOptions);
	return stdout.trim();
}

//#endregion
//#region ../../node_modules/.pnpm/bundle-name@4.1.0/node_modules/bundle-name/index.js
async function bundleName(bundleId) {
	return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser@5.5.0/node_modules/default-browser/windows.js
const execFileAsync$1 = (0, node_util.promisify)(node_child_process.execFile);
const windowsBrowserProgIds = {
	MSEdgeHTM: {
		name: "Edge",
		id: "com.microsoft.edge"
	},
	MSEdgeBHTML: {
		name: "Edge Beta",
		id: "com.microsoft.edge.beta"
	},
	MSEdgeDHTML: {
		name: "Edge Dev",
		id: "com.microsoft.edge.dev"
	},
	AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
		name: "Edge",
		id: "com.microsoft.edge.old"
	},
	ChromeHTML: {
		name: "Chrome",
		id: "com.google.chrome"
	},
	ChromeBHTML: {
		name: "Chrome Beta",
		id: "com.google.chrome.beta"
	},
	ChromeDHTML: {
		name: "Chrome Dev",
		id: "com.google.chrome.dev"
	},
	ChromiumHTM: {
		name: "Chromium",
		id: "org.chromium.Chromium"
	},
	BraveHTML: {
		name: "Brave",
		id: "com.brave.Browser"
	},
	BraveBHTML: {
		name: "Brave Beta",
		id: "com.brave.Browser.beta"
	},
	BraveDHTML: {
		name: "Brave Dev",
		id: "com.brave.Browser.dev"
	},
	BraveSSHTM: {
		name: "Brave Nightly",
		id: "com.brave.Browser.nightly"
	},
	FirefoxURL: {
		name: "Firefox",
		id: "org.mozilla.firefox"
	},
	OperaStable: {
		name: "Opera",
		id: "com.operasoftware.Opera"
	},
	VivaldiHTM: {
		name: "Vivaldi",
		id: "com.vivaldi.Vivaldi"
	},
	"IE.HTTP": {
		name: "Internet Explorer",
		id: "com.microsoft.ie"
	}
};
const _windowsBrowserProgIdMap = new Map(Object.entries(windowsBrowserProgIds));
var UnknownBrowserError = class extends Error {};
async function defaultBrowser$1(_execFileAsync = execFileAsync$1) {
	const { stdout } = await _execFileAsync("reg", [
		"QUERY",
		" HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
		"/v",
		"ProgId"
	]);
	const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
	if (!match) throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
	const { id } = match.groups;
	const dotIndex = id.lastIndexOf(".");
	const hyphenIndex = id.lastIndexOf("-");
	const baseIdByDot = dotIndex === -1 ? void 0 : id.slice(0, dotIndex);
	const baseIdByHyphen = hyphenIndex === -1 ? void 0 : id.slice(0, hyphenIndex);
	return windowsBrowserProgIds[id] ?? windowsBrowserProgIds[baseIdByDot] ?? windowsBrowserProgIds[baseIdByHyphen] ?? {
		name: id,
		id
	};
}

//#endregion
//#region ../../node_modules/.pnpm/default-browser@5.5.0/node_modules/default-browser/index.js
const execFileAsync = (0, node_util.promisify)(node_child_process.execFile);
const titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser() {
	if (node_process.default.platform === "darwin") {
		const id = await defaultBrowserId();
		return {
			name: await bundleName(id),
			id
		};
	}
	if (node_process.default.platform === "linux") {
		const { stdout } = await execFileAsync("xdg-mime", [
			"query",
			"default",
			"x-scheme-handler/http"
		]);
		const id = stdout.trim();
		return {
			name: titleize(id.replace(/.desktop$/, "").replace("-", " ")),
			id
		};
	}
	if (node_process.default.platform === "win32") return defaultBrowser$1();
	throw new Error("Only macOS, Linux, and Windows are supported");
}

//#endregion
//#region ../../node_modules/.pnpm/open@10.2.0/node_modules/open/index.js
const execFile = (0, node_util.promisify)(node_child_process.default.execFile);
const __dirname$1 = node_path.default.dirname((0, node_url.fileURLToPath)(require("url").pathToFileURL(__filename).href));
const localXdgOpenPath = node_path.default.join(__dirname$1, "xdg-open");
const { platform, arch } = node_process.default;
/**
Get the default browser name in Windows from WSL.

@returns {Promise<string>} Browser name.
*/
async function getWindowsDefaultBrowserFromWsl() {
	const powershellPath = await powerShellPath();
	const rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
	const { stdout } = await execFile(powershellPath, [
		"-NoProfile",
		"-NonInteractive",
		"-ExecutionPolicy",
		"Bypass",
		"-EncodedCommand",
		node_buffer.Buffer.from(rawCommand, "utf16le").toString("base64")
	], { encoding: "utf8" });
	const progId = stdout.trim();
	const browserMap = {
		ChromeHTML: "com.google.chrome",
		BraveHTML: "com.brave.Browser",
		MSEdgeHTM: "com.microsoft.edge",
		FirefoxURL: "org.mozilla.firefox"
	};
	return browserMap[progId] ? { id: browserMap[progId] } : {};
}
const pTryEach = async (array, mapper) => {
	let latestError;
	for (const item of array) try {
		return await mapper(item);
	} catch (error) {
		latestError = error;
	}
	throw latestError;
};
const baseOpen = async (options) => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options
	};
	if (Array.isArray(options.app)) return pTryEach(options.app, (singleApp) => baseOpen({
		...options,
		app: singleApp
	}));
	let { name: app, arguments: appArguments = [] } = options.app ?? {};
	appArguments = [...appArguments];
	if (Array.isArray(app)) return pTryEach(app, (appName) => baseOpen({
		...options,
		app: {
			name: appName,
			arguments: appArguments
		}
	}));
	if (app === "browser" || app === "browserPrivate") {
		const ids = {
			"com.google.chrome": "chrome",
			"google-chrome.desktop": "chrome",
			"com.brave.Browser": "brave",
			"org.mozilla.firefox": "firefox",
			"firefox.desktop": "firefox",
			"com.microsoft.msedge": "edge",
			"com.microsoft.edge": "edge",
			"com.microsoft.edgemac": "edge",
			"microsoft-edge.desktop": "edge"
		};
		const flags = {
			chrome: "--incognito",
			brave: "--incognito",
			firefox: "--private-window",
			edge: "--inPrivate"
		};
		const browser = is_wsl_default ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser();
		if (browser.id in ids) {
			const browserName = ids[browser.id];
			if (app === "browserPrivate") appArguments.push(flags[browserName]);
			return baseOpen({
				...options,
				app: {
					name: apps[browserName],
					arguments: appArguments
				}
			});
		}
		throw new Error(`${browser.name} is not supported as a default browser`);
	}
	let command;
	const cliArguments = [];
	const childProcessOptions = {};
	if (platform === "darwin") {
		command = "open";
		if (options.wait) cliArguments.push("--wait-apps");
		if (options.background) cliArguments.push("--background");
		if (options.newInstance) cliArguments.push("--new");
		if (app) cliArguments.push("-a", app);
	} else if (platform === "win32" || is_wsl_default && !isInsideContainer() && !app) {
		command = await powerShellPath();
		cliArguments.push("-NoProfile", "-NonInteractive", "-ExecutionPolicy", "Bypass", "-EncodedCommand");
		if (!is_wsl_default) childProcessOptions.windowsVerbatimArguments = true;
		const encodedArguments = ["Start"];
		if (options.wait) encodedArguments.push("-Wait");
		if (app) {
			encodedArguments.push(`"\`"${app}\`""`);
			if (options.target) appArguments.push(options.target);
		} else if (options.target) encodedArguments.push(`"${options.target}"`);
		if (appArguments.length > 0) {
			appArguments = appArguments.map((argument) => `"\`"${argument}\`""`);
			encodedArguments.push("-ArgumentList", appArguments.join(","));
		}
		options.target = node_buffer.Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
	} else {
		if (app) command = app;
		else {
			const isBundled = !__dirname$1 || __dirname$1 === "/";
			let exeLocalXdgOpen = false;
			try {
				await node_fs_promises.default.access(localXdgOpenPath, node_fs_promises.constants.X_OK);
				exeLocalXdgOpen = true;
			} catch {}
			command = node_process.default.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen) ? "xdg-open" : localXdgOpenPath;
		}
		if (appArguments.length > 0) cliArguments.push(...appArguments);
		if (!options.wait) {
			childProcessOptions.stdio = "ignore";
			childProcessOptions.detached = true;
		}
	}
	if (platform === "darwin" && appArguments.length > 0) cliArguments.push("--args", ...appArguments);
	if (options.target) cliArguments.push(options.target);
	const subprocess = node_child_process.default.spawn(command, cliArguments, childProcessOptions);
	if (options.wait) return new Promise((resolve, reject) => {
		subprocess.once("error", reject);
		subprocess.once("close", (exitCode) => {
			if (!options.allowNonzeroExitCode && exitCode > 0) {
				reject(/* @__PURE__ */ new Error(`Exited with code ${exitCode}`));
				return;
			}
			resolve(subprocess);
		});
	});
	subprocess.unref();
	return subprocess;
};
const open$1 = (target, options) => {
	if (typeof target !== "string") throw new TypeError("Expected a `target`");
	return baseOpen({
		...options,
		target
	});
};
function detectArchBinary(binary) {
	if (typeof binary === "string" || Array.isArray(binary)) return binary;
	const { [arch]: archBinary } = binary;
	if (!archBinary) throw new Error(`${arch} is not supported`);
	return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
	if (wsl && is_wsl_default) return detectArchBinary(wsl);
	if (!platformBinary) throw new Error(`${platform} is not supported`);
	return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
	darwin: "google chrome",
	win32: "chrome",
	linux: [
		"google-chrome",
		"google-chrome-stable",
		"chromium"
	]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
	x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
} }));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
	darwin: "brave browser",
	win32: "brave",
	linux: ["brave-browser", "brave"]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
	x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
} }));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
	darwin: "firefox",
	win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
	linux: "firefox"
}, { wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe" }));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
	darwin: "microsoft edge",
	win32: "msedge",
	linux: ["microsoft-edge", "microsoft-edge-dev"]
}, { wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" }));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");

//#endregion
//#region ../core/dist/types.js
var require_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @maxsim/core  Shared type definitions
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PLANNING_CONFIG_DEFAULTS = void 0;
	exports.phaseNumber = phaseNumber;
	exports.phasePath = phasePath;
	exports.phaseSlug = phaseSlug;
	exports.ok = ok;
	exports.err = err;
	function phaseNumber(value) {
		if (!value.match(/^\d+[A-Z]?(\.\d+)?$/i)) throw new Error(`Invalid phase number: ${value}`);
		return value;
	}
	function phasePath(value) {
		if (!value || typeof value !== "string") throw new Error(`Invalid phase path: ${value}`);
		return value;
	}
	function phaseSlug(value) {
		if (!value || typeof value !== "string") throw new Error(`Invalid phase slug: ${value}`);
		return value;
	}
	function ok(data) {
		return {
			success: true,
			data
		};
	}
	function err(error) {
		return {
			success: false,
			error
		};
	}
	exports.PLANNING_CONFIG_DEFAULTS = {
		model_profile: "balanced",
		commit_docs: true,
		search_gitignored: false,
		branching_strategy: "none",
		phase_branch_template: "maxsim/phase-{phase}-{slug}",
		milestone_branch_template: "maxsim/{milestone}-{slug}",
		workflow: {
			research: true,
			plan_check: true,
			verifier: true,
			nyquist_validation: false
		},
		parallelization: true,
		brave_search: false
	};
}));

//#endregion
//#region ../core/dist/core.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Core  Shared utilities, constants, and internal helpers
	*
	* Ported from maxsim/bin/lib/core.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MODEL_PROFILES = void 0;
	exports.output = output;
	exports.error = error;
	exports.safeReadFile = safeReadFile;
	exports.loadConfig = loadConfig;
	exports.isGitIgnored = isGitIgnored;
	exports.execGit = execGit;
	exports.normalizePhaseName = normalizePhaseName;
	exports.comparePhaseNum = comparePhaseNum;
	exports.getPhasePattern = getPhasePattern;
	exports.findPhaseInternal = findPhaseInternal;
	exports.getArchivedPhaseDirs = getArchivedPhaseDirs;
	exports.getRoadmapPhaseInternal = getRoadmapPhaseInternal;
	exports.resolveModelInternal = resolveModelInternal;
	exports.pathExistsInternal = pathExistsInternal;
	exports.generateSlugInternal = generateSlugInternal;
	exports.getMilestoneInfo = getMilestoneInfo;
	const node_fs_1$10 = __importDefault(require("node:fs"));
	const node_path_1$10 = __importDefault(require("node:path"));
	const node_os_1$2 = __importDefault(require("node:os"));
	const node_child_process_1$1 = require("node:child_process");
	exports.MODEL_PROFILES = {
		"maxsim-planner": {
			quality: "opus",
			balanced: "opus",
			budget: "sonnet",
			tokenburner: "opus"
		},
		"maxsim-roadmapper": {
			quality: "opus",
			balanced: "sonnet",
			budget: "sonnet",
			tokenburner: "opus"
		},
		"maxsim-executor": {
			quality: "opus",
			balanced: "sonnet",
			budget: "sonnet",
			tokenburner: "opus"
		},
		"maxsim-phase-researcher": {
			quality: "opus",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-project-researcher": {
			quality: "opus",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-research-synthesizer": {
			quality: "sonnet",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-debugger": {
			quality: "opus",
			balanced: "sonnet",
			budget: "sonnet",
			tokenburner: "opus"
		},
		"maxsim-codebase-mapper": {
			quality: "sonnet",
			balanced: "haiku",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-verifier": {
			quality: "sonnet",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-plan-checker": {
			quality: "sonnet",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		},
		"maxsim-integration-checker": {
			quality: "sonnet",
			balanced: "sonnet",
			budget: "haiku",
			tokenburner: "opus"
		}
	};
	function output(result, raw, rawValue) {
		if (raw && rawValue !== void 0) process.stdout.write(String(rawValue));
		else {
			const json = JSON.stringify(result, null, 2);
			if (json.length > 5e4) {
				const tmpPath = node_path_1$10.default.join(node_os_1$2.default.tmpdir(), `maxsim-${Date.now()}.json`);
				node_fs_1$10.default.writeFileSync(tmpPath, json, "utf-8");
				process.stdout.write("@file:" + tmpPath);
			} else process.stdout.write(json);
		}
		process.exit(0);
	}
	function error(message) {
		process.stderr.write("Error: " + message + "\n");
		process.exit(1);
	}
	function safeReadFile(filePath) {
		try {
			return node_fs_1$10.default.readFileSync(filePath, "utf-8");
		} catch {
			return null;
		}
	}
	function loadConfig(cwd) {
		const configPath = node_path_1$10.default.join(cwd, ".planning", "config.json");
		const defaults = {
			model_profile: "balanced",
			commit_docs: true,
			search_gitignored: false,
			branching_strategy: "none",
			phase_branch_template: "maxsim/phase-{phase}-{slug}",
			milestone_branch_template: "maxsim/{milestone}-{slug}",
			research: true,
			plan_checker: true,
			verifier: true,
			parallelization: true,
			brave_search: false
		};
		try {
			const raw = node_fs_1$10.default.readFileSync(configPath, "utf-8");
			const parsed = JSON.parse(raw);
			const get = (key, nested) => {
				if (parsed[key] !== void 0) return parsed[key];
				if (nested) {
					const section = parsed[nested.section];
					if (section && typeof section === "object" && section !== null && nested.field in section) return section[nested.field];
				}
			};
			const parallelization = (() => {
				const val = get("parallelization");
				if (typeof val === "boolean") return val;
				if (typeof val === "object" && val !== null && "enabled" in val) return val.enabled;
				return defaults.parallelization;
			})();
			return {
				model_profile: get("model_profile") ?? defaults.model_profile,
				commit_docs: get("commit_docs", {
					section: "planning",
					field: "commit_docs"
				}) ?? defaults.commit_docs,
				search_gitignored: get("search_gitignored", {
					section: "planning",
					field: "search_gitignored"
				}) ?? defaults.search_gitignored,
				branching_strategy: get("branching_strategy", {
					section: "git",
					field: "branching_strategy"
				}) ?? defaults.branching_strategy,
				phase_branch_template: get("phase_branch_template", {
					section: "git",
					field: "phase_branch_template"
				}) ?? defaults.phase_branch_template,
				milestone_branch_template: get("milestone_branch_template", {
					section: "git",
					field: "milestone_branch_template"
				}) ?? defaults.milestone_branch_template,
				research: get("research", {
					section: "workflow",
					field: "research"
				}) ?? defaults.research,
				plan_checker: get("plan_checker", {
					section: "workflow",
					field: "plan_check"
				}) ?? defaults.plan_checker,
				verifier: get("verifier", {
					section: "workflow",
					field: "verifier"
				}) ?? defaults.verifier,
				parallelization,
				brave_search: get("brave_search") ?? defaults.brave_search,
				model_overrides: parsed["model_overrides"]
			};
		} catch {
			return defaults;
		}
	}
	function isGitIgnored(cwd, targetPath) {
		try {
			(0, node_child_process_1$1.execSync)("git check-ignore -q -- " + targetPath.replace(/[^a-zA-Z0-9._\-/]/g, ""), {
				cwd,
				stdio: "pipe"
			});
			return true;
		} catch {
			return false;
		}
	}
	function execGit(cwd, args) {
		try {
			const escaped = args.map((a) => {
				if (/^[a-zA-Z0-9._\-/=:@]+$/.test(a)) return a;
				return "'" + a.replace(/'/g, "'\\''") + "'";
			});
			return {
				exitCode: 0,
				stdout: (0, node_child_process_1$1.execSync)("git " + escaped.join(" "), {
					cwd,
					stdio: "pipe",
					encoding: "utf-8"
				}).trim(),
				stderr: ""
			};
		} catch (thrown) {
			const err = thrown;
			return {
				exitCode: err.status ?? 1,
				stdout: (err.stdout ?? "").toString().trim(),
				stderr: (err.stderr ?? "").toString().trim()
			};
		}
	}
	function normalizePhaseName(phase) {
		const match = phase.match(/^(\d+)([A-Z])?(\.\d+)?/i);
		if (!match) return phase;
		const padded = match[1].padStart(2, "0");
		const letter = match[2] ? match[2].toUpperCase() : "";
		const decimal = match[3] || "";
		return padded + letter + decimal;
	}
	function comparePhaseNum(a, b) {
		const pa = String(a).match(/^(\d+)([A-Z])?(\.\d+)?/i);
		const pb = String(b).match(/^(\d+)([A-Z])?(\.\d+)?/i);
		if (!pa || !pb) return String(a).localeCompare(String(b));
		const intDiff = parseInt(pa[1], 10) - parseInt(pb[1], 10);
		if (intDiff !== 0) return intDiff;
		const la = (pa[2] || "").toUpperCase();
		const lb = (pb[2] || "").toUpperCase();
		if (la !== lb) {
			if (!la) return -1;
			if (!lb) return 1;
			return la < lb ? -1 : 1;
		}
		return (pa[3] ? parseFloat(pa[3]) : -1) - (pb[3] ? parseFloat(pb[3]) : -1);
	}
	/**
	* Returns the canonical regex for matching Phase heading lines in ROADMAP.md.
	*
	* General form (no escapedPhaseNum):
	*   Matches: ## Phase 03: Name Here
	*   Group 1: phase number string (e.g. "03", "3A", "2.1")
	*   Group 2: phase name string (e.g. "Name Here")
	*
	* Specific form (with escapedPhaseNum):
	*   Matches: ## Phase 03: Name Here
	*   Group 1: phase name string only
	*
	* @param escapedPhaseNum - regex-escaped phase number string to match a specific phase
	* @param flags - regex flags (default: 'gi')
	*/
	function getPhasePattern(escapedPhaseNum, flags = "gi") {
		if (escapedPhaseNum) return new RegExp(`#{2,4}\\s*Phase\\s+${escapedPhaseNum}:\\s*([^\\n]+)`, flags);
		return new RegExp(`#{2,4}\\s*Phase\\s+(\\d+[A-Z]?(?:\\.\\d+)?)\\s*:\\s*([^\\n]+)`, flags);
	}
	function searchPhaseInDir(baseDir, relBase, normalized) {
		try {
			const match = node_fs_1$10.default.readdirSync(baseDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => comparePhaseNum(a, b)).find((d) => d.startsWith(normalized));
			if (!match) return null;
			const dirMatch = match.match(/^(\d+[A-Z]?(?:\.\d+)?)-?(.*)/i);
			const phaseNumber = dirMatch ? dirMatch[1] : normalized;
			const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;
			const phaseDir = node_path_1$10.default.join(baseDir, match);
			const phaseFiles = node_fs_1$10.default.readdirSync(phaseDir);
			const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
			const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").sort();
			const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
			const hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
			const hasVerification = phaseFiles.some((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
			const completedPlanIds = new Set(summaries.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", "")));
			const incompletePlans = plans.filter((p) => {
				const planId = p.replace("-PLAN.md", "").replace("PLAN.md", "");
				return !completedPlanIds.has(planId);
			});
			return {
				found: true,
				directory: node_path_1$10.default.join(relBase, match),
				phase_number: phaseNumber,
				phase_name: phaseName,
				phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") : null,
				plans,
				summaries,
				incomplete_plans: incompletePlans,
				has_research: hasResearch,
				has_context: hasContext,
				has_verification: hasVerification
			};
		} catch {
			return null;
		}
	}
	function findPhaseInternal(cwd, phase) {
		if (!phase) return null;
		const phasesDir = node_path_1$10.default.join(cwd, ".planning", "phases");
		const normalized = normalizePhaseName(phase);
		const current = searchPhaseInDir(phasesDir, node_path_1$10.default.join(".planning", "phases"), normalized);
		if (current) return current;
		const milestonesDir = node_path_1$10.default.join(cwd, ".planning", "milestones");
		if (!node_fs_1$10.default.existsSync(milestonesDir)) return null;
		try {
			const archiveDirs = node_fs_1$10.default.readdirSync(milestonesDir, { withFileTypes: true }).filter((e) => e.isDirectory() && /^v[\d.]+-phases$/.test(e.name)).map((e) => e.name).sort().reverse();
			for (const archiveName of archiveDirs) {
				const versionMatch = archiveName.match(/^(v[\d.]+)-phases$/);
				if (!versionMatch) continue;
				const version = versionMatch[1];
				const result = searchPhaseInDir(node_path_1$10.default.join(milestonesDir, archiveName), node_path_1$10.default.join(".planning", "milestones", archiveName), normalized);
				if (result) {
					result.archived = version;
					return result;
				}
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		return null;
	}
	function getArchivedPhaseDirs(cwd) {
		const milestonesDir = node_path_1$10.default.join(cwd, ".planning", "milestones");
		const results = [];
		if (!node_fs_1$10.default.existsSync(milestonesDir)) return results;
		try {
			const phaseDirs = node_fs_1$10.default.readdirSync(milestonesDir, { withFileTypes: true }).filter((e) => e.isDirectory() && /^v[\d.]+-phases$/.test(e.name)).map((e) => e.name).sort().reverse();
			for (const archiveName of phaseDirs) {
				const versionMatch = archiveName.match(/^(v[\d.]+)-phases$/);
				if (!versionMatch) continue;
				const version = versionMatch[1];
				const archivePath = node_path_1$10.default.join(milestonesDir, archiveName);
				const dirs = node_fs_1$10.default.readdirSync(archivePath, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => comparePhaseNum(a, b));
				for (const dir of dirs) results.push({
					name: dir,
					milestone: version,
					basePath: node_path_1$10.default.join(".planning", "milestones", archiveName),
					fullPath: node_path_1$10.default.join(archivePath, dir)
				});
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		return results;
	}
	function getRoadmapPhaseInternal(cwd, phaseNum) {
		if (!phaseNum) return null;
		const roadmapPath = node_path_1$10.default.join(cwd, ".planning", "ROADMAP.md");
		if (!node_fs_1$10.default.existsSync(roadmapPath)) return null;
		try {
			const content = node_fs_1$10.default.readFileSync(roadmapPath, "utf-8");
			const phasePattern = getPhasePattern(phaseNum.toString().replace(/\./g, "\\."), "i");
			const headerMatch = content.match(phasePattern);
			if (!headerMatch) return null;
			const phaseName = headerMatch[1].trim();
			const headerIndex = headerMatch.index;
			const nextHeaderMatch = content.slice(headerIndex).match(/\n#{2,4}\s+Phase\s+\d/i);
			const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index : content.length;
			const section = content.slice(headerIndex, sectionEnd).trim();
			const goalMatch = section.match(/\*\*Goal:\*\*\s*([^\n]+)/i);
			const goal = goalMatch ? goalMatch[1].trim() : null;
			return {
				found: true,
				phase_number: phaseNum.toString(),
				phase_name: phaseName,
				goal,
				section
			};
		} catch {
			return null;
		}
	}
	function resolveModelInternal(cwd, agentType) {
		const config = loadConfig(cwd);
		const override = config.model_overrides?.[agentType];
		if (override) return override === "opus" ? "inherit" : override;
		const profile = config.model_profile || "balanced";
		const agentModels = exports.MODEL_PROFILES[agentType];
		if (!agentModels) return "sonnet";
		const resolved = agentModels[profile] || agentModels["balanced"] || "sonnet";
		return resolved === "opus" ? "inherit" : resolved;
	}
	function pathExistsInternal(cwd, targetPath) {
		const fullPath = node_path_1$10.default.isAbsolute(targetPath) ? targetPath : node_path_1$10.default.join(cwd, targetPath);
		try {
			node_fs_1$10.default.statSync(fullPath);
			return true;
		} catch {
			return false;
		}
	}
	function generateSlugInternal(text) {
		if (!text) return null;
		return text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
	}
	function getMilestoneInfo(cwd) {
		try {
			const roadmap = node_fs_1$10.default.readFileSync(node_path_1$10.default.join(cwd, ".planning", "ROADMAP.md"), "utf-8");
			const versionMatch = roadmap.match(/v(\d+\.\d+)/);
			const nameMatch = roadmap.match(/## .*v\d+\.\d+[:\s]+([^\n(]+)/);
			return {
				version: versionMatch ? versionMatch[0] : "v1.0",
				name: nameMatch ? nameMatch[1].trim() : "milestone"
			};
		} catch {
			return {
				version: "v1.0",
				name: "milestone"
			};
		}
	}
}));

//#endregion
//#region ../core/dist/frontmatter.js
var require_frontmatter = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Frontmatter  YAML frontmatter parsing, serialization, and CRUD commands
	*
	* Ported from maxsim/bin/lib/frontmatter.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FRONTMATTER_SCHEMAS = void 0;
	exports.extractFrontmatter = extractFrontmatter;
	exports.reconstructFrontmatter = reconstructFrontmatter;
	exports.spliceFrontmatter = spliceFrontmatter;
	exports.parseMustHavesBlock = parseMustHavesBlock;
	exports.cmdFrontmatterGet = cmdFrontmatterGet;
	exports.cmdFrontmatterSet = cmdFrontmatterSet;
	exports.cmdFrontmatterMerge = cmdFrontmatterMerge;
	exports.cmdFrontmatterValidate = cmdFrontmatterValidate;
	const node_fs_1$9 = __importDefault(require("node:fs"));
	const node_path_1$9 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	/**
	* Extract YAML frontmatter from markdown content into a typed object.
	*/
	function extractFrontmatter(content) {
		const frontmatter = {};
		const match = content.match(/^---\n([\s\S]+?)\n---/);
		if (!match) return frontmatter;
		const lines = match[1].split("\n");
		const stack = [{
			obj: frontmatter,
			key: null,
			indent: -1
		}];
		for (const line of lines) {
			if (line.trim() === "") continue;
			const indentMatch = line.match(/^(\s*)/);
			const indent = indentMatch ? indentMatch[1].length : 0;
			while (stack.length > 1 && indent <= stack[stack.length - 1].indent) stack.pop();
			const current = stack[stack.length - 1];
			const keyMatch = line.match(/^(\s*)([a-zA-Z0-9_-]+):\s*(.*)/);
			if (keyMatch) {
				const key = keyMatch[2];
				const value = keyMatch[3].trim();
				if (value === "" || value === "[") {
					const newObj = value === "[" ? [] : {};
					current.obj[key] = newObj;
					current.key = null;
					stack.push({
						obj: newObj,
						key: null,
						indent
					});
				} else if (value.startsWith("[") && value.endsWith("]")) {
					current.obj[key] = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, "")).filter(Boolean);
					current.key = null;
				} else {
					current.obj[key] = value.replace(/^["']|["']$/g, "");
					current.key = null;
				}
			} else if (line.trim().startsWith("- ")) {
				const itemValue = line.trim().slice(2).replace(/^["']|["']$/g, "");
				if (typeof current.obj === "object" && !Array.isArray(current.obj) && Object.keys(current.obj).length === 0) {
					const parent = stack.length > 1 ? stack[stack.length - 2] : null;
					if (parent && !Array.isArray(parent.obj)) {
						for (const k of Object.keys(parent.obj)) if (parent.obj[k] === current.obj) {
							const arr = [itemValue];
							parent.obj[k] = arr;
							current.obj = arr;
							break;
						}
					}
				} else if (Array.isArray(current.obj)) current.obj.push(itemValue);
			}
		}
		return frontmatter;
	}
	/**
	* Reconstruct YAML frontmatter string from an object.
	*/
	function reconstructFrontmatter(obj) {
		const lines = [];
		for (const [key, value] of Object.entries(obj)) {
			if (value === null || value === void 0) continue;
			if (Array.isArray(value)) formatArray(lines, key, value, 0);
			else if (typeof value === "object") {
				lines.push(`${key}:`);
				for (const [subkey, subval] of Object.entries(value)) {
					if (subval === null || subval === void 0) continue;
					if (Array.isArray(subval)) formatArray(lines, subkey, subval, 2);
					else if (typeof subval === "object") {
						lines.push(`  ${subkey}:`);
						for (const [subsubkey, subsubval] of Object.entries(subval)) {
							if (subsubval === null || subsubval === void 0) continue;
							if (Array.isArray(subsubval)) if (subsubval.length === 0) lines.push(`    ${subsubkey}: []`);
							else {
								lines.push(`    ${subsubkey}:`);
								for (const item of subsubval) lines.push(`      - ${item}`);
							}
							else lines.push(`    ${subsubkey}: ${subsubval}`);
						}
					} else {
						const sv = String(subval);
						lines.push(`  ${subkey}: ${sv.includes(":") || sv.includes("#") ? `"${sv}"` : sv}`);
					}
				}
			} else {
				const sv = String(value);
				if (sv.includes(":") || sv.includes("#") || sv.startsWith("[") || sv.startsWith("{")) lines.push(`${key}: "${sv}"`);
				else lines.push(`${key}: ${sv}`);
			}
		}
		return lines.join("\n");
	}
	function formatArray(lines, key, value, indentLevel) {
		const prefix = " ".repeat(indentLevel);
		if (value.length === 0) lines.push(`${prefix}${key}: []`);
		else if (value.every((v) => typeof v === "string") && value.length <= 3 && value.join(", ").length < 60) lines.push(`${prefix}${key}: [${value.join(", ")}]`);
		else {
			lines.push(`${prefix}${key}:`);
			for (const item of value) {
				const itemStr = String(item);
				lines.push(`${prefix}  - ${typeof item === "string" && (itemStr.includes(":") || itemStr.includes("#")) ? `"${itemStr}"` : itemStr}`);
			}
		}
	}
	/**
	* Replace or insert frontmatter in markdown content.
	*/
	function spliceFrontmatter(content, newObj) {
		const yamlStr = reconstructFrontmatter(newObj);
		const match = content.match(/^---\n[\s\S]+?\n---/);
		if (match) return `---\n${yamlStr}\n---` + content.slice(match[0].length);
		return `---\n${yamlStr}\n---\n\n` + content;
	}
	/**
	* Parse a specific block from must_haves in raw frontmatter YAML.
	*/
	function parseMustHavesBlock(content, blockName) {
		const fmMatch = content.match(/^---\n([\s\S]+?)\n---/);
		if (!fmMatch) return [];
		const yaml = fmMatch[1];
		const blockPattern = new RegExp(`^\\s{4}${blockName}:\\s*$`, "m");
		const blockStart = yaml.search(blockPattern);
		if (blockStart === -1) return [];
		const blockLines = yaml.slice(blockStart).split("\n").slice(1);
		const items = [];
		let current = null;
		for (const line of blockLines) {
			if (line.trim() === "") continue;
			if (line.match(/^(\s*)/)[1].length <= 4 && line.trim() !== "") break;
			if (line.match(/^\s{6}-\s+/)) {
				if (current !== null) items.push(current);
				current = {};
				const simpleMatch = line.match(/^\s{6}-\s+"?([^"]+)"?\s*$/);
				if (simpleMatch && !line.includes(":")) current = simpleMatch[1];
				else {
					const kvMatch = line.match(/^\s{6}-\s+(\w+):\s*"?([^"]*)"?\s*$/);
					if (kvMatch) current = { [kvMatch[1]]: kvMatch[2] };
				}
			} else if (current !== null && typeof current === "object") {
				const kvMatch = line.match(/^\s{8,}(\w+):\s*"?([^"]*)"?\s*$/);
				if (kvMatch) {
					const val = kvMatch[2];
					current[kvMatch[1]] = /^\d+$/.test(val) ? parseInt(val, 10) : val;
				}
				const arrMatch = line.match(/^\s{10,}-\s+"?([^"]+)"?\s*$/);
				if (arrMatch) {
					const keys = Object.keys(current);
					const lastKey = keys[keys.length - 1];
					if (lastKey && !Array.isArray(current[lastKey])) current[lastKey] = current[lastKey] ? [String(current[lastKey])] : [];
					if (lastKey) current[lastKey].push(arrMatch[1]);
				}
			}
		}
		if (current !== null) items.push(current);
		return items;
	}
	exports.FRONTMATTER_SCHEMAS = {
		plan: { required: [
			"phase",
			"plan",
			"type",
			"wave",
			"depends_on",
			"files_modified",
			"autonomous",
			"must_haves"
		] },
		summary: { required: [
			"phase",
			"plan",
			"subsystem",
			"tags",
			"duration",
			"completed"
		] },
		verification: { required: [
			"phase",
			"verified",
			"status",
			"score"
		] }
	};
	function cmdFrontmatterGet(cwd, filePath, field, raw) {
		if (!filePath) (0, core_js_1.error)("file path required");
		const fullPath = node_path_1$9.default.isAbsolute(filePath) ? filePath : node_path_1$9.default.join(cwd, filePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const fm = extractFrontmatter(content);
		if (field) {
			const value = fm[field];
			if (value === void 0) {
				(0, core_js_1.output)({
					error: "Field not found",
					field
				}, raw);
				return;
			}
			(0, core_js_1.output)({ [field]: value }, raw, JSON.stringify(value));
		} else (0, core_js_1.output)(fm, raw);
	}
	function cmdFrontmatterSet(cwd, filePath, field, value, raw) {
		if (!filePath || !field || value === void 0) (0, core_js_1.error)("file, field, and value required");
		const fullPath = node_path_1$9.default.isAbsolute(filePath) ? filePath : node_path_1$9.default.join(cwd, filePath);
		if (!node_fs_1$9.default.existsSync(fullPath)) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const content = node_fs_1$9.default.readFileSync(fullPath, "utf-8");
		const fm = extractFrontmatter(content);
		let parsedValue;
		try {
			parsedValue = JSON.parse(value);
		} catch {
			parsedValue = value;
		}
		fm[field] = parsedValue;
		const newContent = spliceFrontmatter(content, fm);
		node_fs_1$9.default.writeFileSync(fullPath, newContent, "utf-8");
		(0, core_js_1.output)({
			updated: true,
			field,
			value: parsedValue
		}, raw, "true");
	}
	function cmdFrontmatterMerge(cwd, filePath, data, raw) {
		if (!filePath || !data) (0, core_js_1.error)("file and data required");
		const fullPath = node_path_1$9.default.isAbsolute(filePath) ? filePath : node_path_1$9.default.join(cwd, filePath);
		if (!node_fs_1$9.default.existsSync(fullPath)) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const content = node_fs_1$9.default.readFileSync(fullPath, "utf-8");
		const fm = extractFrontmatter(content);
		let mergeData;
		try {
			mergeData = JSON.parse(data);
		} catch {
			(0, core_js_1.error)("Invalid JSON for --data");
			return;
		}
		Object.assign(fm, mergeData);
		const newContent = spliceFrontmatter(content, fm);
		node_fs_1$9.default.writeFileSync(fullPath, newContent, "utf-8");
		(0, core_js_1.output)({
			merged: true,
			fields: Object.keys(mergeData)
		}, raw, "true");
	}
	function cmdFrontmatterValidate(cwd, filePath, schemaName, raw) {
		if (!filePath || !schemaName) (0, core_js_1.error)("file and schema required");
		const schema = exports.FRONTMATTER_SCHEMAS[schemaName];
		if (!schema) (0, core_js_1.error)(`Unknown schema: ${schemaName}. Available: ${Object.keys(exports.FRONTMATTER_SCHEMAS).join(", ")}`);
		const fullPath = node_path_1$9.default.isAbsolute(filePath) ? filePath : node_path_1$9.default.join(cwd, filePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const fm = extractFrontmatter(content);
		const missing = schema.required.filter((f) => fm[f] === void 0);
		const present = schema.required.filter((f) => fm[f] !== void 0);
		const result = {
			valid: missing.length === 0,
			missing,
			present,
			schema: schemaName
		};
		(0, core_js_1.output)(result, raw, missing.length === 0 ? "valid" : "invalid");
	}
}));

//#endregion
//#region ../core/dist/config.js
var require_config = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Config  Planning config CRUD operations
	*
	* Ported from maxsim/bin/lib/config.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdConfigEnsureSection = cmdConfigEnsureSection;
	exports.cmdConfigSet = cmdConfigSet;
	exports.cmdConfigGet = cmdConfigGet;
	const node_fs_1$8 = __importDefault(require("node:fs"));
	const node_path_1$8 = __importDefault(require("node:path"));
	const node_os_1$1 = __importDefault(require("node:os"));
	const core_js_1 = require_core();
	const types_js_1 = require_types();
	function cmdConfigEnsureSection(cwd, raw) {
		const configPath = node_path_1$8.default.join(cwd, ".planning", "config.json");
		const planningDir = node_path_1$8.default.join(cwd, ".planning");
		try {
			if (!node_fs_1$8.default.existsSync(planningDir)) node_fs_1$8.default.mkdirSync(planningDir, { recursive: true });
		} catch (err) {
			(0, core_js_1.error)("Failed to create .planning directory: " + err.message);
		}
		if (node_fs_1$8.default.existsSync(configPath)) {
			(0, core_js_1.output)({
				created: false,
				reason: "already_exists"
			}, raw, "exists");
			return;
		}
		const homedir = node_os_1$1.default.homedir();
		const braveKeyFile = node_path_1$8.default.join(homedir, ".maxsim", "brave_api_key");
		const hasBraveSearch = !!(process.env.BRAVE_API_KEY || node_fs_1$8.default.existsSync(braveKeyFile));
		const globalDefaultsPath = node_path_1$8.default.join(homedir, ".maxsim", "defaults.json");
		let userDefaults = {};
		try {
			if (node_fs_1$8.default.existsSync(globalDefaultsPath)) userDefaults = JSON.parse(node_fs_1$8.default.readFileSync(globalDefaultsPath, "utf-8"));
		} catch {}
		const hardcoded = {
			...types_js_1.PLANNING_CONFIG_DEFAULTS,
			brave_search: hasBraveSearch
		};
		const defaults = {
			...hardcoded,
			...userDefaults,
			workflow: {
				...hardcoded.workflow,
				...userDefaults.workflow || {}
			}
		};
		try {
			node_fs_1$8.default.writeFileSync(configPath, JSON.stringify(defaults, null, 2), "utf-8");
			(0, core_js_1.output)({
				created: true,
				path: ".planning/config.json"
			}, raw, "created");
		} catch (err) {
			(0, core_js_1.error)("Failed to create config.json: " + err.message);
		}
	}
	function cmdConfigSet(cwd, keyPath, value, raw) {
		const configPath = node_path_1$8.default.join(cwd, ".planning", "config.json");
		if (!keyPath) (0, core_js_1.error)("Usage: config-set <key.path> <value>");
		let parsedValue = value;
		if (value === "true") parsedValue = true;
		else if (value === "false") parsedValue = false;
		else if (value !== void 0 && !isNaN(Number(value)) && value !== "") parsedValue = Number(value);
		let config = {};
		try {
			if (node_fs_1$8.default.existsSync(configPath)) config = JSON.parse(node_fs_1$8.default.readFileSync(configPath, "utf-8"));
		} catch (err) {
			(0, core_js_1.error)("Failed to read config.json: " + err.message);
		}
		const keys = keyPath.split(".");
		let current = config;
		for (let i = 0; i < keys.length - 1; i++) {
			const key = keys[i];
			if (current[key] === void 0 || typeof current[key] !== "object") current[key] = {};
			current = current[key];
		}
		current[keys[keys.length - 1]] = parsedValue;
		try {
			node_fs_1$8.default.writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
			const result = {
				updated: true,
				key: keyPath,
				value: parsedValue
			};
			(0, core_js_1.output)(result, raw, `${keyPath}=${parsedValue}`);
		} catch (err) {
			(0, core_js_1.error)("Failed to write config.json: " + err.message);
		}
	}
	function cmdConfigGet(cwd, keyPath, raw) {
		const configPath = node_path_1$8.default.join(cwd, ".planning", "config.json");
		if (!keyPath) (0, core_js_1.error)("Usage: config-get <key.path>");
		let config = {};
		try {
			if (node_fs_1$8.default.existsSync(configPath)) config = JSON.parse(node_fs_1$8.default.readFileSync(configPath, "utf-8"));
			else (0, core_js_1.error)("No config.json found at " + configPath);
		} catch (err) {
			if (err.message.startsWith("No config.json")) throw err;
			(0, core_js_1.error)("Failed to read config.json: " + err.message);
		}
		const keys = keyPath.split(".");
		let current = config;
		for (const key of keys) {
			if (current === void 0 || current === null || typeof current !== "object") (0, core_js_1.error)(`Key not found: ${keyPath}`);
			current = current[key];
		}
		if (current === void 0) (0, core_js_1.error)(`Key not found: ${keyPath}`);
		(0, core_js_1.output)(current, raw, String(current));
	}
}));

//#endregion
//#region ../core/dist/state.js
var require_state = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* State  STATE.md operations and progression engine
	*
	* Ported from maxsim/bin/lib/state.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.stateExtractField = stateExtractField;
	exports.stateReplaceField = stateReplaceField;
	exports.cmdStateLoad = cmdStateLoad;
	exports.cmdStateGet = cmdStateGet;
	exports.cmdStatePatch = cmdStatePatch;
	exports.cmdStateUpdate = cmdStateUpdate;
	exports.cmdStateAdvancePlan = cmdStateAdvancePlan;
	exports.cmdStateRecordMetric = cmdStateRecordMetric;
	exports.cmdStateUpdateProgress = cmdStateUpdateProgress;
	exports.cmdStateAddDecision = cmdStateAddDecision;
	exports.cmdStateAddBlocker = cmdStateAddBlocker;
	exports.cmdStateResolveBlocker = cmdStateResolveBlocker;
	exports.cmdStateRecordSession = cmdStateRecordSession;
	exports.cmdStateSnapshot = cmdStateSnapshot;
	const node_fs_1$7 = __importDefault(require("node:fs"));
	const node_path_1$7 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	function escapeRegex(str) {
		return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	}
	function stateExtractField(content, fieldName) {
		const pattern = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, "i");
		const match = content.match(pattern);
		return match ? match[1].trim() : null;
	}
	function stateReplaceField(content, fieldName, newValue) {
		const escaped = escapeRegex(fieldName);
		const pattern = new RegExp(`(\\*\\*${escaped}:\\*\\*\\s*)(.*)`, "i");
		if (pattern.test(content)) return content.replace(pattern, (_match, prefix) => `${prefix}${newValue}`);
		return null;
	}
	function readTextArgOrFile(cwd, value, filePath, label) {
		if (!filePath) return value;
		const resolvedPath = node_path_1$7.default.isAbsolute(filePath) ? filePath : node_path_1$7.default.join(cwd, filePath);
		try {
			return node_fs_1$7.default.readFileSync(resolvedPath, "utf-8").trimEnd();
		} catch {
			throw new Error(`${label} file not found: ${filePath}`);
		}
	}
	function cmdStateLoad(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const planningDir = node_path_1$7.default.join(cwd, ".planning");
		let stateRaw = "";
		try {
			stateRaw = node_fs_1$7.default.readFileSync(node_path_1$7.default.join(planningDir, "STATE.md"), "utf-8");
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const configExists = node_fs_1$7.default.existsSync(node_path_1$7.default.join(planningDir, "config.json"));
		const roadmapExists = node_fs_1$7.default.existsSync(node_path_1$7.default.join(planningDir, "ROADMAP.md"));
		const stateExists = stateRaw.length > 0;
		const result = {
			config,
			state_raw: stateRaw,
			state_exists: stateExists,
			roadmap_exists: roadmapExists,
			config_exists: configExists
		};
		if (raw) {
			const c = config;
			const lines = [
				`model_profile=${c.model_profile}`,
				`commit_docs=${c.commit_docs}`,
				`branching_strategy=${c.branching_strategy}`,
				`phase_branch_template=${c.phase_branch_template}`,
				`milestone_branch_template=${c.milestone_branch_template}`,
				`parallelization=${c.parallelization}`,
				`research=${c.research}`,
				`plan_checker=${c.plan_checker}`,
				`verifier=${c.verifier}`,
				`config_exists=${configExists}`,
				`roadmap_exists=${roadmapExists}`,
				`state_exists=${stateExists}`
			];
			process.stdout.write(lines.join("\n"));
			process.exit(0);
		}
		(0, core_js_1.output)(result);
	}
	function cmdStateGet(cwd, section, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		try {
			const content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
			if (!section) {
				(0, core_js_1.output)({ content }, raw, content);
				return;
			}
			const fieldEscaped = escapeRegex(section);
			const fieldPattern = new RegExp(`\\*\\*${fieldEscaped}:\\*\\*\\s*(.*)`, "i");
			const fieldMatch = content.match(fieldPattern);
			if (fieldMatch) {
				(0, core_js_1.output)({ [section]: fieldMatch[1].trim() }, raw, fieldMatch[1].trim());
				return;
			}
			const sectionPattern = new RegExp(`##\\s*${fieldEscaped}\\s*\n([\\s\\S]*?)(?=\\n##|$)`, "i");
			const sectionMatch = content.match(sectionPattern);
			if (sectionMatch) {
				(0, core_js_1.output)({ [section]: sectionMatch[1].trim() }, raw, sectionMatch[1].trim());
				return;
			}
			(0, core_js_1.output)({ error: `Section or field "${section}" not found` }, raw, "");
		} catch {
			(0, core_js_1.error)("STATE.md not found");
		}
	}
	function cmdStatePatch(cwd, patches, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		try {
			let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
			const results = {
				updated: [],
				failed: []
			};
			for (const [field, value] of Object.entries(patches)) {
				const fieldEscaped = escapeRegex(field);
				const pattern = new RegExp(`(\\*\\*${fieldEscaped}:\\*\\*\\s*)(.*)`, "i");
				if (pattern.test(content)) {
					content = content.replace(pattern, (_match, prefix) => `${prefix}${value}`);
					results.updated.push(field);
				} else results.failed.push(field);
			}
			if (results.updated.length > 0) node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)(results, raw, results.updated.length > 0 ? "true" : "false");
		} catch {
			(0, core_js_1.error)("STATE.md not found");
		}
	}
	function cmdStateUpdate(cwd, field, value) {
		if (!field || value === void 0) (0, core_js_1.error)("field and value required for state update");
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		try {
			let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
			const fieldEscaped = escapeRegex(field);
			const pattern = new RegExp(`(\\*\\*${fieldEscaped}:\\*\\*\\s*)(.*)`, "i");
			if (pattern.test(content)) {
				content = content.replace(pattern, (_match, prefix) => `${prefix}${value}`);
				node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
				(0, core_js_1.output)({ updated: true });
			} else (0, core_js_1.output)({
				updated: false,
				reason: `Field "${field}" not found in STATE.md`
			});
		} catch {
			(0, core_js_1.output)({
				updated: false,
				reason: "STATE.md not found"
			});
		}
	}
	function cmdStateAdvancePlan(cwd, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const currentPlan = parseInt(stateExtractField(content, "Current Plan") ?? "", 10);
		const totalPlans = parseInt(stateExtractField(content, "Total Plans in Phase") ?? "", 10);
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		if (isNaN(currentPlan) || isNaN(totalPlans)) {
			(0, core_js_1.output)({ error: "Cannot parse Current Plan or Total Plans in Phase from STATE.md" }, raw);
			return;
		}
		if (currentPlan >= totalPlans) {
			content = stateReplaceField(content, "Status", "Phase complete  ready for verification") || content;
			content = stateReplaceField(content, "Last Activity", today) || content;
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				advanced: false,
				reason: "last_plan",
				current_plan: currentPlan,
				total_plans: totalPlans,
				status: "ready_for_verification"
			}, raw, "false");
		} else {
			const newPlan = currentPlan + 1;
			content = stateReplaceField(content, "Current Plan", String(newPlan)) || content;
			content = stateReplaceField(content, "Status", "Ready to execute") || content;
			content = stateReplaceField(content, "Last Activity", today) || content;
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				advanced: true,
				previous_plan: currentPlan,
				current_plan: newPlan,
				total_plans: totalPlans
			}, raw, "true");
		}
	}
	function cmdStateRecordMetric(cwd, options, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const { phase, plan, duration, tasks, files } = options;
		if (!phase || !plan || !duration) {
			(0, core_js_1.output)({ error: "phase, plan, and duration required" }, raw);
			return;
		}
		const metricsPattern = /(##\s*Performance Metrics[\s\S]*?\n\|[^\n]+\n\|[-|\s]+\n)([\s\S]*?)(?=\n##|\n$|$)/i;
		const metricsMatch = content.match(metricsPattern);
		if (metricsMatch) {
			let tableBody = metricsMatch[2].trimEnd();
			const newRow = `| Phase ${phase} P${plan} | ${duration} | ${tasks || "-"} tasks | ${files || "-"} files |`;
			if (tableBody.trim() === "" || tableBody.includes("None yet")) tableBody = newRow;
			else tableBody = tableBody + "\n" + newRow;
			content = content.replace(metricsPattern, (_match, header) => `${header}${tableBody}\n`);
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				recorded: true,
				phase,
				plan,
				duration
			}, raw, "true");
		} else (0, core_js_1.output)({
			recorded: false,
			reason: "Performance Metrics section not found in STATE.md"
		}, raw, "false");
	}
	function cmdStateUpdateProgress(cwd, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const phasesDir = node_path_1$7.default.join(cwd, ".planning", "phases");
		let totalPlans = 0;
		let totalSummaries = 0;
		if (node_fs_1$7.default.existsSync(phasesDir)) {
			const phaseDirs = node_fs_1$7.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			for (const dir of phaseDirs) {
				const files = node_fs_1$7.default.readdirSync(node_path_1$7.default.join(phasesDir, dir));
				totalPlans += files.filter((f) => f.match(/-PLAN\.md$/i)).length;
				totalSummaries += files.filter((f) => f.match(/-SUMMARY\.md$/i)).length;
			}
		}
		const percent = totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0;
		const barWidth = 10;
		const filled = Math.round(percent / 100 * barWidth);
		const progressStr = `[${"".repeat(filled) + "".repeat(barWidth - filled)}] ${percent}%`;
		const progressPattern = /(\*\*Progress:\*\*\s*).*/i;
		if (progressPattern.test(content)) {
			content = content.replace(progressPattern, (_match, prefix) => `${prefix}${progressStr}`);
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				updated: true,
				percent,
				completed: totalSummaries,
				total: totalPlans,
				bar: progressStr
			}, raw, progressStr);
		} else (0, core_js_1.output)({
			updated: false,
			reason: "Progress field not found in STATE.md"
		}, raw, "false");
	}
	function cmdStateAddDecision(cwd, options, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		const { phase, summary, summary_file, rationale, rationale_file } = options;
		let summaryText;
		let rationaleText = "";
		try {
			summaryText = readTextArgOrFile(cwd, summary, summary_file, "summary");
			rationaleText = readTextArgOrFile(cwd, rationale || "", rationale_file, "rationale") || "";
		} catch (thrown) {
			const e = thrown;
			(0, core_js_1.output)({
				added: false,
				reason: e.message
			}, raw, "false");
			return;
		}
		if (!summaryText) {
			(0, core_js_1.output)({ error: "summary required" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const entry = `- [Phase ${phase || "?"}]: ${summaryText}${rationaleText ? `  ${rationaleText}` : ""}`;
		const sectionPattern = /(###?\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
		const match = content.match(sectionPattern);
		if (match) {
			let sectionBody = match[2];
			sectionBody = sectionBody.replace(/None yet\.?\s*\n?/gi, "").replace(/No decisions yet\.?\s*\n?/gi, "");
			sectionBody = sectionBody.trimEnd() + "\n" + entry + "\n";
			content = content.replace(sectionPattern, (_match, header) => `${header}${sectionBody}`);
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				added: true,
				decision: entry
			}, raw, "true");
		} else (0, core_js_1.output)({
			added: false,
			reason: "Decisions section not found in STATE.md"
		}, raw, "false");
	}
	function cmdStateAddBlocker(cwd, text, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		const blockerOptions = typeof text === "object" && text !== null ? text : { text };
		let blockerText;
		try {
			blockerText = readTextArgOrFile(cwd, blockerOptions.text, blockerOptions.text_file, "blocker");
		} catch (thrown) {
			const e = thrown;
			(0, core_js_1.output)({
				added: false,
				reason: e.message
			}, raw, "false");
			return;
		}
		if (!blockerText) {
			(0, core_js_1.output)({ error: "text required" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const entry = `- ${blockerText}`;
		const sectionPattern = /(###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
		const match = content.match(sectionPattern);
		if (match) {
			let sectionBody = match[2];
			sectionBody = sectionBody.replace(/None\.?\s*\n?/gi, "").replace(/None yet\.?\s*\n?/gi, "");
			sectionBody = sectionBody.trimEnd() + "\n" + entry + "\n";
			content = content.replace(sectionPattern, (_match, header) => `${header}${sectionBody}`);
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				added: true,
				blocker: blockerText
			}, raw, "true");
		} else (0, core_js_1.output)({
			added: false,
			reason: "Blockers section not found in STATE.md"
		}, raw, "false");
	}
	function cmdStateResolveBlocker(cwd, text, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		if (!text) {
			(0, core_js_1.output)({ error: "text required" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const sectionPattern = /(###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i;
		const match = content.match(sectionPattern);
		if (match) {
			let newBody = match[2].split("\n").filter((line) => {
				if (!line.startsWith("- ")) return true;
				return !line.toLowerCase().includes(text.toLowerCase());
			}).join("\n");
			if (!newBody.trim() || !newBody.includes("- ")) newBody = "None\n";
			content = content.replace(sectionPattern, (_match, header) => `${header}${newBody}`);
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				resolved: true,
				blocker: text
			}, raw, "true");
		} else (0, core_js_1.output)({
			resolved: false,
			reason: "Blockers section not found in STATE.md"
		}, raw, "false");
	}
	function cmdStateRecordSession(cwd, options, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		let content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const now = (/* @__PURE__ */ new Date()).toISOString();
		const updated = [];
		let result = stateReplaceField(content, "Last session", now);
		if (result) {
			content = result;
			updated.push("Last session");
		}
		result = stateReplaceField(content, "Last Date", now);
		if (result) {
			content = result;
			updated.push("Last Date");
		}
		if (options.stopped_at) {
			result = stateReplaceField(content, "Stopped At", options.stopped_at);
			if (!result) result = stateReplaceField(content, "Stopped at", options.stopped_at);
			if (result) {
				content = result;
				updated.push("Stopped At");
			}
		}
		const resumeFile = options.resume_file || "None";
		result = stateReplaceField(content, "Resume File", resumeFile);
		if (!result) result = stateReplaceField(content, "Resume file", resumeFile);
		if (result) {
			content = result;
			updated.push("Resume File");
		}
		if (updated.length > 0) {
			node_fs_1$7.default.writeFileSync(statePath, content, "utf-8");
			(0, core_js_1.output)({
				recorded: true,
				updated
			}, raw, "true");
		} else (0, core_js_1.output)({
			recorded: false,
			reason: "No session fields found in STATE.md"
		}, raw, "false");
	}
	function cmdStateSnapshot(cwd, raw) {
		const statePath = node_path_1$7.default.join(cwd, ".planning", "STATE.md");
		if (!node_fs_1$7.default.existsSync(statePath)) {
			(0, core_js_1.output)({ error: "STATE.md not found" }, raw);
			return;
		}
		const content = node_fs_1$7.default.readFileSync(statePath, "utf-8");
		const extractField = (fieldName) => {
			const pattern = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, "i");
			const match = content.match(pattern);
			return match ? match[1].trim() : null;
		};
		const currentPhase = extractField("Current Phase");
		const currentPhaseName = extractField("Current Phase Name");
		const totalPhasesRaw = extractField("Total Phases");
		const currentPlan = extractField("Current Plan");
		const totalPlansRaw = extractField("Total Plans in Phase");
		const status = extractField("Status");
		const progressRaw = extractField("Progress");
		const lastActivity = extractField("Last Activity");
		const lastActivityDesc = extractField("Last Activity Description");
		const pausedAt = extractField("Paused At");
		const totalPhases = totalPhasesRaw ? parseInt(totalPhasesRaw, 10) : null;
		const totalPlansInPhase = totalPlansRaw ? parseInt(totalPlansRaw, 10) : null;
		const progressPercent = progressRaw ? parseInt(progressRaw.replace("%", ""), 10) : null;
		const decisions = [];
		const decisionsMatch = content.match(/##\s*Decisions Made[\s\S]*?\n\|[^\n]+\n\|[-|\s]+\n([\s\S]*?)(?=\n##|\n$|$)/i);
		if (decisionsMatch) {
			const rows = decisionsMatch[1].trim().split("\n").filter((r) => r.includes("|"));
			for (const row of rows) {
				const cells = row.split("|").map((c) => c.trim()).filter(Boolean);
				if (cells.length >= 3) decisions.push({
					phase: cells[0],
					summary: cells[1],
					rationale: cells[2]
				});
			}
		}
		const blockers = [];
		const blockersMatch = content.match(/##\s*Blockers\s*\n([\s\S]*?)(?=\n##|$)/i);
		if (blockersMatch) {
			const items = blockersMatch[1].match(/^-\s+(.+)$/gm) || [];
			for (const item of items) blockers.push(item.replace(/^-\s+/, "").trim());
		}
		const session = {
			last_date: null,
			stopped_at: null,
			resume_file: null
		};
		const sessionMatch = content.match(/##\s*Session\s*\n([\s\S]*?)(?=\n##|$)/i);
		if (sessionMatch) {
			const sessionSection = sessionMatch[1];
			const lastDateMatch = sessionSection.match(/\*\*Last Date:\*\*\s*(.+)/i);
			const stoppedAtMatch = sessionSection.match(/\*\*Stopped At:\*\*\s*(.+)/i);
			const resumeFileMatch = sessionSection.match(/\*\*Resume File:\*\*\s*(.+)/i);
			if (lastDateMatch) session.last_date = lastDateMatch[1].trim();
			if (stoppedAtMatch) session.stopped_at = stoppedAtMatch[1].trim();
			if (resumeFileMatch) session.resume_file = resumeFileMatch[1].trim();
		}
		const snapshot = {
			current_phase: currentPhase,
			current_phase_name: currentPhaseName,
			total_phases: totalPhases,
			current_plan: currentPlan,
			total_plans_in_phase: totalPlansInPhase,
			status,
			progress_percent: progressPercent,
			last_activity: lastActivity,
			last_activity_desc: lastActivityDesc,
			decisions,
			blockers,
			paused_at: pausedAt,
			session
		};
		(0, core_js_1.output)(snapshot, raw);
	}
}));

//#endregion
//#region ../core/dist/roadmap.js
var require_roadmap = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Roadmap  Roadmap parsing and update operations
	*
	* Ported from maxsim/bin/lib/roadmap.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdRoadmapGetPhase = cmdRoadmapGetPhase;
	exports.cmdRoadmapAnalyze = cmdRoadmapAnalyze;
	exports.cmdRoadmapUpdatePlanProgress = cmdRoadmapUpdatePlanProgress;
	const node_fs_1$6 = __importDefault(require("node:fs"));
	const node_path_1$6 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	function cmdRoadmapGetPhase(cwd, phaseNum, raw) {
		const roadmapPath = node_path_1$6.default.join(cwd, ".planning", "ROADMAP.md");
		if (!node_fs_1$6.default.existsSync(roadmapPath)) {
			(0, core_js_1.output)({
				found: false,
				error: "ROADMAP.md not found"
			}, raw, "");
			return;
		}
		try {
			const content = node_fs_1$6.default.readFileSync(roadmapPath, "utf-8");
			const escapedPhase = phaseNum.replace(/\./g, "\\.");
			const phasePattern = (0, core_js_1.getPhasePattern)(escapedPhase, "i");
			const headerMatch = content.match(phasePattern);
			if (!headerMatch) {
				const checklistPattern = new RegExp(`-\\s*\\[[ x]\\]\\s*\\*\\*Phase\\s+${escapedPhase}:\\s*([^*]+)\\*\\*`, "i");
				const checklistMatch = content.match(checklistPattern);
				if (checklistMatch) {
					(0, core_js_1.output)({
						found: false,
						phase_number: phaseNum,
						phase_name: checklistMatch[1].trim(),
						error: "malformed_roadmap",
						message: `Phase ${phaseNum} exists in summary list but missing "### Phase ${phaseNum}:" detail section. ROADMAP.md needs both formats.`
					}, raw, "");
					return;
				}
				(0, core_js_1.output)({
					found: false,
					phase_number: phaseNum
				}, raw, "");
				return;
			}
			const phaseName = headerMatch[1].trim();
			const headerIndex = headerMatch.index;
			const nextHeaderMatch = content.slice(headerIndex).match(/\n#{2,4}\s+Phase\s+\d/i);
			const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index : content.length;
			const section = content.slice(headerIndex, sectionEnd).trim();
			const goalMatch = section.match(/\*\*Goal:\*\*\s*([^\n]+)/i);
			const goal = goalMatch ? goalMatch[1].trim() : null;
			const criteriaMatch = section.match(/\*\*Success Criteria\*\*[^\n]*:\s*\n((?:\s*\d+\.\s*[^\n]+\n?)+)/i);
			const success_criteria = criteriaMatch ? criteriaMatch[1].trim().split("\n").map((line) => line.replace(/^\s*\d+\.\s*/, "").trim()).filter(Boolean) : [];
			(0, core_js_1.output)({
				found: true,
				phase_number: phaseNum,
				phase_name: phaseName,
				goal,
				success_criteria,
				section
			}, raw, section);
		} catch (e) {
			(0, core_js_1.error)("Failed to read ROADMAP.md: " + e.message);
		}
	}
	function cmdRoadmapAnalyze(cwd, raw) {
		const roadmapPath = node_path_1$6.default.join(cwd, ".planning", "ROADMAP.md");
		if (!node_fs_1$6.default.existsSync(roadmapPath)) {
			(0, core_js_1.output)({
				error: "ROADMAP.md not found",
				milestones: [],
				phases: [],
				current_phase: null
			}, raw);
			return;
		}
		const content = node_fs_1$6.default.readFileSync(roadmapPath, "utf-8");
		const phasesDir = node_path_1$6.default.join(cwd, ".planning", "phases");
		const phasePattern = (0, core_js_1.getPhasePattern)();
		const phases = [];
		let match;
		while ((match = phasePattern.exec(content)) !== null) {
			const phaseNum = match[1];
			const phaseName = match[2].replace(/\(INSERTED\)/i, "").trim();
			const sectionStart = match.index;
			const nextHeader = content.slice(sectionStart).match(/\n#{2,4}\s+Phase\s+\d/i);
			const sectionEnd = nextHeader ? sectionStart + nextHeader.index : content.length;
			const section = content.slice(sectionStart, sectionEnd);
			const goalMatch = section.match(/\*\*Goal:\*\*\s*([^\n]+)/i);
			const goal = goalMatch ? goalMatch[1].trim() : null;
			const dependsMatch = section.match(/\*\*Depends on:\*\*\s*([^\n]+)/i);
			const depends_on = dependsMatch ? dependsMatch[1].trim() : null;
			const normalized = (0, core_js_1.normalizePhaseName)(phaseNum);
			let diskStatus = "no_directory";
			let planCount = 0;
			let summaryCount = 0;
			let hasContext = false;
			let hasResearch = false;
			try {
				const dirMatch = node_fs_1$6.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).find((d) => d.startsWith(normalized + "-") || d === normalized);
				if (dirMatch) {
					const phaseFiles = node_fs_1$6.default.readdirSync(node_path_1$6.default.join(phasesDir, dirMatch));
					planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
					summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
					hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
					hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
					if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
					else if (summaryCount > 0) diskStatus = "partial";
					else if (planCount > 0) diskStatus = "planned";
					else if (hasResearch) diskStatus = "researched";
					else if (hasContext) diskStatus = "discussed";
					else diskStatus = "empty";
				}
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
			const checkboxPattern = new RegExp(`-\\s*\\[(x| )\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}`, "i");
			const checkboxMatch = content.match(checkboxPattern);
			const roadmapComplete = checkboxMatch ? checkboxMatch[1] === "x" : false;
			phases.push({
				number: phaseNum,
				name: phaseName,
				goal,
				depends_on,
				plan_count: planCount,
				summary_count: summaryCount,
				has_context: hasContext,
				has_research: hasResearch,
				disk_status: diskStatus,
				roadmap_complete: roadmapComplete
			});
		}
		const milestones = [];
		const milestonePattern = /##\s*(.*v(\d+\.\d+)[^(\n]*)/gi;
		let mMatch;
		while ((mMatch = milestonePattern.exec(content)) !== null) milestones.push({
			heading: mMatch[1].trim(),
			version: "v" + mMatch[2]
		});
		const currentPhase = phases.find((p) => p.disk_status === "planned" || p.disk_status === "partial") || null;
		const nextPhase = phases.find((p) => p.disk_status === "empty" || p.disk_status === "no_directory" || p.disk_status === "discussed" || p.disk_status === "researched") || null;
		const totalPlans = phases.reduce((sum, p) => sum + p.plan_count, 0);
		const totalSummaries = phases.reduce((sum, p) => sum + p.summary_count, 0);
		const completedPhases = phases.filter((p) => p.disk_status === "complete").length;
		const checklistPattern = /-\s*\[[ x]\]\s*\*\*Phase\s+(\d+[A-Z]?(?:\.\d+)?)/gi;
		const checklistPhases = /* @__PURE__ */ new Set();
		let checklistMatch;
		while ((checklistMatch = checklistPattern.exec(content)) !== null) checklistPhases.add(checklistMatch[1]);
		const detailPhases = new Set(phases.map((p) => p.number));
		const missingDetails = [...checklistPhases].filter((p) => !detailPhases.has(p));
		const result = {
			milestones,
			phases,
			phase_count: phases.length,
			completed_phases: completedPhases,
			total_plans: totalPlans,
			total_summaries: totalSummaries,
			progress_percent: totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0,
			current_phase: currentPhase ? currentPhase.number : null,
			next_phase: nextPhase ? nextPhase.number : null,
			missing_phase_details: missingDetails.length > 0 ? missingDetails : null
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdRoadmapUpdatePlanProgress(cwd, phaseNum, raw) {
		if (!phaseNum) (0, core_js_1.error)("phase number required for roadmap update-plan-progress");
		const roadmapPath = node_path_1$6.default.join(cwd, ".planning", "ROADMAP.md");
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phaseNum);
		if (!phaseInfo) (0, core_js_1.error)(`Phase ${phaseNum} not found`);
		const planCount = phaseInfo.plans.length;
		const summaryCount = phaseInfo.summaries.length;
		if (planCount === 0) {
			(0, core_js_1.output)({
				updated: false,
				reason: "No plans found",
				plan_count: 0,
				summary_count: 0
			}, raw, "no plans");
			return;
		}
		const isComplete = summaryCount >= planCount;
		const status = isComplete ? "Complete" : summaryCount > 0 ? "In Progress" : "Planned";
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		if (!node_fs_1$6.default.existsSync(roadmapPath)) {
			(0, core_js_1.output)({
				updated: false,
				reason: "ROADMAP.md not found",
				plan_count: planCount,
				summary_count: summaryCount
			}, raw, "no roadmap");
			return;
		}
		let roadmapContent = node_fs_1$6.default.readFileSync(roadmapPath, "utf-8");
		const phaseEscaped = phaseNum.replace(".", "\\.");
		const tablePattern = new RegExp(`(\\|\\s*${phaseEscaped}\\.?\\s[^|]*\\|)[^|]*(\\|)\\s*[^|]*(\\|)\\s*[^|]*(\\|)`, "i");
		const dateField = isComplete ? ` ${today} ` : "  ";
		roadmapContent = roadmapContent.replace(tablePattern, `$1 ${summaryCount}/${planCount} $2 ${status.padEnd(11)}$3${dateField}$4`);
		const planCountPattern = new RegExp(`(#{2,4}\\s*Phase\\s+${phaseEscaped}[\\s\\S]*?\\*\\*Plans:\\*\\*\\s*)[^\\n]+`, "i");
		const planCountText = isComplete ? `${summaryCount}/${planCount} plans complete` : `${summaryCount}/${planCount} plans executed`;
		roadmapContent = roadmapContent.replace(planCountPattern, `$1${planCountText}`);
		if (isComplete) {
			const checkboxPattern = new RegExp(`(-\\s*\\[)[ ](\\]\\s*.*Phase\\s+${phaseEscaped}[:\\s][^\\n]*)`, "i");
			roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);
		}
		node_fs_1$6.default.writeFileSync(roadmapPath, roadmapContent, "utf-8");
		(0, core_js_1.output)({
			updated: true,
			phase: phaseNum,
			plan_count: planCount,
			summary_count: summaryCount,
			status,
			complete: isComplete
		}, raw, `${summaryCount}/${planCount} ${status}`);
	}
}));

//#endregion
//#region ../core/dist/milestone.js
var require_milestone = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Milestone  Milestone and requirements lifecycle operations
	*
	* Ported from maxsim/bin/lib/milestone.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdRequirementsMarkComplete = cmdRequirementsMarkComplete;
	exports.cmdMilestoneComplete = cmdMilestoneComplete;
	const node_fs_1$5 = __importDefault(require("node:fs"));
	const node_path_1$5 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	const frontmatter_js_1 = require_frontmatter();
	function cmdRequirementsMarkComplete(cwd, reqIdsRaw, raw) {
		if (!reqIdsRaw || reqIdsRaw.length === 0) (0, core_js_1.error)("requirement IDs required. Usage: requirements mark-complete REQ-01,REQ-02 or REQ-01 REQ-02");
		const reqIds = reqIdsRaw.join(" ").replace(/[\[\]]/g, "").split(/[,\s]+/).map((r) => r.trim()).filter(Boolean);
		if (reqIds.length === 0) (0, core_js_1.error)("no valid requirement IDs found");
		const reqPath = node_path_1$5.default.join(cwd, ".planning", "REQUIREMENTS.md");
		if (!node_fs_1$5.default.existsSync(reqPath)) {
			(0, core_js_1.output)({
				updated: false,
				reason: "REQUIREMENTS.md not found",
				ids: reqIds
			}, raw, "no requirements file");
			return;
		}
		let reqContent = node_fs_1$5.default.readFileSync(reqPath, "utf-8");
		const updated = [];
		const notFound = [];
		for (const reqId of reqIds) {
			let found = false;
			const checkboxPattern = new RegExp(`(-\\s*\\[)[ ](\\]\\s*\\*\\*${reqId}\\*\\*)`, "gi");
			if (checkboxPattern.test(reqContent)) {
				reqContent = reqContent.replace(checkboxPattern, "$1x$2");
				found = true;
			}
			if (new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi").test(reqContent)) {
				reqContent = reqContent.replace(new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi"), "$1 Complete $2");
				found = true;
			}
			if (found) updated.push(reqId);
			else notFound.push(reqId);
		}
		if (updated.length > 0) node_fs_1$5.default.writeFileSync(reqPath, reqContent, "utf-8");
		const result = {
			updated: updated.length > 0,
			marked_complete: updated,
			not_found: notFound,
			total: reqIds.length
		};
		(0, core_js_1.output)(result, raw, `${updated.length}/${reqIds.length} requirements marked complete`);
	}
	function cmdMilestoneComplete(cwd, version, options, raw) {
		if (!version) (0, core_js_1.error)("version required for milestone complete (e.g., v1.0)");
		const roadmapPath = node_path_1$5.default.join(cwd, ".planning", "ROADMAP.md");
		const reqPath = node_path_1$5.default.join(cwd, ".planning", "REQUIREMENTS.md");
		const statePath = node_path_1$5.default.join(cwd, ".planning", "STATE.md");
		const milestonesPath = node_path_1$5.default.join(cwd, ".planning", "MILESTONES.md");
		const archiveDir = node_path_1$5.default.join(cwd, ".planning", "milestones");
		const phasesDir = node_path_1$5.default.join(cwd, ".planning", "phases");
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		const milestoneName = options.name || version;
		node_fs_1$5.default.mkdirSync(archiveDir, { recursive: true });
		let phaseCount = 0;
		let totalPlans = 0;
		let totalTasks = 0;
		const accomplishments = [];
		try {
			const dirs = node_fs_1$5.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort();
			for (const dir of dirs) {
				phaseCount++;
				const phaseFiles = node_fs_1$5.default.readdirSync(node_path_1$5.default.join(phasesDir, dir));
				const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
				const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
				totalPlans += plans.length;
				for (const s of summaries) try {
					const content = node_fs_1$5.default.readFileSync(node_path_1$5.default.join(phasesDir, dir, s), "utf-8");
					const fm = (0, frontmatter_js_1.extractFrontmatter)(content);
					if (fm["one-liner"]) accomplishments.push(String(fm["one-liner"]));
					const taskMatches = content.match(/##\s*Task\s*\d+/gi) || [];
					totalTasks += taskMatches.length;
				} catch (e) {
					if (process.env.MAXSIM_DEBUG) console.error(e);
				}
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (node_fs_1$5.default.existsSync(roadmapPath)) {
			const roadmapContent = node_fs_1$5.default.readFileSync(roadmapPath, "utf-8");
			node_fs_1$5.default.writeFileSync(node_path_1$5.default.join(archiveDir, `${version}-ROADMAP.md`), roadmapContent, "utf-8");
		}
		if (node_fs_1$5.default.existsSync(reqPath)) {
			const reqContent = node_fs_1$5.default.readFileSync(reqPath, "utf-8");
			const archiveHeader = `# Requirements Archive: ${version} ${milestoneName}\n\n**Archived:** ${today}\n**Status:** SHIPPED\n\nFor current requirements, see \`.planning/REQUIREMENTS.md\`.\n\n---\n\n`;
			node_fs_1$5.default.writeFileSync(node_path_1$5.default.join(archiveDir, `${version}-REQUIREMENTS.md`), archiveHeader + reqContent, "utf-8");
		}
		const auditFile = node_path_1$5.default.join(cwd, ".planning", `${version}-MILESTONE-AUDIT.md`);
		if (node_fs_1$5.default.existsSync(auditFile)) node_fs_1$5.default.renameSync(auditFile, node_path_1$5.default.join(archiveDir, `${version}-MILESTONE-AUDIT.md`));
		const accomplishmentsList = accomplishments.map((a) => `- ${a}`).join("\n");
		const milestoneEntry = `## ${version} ${milestoneName} (Shipped: ${today})\n\n**Phases completed:** ${phaseCount} phases, ${totalPlans} plans, ${totalTasks} tasks\n\n**Key accomplishments:**\n${accomplishmentsList || "- (none recorded)"}\n\n---\n\n`;
		if (node_fs_1$5.default.existsSync(milestonesPath)) {
			const existing = node_fs_1$5.default.readFileSync(milestonesPath, "utf-8");
			node_fs_1$5.default.writeFileSync(milestonesPath, existing + "\n" + milestoneEntry, "utf-8");
		} else node_fs_1$5.default.writeFileSync(milestonesPath, `# Milestones\n\n${milestoneEntry}`, "utf-8");
		if (node_fs_1$5.default.existsSync(statePath)) {
			let stateContent = node_fs_1$5.default.readFileSync(statePath, "utf-8");
			stateContent = stateContent.replace(/(\*\*Status:\*\*\s*).*/, `$1${version} milestone complete`);
			stateContent = stateContent.replace(/(\*\*Last Activity:\*\*\s*).*/, `$1${today}`);
			stateContent = stateContent.replace(/(\*\*Last Activity Description:\*\*\s*).*/, `$1${version} milestone completed and archived`);
			node_fs_1$5.default.writeFileSync(statePath, stateContent, "utf-8");
		}
		let phasesArchived = false;
		if (options.archivePhases) try {
			const phaseArchiveDir = node_path_1$5.default.join(archiveDir, `${version}-phases`);
			node_fs_1$5.default.mkdirSync(phaseArchiveDir, { recursive: true });
			const phaseDirNames = node_fs_1$5.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			for (const dir of phaseDirNames) node_fs_1$5.default.renameSync(node_path_1$5.default.join(phasesDir, dir), node_path_1$5.default.join(phaseArchiveDir, dir));
			phasesArchived = phaseDirNames.length > 0;
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			version,
			name: milestoneName,
			date: today,
			phases: phaseCount,
			plans: totalPlans,
			tasks: totalTasks,
			accomplishments,
			archived: {
				roadmap: node_fs_1$5.default.existsSync(node_path_1$5.default.join(archiveDir, `${version}-ROADMAP.md`)),
				requirements: node_fs_1$5.default.existsSync(node_path_1$5.default.join(archiveDir, `${version}-REQUIREMENTS.md`)),
				audit: node_fs_1$5.default.existsSync(node_path_1$5.default.join(archiveDir, `${version}-MILESTONE-AUDIT.md`)),
				phases: phasesArchived
			},
			milestones_updated: true,
			state_updated: node_fs_1$5.default.existsSync(statePath)
		};
		(0, core_js_1.output)(result, raw);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
function assembleStyles() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$1[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$1, "codes", {
		value: codes,
		enumerable: false
	});
	styles$1.color.close = "\x1B[39m";
	styles$1.bgColor.close = "\x1B[49m";
	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$1;
}
var ANSI_BACKGROUND_OFFSET, wrapAnsi16, wrapAnsi256, wrapAnsi16m, styles$1, modifierNames, foregroundColorNames, backgroundColorNames, colorNames, ansiStyles;
var init_ansi_styles = __esmMin((() => {
	ANSI_BACKGROUND_OFFSET = 10;
	wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
	wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
	wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
	styles$1 = {
		modifier: {
			reset: [0, 0],
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			overline: [53, 55],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			blackBright: [90, 39],
			gray: [90, 39],
			grey: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],
			bgBlackBright: [100, 49],
			bgGray: [100, 49],
			bgGrey: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};
	modifierNames = Object.keys(styles$1.modifier);
	foregroundColorNames = Object.keys(styles$1.color);
	backgroundColorNames = Object.keys(styles$1.bgColor);
	colorNames = [...foregroundColorNames, ...backgroundColorNames];
	ansiStyles = assembleStyles();
}));

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process.default.argv) {
	const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf("--");
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
function envForceColor() {
	if ("FORCE_COLOR" in env) {
		if (env.FORCE_COLOR === "true") return 1;
		if (env.FORCE_COLOR === "false") return 0;
		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}
function translateLevel(level) {
	if (level === 0) return false;
	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
	if (forceColor === 0) return 0;
	if (sniffFlags) {
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
	}
	if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
	if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
	const min = forceColor || 0;
	if (env.TERM === "dumb") return min;
	if (node_process.default.platform === "win32") {
		const osRelease = node_os.default.release().split(".");
		if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
		return 1;
	}
	if ("CI" in env) {
		if ([
			"GITHUB_ACTIONS",
			"GITEA_ACTIONS",
			"CIRCLECI"
		].some((key) => key in env)) return 3;
		if ([
			"TRAVIS",
			"APPVEYOR",
			"GITLAB_CI",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env) || env.CI_NAME === "codeship") return 1;
		return min;
	}
	if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	if (env.COLORTERM === "truecolor") return 3;
	if (env.TERM === "xterm-kitty") return 3;
	if (env.TERM === "xterm-ghostty") return 3;
	if (env.TERM === "wezterm") return 3;
	if ("TERM_PROGRAM" in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
		switch (env.TERM_PROGRAM) {
			case "iTerm.app": return version >= 3 ? 3 : 2;
			case "Apple_Terminal": return 2;
		}
	}
	if (/-256(color)?$/i.test(env.TERM)) return 2;
	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
	if ("COLORTERM" in env) return 1;
	return min;
}
function createSupportsColor(stream, options = {}) {
	return translateLevel(_supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options
	}));
}
var env, flagForceColor, supportsColor;
var init_supports_color = __esmMin((() => {
	({env} = node_process.default);
	;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
	supportsColor = {
		stdout: createSupportsColor({ isTTY: node_tty.default.isatty(1) }),
		stderr: createSupportsColor({ isTTY: node_tty.default.isatty(2) })
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) return string;
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = "";
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = "";
	do {
		const gotCR = string[index - 1] === "\r";
		returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
		endIndex = index + 1;
		index = string.indexOf("\n", endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}
var init_utilities = __esmMin((() => {}));

//#endregion
//#region ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
var source_exports = /* @__PURE__ */ __exportAll({
	Chalk: () => Chalk,
	backgroundColorNames: () => backgroundColorNames,
	backgroundColors: () => backgroundColorNames,
	chalkStderr: () => chalkStderr,
	colorNames: () => colorNames,
	colors: () => colorNames,
	default: () => chalk,
	foregroundColorNames: () => foregroundColorNames,
	foregroundColors: () => foregroundColorNames,
	modifierNames: () => modifierNames,
	modifiers: () => modifierNames,
	supportsColor: () => stdoutColor,
	supportsColorStderr: () => stderrColor
});
function createChalk(options) {
	return chalkFactory(options);
}
var stdoutColor, stderrColor, GENERATOR, STYLER, IS_EMPTY, levelMapping, styles, applyOptions, Chalk, chalkFactory, getModelAnsi, proto, createStyler, createBuilder, applyStyle, chalk, chalkStderr;
var init_source = __esmMin((() => {
	init_ansi_styles();
	init_supports_color();
	init_utilities();
	({stdout: stdoutColor, stderr: stderrColor} = supportsColor);
	GENERATOR = Symbol("GENERATOR");
	STYLER = Symbol("STYLER");
	IS_EMPTY = Symbol("IS_EMPTY");
	levelMapping = [
		"ansi",
		"ansi",
		"ansi256",
		"ansi16m"
	];
	styles = Object.create(null);
	applyOptions = (object, options = {}) => {
		if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
		const colorLevel = stdoutColor ? stdoutColor.level : 0;
		object.level = options.level === void 0 ? colorLevel : options.level;
	};
	Chalk = class {
		constructor(options) {
			return chalkFactory(options);
		}
	};
	chalkFactory = (options) => {
		const chalk = (...strings) => strings.join(" ");
		applyOptions(chalk, options);
		Object.setPrototypeOf(chalk, createChalk.prototype);
		return chalk;
	};
	Object.setPrototypeOf(createChalk.prototype, Function.prototype);
	for (const [styleName, style] of Object.entries(ansiStyles)) styles[styleName] = { get() {
		const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
		Object.defineProperty(this, styleName, { value: builder });
		return builder;
	} };
	styles.visible = { get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, "visible", { value: builder });
		return builder;
	} };
	getModelAnsi = (model, level, type, ...arguments_) => {
		if (model === "rgb") {
			if (level === "ansi16m") return ansiStyles[type].ansi16m(...arguments_);
			if (level === "ansi256") return ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
			return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));
		}
		if (model === "hex") return getModelAnsi("rgb", level, type, ...ansiStyles.hexToRgb(...arguments_));
		return ansiStyles[type][model](...arguments_);
	};
	for (const model of [
		"rgb",
		"hex",
		"ansi256"
	]) {
		styles[model] = { get() {
			const { level } = this;
			return function(...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansiStyles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		} };
		const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
		styles[bgModel] = { get() {
			const { level } = this;
			return function(...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		} };
	}
	proto = Object.defineProperties(() => {}, {
		...styles,
		level: {
			enumerable: true,
			get() {
				return this[GENERATOR].level;
			},
			set(level) {
				this[GENERATOR].level = level;
			}
		}
	});
	createStyler = (open, close, parent) => {
		let openAll;
		let closeAll;
		if (parent === void 0) {
			openAll = open;
			closeAll = close;
		} else {
			openAll = parent.openAll + open;
			closeAll = close + parent.closeAll;
		}
		return {
			open,
			close,
			openAll,
			closeAll,
			parent
		};
	};
	createBuilder = (self, _styler, _isEmpty) => {
		const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
		Object.setPrototypeOf(builder, proto);
		builder[GENERATOR] = self;
		builder[STYLER] = _styler;
		builder[IS_EMPTY] = _isEmpty;
		return builder;
	};
	applyStyle = (self, string) => {
		if (self.level <= 0 || !string) return self[IS_EMPTY] ? "" : string;
		let styler = self[STYLER];
		if (styler === void 0) return string;
		const { openAll, closeAll } = styler;
		if (string.includes("\x1B")) while (styler !== void 0) {
			string = stringReplaceAll(string, styler.close, styler.open);
			styler = styler.parent;
		}
		const lfIndex = string.indexOf("\n");
		if (lfIndex !== -1) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
		return openAll + string + closeAll;
	};
	Object.defineProperties(createChalk.prototype, styles);
	chalk = createChalk();
	chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
}));

//#endregion
//#region ../core/dist/commands.js
var require_commands = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Commands  Standalone utility commands
	*
	* Ported from maxsim/bin/lib/commands.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdGenerateSlug = cmdGenerateSlug;
	exports.cmdCurrentTimestamp = cmdCurrentTimestamp;
	exports.cmdListTodos = cmdListTodos;
	exports.cmdVerifyPathExists = cmdVerifyPathExists;
	exports.cmdHistoryDigest = cmdHistoryDigest;
	exports.cmdResolveModel = cmdResolveModel;
	exports.cmdCommit = cmdCommit;
	exports.cmdSummaryExtract = cmdSummaryExtract;
	exports.cmdWebsearch = cmdWebsearch;
	exports.cmdProgressRender = cmdProgressRender;
	exports.cmdTodoComplete = cmdTodoComplete;
	exports.cmdScaffold = cmdScaffold;
	const node_fs_1$4 = __importDefault(require("node:fs"));
	const node_path_1$4 = __importDefault(require("node:path"));
	const chalk_1 = __importDefault((init_source(), __toCommonJS(source_exports)));
	const core_js_1 = require_core();
	const frontmatter_js_1 = require_frontmatter();
	function cmdGenerateSlug(text, raw) {
		if (!text) (0, core_js_1.error)("text required for slug generation");
		const slug = text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
		const result = { slug };
		(0, core_js_1.output)(result, raw, slug);
	}
	function cmdCurrentTimestamp(format, raw) {
		const now = /* @__PURE__ */ new Date();
		let result;
		switch (format) {
			case "date":
				result = now.toISOString().split("T")[0];
				break;
			case "filename":
				result = now.toISOString().replace(/:/g, "-").replace(/\..+/, "");
				break;
			default:
				result = now.toISOString();
				break;
		}
		(0, core_js_1.output)({ timestamp: result }, raw, result);
	}
	function cmdListTodos(cwd, area, raw) {
		const pendingDir = node_path_1$4.default.join(cwd, ".planning", "todos", "pending");
		let count = 0;
		const todos = [];
		try {
			const files = node_fs_1$4.default.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
			for (const file of files) try {
				const content = node_fs_1$4.default.readFileSync(node_path_1$4.default.join(pendingDir, file), "utf-8");
				const createdMatch = content.match(/^created:\s*(.+)$/m);
				const titleMatch = content.match(/^title:\s*(.+)$/m);
				const areaMatch = content.match(/^area:\s*(.+)$/m);
				const todoArea = areaMatch ? areaMatch[1].trim() : "general";
				if (area && todoArea !== area) continue;
				count++;
				todos.push({
					file,
					created: createdMatch ? createdMatch[1].trim() : "unknown",
					title: titleMatch ? titleMatch[1].trim() : "Untitled",
					area: todoArea,
					path: node_path_1$4.default.join(".planning", "todos", "pending", file)
				});
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			count,
			todos
		};
		(0, core_js_1.output)(result, raw, count.toString());
	}
	function cmdVerifyPathExists(cwd, targetPath, raw) {
		if (!targetPath) (0, core_js_1.error)("path required for verification");
		const fullPath = node_path_1$4.default.isAbsolute(targetPath) ? targetPath : node_path_1$4.default.join(cwd, targetPath);
		try {
			const stats = node_fs_1$4.default.statSync(fullPath);
			const result = {
				exists: true,
				type: stats.isDirectory() ? "directory" : stats.isFile() ? "file" : "other"
			};
			(0, core_js_1.output)(result, raw, "true");
		} catch {
			(0, core_js_1.output)({
				exists: false,
				type: null
			}, raw, "false");
		}
	}
	function cmdHistoryDigest(cwd, raw) {
		const phasesDir = node_path_1$4.default.join(cwd, ".planning", "phases");
		const digest = {
			phases: {},
			decisions: [],
			tech_stack: /* @__PURE__ */ new Set()
		};
		const allPhaseDirs = [];
		const archived = (0, core_js_1.getArchivedPhaseDirs)(cwd);
		for (const a of archived) allPhaseDirs.push({
			name: a.name,
			fullPath: a.fullPath,
			milestone: a.milestone
		});
		if (node_fs_1$4.default.existsSync(phasesDir)) try {
			const currentDirs = node_fs_1$4.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort();
			for (const dir of currentDirs) allPhaseDirs.push({
				name: dir,
				fullPath: node_path_1$4.default.join(phasesDir, dir),
				milestone: null
			});
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (allPhaseDirs.length === 0) {
			(0, core_js_1.output)({
				phases: {},
				decisions: [],
				tech_stack: []
			}, raw);
			return;
		}
		try {
			for (const { name: dir, fullPath: dirPath } of allPhaseDirs) {
				const summaries = node_fs_1$4.default.readdirSync(dirPath).filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
				for (const summary of summaries) try {
					const content = node_fs_1$4.default.readFileSync(node_path_1$4.default.join(dirPath, summary), "utf-8");
					const fm = (0, frontmatter_js_1.extractFrontmatter)(content);
					const phaseNum = fm.phase || dir.split("-")[0];
					if (!digest.phases[phaseNum]) digest.phases[phaseNum] = {
						name: fm.name || dir.split("-").slice(1).join(" ") || "Unknown",
						provides: /* @__PURE__ */ new Set(),
						affects: /* @__PURE__ */ new Set(),
						patterns: /* @__PURE__ */ new Set()
					};
					const depGraph = fm["dependency-graph"];
					if (depGraph && depGraph.provides) depGraph.provides.forEach((p) => digest.phases[phaseNum].provides.add(p));
					else if (fm.provides) fm.provides.forEach((p) => digest.phases[phaseNum].provides.add(p));
					if (depGraph && depGraph.affects) depGraph.affects.forEach((a) => digest.phases[phaseNum].affects.add(a));
					if (fm["patterns-established"]) fm["patterns-established"].forEach((p) => digest.phases[phaseNum].patterns.add(p));
					if (fm["key-decisions"]) fm["key-decisions"].forEach((d) => {
						digest.decisions.push({
							phase: phaseNum,
							decision: d
						});
					});
					const techStack = fm["tech-stack"];
					if (techStack && techStack.added) techStack.added.forEach((t) => digest.tech_stack.add(typeof t === "string" ? t : t.name));
				} catch (e) {
					if (process.env.MAXSIM_DEBUG) console.error(e);
				}
			}
			const outputDigest = {
				phases: {},
				decisions: digest.decisions,
				tech_stack: [...digest.tech_stack]
			};
			for (const [p, data] of Object.entries(digest.phases)) outputDigest.phases[p] = {
				name: data.name,
				provides: [...data.provides],
				affects: [...data.affects],
				patterns: [...data.patterns]
			};
			(0, core_js_1.output)(outputDigest, raw);
		} catch (e) {
			(0, core_js_1.error)("Failed to generate history digest: " + e.message);
		}
	}
	function cmdResolveModel(cwd, agentType, raw) {
		if (!agentType) (0, core_js_1.error)("agent-type required");
		const profile = (0, core_js_1.loadConfig)(cwd).model_profile || "balanced";
		const agentModels = core_js_1.MODEL_PROFILES[agentType];
		if (!agentModels) {
			const result = {
				model: "sonnet",
				profile,
				unknown_agent: true
			};
			(0, core_js_1.output)(result, raw, "sonnet");
			return;
		}
		const resolved = agentModels[profile] || agentModels["balanced"] || "sonnet";
		const model = resolved === "opus" ? "inherit" : resolved;
		const result = {
			model,
			profile
		};
		(0, core_js_1.output)(result, raw, model);
	}
	function cmdCommit(cwd, message, files, raw, amend) {
		if (!message && !amend) (0, core_js_1.error)("commit message required");
		if (!(0, core_js_1.loadConfig)(cwd).commit_docs) {
			(0, core_js_1.output)({
				committed: false,
				hash: null,
				reason: "skipped_commit_docs_false"
			}, raw, "skipped");
			return;
		}
		if ((0, core_js_1.isGitIgnored)(cwd, ".planning")) {
			(0, core_js_1.output)({
				committed: false,
				hash: null,
				reason: "skipped_gitignored"
			}, raw, "skipped");
			return;
		}
		const filesToStage = files && files.length > 0 ? files : [".planning/"];
		for (const file of filesToStage) (0, core_js_1.execGit)(cwd, ["add", file]);
		const commitArgs = amend ? [
			"commit",
			"--amend",
			"--no-edit"
		] : [
			"commit",
			"-m",
			message
		];
		const commitResult = (0, core_js_1.execGit)(cwd, commitArgs);
		if (commitResult.exitCode !== 0) {
			if (commitResult.stdout.includes("nothing to commit") || commitResult.stderr.includes("nothing to commit")) {
				(0, core_js_1.output)({
					committed: false,
					hash: null,
					reason: "nothing_to_commit"
				}, raw, "nothing");
				return;
			}
			const result = {
				committed: false,
				hash: null,
				reason: "nothing_to_commit",
				error: commitResult.stderr
			};
			(0, core_js_1.output)(result, raw, "nothing");
			return;
		}
		const hashResult = (0, core_js_1.execGit)(cwd, [
			"rev-parse",
			"--short",
			"HEAD"
		]);
		const hash = hashResult.exitCode === 0 ? hashResult.stdout : null;
		const result = {
			committed: true,
			hash,
			reason: "committed"
		};
		(0, core_js_1.output)(result, raw, hash || "committed");
	}
	function cmdSummaryExtract(cwd, summaryPath, fields, raw) {
		if (!summaryPath) (0, core_js_1.error)("summary-path required for summary-extract");
		const fullPath = node_path_1$4.default.join(cwd, summaryPath);
		if (!node_fs_1$4.default.existsSync(fullPath)) {
			(0, core_js_1.output)({
				error: "File not found",
				path: summaryPath
			}, raw);
			return;
		}
		const content = node_fs_1$4.default.readFileSync(fullPath, "utf-8");
		const fm = (0, frontmatter_js_1.extractFrontmatter)(content);
		const parseDecisions = (decisionsList) => {
			if (!decisionsList || !Array.isArray(decisionsList)) return [];
			return decisionsList.map((d) => {
				const colonIdx = d.indexOf(":");
				if (colonIdx > 0) return {
					summary: d.substring(0, colonIdx).trim(),
					rationale: d.substring(colonIdx + 1).trim()
				};
				return {
					summary: d,
					rationale: null
				};
			});
		};
		const techStack = fm["tech-stack"];
		const fullResult = {
			path: summaryPath,
			one_liner: fm["one-liner"] || null,
			key_files: fm["key-files"] || [],
			tech_added: techStack && techStack.added || [],
			patterns: fm["patterns-established"] || [],
			decisions: parseDecisions(fm["key-decisions"]),
			requirements_completed: fm["requirements-completed"] || []
		};
		if (fields && fields.length > 0) {
			const filtered = { path: summaryPath };
			for (const field of fields) if (fullResult[field] !== void 0) filtered[field] = fullResult[field];
			(0, core_js_1.output)(filtered, raw);
			return;
		}
		(0, core_js_1.output)(fullResult, raw);
	}
	async function cmdWebsearch(query, options, raw) {
		const apiKey = process.env.BRAVE_API_KEY;
		if (!apiKey) {
			(0, core_js_1.output)({
				available: false,
				reason: "BRAVE_API_KEY not set"
			}, raw, "");
			return;
		}
		if (!query) {
			(0, core_js_1.output)({
				available: false,
				error: "Query required"
			}, raw, "");
			return;
		}
		const params = new URLSearchParams({
			q: query,
			count: String(options.limit || 10),
			country: "us",
			search_lang: "en",
			text_decorations: "false"
		});
		if (options.freshness) params.set("freshness", options.freshness);
		try {
			const response = await fetch(`https://api.search.brave.com/res/v1/web/search?${params}`, { headers: {
				Accept: "application/json",
				"X-Subscription-Token": apiKey
			} });
			if (!response.ok) {
				(0, core_js_1.output)({
					available: false,
					error: `API error: ${response.status}`
				}, raw, "");
				return;
			}
			const results = ((await response.json()).web?.results || []).map((r) => ({
				title: r.title,
				url: r.url,
				description: r.description,
				age: r.age || null
			}));
			(0, core_js_1.output)({
				available: true,
				query,
				count: results.length,
				results
			}, raw, results.map((r) => `${r.title}\n${r.url}\n${r.description}`).join("\n\n"));
		} catch (err) {
			(0, core_js_1.output)({
				available: false,
				error: err.message
			}, raw, "");
		}
	}
	function cmdProgressRender(cwd, format, raw) {
		const phasesDir = node_path_1$4.default.join(cwd, ".planning", "phases");
		const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
		const phases = [];
		let totalPlans = 0;
		let totalSummaries = 0;
		try {
			const dirs = node_fs_1$4.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => {
				return parseFloat(a.match(/^(\d+(?:\.\d+)?)/)?.[1] || "0") - parseFloat(b.match(/^(\d+(?:\.\d+)?)/)?.[1] || "0");
			});
			for (const dir of dirs) {
				const dm = dir.match(/^(\d+(?:\.\d+)?)-?(.*)/);
				const phaseNum = dm ? dm[1] : dir;
				const phaseName = dm && dm[2] ? dm[2].replace(/-/g, " ") : "";
				const phaseFiles = node_fs_1$4.default.readdirSync(node_path_1$4.default.join(phasesDir, dir));
				const planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
				const summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
				totalPlans += planCount;
				totalSummaries += summaryCount;
				let status;
				if (planCount === 0) status = "Pending";
				else if (summaryCount >= planCount) status = "Complete";
				else if (summaryCount > 0) status = "In Progress";
				else status = "Planned";
				phases.push({
					number: phaseNum,
					name: phaseName,
					plans: planCount,
					summaries: summaryCount,
					status
				});
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const percent = totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0;
		if (format === "table") {
			const barWidth = 10;
			const filled = Math.round(percent / 100 * barWidth);
			const bar = "".repeat(filled) + "".repeat(barWidth - filled);
			let out = `# ${milestone.version} ${milestone.name}\n\n`;
			out += `**Progress:** [${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)\n\n`;
			out += `| Phase | Name | Plans | Status |\n`;
			out += `|-------|------|-------|--------|\n`;
			for (const p of phases) out += `| ${p.number} | ${p.name} | ${p.summaries}/${p.plans} | ${p.status} |\n`;
			(0, core_js_1.output)({ rendered: out }, raw, out);
		} else if (format === "bar") {
			const barWidth = 20;
			const filled = Math.round(percent / 100 * barWidth);
			const text = `[${"".repeat(filled) + "".repeat(barWidth - filled)}] ${totalSummaries}/${totalPlans} plans (${percent}%)`;
			(0, core_js_1.output)({
				bar: text,
				percent,
				completed: totalSummaries,
				total: totalPlans
			}, raw, text);
		} else if (format === "phase-bars") {
			const doneCount = phases.filter((p) => p.status === "Complete").length;
			const inProgressCount = phases.filter((p) => p.status === "In Progress").length;
			const totalCount = phases.length;
			const lines = [chalk_1.default.bold(`Milestone: ${milestone.name}  ${doneCount}/${totalCount} phases complete (${percent}%)`), ""];
			for (const p of phases) {
				const pPercent = p.plans > 0 ? Math.min(100, Math.round(p.summaries / p.plans * 100)) : 0;
				const barWidth = 10;
				const filled = Math.round(pPercent / 100 * barWidth);
				const bar = "".repeat(filled) + "".repeat(barWidth - filled);
				const phaseLabel = `Phase ${p.number.padStart(2, "0")}`;
				const statusLabel = p.status === "Complete" ? "DONE" : p.status === "In Progress" ? "IN PROGRESS" : "PLANNED";
				let line = `${phaseLabel} [${bar}] ${String(pPercent).padStart(3, " ")}%  ${statusLabel}`;
				if (p.status === "Complete") line = chalk_1.default.green(line);
				else if (p.status === "In Progress") line = chalk_1.default.yellow(line);
				else line = chalk_1.default.dim(line);
				lines.push(line);
			}
			const rendered = lines.join("\n");
			(0, core_js_1.output)({
				rendered,
				done: doneCount,
				in_progress: inProgressCount,
				total: totalCount,
				percent
			}, raw, rendered);
		} else (0, core_js_1.output)({
			milestone_version: milestone.version,
			milestone_name: milestone.name,
			phases,
			total_plans: totalPlans,
			total_summaries: totalSummaries,
			percent
		}, raw);
	}
	function cmdTodoComplete(cwd, filename, raw) {
		if (!filename) (0, core_js_1.error)("filename required for todo complete");
		const pendingDir = node_path_1$4.default.join(cwd, ".planning", "todos", "pending");
		const completedDir = node_path_1$4.default.join(cwd, ".planning", "todos", "completed");
		const sourcePath = node_path_1$4.default.join(pendingDir, filename);
		if (!node_fs_1$4.default.existsSync(sourcePath)) (0, core_js_1.error)(`Todo not found: ${filename}`);
		node_fs_1$4.default.mkdirSync(completedDir, { recursive: true });
		let content = node_fs_1$4.default.readFileSync(sourcePath, "utf-8");
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		content = `completed: ${today}\n` + content;
		node_fs_1$4.default.writeFileSync(node_path_1$4.default.join(completedDir, filename), content, "utf-8");
		node_fs_1$4.default.unlinkSync(sourcePath);
		(0, core_js_1.output)({
			completed: true,
			file: filename,
			date: today
		}, raw, "completed");
	}
	function cmdScaffold(cwd, type, options, raw) {
		const { phase, name } = options;
		const padded = phase ? (0, core_js_1.normalizePhaseName)(phase) : "00";
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		const phaseInfo = phase ? (0, core_js_1.findPhaseInternal)(cwd, phase) : null;
		const phaseDir = phaseInfo ? node_path_1$4.default.join(cwd, phaseInfo.directory) : null;
		if (phase && !phaseDir && type !== "phase-dir") (0, core_js_1.error)(`Phase ${phase} directory not found`);
		let filePath;
		let content;
		switch (type) {
			case "context":
				filePath = node_path_1$4.default.join(phaseDir, `${padded}-CONTEXT.md`);
				content = `---\nphase: "${padded}"\nname: "${name || phaseInfo?.phase_name || "Unnamed"}"\ncreated: ${today}\n---\n\n# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"}  Context\n\n## Decisions\n\n_Decisions will be captured during /maxsim:discuss-phase ${phase}_\n\n## Discretion Areas\n\n_Areas where the executor can use judgment_\n\n## Deferred Ideas\n\n_Ideas to consider later_\n`;
				break;
			case "uat":
				filePath = node_path_1$4.default.join(phaseDir, `${padded}-UAT.md`);
				content = `---\nphase: "${padded}"\nname: "${name || phaseInfo?.phase_name || "Unnamed"}"\ncreated: ${today}\nstatus: pending\n---\n\n# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"}  User Acceptance Testing\n\n## Test Results\n\n| # | Test | Status | Notes |\n|---|------|--------|-------|\n\n## Summary\n\n_Pending UAT_\n`;
				break;
			case "verification":
				filePath = node_path_1$4.default.join(phaseDir, `${padded}-VERIFICATION.md`);
				content = `---\nphase: "${padded}"\nname: "${name || phaseInfo?.phase_name || "Unnamed"}"\ncreated: ${today}\nstatus: pending\n---\n\n# Phase ${phase}: ${name || phaseInfo?.phase_name || "Unnamed"}  Verification\n\n## Goal-Backward Verification\n\n**Phase Goal:** [From ROADMAP.md]\n\n## Checks\n\n| # | Requirement | Status | Evidence |\n|---|------------|--------|----------|\n\n## Result\n\n_Pending verification_\n`;
				break;
			case "phase-dir": {
				if (!phase || !name) (0, core_js_1.error)("phase and name required for phase-dir scaffold");
				const dirName = `${padded}-${(0, core_js_1.generateSlugInternal)(name)}`;
				const phasesParent = node_path_1$4.default.join(cwd, ".planning", "phases");
				node_fs_1$4.default.mkdirSync(phasesParent, { recursive: true });
				const dirPath = node_path_1$4.default.join(phasesParent, dirName);
				node_fs_1$4.default.mkdirSync(dirPath, { recursive: true });
				(0, core_js_1.output)({
					created: true,
					directory: `.planning/phases/${dirName}`,
					path: dirPath
				}, raw, dirPath);
				return;
			}
			default:
				(0, core_js_1.error)(`Unknown scaffold type: ${type}. Available: context, uat, verification, phase-dir`);
				return;
		}
		if (node_fs_1$4.default.existsSync(filePath)) {
			(0, core_js_1.output)({
				created: false,
				reason: "already_exists",
				path: filePath
			}, raw, "exists");
			return;
		}
		node_fs_1$4.default.writeFileSync(filePath, content, "utf-8");
		const relPath = node_path_1$4.default.relative(cwd, filePath);
		(0, core_js_1.output)({
			created: true,
			path: relPath
		}, raw, relPath);
	}
}));

//#endregion
//#region ../core/dist/verify.js
var require_verify = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Verify  Verification suite, consistency, and health validation
	*
	* Ported from maxsim/bin/lib/verify.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdVerifySummary = cmdVerifySummary;
	exports.cmdVerifyPlanStructure = cmdVerifyPlanStructure;
	exports.cmdVerifyPhaseCompleteness = cmdVerifyPhaseCompleteness;
	exports.cmdVerifyReferences = cmdVerifyReferences;
	exports.cmdVerifyCommits = cmdVerifyCommits;
	exports.cmdVerifyArtifacts = cmdVerifyArtifacts;
	exports.cmdVerifyKeyLinks = cmdVerifyKeyLinks;
	exports.cmdValidateConsistency = cmdValidateConsistency;
	exports.cmdValidateHealth = cmdValidateHealth;
	const node_fs_1$3 = __importDefault(require("node:fs"));
	const node_path_1$3 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	const frontmatter_js_1 = require_frontmatter();
	function cmdVerifySummary(cwd, summaryPath, checkFileCount, raw) {
		if (!summaryPath) (0, core_js_1.error)("summary-path required");
		const fullPath = node_path_1$3.default.join(cwd, summaryPath);
		const checkCount = checkFileCount || 2;
		if (!node_fs_1$3.default.existsSync(fullPath)) {
			(0, core_js_1.output)({
				passed: false,
				checks: {
					summary_exists: false,
					files_created: {
						checked: 0,
						found: 0,
						missing: []
					},
					commits_exist: false,
					self_check: "not_found"
				},
				errors: ["SUMMARY.md not found"]
			}, raw, "failed");
			return;
		}
		const content = node_fs_1$3.default.readFileSync(fullPath, "utf-8");
		const errors = [];
		const mentionedFiles = /* @__PURE__ */ new Set();
		for (const pattern of [/`([^`]+\.[a-zA-Z]+)`/g, /(?:Created|Modified|Added|Updated|Edited):\s*`?([^\s`]+\.[a-zA-Z]+)`?/gi]) {
			let m;
			while ((m = pattern.exec(content)) !== null) {
				const filePath = m[1];
				if (filePath && !filePath.startsWith("http") && filePath.includes("/")) mentionedFiles.add(filePath);
			}
		}
		const filesToCheck = Array.from(mentionedFiles).slice(0, checkCount);
		const missing = [];
		for (const file of filesToCheck) if (!node_fs_1$3.default.existsSync(node_path_1$3.default.join(cwd, file))) missing.push(file);
		const hashes = content.match(/\b[0-9a-f]{7,40}\b/g) || [];
		let commitsExist = false;
		if (hashes.length > 0) for (const hash of hashes.slice(0, 3)) {
			const result = (0, core_js_1.execGit)(cwd, [
				"cat-file",
				"-t",
				hash
			]);
			if (result.exitCode === 0 && result.stdout === "commit") {
				commitsExist = true;
				break;
			}
		}
		let selfCheck = "not_found";
		const selfCheckPattern = /##\s*(?:Self[- ]?Check|Verification|Quality Check)/i;
		if (selfCheckPattern.test(content)) {
			const passPattern = /(?:all\s+)?(?:pass|||complete|succeeded)/i;
			const failPattern = /(?:fail|||incomplete|blocked)/i;
			const checkSection = content.slice(content.search(selfCheckPattern));
			if (failPattern.test(checkSection)) selfCheck = "failed";
			else if (passPattern.test(checkSection)) selfCheck = "passed";
		}
		if (missing.length > 0) errors.push("Missing files: " + missing.join(", "));
		if (!commitsExist && hashes.length > 0) errors.push("Referenced commit hashes not found in git history");
		if (selfCheck === "failed") errors.push("Self-check section indicates failure");
		const checks = {
			summary_exists: true,
			files_created: {
				checked: filesToCheck.length,
				found: filesToCheck.length - missing.length,
				missing
			},
			commits_exist: commitsExist,
			self_check: selfCheck
		};
		const passed = missing.length === 0 && selfCheck !== "failed";
		const result = {
			passed,
			checks,
			errors
		};
		(0, core_js_1.output)(result, raw, passed ? "passed" : "failed");
	}
	function cmdVerifyPlanStructure(cwd, filePath, raw) {
		if (!filePath) (0, core_js_1.error)("file path required");
		const fullPath = node_path_1$3.default.isAbsolute(filePath) ? filePath : node_path_1$3.default.join(cwd, filePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const fm = (0, frontmatter_js_1.extractFrontmatter)(content);
		const errors = [];
		const warnings = [];
		for (const field of [
			"phase",
			"plan",
			"type",
			"wave",
			"depends_on",
			"files_modified",
			"autonomous",
			"must_haves"
		]) if (fm[field] === void 0) errors.push(`Missing required frontmatter field: ${field}`);
		const taskPattern = /<task[^>]*>([\s\S]*?)<\/task>/g;
		const tasks = [];
		let taskMatch;
		while ((taskMatch = taskPattern.exec(content)) !== null) {
			const taskContent = taskMatch[1];
			const nameMatch = taskContent.match(/<name>([\s\S]*?)<\/name>/);
			const taskName = nameMatch ? nameMatch[1].trim() : "unnamed";
			const hasFiles = /<files>/.test(taskContent);
			const hasAction = /<action>/.test(taskContent);
			const hasVerify = /<verify>/.test(taskContent);
			const hasDone = /<done>/.test(taskContent);
			if (!nameMatch) errors.push("Task missing <name> element");
			if (!hasAction) errors.push(`Task '${taskName}' missing <action>`);
			if (!hasVerify) warnings.push(`Task '${taskName}' missing <verify>`);
			if (!hasDone) warnings.push(`Task '${taskName}' missing <done>`);
			if (!hasFiles) warnings.push(`Task '${taskName}' missing <files>`);
			tasks.push({
				name: taskName,
				hasFiles,
				hasAction,
				hasVerify,
				hasDone
			});
		}
		if (tasks.length === 0) warnings.push("No <task> elements found");
		if (fm.wave && parseInt(String(fm.wave)) > 1 && (!fm.depends_on || Array.isArray(fm.depends_on) && fm.depends_on.length === 0)) warnings.push("Wave > 1 but depends_on is empty");
		if (/<task\s+type=["']?checkpoint/.test(content) && fm.autonomous !== "false" && fm.autonomous !== false) errors.push("Has checkpoint tasks but autonomous is not false");
		const result = {
			valid: errors.length === 0,
			errors,
			warnings,
			task_count: tasks.length,
			tasks,
			frontmatter_fields: Object.keys(fm)
		};
		(0, core_js_1.output)(result, raw, errors.length === 0 ? "valid" : "invalid");
	}
	function cmdVerifyPhaseCompleteness(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase required");
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phase);
		if (!phaseInfo) {
			(0, core_js_1.output)({
				error: "Phase not found",
				phase
			}, raw);
			return;
		}
		const errors = [];
		const warnings = [];
		const phaseDir = node_path_1$3.default.join(cwd, phaseInfo.directory);
		let files;
		try {
			files = node_fs_1$3.default.readdirSync(phaseDir);
		} catch {
			(0, core_js_1.output)({ error: "Cannot read phase directory" }, raw);
			return;
		}
		const plans = files.filter((f) => /-PLAN\.md$/i.test(f));
		const summaries = files.filter((f) => /-SUMMARY\.md$/i.test(f));
		const planIds = new Set(plans.map((p) => p.replace(/-PLAN\.md$/i, "")));
		const summaryIds = new Set(summaries.map((s) => s.replace(/-SUMMARY\.md$/i, "")));
		const incompletePlans = [...planIds].filter((id) => !summaryIds.has(id));
		if (incompletePlans.length > 0) errors.push(`Plans without summaries: ${incompletePlans.join(", ")}`);
		const orphanSummaries = [...summaryIds].filter((id) => !planIds.has(id));
		if (orphanSummaries.length > 0) warnings.push(`Summaries without plans: ${orphanSummaries.join(", ")}`);
		const result = {
			complete: errors.length === 0,
			phase: phaseInfo.phase_number,
			plan_count: plans.length,
			summary_count: summaries.length,
			incomplete_plans: incompletePlans,
			orphan_summaries: orphanSummaries,
			errors,
			warnings
		};
		(0, core_js_1.output)(result, raw, errors.length === 0 ? "complete" : "incomplete");
	}
	function cmdVerifyReferences(cwd, filePath, raw) {
		if (!filePath) (0, core_js_1.error)("file path required");
		const fullPath = node_path_1$3.default.isAbsolute(filePath) ? filePath : node_path_1$3.default.join(cwd, filePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: filePath
			}, raw);
			return;
		}
		const found = [];
		const missing = [];
		const atRefs = content.match(/@([^\s\n,)]+\/[^\s\n,)]+)/g) || [];
		for (const ref of atRefs) {
			const cleanRef = ref.slice(1);
			const resolved = cleanRef.startsWith("~/") ? node_path_1$3.default.join(process.env.HOME || "", cleanRef.slice(2)) : node_path_1$3.default.join(cwd, cleanRef);
			if (node_fs_1$3.default.existsSync(resolved)) found.push(cleanRef);
			else missing.push(cleanRef);
		}
		const backtickRefs = content.match(/`([^`]+\/[^`]+\.[a-zA-Z]{1,10})`/g) || [];
		for (const ref of backtickRefs) {
			const cleanRef = ref.slice(1, -1);
			if (cleanRef.startsWith("http") || cleanRef.includes("${") || cleanRef.includes("{{")) continue;
			if (found.includes(cleanRef) || missing.includes(cleanRef)) continue;
			const resolved = node_path_1$3.default.join(cwd, cleanRef);
			if (node_fs_1$3.default.existsSync(resolved)) found.push(cleanRef);
			else missing.push(cleanRef);
		}
		const result = {
			valid: missing.length === 0,
			found: found.length,
			missing,
			total: found.length + missing.length
		};
		(0, core_js_1.output)(result, raw, missing.length === 0 ? "valid" : "invalid");
	}
	function cmdVerifyCommits(cwd, hashes, raw) {
		if (!hashes || hashes.length === 0) (0, core_js_1.error)("At least one commit hash required");
		const valid = [];
		const invalid = [];
		for (const hash of hashes) {
			const result = (0, core_js_1.execGit)(cwd, [
				"cat-file",
				"-t",
				hash
			]);
			if (result.exitCode === 0 && result.stdout.trim() === "commit") valid.push(hash);
			else invalid.push(hash);
		}
		const commitResult = {
			all_valid: invalid.length === 0,
			valid,
			invalid,
			total: hashes.length
		};
		(0, core_js_1.output)(commitResult, raw, invalid.length === 0 ? "valid" : "invalid");
	}
	function cmdVerifyArtifacts(cwd, planFilePath, raw) {
		if (!planFilePath) (0, core_js_1.error)("plan file path required");
		const fullPath = node_path_1$3.default.isAbsolute(planFilePath) ? planFilePath : node_path_1$3.default.join(cwd, planFilePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: planFilePath
			}, raw);
			return;
		}
		const artifacts = (0, frontmatter_js_1.parseMustHavesBlock)(content, "artifacts");
		if (artifacts.length === 0) {
			(0, core_js_1.output)({
				error: "No must_haves.artifacts found in frontmatter",
				path: planFilePath
			}, raw);
			return;
		}
		const results = [];
		for (const artifact of artifacts) {
			if (typeof artifact === "string") continue;
			const artObj = artifact;
			const artPath = artObj.path;
			if (!artPath) continue;
			const artFullPath = node_path_1$3.default.join(cwd, artPath);
			const exists = node_fs_1$3.default.existsSync(artFullPath);
			const check = {
				path: artPath,
				exists,
				issues: [],
				passed: false
			};
			if (exists) {
				const fileContent = (0, core_js_1.safeReadFile)(artFullPath) || "";
				const lineCount = fileContent.split("\n").length;
				if (artObj.min_lines && lineCount < artObj.min_lines) check.issues.push(`Only ${lineCount} lines, need ${artObj.min_lines}`);
				if (artObj.contains && !fileContent.includes(artObj.contains)) check.issues.push(`Missing pattern: ${artObj.contains}`);
				if (artObj.exports) {
					const exportList = Array.isArray(artObj.exports) ? artObj.exports : [artObj.exports];
					for (const exp of exportList) if (!fileContent.includes(exp)) check.issues.push(`Missing export: ${exp}`);
				}
				check.passed = check.issues.length === 0;
			} else check.issues.push("File not found");
			results.push(check);
		}
		const passed = results.filter((r) => r.passed).length;
		const artifactsResult = {
			all_passed: passed === results.length,
			passed,
			total: results.length,
			artifacts: results
		};
		(0, core_js_1.output)(artifactsResult, raw, passed === results.length ? "valid" : "invalid");
	}
	function cmdVerifyKeyLinks(cwd, planFilePath, raw) {
		if (!planFilePath) (0, core_js_1.error)("plan file path required");
		const fullPath = node_path_1$3.default.isAbsolute(planFilePath) ? planFilePath : node_path_1$3.default.join(cwd, planFilePath);
		const content = (0, core_js_1.safeReadFile)(fullPath);
		if (!content) {
			(0, core_js_1.output)({
				error: "File not found",
				path: planFilePath
			}, raw);
			return;
		}
		const keyLinks = (0, frontmatter_js_1.parseMustHavesBlock)(content, "key_links");
		if (keyLinks.length === 0) {
			(0, core_js_1.output)({
				error: "No must_haves.key_links found in frontmatter",
				path: planFilePath
			}, raw);
			return;
		}
		const results = [];
		for (const link of keyLinks) {
			if (typeof link === "string") continue;
			const linkObj = link;
			const check = {
				from: linkObj.from || "",
				to: linkObj.to || "",
				via: linkObj.via || "",
				verified: false,
				detail: ""
			};
			const sourceContent = (0, core_js_1.safeReadFile)(node_path_1$3.default.join(cwd, linkObj.from || ""));
			if (!sourceContent) check.detail = "Source file not found";
			else if (linkObj.pattern) try {
				const regex = new RegExp(linkObj.pattern);
				if (regex.test(sourceContent)) {
					check.verified = true;
					check.detail = "Pattern found in source";
				} else {
					const targetContent = (0, core_js_1.safeReadFile)(node_path_1$3.default.join(cwd, linkObj.to || ""));
					if (targetContent && regex.test(targetContent)) {
						check.verified = true;
						check.detail = "Pattern found in target";
					} else check.detail = `Pattern "${linkObj.pattern}" not found in source or target`;
				}
			} catch {
				check.detail = `Invalid regex pattern: ${linkObj.pattern}`;
			}
			else if (sourceContent.includes(linkObj.to || "")) {
				check.verified = true;
				check.detail = "Target referenced in source";
			} else check.detail = "Target not referenced in source";
			results.push(check);
		}
		const verified = results.filter((r) => r.verified).length;
		const linksResult = {
			all_verified: verified === results.length,
			verified,
			total: results.length,
			links: results
		};
		(0, core_js_1.output)(linksResult, raw, verified === results.length ? "valid" : "invalid");
	}
	function cmdValidateConsistency(cwd, raw) {
		const roadmapPath = node_path_1$3.default.join(cwd, ".planning", "ROADMAP.md");
		const phasesDir = node_path_1$3.default.join(cwd, ".planning", "phases");
		const errors = [];
		const warnings = [];
		if (!node_fs_1$3.default.existsSync(roadmapPath)) {
			errors.push("ROADMAP.md not found");
			(0, core_js_1.output)({
				passed: false,
				errors,
				warnings
			}, raw, "failed");
			return;
		}
		const roadmapContent = node_fs_1$3.default.readFileSync(roadmapPath, "utf-8");
		const roadmapPhases = /* @__PURE__ */ new Set();
		const phasePattern = (0, core_js_1.getPhasePattern)();
		let m;
		while ((m = phasePattern.exec(roadmapContent)) !== null) roadmapPhases.add(m[1]);
		const diskPhases = /* @__PURE__ */ new Set();
		try {
			const dirs = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			for (const dir of dirs) {
				const dm = dir.match(/^(\d+[A-Z]?(?:\.\d+)?)/i);
				if (dm) diskPhases.add(dm[1]);
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		for (const p of roadmapPhases) if (!diskPhases.has(p) && !diskPhases.has((0, core_js_1.normalizePhaseName)(p))) warnings.push(`Phase ${p} in ROADMAP.md but no directory on disk`);
		for (const p of diskPhases) {
			const unpadded = String(parseInt(p, 10));
			if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) warnings.push(`Phase ${p} exists on disk but not in ROADMAP.md`);
		}
		const integerPhases = [...diskPhases].filter((p) => !p.includes(".")).map((p) => parseInt(p, 10)).sort((a, b) => a - b);
		for (let i = 1; i < integerPhases.length; i++) if (integerPhases[i] !== integerPhases[i - 1] + 1) warnings.push(`Gap in phase numbering: ${integerPhases[i - 1]}  ${integerPhases[i]}`);
		try {
			const dirs = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort();
			for (const dir of dirs) {
				const phaseFiles = node_fs_1$3.default.readdirSync(node_path_1$3.default.join(phasesDir, dir));
				const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md")).sort();
				const planNums = plans.map((p) => {
					const pm = p.match(/-(\d{2})-PLAN\.md$/);
					return pm ? parseInt(pm[1], 10) : null;
				}).filter((n) => n !== null);
				for (let i = 1; i < planNums.length; i++) if (planNums[i] !== planNums[i - 1] + 1) warnings.push(`Gap in plan numbering in ${dir}: plan ${planNums[i - 1]}  ${planNums[i]}`);
				const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md"));
				const planIdsSet = new Set(plans.map((p) => p.replace("-PLAN.md", "")));
				const summaryIdsSet = new Set(summaries.map((s) => s.replace("-SUMMARY.md", "")));
				for (const sid of summaryIdsSet) if (!planIdsSet.has(sid)) warnings.push(`Summary ${sid}-SUMMARY.md in ${dir} has no matching PLAN.md`);
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		try {
			const dirs = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			for (const dir of dirs) {
				const plans = node_fs_1$3.default.readdirSync(node_path_1$3.default.join(phasesDir, dir)).filter((f) => f.endsWith("-PLAN.md"));
				for (const plan of plans) {
					const content = node_fs_1$3.default.readFileSync(node_path_1$3.default.join(phasesDir, dir, plan), "utf-8");
					if (!(0, frontmatter_js_1.extractFrontmatter)(content).wave) warnings.push(`${dir}/${plan}: missing 'wave' in frontmatter`);
				}
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const passed = errors.length === 0;
		const result = {
			passed,
			errors,
			warnings,
			warning_count: warnings.length
		};
		(0, core_js_1.output)(result, raw, passed ? "passed" : "failed");
	}
	function cmdValidateHealth(cwd, options, raw) {
		const planningDir = node_path_1$3.default.join(cwd, ".planning");
		const projectPath = node_path_1$3.default.join(planningDir, "PROJECT.md");
		const roadmapPath = node_path_1$3.default.join(planningDir, "ROADMAP.md");
		const statePath = node_path_1$3.default.join(planningDir, "STATE.md");
		const configPath = node_path_1$3.default.join(planningDir, "config.json");
		const phasesDir = node_path_1$3.default.join(planningDir, "phases");
		const errors = [];
		const warnings = [];
		const info = [];
		const repairs = [];
		const addIssue = (severity, code, message, fix, repairable = false) => {
			const issue = {
				code,
				message,
				fix,
				repairable
			};
			if (severity === "error") errors.push(issue);
			else if (severity === "warning") warnings.push(issue);
			else info.push(issue);
		};
		if (!node_fs_1$3.default.existsSync(planningDir)) {
			addIssue("error", "E001", ".planning/ directory not found", "Run /maxsim:new-project to initialize");
			(0, core_js_1.output)({
				status: "broken",
				errors,
				warnings,
				info,
				repairable_count: 0
			}, raw);
			return;
		}
		if (!node_fs_1$3.default.existsSync(projectPath)) addIssue("error", "E002", "PROJECT.md not found", "Run /maxsim:new-project to create");
		else {
			const content = node_fs_1$3.default.readFileSync(projectPath, "utf-8");
			for (const section of [
				"## What This Is",
				"## Core Value",
				"## Requirements"
			]) if (!content.includes(section)) addIssue("warning", "W001", `PROJECT.md missing section: ${section}`, "Add section manually");
		}
		if (!node_fs_1$3.default.existsSync(roadmapPath)) addIssue("error", "E003", "ROADMAP.md not found", "Run /maxsim:new-milestone to create roadmap");
		if (!node_fs_1$3.default.existsSync(statePath)) {
			addIssue("error", "E004", "STATE.md not found", "Run /maxsim:health --repair to regenerate", true);
			repairs.push("regenerateState");
		} else {
			const phaseRefs = [...node_fs_1$3.default.readFileSync(statePath, "utf-8").matchAll(/[Pp]hase\s+(\d+(?:\.\d+)?)/g)].map((m) => m[1]);
			const diskPhases = /* @__PURE__ */ new Set();
			try {
				const entries = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true });
				for (const e of entries) if (e.isDirectory()) {
					const dm = e.name.match(/^(\d+(?:\.\d+)?)/);
					if (dm) diskPhases.add(dm[1]);
				}
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
			for (const ref of phaseRefs) {
				const normalizedRef = String(parseInt(ref, 10)).padStart(2, "0");
				if (!diskPhases.has(ref) && !diskPhases.has(normalizedRef) && !diskPhases.has(String(parseInt(ref, 10)))) {
					if (diskPhases.size > 0) {
						addIssue("warning", "W002", `STATE.md references phase ${ref}, but only phases ${[...diskPhases].sort().join(", ")} exist`, "Run /maxsim:health --repair to regenerate STATE.md", true);
						if (!repairs.includes("regenerateState")) repairs.push("regenerateState");
					}
				}
			}
		}
		if (!node_fs_1$3.default.existsSync(configPath)) {
			addIssue("warning", "W003", "config.json not found", "Run /maxsim:health --repair to create with defaults", true);
			repairs.push("createConfig");
		} else try {
			const rawContent = node_fs_1$3.default.readFileSync(configPath, "utf-8");
			const parsed = JSON.parse(rawContent);
			const validProfiles = [
				"quality",
				"balanced",
				"budget",
				"tokenburner"
			];
			if (parsed.model_profile && !validProfiles.includes(parsed.model_profile)) addIssue("warning", "W004", `config.json: invalid model_profile "${parsed.model_profile}"`, `Valid values: ${validProfiles.join(", ")}`);
		} catch (thrown) {
			addIssue("error", "E005", `config.json: JSON parse error - ${thrown.message}`, "Run /maxsim:health --repair to reset to defaults", true);
			repairs.push("resetConfig");
		}
		try {
			const entries = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true });
			for (const e of entries) if (e.isDirectory() && !e.name.match(/^\d{2}(?:\.\d+)?-[\w-]+$/)) addIssue("warning", "W005", `Phase directory "${e.name}" doesn't follow NN-name format`, "Rename to match pattern (e.g., 01-setup)");
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		try {
			const entries = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true });
			for (const e of entries) {
				if (!e.isDirectory()) continue;
				const phaseFiles = node_fs_1$3.default.readdirSync(node_path_1$3.default.join(phasesDir, e.name));
				const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
				const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
				const summaryBases = new Set(summaries.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", "")));
				for (const plan of plans) {
					const planBase = plan.replace("-PLAN.md", "").replace("PLAN.md", "");
					if (!summaryBases.has(planBase)) addIssue("info", "I001", `${e.name}/${plan} has no SUMMARY.md`, "May be in progress");
				}
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (node_fs_1$3.default.existsSync(roadmapPath)) {
			const roadmapContent = node_fs_1$3.default.readFileSync(roadmapPath, "utf-8");
			const roadmapPhases = /* @__PURE__ */ new Set();
			const phasePattern = (0, core_js_1.getPhasePattern)();
			let m;
			while ((m = phasePattern.exec(roadmapContent)) !== null) roadmapPhases.add(m[1]);
			const diskPhases = /* @__PURE__ */ new Set();
			try {
				const entries = node_fs_1$3.default.readdirSync(phasesDir, { withFileTypes: true });
				for (const e of entries) if (e.isDirectory()) {
					const dm = e.name.match(/^(\d+[A-Z]?(?:\.\d+)?)/i);
					if (dm) diskPhases.add(dm[1]);
				}
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
			for (const p of roadmapPhases) {
				const padded = String(parseInt(p, 10)).padStart(2, "0");
				if (!diskPhases.has(p) && !diskPhases.has(padded)) addIssue("warning", "W006", `Phase ${p} in ROADMAP.md but no directory on disk`, "Create phase directory or remove from roadmap");
			}
			for (const p of diskPhases) {
				const unpadded = String(parseInt(p, 10));
				if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) addIssue("warning", "W007", `Phase ${p} exists on disk but not in ROADMAP.md`, "Add to roadmap or remove directory");
			}
		}
		const repairActions = [];
		if (options.repair && repairs.length > 0) for (const repair of repairs) try {
			switch (repair) {
				case "createConfig":
				case "resetConfig":
					node_fs_1$3.default.writeFileSync(configPath, JSON.stringify({
						model_profile: "balanced",
						commit_docs: true,
						search_gitignored: false,
						branching_strategy: "none",
						research: true,
						plan_checker: true,
						verifier: true,
						parallelization: true
					}, null, 2), "utf-8");
					repairActions.push({
						action: repair,
						success: true,
						path: "config.json"
					});
					break;
				case "regenerateState": {
					if (node_fs_1$3.default.existsSync(statePath)) {
						const backupPath = `${statePath}.bak-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, 19)}`;
						node_fs_1$3.default.copyFileSync(statePath, backupPath);
						repairActions.push({
							action: "backupState",
							success: true,
							path: backupPath
						});
					}
					const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
					let stateContent = `# Session State\n\n`;
					stateContent += `## Project Reference\n\n`;
					stateContent += `See: .planning/PROJECT.md\n\n`;
					stateContent += `## Position\n\n`;
					stateContent += `**Milestone:** ${milestone.version} ${milestone.name}\n`;
					stateContent += `**Current phase:** (determining...)\n`;
					stateContent += `**Status:** Resuming\n\n`;
					stateContent += `## Session Log\n\n`;
					stateContent += `- ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}: STATE.md regenerated by /maxsim:health --repair\n`;
					node_fs_1$3.default.writeFileSync(statePath, stateContent, "utf-8");
					repairActions.push({
						action: repair,
						success: true,
						path: "STATE.md"
					});
					break;
				}
			}
		} catch (thrown) {
			const repairErr = thrown;
			repairActions.push({
				action: repair,
				success: false,
				error: repairErr.message
			});
		}
		let status;
		if (errors.length > 0) status = "broken";
		else if (warnings.length > 0) status = "degraded";
		else status = "healthy";
		const repairableCount = errors.filter((e) => e.repairable).length + warnings.filter((w) => w.repairable).length;
		const result = {
			status,
			errors,
			warnings,
			info,
			repairable_count: repairableCount,
			repairs_performed: repairActions.length > 0 ? repairActions : void 0
		};
		(0, core_js_1.output)(result, raw);
	}
}));

//#endregion
//#region ../core/dist/phase.js
var require_phase = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Phase  Phase CRUD, query, and lifecycle operations
	*
	* Ported from maxsim/bin/lib/phase.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdPhasesList = cmdPhasesList;
	exports.cmdPhaseNextDecimal = cmdPhaseNextDecimal;
	exports.cmdFindPhase = cmdFindPhase;
	exports.cmdPhasePlanIndex = cmdPhasePlanIndex;
	exports.cmdPhaseAdd = cmdPhaseAdd;
	exports.cmdPhaseInsert = cmdPhaseInsert;
	exports.cmdPhaseRemove = cmdPhaseRemove;
	exports.cmdPhaseComplete = cmdPhaseComplete;
	const node_fs_1$2 = __importDefault(require("node:fs"));
	const node_path_1$2 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	const frontmatter_js_1 = require_frontmatter();
	function cmdPhasesList(cwd, options, raw) {
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const { type, phase, includeArchived } = options;
		if (!node_fs_1$2.default.existsSync(phasesDir)) {
			if (type) (0, core_js_1.output)({
				files: [],
				count: 0
			}, raw, "");
			else (0, core_js_1.output)({
				directories: [],
				count: 0
			}, raw, "");
			return;
		}
		try {
			let dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			if (includeArchived) {
				const archived = (0, core_js_1.getArchivedPhaseDirs)(cwd);
				for (const a of archived) dirs.push(`${a.name} [${a.milestone}]`);
			}
			dirs.sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b));
			if (phase) {
				const normalized = (0, core_js_1.normalizePhaseName)(phase);
				const match = dirs.find((d) => d.startsWith(normalized));
				if (!match) {
					(0, core_js_1.output)({
						files: [],
						count: 0,
						phase_dir: null,
						error: "Phase not found"
					}, raw, "");
					return;
				}
				dirs = [match];
			}
			if (type) {
				const files = [];
				for (const dir of dirs) {
					const dirPath = node_path_1$2.default.join(phasesDir, dir);
					const dirFiles = node_fs_1$2.default.readdirSync(dirPath);
					let filtered;
					if (type === "plans") filtered = dirFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
					else if (type === "summaries") filtered = dirFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
					else filtered = dirFiles;
					files.push(...filtered.sort());
				}
				const result = {
					files,
					count: files.length,
					phase_dir: phase ? dirs[0].replace(/^\d+(?:\.\d+)?-?/, "") : null
				};
				(0, core_js_1.output)(result, raw, files.join("\n"));
				return;
			}
			(0, core_js_1.output)({
				directories: dirs,
				count: dirs.length
			}, raw, dirs.join("\n"));
		} catch (e) {
			(0, core_js_1.error)("Failed to list phases: " + e.message);
		}
	}
	function cmdPhaseNextDecimal(cwd, basePhase, raw) {
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const normalized = (0, core_js_1.normalizePhaseName)(basePhase);
		if (!node_fs_1$2.default.existsSync(phasesDir)) {
			(0, core_js_1.output)({
				found: false,
				base_phase: normalized,
				next: `${normalized}.1`,
				existing: []
			}, raw, `${normalized}.1`);
			return;
		}
		try {
			const dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			const baseExists = dirs.some((d) => d.startsWith(normalized + "-") || d === normalized);
			const decimalPattern = new RegExp(`^${normalized}\\.(\\d+)`);
			const existingDecimals = [];
			for (const dir of dirs) {
				const match = dir.match(decimalPattern);
				if (match) existingDecimals.push(`${normalized}.${match[1]}`);
			}
			existingDecimals.sort((a, b) => {
				return parseFloat(a) - parseFloat(b);
			});
			let nextDecimal;
			if (existingDecimals.length === 0) nextDecimal = `${normalized}.1`;
			else {
				const lastDecimal = existingDecimals[existingDecimals.length - 1];
				nextDecimal = `${normalized}.${parseInt(lastDecimal.split(".")[1], 10) + 1}`;
			}
			(0, core_js_1.output)({
				found: baseExists,
				base_phase: normalized,
				next: nextDecimal,
				existing: existingDecimals
			}, raw, nextDecimal);
		} catch (e) {
			(0, core_js_1.error)("Failed to calculate next decimal phase: " + e.message);
		}
	}
	function cmdFindPhase(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase identifier required");
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const normalized = (0, core_js_1.normalizePhaseName)(phase);
		const notFound = {
			found: false,
			directory: null,
			phase_number: null,
			phase_name: null,
			plans: [],
			summaries: []
		};
		try {
			const match = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b)).find((d) => d.startsWith(normalized));
			if (!match) {
				(0, core_js_1.output)(notFound, raw, "");
				return;
			}
			const dirMatch = match.match(/^(\d+[A-Z]?(?:\.\d+)?)-?(.*)/i);
			const phaseNumber = dirMatch ? dirMatch[1] : normalized;
			const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;
			const phaseDir = node_path_1$2.default.join(phasesDir, match);
			const phaseFiles = node_fs_1$2.default.readdirSync(phaseDir);
			const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
			const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").sort();
			const result = {
				found: true,
				directory: node_path_1$2.default.join(".planning", "phases", match),
				phase_number: phaseNumber,
				phase_name: phaseName,
				plans,
				summaries
			};
			(0, core_js_1.output)(result, raw, result.directory);
		} catch {
			(0, core_js_1.output)(notFound, raw, "");
		}
	}
	function cmdPhasePlanIndex(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase required for phase-plan-index");
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const normalized = (0, core_js_1.normalizePhaseName)(phase);
		let phaseDir = null;
		try {
			const match = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b)).find((d) => d.startsWith(normalized));
			if (match) phaseDir = node_path_1$2.default.join(phasesDir, match);
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (!phaseDir) {
			(0, core_js_1.output)({
				phase: normalized,
				error: "Phase not found",
				plans: [],
				waves: {},
				incomplete: [],
				has_checkpoints: false
			}, raw);
			return;
		}
		const phaseFiles = node_fs_1$2.default.readdirSync(phaseDir);
		const planFiles = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
		const summaryFiles = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
		const completedPlanIds = new Set(summaryFiles.map((s) => s.replace("-SUMMARY.md", "").replace("SUMMARY.md", "")));
		const plans = [];
		const waves = {};
		const incomplete = [];
		let hasCheckpoints = false;
		for (const planFile of planFiles) {
			const planId = planFile.replace("-PLAN.md", "").replace("PLAN.md", "");
			const planPath = node_path_1$2.default.join(phaseDir, planFile);
			const content = node_fs_1$2.default.readFileSync(planPath, "utf-8");
			const fm = (0, frontmatter_js_1.extractFrontmatter)(content);
			const taskCount = (content.match(/##\s*Task\s*\d+/gi) || []).length;
			const wave = parseInt(fm.wave, 10) || 1;
			let autonomous = true;
			if (fm.autonomous !== void 0) autonomous = fm.autonomous === "true" || fm.autonomous === true;
			if (!autonomous) hasCheckpoints = true;
			let filesModified = [];
			if (fm["files-modified"]) filesModified = Array.isArray(fm["files-modified"]) ? fm["files-modified"] : [fm["files-modified"]];
			const hasSummary = completedPlanIds.has(planId);
			if (!hasSummary) incomplete.push(planId);
			const plan = {
				id: planId,
				wave,
				autonomous,
				objective: fm.objective || null,
				files_modified: filesModified,
				task_count: taskCount,
				has_summary: hasSummary
			};
			plans.push(plan);
			const waveKey = String(wave);
			if (!waves[waveKey]) waves[waveKey] = [];
			waves[waveKey].push(planId);
		}
		(0, core_js_1.output)({
			phase: normalized,
			plans,
			waves,
			incomplete,
			has_checkpoints: hasCheckpoints
		}, raw);
	}
	function cmdPhaseAdd(cwd, description, raw) {
		if (!description) (0, core_js_1.error)("description required for phase add");
		const roadmapPath = node_path_1$2.default.join(cwd, ".planning", "ROADMAP.md");
		if (!node_fs_1$2.default.existsSync(roadmapPath)) (0, core_js_1.error)("ROADMAP.md not found");
		const content = node_fs_1$2.default.readFileSync(roadmapPath, "utf-8");
		const slug = (0, core_js_1.generateSlugInternal)(description);
		const phasePattern = (0, core_js_1.getPhasePattern)();
		let maxPhase = 0;
		let m;
		while ((m = phasePattern.exec(content)) !== null) {
			const num = parseInt(m[1], 10);
			if (num > maxPhase) maxPhase = num;
		}
		const newPhaseNum = maxPhase + 1;
		const paddedNum = String(newPhaseNum).padStart(2, "0");
		const dirName = `${paddedNum}-${slug}`;
		const dirPath = node_path_1$2.default.join(cwd, ".planning", "phases", dirName);
		node_fs_1$2.default.mkdirSync(dirPath, { recursive: true });
		node_fs_1$2.default.writeFileSync(node_path_1$2.default.join(dirPath, ".gitkeep"), "");
		const phaseEntry = `\n### Phase ${newPhaseNum}: ${description}\n\n**Goal:** [To be planned]\n**Requirements**: TBD\n**Depends on:** Phase ${maxPhase}\n**Plans:** 0 plans\n\nPlans:\n- [ ] TBD (run /maxsim:plan-phase ${newPhaseNum} to break down)\n`;
		let updatedContent;
		const lastSeparator = content.lastIndexOf("\n---");
		if (lastSeparator > 0) updatedContent = content.slice(0, lastSeparator) + phaseEntry + content.slice(lastSeparator);
		else updatedContent = content + phaseEntry;
		node_fs_1$2.default.writeFileSync(roadmapPath, updatedContent, "utf-8");
		(0, core_js_1.output)({
			phase_number: newPhaseNum,
			padded: paddedNum,
			name: description,
			slug,
			directory: `.planning/phases/${dirName}`
		}, raw, paddedNum);
	}
	function cmdPhaseInsert(cwd, afterPhase, description, raw) {
		if (!afterPhase || !description) (0, core_js_1.error)("after-phase and description required for phase insert");
		const roadmapPath = node_path_1$2.default.join(cwd, ".planning", "ROADMAP.md");
		if (!node_fs_1$2.default.existsSync(roadmapPath)) (0, core_js_1.error)("ROADMAP.md not found");
		const content = node_fs_1$2.default.readFileSync(roadmapPath, "utf-8");
		const slug = (0, core_js_1.generateSlugInternal)(description);
		const afterPhaseEscaped = (0, core_js_1.normalizePhaseName)(afterPhase).replace(/^0+/, "").replace(/\./g, "\\.");
		if (!(0, core_js_1.getPhasePattern)(afterPhaseEscaped, "i").test(content)) (0, core_js_1.error)(`Phase ${afterPhase} not found in ROADMAP.md`);
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const normalizedBase = (0, core_js_1.normalizePhaseName)(afterPhase);
		const existingDecimals = [];
		try {
			const dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			const decimalPattern = new RegExp(`^${normalizedBase}\\.(\\d+)`);
			for (const dir of dirs) {
				const dm = dir.match(decimalPattern);
				if (dm) existingDecimals.push(parseInt(dm[1], 10));
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const decimalPhase = `${normalizedBase}.${existingDecimals.length === 0 ? 1 : Math.max(...existingDecimals) + 1}`;
		const dirName = `${decimalPhase}-${slug}`;
		const dirPath = node_path_1$2.default.join(cwd, ".planning", "phases", dirName);
		node_fs_1$2.default.mkdirSync(dirPath, { recursive: true });
		node_fs_1$2.default.writeFileSync(node_path_1$2.default.join(dirPath, ".gitkeep"), "");
		const phaseEntry = `\n### Phase ${decimalPhase}: ${description} (INSERTED)\n\n**Goal:** [Urgent work - to be planned]\n**Requirements**: TBD\n**Depends on:** Phase ${afterPhase}\n**Plans:** 0 plans\n\nPlans:\n- [ ] TBD (run /maxsim:plan-phase ${decimalPhase} to break down)\n`;
		const headerPattern = new RegExp(`(#{2,4}\\s*Phase\\s+0*${afterPhaseEscaped}:[^\\n]*\\n)`, "i");
		const headerMatch = content.match(headerPattern);
		if (!headerMatch) (0, core_js_1.error)(`Could not find Phase ${afterPhase} header`);
		const headerIdx = content.indexOf(headerMatch[0]);
		const nextPhaseMatch = content.slice(headerIdx + headerMatch[0].length).match(/\n#{2,4}\s+Phase\s+\d/i);
		let insertIdx;
		if (nextPhaseMatch) insertIdx = headerIdx + headerMatch[0].length + nextPhaseMatch.index;
		else insertIdx = content.length;
		const updatedContent = content.slice(0, insertIdx) + phaseEntry + content.slice(insertIdx);
		node_fs_1$2.default.writeFileSync(roadmapPath, updatedContent, "utf-8");
		(0, core_js_1.output)({
			phase_number: decimalPhase,
			after_phase: afterPhase,
			name: description,
			slug,
			directory: `.planning/phases/${dirName}`
		}, raw, decimalPhase);
	}
	function cmdPhaseRemove(cwd, targetPhase, options, raw) {
		if (!targetPhase) (0, core_js_1.error)("phase number required for phase remove");
		const roadmapPath = node_path_1$2.default.join(cwd, ".planning", "ROADMAP.md");
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		const force = options.force || false;
		if (!node_fs_1$2.default.existsSync(roadmapPath)) (0, core_js_1.error)("ROADMAP.md not found");
		const normalized = (0, core_js_1.normalizePhaseName)(targetPhase);
		const isDecimal = targetPhase.includes(".");
		let targetDir = null;
		try {
			targetDir = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b)).find((d) => d.startsWith(normalized + "-") || d === normalized) || null;
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (targetDir && !force) {
			const targetPath = node_path_1$2.default.join(phasesDir, targetDir);
			const summaries = node_fs_1$2.default.readdirSync(targetPath).filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
			if (summaries.length > 0) (0, core_js_1.error)(`Phase ${targetPhase} has ${summaries.length} executed plan(s). Use --force to remove anyway.`);
		}
		if (targetDir) node_fs_1$2.default.rmSync(node_path_1$2.default.join(phasesDir, targetDir), {
			recursive: true,
			force: true
		});
		const renamedDirs = [];
		const renamedFiles = [];
		if (isDecimal) {
			const baseParts = normalized.split(".");
			const baseInt = baseParts[0];
			const removedDecimal = parseInt(baseParts[1], 10);
			try {
				const dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b));
				const decPattern = new RegExp(`^${baseInt}\\.(\\d+)-(.+)$`);
				const toRename = [];
				for (const dir of dirs) {
					const dm = dir.match(decPattern);
					if (dm && parseInt(dm[1], 10) > removedDecimal) toRename.push({
						dir,
						oldDecimal: parseInt(dm[1], 10),
						slug: dm[2]
					});
				}
				toRename.sort((a, b) => b.oldDecimal - a.oldDecimal);
				for (const item of toRename) {
					const newDecimal = item.oldDecimal - 1;
					const oldPhaseId = `${baseInt}.${item.oldDecimal}`;
					const newPhaseId = `${baseInt}.${newDecimal}`;
					const newDirName = `${baseInt}.${newDecimal}-${item.slug}`;
					node_fs_1$2.default.renameSync(node_path_1$2.default.join(phasesDir, item.dir), node_path_1$2.default.join(phasesDir, newDirName));
					renamedDirs.push({
						from: item.dir,
						to: newDirName
					});
					const dirFiles = node_fs_1$2.default.readdirSync(node_path_1$2.default.join(phasesDir, newDirName));
					for (const f of dirFiles) if (f.includes(oldPhaseId)) {
						const newFileName = f.replace(oldPhaseId, newPhaseId);
						node_fs_1$2.default.renameSync(node_path_1$2.default.join(phasesDir, newDirName, f), node_path_1$2.default.join(phasesDir, newDirName, newFileName));
						renamedFiles.push({
							from: f,
							to: newFileName
						});
					}
				}
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
		} else {
			const removedInt = parseInt(normalized, 10);
			try {
				const dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b));
				const toRename = [];
				for (const dir of dirs) {
					const dm = dir.match(/^(\d+)([A-Z])?(?:\.(\d+))?-(.+)$/i);
					if (!dm) continue;
					const dirInt = parseInt(dm[1], 10);
					if (dirInt > removedInt) toRename.push({
						dir,
						oldInt: dirInt,
						letter: dm[2] ? dm[2].toUpperCase() : "",
						decimal: dm[3] ? parseInt(dm[3], 10) : null,
						slug: dm[4]
					});
				}
				toRename.sort((a, b) => {
					if (a.oldInt !== b.oldInt) return b.oldInt - a.oldInt;
					return (b.decimal || 0) - (a.decimal || 0);
				});
				for (const item of toRename) {
					const newInt = item.oldInt - 1;
					const newPadded = String(newInt).padStart(2, "0");
					const oldPadded = String(item.oldInt).padStart(2, "0");
					const letterSuffix = item.letter || "";
					const decimalSuffix = item.decimal !== null ? `.${item.decimal}` : "";
					const oldPrefix = `${oldPadded}${letterSuffix}${decimalSuffix}`;
					const newPrefix = `${newPadded}${letterSuffix}${decimalSuffix}`;
					const newDirName = `${newPrefix}-${item.slug}`;
					node_fs_1$2.default.renameSync(node_path_1$2.default.join(phasesDir, item.dir), node_path_1$2.default.join(phasesDir, newDirName));
					renamedDirs.push({
						from: item.dir,
						to: newDirName
					});
					const dirFiles = node_fs_1$2.default.readdirSync(node_path_1$2.default.join(phasesDir, newDirName));
					for (const f of dirFiles) if (f.startsWith(oldPrefix)) {
						const newFileName = newPrefix + f.slice(oldPrefix.length);
						node_fs_1$2.default.renameSync(node_path_1$2.default.join(phasesDir, newDirName, f), node_path_1$2.default.join(phasesDir, newDirName, newFileName));
						renamedFiles.push({
							from: f,
							to: newFileName
						});
					}
				}
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
		}
		let roadmapContent = node_fs_1$2.default.readFileSync(roadmapPath, "utf-8");
		const targetEscaped = targetPhase.replace(/\./g, "\\.");
		const sectionPattern = new RegExp(`\\n?#{2,4}\\s*Phase\\s+${targetEscaped}\\s*:[\\s\\S]*?(?=\\n#{2,4}\\s+Phase\\s+\\d|$)`, "i");
		roadmapContent = roadmapContent.replace(sectionPattern, "");
		const checkboxPattern = new RegExp(`\\n?-\\s*\\[[ x]\\]\\s*.*Phase\\s+${targetEscaped}[:\\s][^\\n]*`, "gi");
		roadmapContent = roadmapContent.replace(checkboxPattern, "");
		const tableRowPattern = new RegExp(`\\n?\\|\\s*${targetEscaped}\\.?\\s[^|]*\\|[^\\n]*`, "gi");
		roadmapContent = roadmapContent.replace(tableRowPattern, "");
		if (!isDecimal) {
			const removedInt = parseInt(normalized, 10);
			for (let oldNum = 99; oldNum > removedInt; oldNum--) {
				const newNum = oldNum - 1;
				const oldStr = String(oldNum);
				const newStr = String(newNum);
				const oldPad = oldStr.padStart(2, "0");
				const newPad = newStr.padStart(2, "0");
				roadmapContent = roadmapContent.replace(new RegExp(`(#{2,4}\\s*Phase\\s+)${oldStr}(\\s*:)`, "gi"), `$1${newStr}$2`);
				roadmapContent = roadmapContent.replace(new RegExp(`(Phase\\s+)${oldStr}([:\\s])`, "g"), `$1${newStr}$2`);
				roadmapContent = roadmapContent.replace(new RegExp(`${oldPad}-(\\d{2})`, "g"), `${newPad}-$1`);
				roadmapContent = roadmapContent.replace(new RegExp(`(\\|\\s*)${oldStr}\\.\\s`, "g"), `$1${newStr}. `);
				roadmapContent = roadmapContent.replace(new RegExp(`(Depends on:\\*\\*\\s*Phase\\s+)${oldStr}\\b`, "gi"), `$1${newStr}`);
			}
		}
		node_fs_1$2.default.writeFileSync(roadmapPath, roadmapContent, "utf-8");
		const statePath = node_path_1$2.default.join(cwd, ".planning", "STATE.md");
		if (node_fs_1$2.default.existsSync(statePath)) {
			let stateContent = node_fs_1$2.default.readFileSync(statePath, "utf-8");
			const totalPattern = /(\*\*Total Phases:\*\*\s*)(\d+)/;
			const totalMatch = stateContent.match(totalPattern);
			if (totalMatch) {
				const oldTotal = parseInt(totalMatch[2], 10);
				stateContent = stateContent.replace(totalPattern, `$1${oldTotal - 1}`);
			}
			const ofPattern = /(\bof\s+)(\d+)(\s*(?:\(|phases?))/i;
			const ofMatch = stateContent.match(ofPattern);
			if (ofMatch) {
				const oldTotal = parseInt(ofMatch[2], 10);
				stateContent = stateContent.replace(ofPattern, `$1${oldTotal - 1}$3`);
			}
			node_fs_1$2.default.writeFileSync(statePath, stateContent, "utf-8");
		}
		(0, core_js_1.output)({
			removed: targetPhase,
			directory_deleted: targetDir || null,
			renamed_directories: renamedDirs,
			renamed_files: renamedFiles,
			roadmap_updated: true,
			state_updated: node_fs_1$2.default.existsSync(statePath)
		}, raw);
	}
	function cmdPhaseComplete(cwd, phaseNum, raw) {
		if (!phaseNum) (0, core_js_1.error)("phase number required for phase complete");
		const roadmapPath = node_path_1$2.default.join(cwd, ".planning", "ROADMAP.md");
		const statePath = node_path_1$2.default.join(cwd, ".planning", "STATE.md");
		const phasesDir = node_path_1$2.default.join(cwd, ".planning", "phases");
		(0, core_js_1.normalizePhaseName)(phaseNum);
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phaseNum);
		if (!phaseInfo) (0, core_js_1.error)(`Phase ${phaseNum} not found`);
		const planCount = phaseInfo.plans.length;
		const summaryCount = phaseInfo.summaries.length;
		if (node_fs_1$2.default.existsSync(roadmapPath)) {
			let roadmapContent = node_fs_1$2.default.readFileSync(roadmapPath, "utf-8");
			const checkboxPattern = new RegExp(`(-\\s*\\[)[ ](\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}[:\\s][^\\n]*)`, "i");
			roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);
			const phaseEscaped = phaseNum.replace(".", "\\.");
			const tablePattern = new RegExp(`(\\|\\s*${phaseEscaped}\\.?\\s[^|]*\\|[^|]*\\|)\\s*[^|]*(\\|)\\s*[^|]*(\\|)`, "i");
			roadmapContent = roadmapContent.replace(tablePattern, `$1 Complete    $2 ${today} $3`);
			const planCountPattern = new RegExp(`(#{2,4}\\s*Phase\\s+${phaseEscaped}[\\s\\S]*?\\*\\*Plans:\\*\\*\\s*)[^\\n]+`, "i");
			roadmapContent = roadmapContent.replace(planCountPattern, `$1${summaryCount}/${planCount} plans complete`);
			node_fs_1$2.default.writeFileSync(roadmapPath, roadmapContent, "utf-8");
			const reqPath = node_path_1$2.default.join(cwd, ".planning", "REQUIREMENTS.md");
			if (node_fs_1$2.default.existsSync(reqPath)) {
				const reqMatch = roadmapContent.match(new RegExp(`Phase\\s+${phaseNum.replace(".", "\\.")}[\\s\\S]*?\\*\\*Requirements:\\*\\*\\s*([^\\n]+)`, "i"));
				if (reqMatch) {
					const reqIds = reqMatch[1].replace(/[\[\]]/g, "").split(/[,\s]+/).map((r) => r.trim()).filter(Boolean);
					let reqContent = node_fs_1$2.default.readFileSync(reqPath, "utf-8");
					for (const reqId of reqIds) {
						reqContent = reqContent.replace(new RegExp(`(-\\s*\\[)[ ](\\]\\s*\\*\\*${reqId}\\*\\*)`, "gi"), "$1x$2");
						reqContent = reqContent.replace(new RegExp(`(\\|\\s*${reqId}\\s*\\|[^|]+\\|)\\s*Pending\\s*(\\|)`, "gi"), "$1 Complete $2");
					}
					node_fs_1$2.default.writeFileSync(reqPath, reqContent, "utf-8");
				}
			}
		}
		let nextPhaseNum = null;
		let nextPhaseName = null;
		let isLastPhase = true;
		try {
			const dirs = node_fs_1$2.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, core_js_1.comparePhaseNum)(a, b));
			for (const dir of dirs) {
				const dm = dir.match(/^(\d+[A-Z]?(?:\.\d+)?)-?(.*)/i);
				if (dm) {
					if ((0, core_js_1.comparePhaseNum)(dm[1], phaseNum) > 0) {
						nextPhaseNum = dm[1];
						nextPhaseName = dm[2] || null;
						isLastPhase = false;
						break;
					}
				}
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		if (node_fs_1$2.default.existsSync(statePath)) {
			let stateContent = node_fs_1$2.default.readFileSync(statePath, "utf-8");
			stateContent = stateContent.replace(/(\*\*Current Phase:\*\*\s*).*/, `$1${nextPhaseNum || phaseNum}`);
			if (nextPhaseName) stateContent = stateContent.replace(/(\*\*Current Phase Name:\*\*\s*).*/, `$1${nextPhaseName.replace(/-/g, " ")}`);
			stateContent = stateContent.replace(/(\*\*Status:\*\*\s*).*/, `$1${isLastPhase ? "Milestone complete" : "Ready to plan"}`);
			stateContent = stateContent.replace(/(\*\*Current Plan:\*\*\s*).*/, `$1Not started`);
			stateContent = stateContent.replace(/(\*\*Last Activity:\*\*\s*).*/, `$1${today}`);
			stateContent = stateContent.replace(/(\*\*Last Activity Description:\*\*\s*).*/, `$1Phase ${phaseNum} complete${nextPhaseNum ? `, transitioned to Phase ${nextPhaseNum}` : ""}`);
			node_fs_1$2.default.writeFileSync(statePath, stateContent, "utf-8");
		}
		(0, core_js_1.output)({
			completed_phase: phaseNum,
			phase_name: phaseInfo.phase_name,
			plans_executed: `${summaryCount}/${planCount}`,
			next_phase: nextPhaseNum,
			next_phase_name: nextPhaseName,
			is_last_phase: isLastPhase,
			date: today,
			roadmap_updated: node_fs_1$2.default.existsSync(roadmapPath),
			state_updated: node_fs_1$2.default.existsSync(statePath)
		}, raw);
	}
}));

//#endregion
//#region ../core/dist/template.js
var require_template = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Template  Template selection and fill operations
	*
	* Ported from maxsim/bin/lib/template.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdTemplateSelect = cmdTemplateSelect;
	exports.cmdTemplateFill = cmdTemplateFill;
	const node_fs_1$1 = __importDefault(require("node:fs"));
	const node_path_1$1 = __importDefault(require("node:path"));
	const core_js_1 = require_core();
	const frontmatter_js_1 = require_frontmatter();
	function cmdTemplateSelect(cwd, planPath, raw) {
		if (!planPath) (0, core_js_1.error)("plan-path required");
		try {
			const fullPath = node_path_1$1.default.join(cwd, planPath);
			const content = node_fs_1$1.default.readFileSync(fullPath, "utf-8");
			const taskCount = (content.match(/###\s*Task\s*\d+/g) || []).length;
			const hasDecisions = (content.match(/decision/gi) || []).length > 0;
			const fileMentions = /* @__PURE__ */ new Set();
			const filePattern = /`([^`]+\.[a-zA-Z]+)`/g;
			let m;
			while ((m = filePattern.exec(content)) !== null) if (m[1].includes("/") && !m[1].startsWith("http")) fileMentions.add(m[1]);
			const fileCount = fileMentions.size;
			let template = "templates/summary-standard.md";
			let type = "standard";
			if (taskCount <= 2 && fileCount <= 3 && !hasDecisions) {
				template = "templates/summary-minimal.md";
				type = "minimal";
			} else if (hasDecisions || fileCount > 6 || taskCount > 5) {
				template = "templates/summary-complex.md";
				type = "complex";
			}
			const result = {
				template,
				type,
				taskCount,
				fileCount,
				hasDecisions
			};
			(0, core_js_1.output)(result, raw, template);
		} catch (thrown) {
			const selectErr = thrown;
			(0, core_js_1.output)({
				template: "templates/summary-standard.md",
				type: "standard",
				error: selectErr.message
			}, raw, "templates/summary-standard.md");
		}
	}
	function cmdTemplateFill(cwd, templateType, options, raw) {
		if (!templateType) (0, core_js_1.error)("template type required: summary, plan, or verification");
		if (!options.phase) (0, core_js_1.error)("--phase required");
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, options.phase);
		if (!phaseInfo) {
			(0, core_js_1.output)({
				error: "Phase not found",
				phase: options.phase
			}, raw);
			return;
		}
		const padded = (0, core_js_1.normalizePhaseName)(options.phase);
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		const phaseName = options.name || phaseInfo.phase_name || "Unnamed";
		const phaseId = `${padded}-${phaseInfo.phase_slug || (0, core_js_1.generateSlugInternal)(phaseName)}`;
		const planNum = (options.plan || "01").padStart(2, "0");
		const fields = options.fields || {};
		let frontmatter;
		let body;
		let fileName;
		switch (templateType) {
			case "summary":
				frontmatter = {
					phase: phaseId,
					plan: planNum,
					subsystem: "[primary category]",
					tags: [],
					provides: [],
					affects: [],
					"tech-stack": {
						added: [],
						patterns: []
					},
					"key-files": {
						created: [],
						modified: []
					},
					"key-decisions": [],
					"patterns-established": [],
					duration: "[X]min",
					completed: today,
					...fields
				};
				body = [
					`# Phase ${options.phase}: ${phaseName} Summary`,
					"",
					"**[Substantive one-liner describing outcome]**",
					"",
					"## Performance",
					"- **Duration:** [time]",
					"- **Tasks:** [count completed]",
					"- **Files modified:** [count]",
					"",
					"## Accomplishments",
					"- [Key outcome 1]",
					"- [Key outcome 2]",
					"",
					"## Task Commits",
					"1. **Task 1: [task name]** - `hash`",
					"",
					"## Files Created/Modified",
					"- `path/to/file.ts` - What it does",
					"",
					"## Decisions & Deviations",
					"[Key decisions or \"None - followed plan as specified\"]",
					"",
					"## Next Phase Readiness",
					"[What's ready for next phase]"
				].join("\n");
				fileName = `${padded}-${planNum}-SUMMARY.md`;
				break;
			case "plan":
				frontmatter = {
					phase: phaseId,
					plan: planNum,
					type: options.type || "execute",
					wave: parseInt(options.wave || "1") || 1,
					depends_on: [],
					files_modified: [],
					autonomous: true,
					user_setup: [],
					must_haves: {
						truths: [],
						artifacts: [],
						key_links: []
					},
					...fields
				};
				body = [
					`# Phase ${options.phase} Plan ${planNum}: [Title]`,
					"",
					"## Objective",
					"- **What:** [What this plan builds]",
					"- **Why:** [Why it matters for the phase goal]",
					"- **Output:** [Concrete deliverable]",
					"",
					"## Context",
					"@.planning/PROJECT.md",
					"@.planning/ROADMAP.md",
					"@.planning/STATE.md",
					"",
					"## Tasks",
					"",
					"<task type=\"code\">",
					"  <name>[Task name]</name>",
					"  <files>[file paths]</files>",
					"  <action>[What to do]</action>",
					"  <verify>[How to verify]</verify>",
					"  <done>[Definition of done]</done>",
					"</task>",
					"",
					"## Verification",
					"[How to verify this plan achieved its objective]",
					"",
					"## Success Criteria",
					"- [ ] [Criterion 1]",
					"- [ ] [Criterion 2]"
				].join("\n");
				fileName = `${padded}-${planNum}-PLAN.md`;
				break;
			case "verification":
				frontmatter = {
					phase: phaseId,
					verified: (/* @__PURE__ */ new Date()).toISOString(),
					status: "pending",
					score: "0/0 must-haves verified",
					...fields
				};
				body = [
					`# Phase ${options.phase}: ${phaseName}  Verification`,
					"",
					"## Observable Truths",
					"| # | Truth | Status | Evidence |",
					"|---|-------|--------|----------|",
					"| 1 | [Truth] | pending | |",
					"",
					"## Required Artifacts",
					"| Artifact | Expected | Status | Details |",
					"|----------|----------|--------|---------|",
					"| [path] | [what] | pending | |",
					"",
					"## Key Link Verification",
					"| From | To | Via | Status | Details |",
					"|------|----|----|--------|---------|",
					"| [source] | [target] | [connection] | pending | |",
					"",
					"## Requirements Coverage",
					"| Requirement | Status | Blocking Issue |",
					"|-------------|--------|----------------|",
					"| [req] | pending | |",
					"",
					"## Result",
					"[Pending verification]"
				].join("\n");
				fileName = `${padded}-VERIFICATION.md`;
				break;
			default:
				(0, core_js_1.error)(`Unknown template type: ${templateType}. Available: summary, plan, verification`);
				return;
		}
		const fullContent = `---\n${(0, frontmatter_js_1.reconstructFrontmatter)(frontmatter)}\n---\n\n${body}\n`;
		const outPath = node_path_1$1.default.join(cwd, phaseInfo.directory, fileName);
		if (node_fs_1$1.default.existsSync(outPath)) {
			(0, core_js_1.output)({
				error: "File already exists",
				path: node_path_1$1.default.relative(cwd, outPath)
			}, raw);
			return;
		}
		node_fs_1$1.default.writeFileSync(outPath, fullContent, "utf-8");
		const relPath = node_path_1$1.default.relative(cwd, outPath);
		const result = {
			created: true,
			path: relPath,
			template: templateType
		};
		(0, core_js_1.output)(result, raw, relPath);
	}
}));

//#endregion
//#region ../core/dist/init.js
var require_init = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Init  Compound init commands for workflow bootstrapping
	*
	* Ported from maxsim/bin/lib/init.cjs
	*/
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdInitExecutePhase = cmdInitExecutePhase;
	exports.cmdInitPlanPhase = cmdInitPlanPhase;
	exports.cmdInitNewProject = cmdInitNewProject;
	exports.cmdInitNewMilestone = cmdInitNewMilestone;
	exports.cmdInitQuick = cmdInitQuick;
	exports.cmdInitResume = cmdInitResume;
	exports.cmdInitVerifyWork = cmdInitVerifyWork;
	exports.cmdInitPhaseOp = cmdInitPhaseOp;
	exports.cmdInitTodos = cmdInitTodos;
	exports.cmdInitMilestoneOp = cmdInitMilestoneOp;
	exports.cmdInitMapCodebase = cmdInitMapCodebase;
	exports.cmdInitProgress = cmdInitProgress;
	const node_fs_1 = __importDefault(require("node:fs"));
	const node_path_1 = __importDefault(require("node:path"));
	const node_os_1 = __importDefault(require("node:os"));
	const node_child_process_1 = require("node:child_process");
	const core_js_1 = require_core();
	function extractReqIds(cwd, phase) {
		const reqMatch = (0, core_js_1.getRoadmapPhaseInternal)(cwd, phase)?.section?.match(/^\*\*Requirements\*\*:[^\S\n]*([^\n]*)$/m);
		const reqExtracted = reqMatch ? reqMatch[1].replace(/[\[\]]/g, "").split(",").map((s) => s.trim()).filter(Boolean).join(", ") : null;
		return reqExtracted && reqExtracted !== "TBD" ? reqExtracted : null;
	}
	function scanPhaseArtifacts(cwd, phaseDirectory) {
		const result = {};
		const phaseDirFull = node_path_1.default.join(cwd, phaseDirectory);
		try {
			const files = node_fs_1.default.readdirSync(phaseDirFull);
			const contextFile = files.find((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
			if (contextFile) result.context_path = node_path_1.default.join(phaseDirectory, contextFile);
			const researchFile = files.find((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
			if (researchFile) result.research_path = node_path_1.default.join(phaseDirectory, researchFile);
			const verificationFile = files.find((f) => f.endsWith("-VERIFICATION.md") || f === "VERIFICATION.md");
			if (verificationFile) result.verification_path = node_path_1.default.join(phaseDirectory, verificationFile);
			const uatFile = files.find((f) => f.endsWith("-UAT.md") || f === "UAT.md");
			if (uatFile) result.uat_path = node_path_1.default.join(phaseDirectory, uatFile);
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		return result;
	}
	function cmdInitExecutePhase(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase required for init execute-phase");
		const config = (0, core_js_1.loadConfig)(cwd);
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phase);
		const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
		const phase_req_ids = extractReqIds(cwd, phase);
		const result = {
			executor_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-executor"),
			verifier_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-verifier"),
			commit_docs: config.commit_docs,
			parallelization: config.parallelization,
			branching_strategy: config.branching_strategy,
			phase_branch_template: config.phase_branch_template,
			milestone_branch_template: config.milestone_branch_template,
			verifier_enabled: config.verifier,
			phase_found: !!phaseInfo,
			phase_dir: phaseInfo?.directory ?? null,
			phase_number: phaseInfo?.phase_number ?? null,
			phase_name: phaseInfo?.phase_name ?? null,
			phase_slug: phaseInfo?.phase_slug ?? null,
			phase_req_ids,
			plans: phaseInfo?.plans ?? [],
			summaries: phaseInfo?.summaries ?? [],
			incomplete_plans: phaseInfo?.incomplete_plans ?? [],
			plan_count: phaseInfo?.plans?.length ?? 0,
			incomplete_count: phaseInfo?.incomplete_plans?.length ?? 0,
			branch_name: config.branching_strategy === "phase" && phaseInfo ? config.phase_branch_template.replace("{phase}", phaseInfo.phase_number).replace("{slug}", phaseInfo.phase_slug || "phase") : config.branching_strategy === "milestone" ? config.milestone_branch_template.replace("{milestone}", milestone.version).replace("{slug}", (0, core_js_1.generateSlugInternal)(milestone.name) || "milestone") : null,
			milestone_version: milestone.version,
			milestone_name: milestone.name,
			milestone_slug: (0, core_js_1.generateSlugInternal)(milestone.name),
			state_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/STATE.md"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			config_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/config.json"),
			state_path: ".planning/STATE.md",
			roadmap_path: ".planning/ROADMAP.md",
			config_path: ".planning/config.json"
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitPlanPhase(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase required for init plan-phase");
		const config = (0, core_js_1.loadConfig)(cwd);
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phase);
		const phase_req_ids = extractReqIds(cwd, phase);
		const result = {
			researcher_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-phase-researcher"),
			planner_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-planner"),
			checker_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-plan-checker"),
			research_enabled: config.research,
			plan_checker_enabled: config.plan_checker,
			nyquist_validation_enabled: false,
			commit_docs: config.commit_docs,
			phase_found: !!phaseInfo,
			phase_dir: phaseInfo?.directory ?? null,
			phase_number: phaseInfo?.phase_number ?? null,
			phase_name: phaseInfo?.phase_name ?? null,
			phase_slug: phaseInfo?.phase_slug ?? null,
			padded_phase: phaseInfo?.phase_number?.padStart(2, "0") ?? null,
			phase_req_ids,
			has_research: phaseInfo?.has_research ?? false,
			has_context: phaseInfo?.has_context ?? false,
			has_plans: (phaseInfo?.plans?.length ?? 0) > 0,
			plan_count: phaseInfo?.plans?.length ?? 0,
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			state_path: ".planning/STATE.md",
			roadmap_path: ".planning/ROADMAP.md",
			requirements_path: ".planning/REQUIREMENTS.md"
		};
		if (phaseInfo?.directory) {
			const artifacts = scanPhaseArtifacts(cwd, phaseInfo.directory);
			if (artifacts.context_path) result.context_path = artifacts.context_path;
			if (artifacts.research_path) result.research_path = artifacts.research_path;
			if (artifacts.verification_path) result.verification_path = artifacts.verification_path;
			if (artifacts.uat_path) result.uat_path = artifacts.uat_path;
		}
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitNewProject(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const homedir = node_os_1.default.homedir();
		const braveKeyFile = node_path_1.default.join(homedir, ".maxsim", "brave_api_key");
		const hasBraveSearch = !!(process.env.BRAVE_API_KEY || node_fs_1.default.existsSync(braveKeyFile));
		let hasCode = false;
		let hasPackageFile = false;
		try {
			hasCode = (0, node_child_process_1.execSync)("find . -maxdepth 3 \\( -name \"*.ts\" -o -name \"*.js\" -o -name \"*.py\" -o -name \"*.go\" -o -name \"*.rs\" -o -name \"*.swift\" -o -name \"*.java\" \\) 2>/dev/null | grep -v node_modules | grep -v .git | head -5", {
				cwd,
				encoding: "utf-8",
				stdio: [
					"pipe",
					"pipe",
					"pipe"
				]
			}).trim().length > 0;
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		hasPackageFile = (0, core_js_1.pathExistsInternal)(cwd, "package.json") || (0, core_js_1.pathExistsInternal)(cwd, "requirements.txt") || (0, core_js_1.pathExistsInternal)(cwd, "Cargo.toml") || (0, core_js_1.pathExistsInternal)(cwd, "go.mod") || (0, core_js_1.pathExistsInternal)(cwd, "Package.swift");
		const result = {
			researcher_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-project-researcher"),
			synthesizer_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-research-synthesizer"),
			roadmapper_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-roadmapper"),
			commit_docs: config.commit_docs,
			project_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/PROJECT.md"),
			has_codebase_map: (0, core_js_1.pathExistsInternal)(cwd, ".planning/codebase"),
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			has_existing_code: hasCode,
			has_package_file: hasPackageFile,
			is_brownfield: hasCode || hasPackageFile,
			needs_codebase_map: (hasCode || hasPackageFile) && !(0, core_js_1.pathExistsInternal)(cwd, ".planning/codebase"),
			has_git: (0, core_js_1.pathExistsInternal)(cwd, ".git"),
			brave_search_available: hasBraveSearch,
			project_path: ".planning/PROJECT.md"
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitNewMilestone(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
		const result = {
			researcher_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-project-researcher"),
			synthesizer_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-research-synthesizer"),
			roadmapper_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-roadmapper"),
			commit_docs: config.commit_docs,
			research_enabled: config.research,
			current_milestone: milestone.version,
			current_milestone_name: milestone.name,
			project_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/PROJECT.md"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			state_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/STATE.md"),
			project_path: ".planning/PROJECT.md",
			roadmap_path: ".planning/ROADMAP.md",
			state_path: ".planning/STATE.md"
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitQuick(cwd, description, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const now = /* @__PURE__ */ new Date();
		const slug = description ? (0, core_js_1.generateSlugInternal)(description)?.substring(0, 40) ?? null : null;
		const quickDir = node_path_1.default.join(cwd, ".planning", "quick");
		let nextNum = 1;
		try {
			const existing = node_fs_1.default.readdirSync(quickDir).filter((f) => /^\d+-/.test(f)).map((f) => parseInt(f.split("-")[0], 10)).filter((n) => !isNaN(n));
			if (existing.length > 0) nextNum = Math.max(...existing) + 1;
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			planner_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-planner"),
			executor_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-executor"),
			checker_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-plan-checker"),
			verifier_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-verifier"),
			commit_docs: config.commit_docs,
			next_num: nextNum,
			slug,
			description: description ?? null,
			date: now.toISOString().split("T")[0],
			timestamp: now.toISOString(),
			quick_dir: ".planning/quick",
			task_dir: slug ? `.planning/quick/${nextNum}-${slug}` : null,
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning")
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitResume(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		let interruptedAgentId = null;
		try {
			interruptedAgentId = node_fs_1.default.readFileSync(node_path_1.default.join(cwd, ".planning", "current-agent-id.txt"), "utf-8").trim();
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			state_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/STATE.md"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			project_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/PROJECT.md"),
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			state_path: ".planning/STATE.md",
			roadmap_path: ".planning/ROADMAP.md",
			project_path: ".planning/PROJECT.md",
			has_interrupted_agent: !!interruptedAgentId,
			interrupted_agent_id: interruptedAgentId,
			commit_docs: config.commit_docs
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitVerifyWork(cwd, phase, raw) {
		if (!phase) (0, core_js_1.error)("phase required for init verify-work");
		const config = (0, core_js_1.loadConfig)(cwd);
		const phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phase);
		const result = {
			planner_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-planner"),
			checker_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-plan-checker"),
			commit_docs: config.commit_docs,
			phase_found: !!phaseInfo,
			phase_dir: phaseInfo?.directory ?? null,
			phase_number: phaseInfo?.phase_number ?? null,
			phase_name: phaseInfo?.phase_name ?? null,
			has_verification: phaseInfo?.has_verification ?? false
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitPhaseOp(cwd, phase, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		let phaseInfo = (0, core_js_1.findPhaseInternal)(cwd, phase ?? "");
		if (!phaseInfo) {
			const roadmapPhase = (0, core_js_1.getRoadmapPhaseInternal)(cwd, phase ?? "");
			if (roadmapPhase?.found) {
				const phaseName = roadmapPhase.phase_name;
				phaseInfo = {
					found: true,
					directory: "",
					phase_number: roadmapPhase.phase_number,
					phase_name: phaseName,
					phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") : null,
					plans: [],
					summaries: [],
					incomplete_plans: [],
					has_research: false,
					has_context: false,
					has_verification: false
				};
			}
		}
		const result = {
			commit_docs: config.commit_docs,
			brave_search: config.brave_search,
			phase_found: !!phaseInfo,
			phase_dir: phaseInfo?.directory || null,
			phase_number: phaseInfo?.phase_number ?? null,
			phase_name: phaseInfo?.phase_name ?? null,
			phase_slug: phaseInfo?.phase_slug ?? null,
			padded_phase: phaseInfo?.phase_number?.padStart(2, "0") ?? null,
			has_research: phaseInfo?.has_research ?? false,
			has_context: phaseInfo?.has_context ?? false,
			has_plans: (phaseInfo?.plans?.length ?? 0) > 0,
			has_verification: phaseInfo?.has_verification ?? false,
			plan_count: phaseInfo?.plans?.length ?? 0,
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			state_path: ".planning/STATE.md",
			roadmap_path: ".planning/ROADMAP.md",
			requirements_path: ".planning/REQUIREMENTS.md"
		};
		if (phaseInfo?.directory) {
			const artifacts = scanPhaseArtifacts(cwd, phaseInfo.directory);
			if (artifacts.context_path) result.context_path = artifacts.context_path;
			if (artifacts.research_path) result.research_path = artifacts.research_path;
			if (artifacts.verification_path) result.verification_path = artifacts.verification_path;
			if (artifacts.uat_path) result.uat_path = artifacts.uat_path;
		}
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitTodos(cwd, area, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const now = /* @__PURE__ */ new Date();
		const pendingDir = node_path_1.default.join(cwd, ".planning", "todos", "pending");
		let count = 0;
		const todos = [];
		try {
			const files = node_fs_1.default.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
			for (const file of files) try {
				const content = node_fs_1.default.readFileSync(node_path_1.default.join(pendingDir, file), "utf-8");
				const createdMatch = content.match(/^created:\s*(.+)$/m);
				const titleMatch = content.match(/^title:\s*(.+)$/m);
				const areaMatch = content.match(/^area:\s*(.+)$/m);
				const todoArea = areaMatch ? areaMatch[1].trim() : "general";
				if (area && todoArea !== area) continue;
				count++;
				todos.push({
					file,
					created: createdMatch ? createdMatch[1].trim() : "unknown",
					title: titleMatch ? titleMatch[1].trim() : "Untitled",
					area: todoArea,
					path: node_path_1.default.join(".planning", "todos", "pending", file)
				});
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			commit_docs: config.commit_docs,
			date: now.toISOString().split("T")[0],
			timestamp: now.toISOString(),
			todo_count: count,
			todos,
			area_filter: area ?? null,
			pending_dir: ".planning/todos/pending",
			completed_dir: ".planning/todos/completed",
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			todos_dir_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/todos"),
			pending_dir_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/todos/pending")
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitMilestoneOp(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
		let phaseCount = 0;
		let completedPhases = 0;
		const phasesDir = node_path_1.default.join(cwd, ".planning", "phases");
		try {
			const dirs = node_fs_1.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
			phaseCount = dirs.length;
			for (const dir of dirs) try {
				if (node_fs_1.default.readdirSync(node_path_1.default.join(phasesDir, dir)).some((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md")) completedPhases++;
			} catch (e) {
				if (process.env.MAXSIM_DEBUG) console.error(e);
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const archiveDir = node_path_1.default.join(cwd, ".planning", "archive");
		let archivedMilestones = [];
		try {
			archivedMilestones = node_fs_1.default.readdirSync(archiveDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name);
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			commit_docs: config.commit_docs,
			milestone_version: milestone.version,
			milestone_name: milestone.name,
			milestone_slug: (0, core_js_1.generateSlugInternal)(milestone.name),
			phase_count: phaseCount,
			completed_phases: completedPhases,
			all_phases_complete: phaseCount > 0 && phaseCount === completedPhases,
			archived_milestones: archivedMilestones,
			archive_count: archivedMilestones.length,
			project_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/PROJECT.md"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			state_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/STATE.md"),
			archive_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/archive"),
			phases_dir_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/phases")
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitMapCodebase(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const codebaseDir = node_path_1.default.join(cwd, ".planning", "codebase");
		let existingMaps = [];
		try {
			existingMaps = node_fs_1.default.readdirSync(codebaseDir).filter((f) => f.endsWith(".md"));
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			mapper_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-codebase-mapper"),
			commit_docs: config.commit_docs,
			search_gitignored: config.search_gitignored,
			parallelization: config.parallelization,
			codebase_dir: ".planning/codebase",
			existing_maps: existingMaps,
			has_maps: existingMaps.length > 0,
			planning_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning"),
			codebase_dir_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/codebase")
		};
		(0, core_js_1.output)(result, raw);
	}
	function cmdInitProgress(cwd, raw) {
		const config = (0, core_js_1.loadConfig)(cwd);
		const milestone = (0, core_js_1.getMilestoneInfo)(cwd);
		const phasesDir = node_path_1.default.join(cwd, ".planning", "phases");
		const phases = [];
		let currentPhase = null;
		let nextPhase = null;
		try {
			const dirs = node_fs_1.default.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort();
			for (const dir of dirs) {
				const match = dir.match(/^(\d+(?:\.\d+)?)-?(.*)/);
				const phaseNumber = match ? match[1] : dir;
				const phaseName = match && match[2] ? match[2] : null;
				const phasePath = node_path_1.default.join(phasesDir, dir);
				const phaseFiles = node_fs_1.default.readdirSync(phasePath);
				const plans = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md");
				const summaries = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md");
				const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
				const status = summaries.length >= plans.length && plans.length > 0 ? "complete" : plans.length > 0 ? "in_progress" : hasResearch ? "researched" : "pending";
				const phaseInfo = {
					number: phaseNumber,
					name: phaseName,
					directory: node_path_1.default.join(".planning", "phases", dir),
					status,
					plan_count: plans.length,
					summary_count: summaries.length,
					has_research: hasResearch
				};
				phases.push(phaseInfo);
				if (!currentPhase && (status === "in_progress" || status === "researched")) currentPhase = phaseInfo;
				if (!nextPhase && status === "pending") nextPhase = phaseInfo;
			}
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		let pausedAt = null;
		try {
			const pauseMatch = node_fs_1.default.readFileSync(node_path_1.default.join(cwd, ".planning", "STATE.md"), "utf-8").match(/\*\*Paused At:\*\*\s*(.+)/);
			if (pauseMatch) pausedAt = pauseMatch[1].trim();
		} catch (e) {
			if (process.env.MAXSIM_DEBUG) console.error(e);
		}
		const result = {
			executor_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-executor"),
			planner_model: (0, core_js_1.resolveModelInternal)(cwd, "maxsim-planner"),
			commit_docs: config.commit_docs,
			milestone_version: milestone.version,
			milestone_name: milestone.name,
			phases,
			phase_count: phases.length,
			completed_count: phases.filter((p) => p.status === "complete").length,
			in_progress_count: phases.filter((p) => p.status === "in_progress").length,
			current_phase: currentPhase,
			next_phase: nextPhase,
			paused_at: pausedAt,
			has_work_in_progress: !!currentPhase,
			project_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/PROJECT.md"),
			roadmap_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/ROADMAP.md"),
			state_exists: (0, core_js_1.pathExistsInternal)(cwd, ".planning/STATE.md"),
			state_path: ".planning/STATE.md",
			roadmap_path: ".planning/ROADMAP.md",
			project_path: ".planning/PROJECT.md",
			config_path: ".planning/config.json"
		};
		(0, core_js_1.output)(result, raw);
	}
}));

//#endregion
//#region ../core/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @maxsim/core  Shared utilities, constants, and type definitions
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cmdRoadmapGetPhase = exports.cmdStateSnapshot = exports.cmdStateRecordSession = exports.cmdStateResolveBlocker = exports.cmdStateAddBlocker = exports.cmdStateAddDecision = exports.cmdStateUpdateProgress = exports.cmdStateRecordMetric = exports.cmdStateAdvancePlan = exports.cmdStateUpdate = exports.cmdStatePatch = exports.cmdStateGet = exports.cmdStateLoad = exports.stateReplaceField = exports.stateExtractField = exports.cmdConfigGet = exports.cmdConfigSet = exports.cmdConfigEnsureSection = exports.cmdFrontmatterValidate = exports.cmdFrontmatterMerge = exports.cmdFrontmatterSet = exports.cmdFrontmatterGet = exports.FRONTMATTER_SCHEMAS = exports.parseMustHavesBlock = exports.spliceFrontmatter = exports.reconstructFrontmatter = exports.extractFrontmatter = exports.getMilestoneInfo = exports.generateSlugInternal = exports.pathExistsInternal = exports.resolveModelInternal = exports.getRoadmapPhaseInternal = exports.getArchivedPhaseDirs = exports.findPhaseInternal = exports.getPhasePattern = exports.comparePhaseNum = exports.normalizePhaseName = exports.execGit = exports.isGitIgnored = exports.loadConfig = exports.safeReadFile = exports.error = exports.output = exports.MODEL_PROFILES = exports.PLANNING_CONFIG_DEFAULTS = exports.err = exports.ok = exports.phaseSlug = exports.phasePath = exports.phaseNumber = void 0;
	exports.cmdInitProgress = exports.cmdInitMapCodebase = exports.cmdInitMilestoneOp = exports.cmdInitTodos = exports.cmdInitPhaseOp = exports.cmdInitVerifyWork = exports.cmdInitResume = exports.cmdInitQuick = exports.cmdInitNewMilestone = exports.cmdInitNewProject = exports.cmdInitPlanPhase = exports.cmdInitExecutePhase = exports.cmdTemplateFill = exports.cmdTemplateSelect = exports.cmdPhaseComplete = exports.cmdPhaseRemove = exports.cmdPhaseInsert = exports.cmdPhaseAdd = exports.cmdPhasePlanIndex = exports.cmdFindPhase = exports.cmdPhaseNextDecimal = exports.cmdPhasesList = exports.cmdValidateHealth = exports.cmdValidateConsistency = exports.cmdVerifyKeyLinks = exports.cmdVerifyArtifacts = exports.cmdVerifyCommits = exports.cmdVerifyReferences = exports.cmdVerifyPhaseCompleteness = exports.cmdVerifyPlanStructure = exports.cmdVerifySummary = exports.cmdScaffold = exports.cmdTodoComplete = exports.cmdProgressRender = exports.cmdWebsearch = exports.cmdSummaryExtract = exports.cmdCommit = exports.cmdResolveModel = exports.cmdHistoryDigest = exports.cmdVerifyPathExists = exports.cmdListTodos = exports.cmdCurrentTimestamp = exports.cmdGenerateSlug = exports.cmdMilestoneComplete = exports.cmdRequirementsMarkComplete = exports.cmdRoadmapUpdatePlanProgress = exports.cmdRoadmapAnalyze = void 0;
	var types_js_1 = require_types();
	Object.defineProperty(exports, "phaseNumber", {
		enumerable: true,
		get: function() {
			return types_js_1.phaseNumber;
		}
	});
	Object.defineProperty(exports, "phasePath", {
		enumerable: true,
		get: function() {
			return types_js_1.phasePath;
		}
	});
	Object.defineProperty(exports, "phaseSlug", {
		enumerable: true,
		get: function() {
			return types_js_1.phaseSlug;
		}
	});
	Object.defineProperty(exports, "ok", {
		enumerable: true,
		get: function() {
			return types_js_1.ok;
		}
	});
	Object.defineProperty(exports, "err", {
		enumerable: true,
		get: function() {
			return types_js_1.err;
		}
	});
	Object.defineProperty(exports, "PLANNING_CONFIG_DEFAULTS", {
		enumerable: true,
		get: function() {
			return types_js_1.PLANNING_CONFIG_DEFAULTS;
		}
	});
	var core_js_1 = require_core();
	Object.defineProperty(exports, "MODEL_PROFILES", {
		enumerable: true,
		get: function() {
			return core_js_1.MODEL_PROFILES;
		}
	});
	Object.defineProperty(exports, "output", {
		enumerable: true,
		get: function() {
			return core_js_1.output;
		}
	});
	Object.defineProperty(exports, "error", {
		enumerable: true,
		get: function() {
			return core_js_1.error;
		}
	});
	Object.defineProperty(exports, "safeReadFile", {
		enumerable: true,
		get: function() {
			return core_js_1.safeReadFile;
		}
	});
	Object.defineProperty(exports, "loadConfig", {
		enumerable: true,
		get: function() {
			return core_js_1.loadConfig;
		}
	});
	Object.defineProperty(exports, "isGitIgnored", {
		enumerable: true,
		get: function() {
			return core_js_1.isGitIgnored;
		}
	});
	Object.defineProperty(exports, "execGit", {
		enumerable: true,
		get: function() {
			return core_js_1.execGit;
		}
	});
	Object.defineProperty(exports, "normalizePhaseName", {
		enumerable: true,
		get: function() {
			return core_js_1.normalizePhaseName;
		}
	});
	Object.defineProperty(exports, "comparePhaseNum", {
		enumerable: true,
		get: function() {
			return core_js_1.comparePhaseNum;
		}
	});
	Object.defineProperty(exports, "getPhasePattern", {
		enumerable: true,
		get: function() {
			return core_js_1.getPhasePattern;
		}
	});
	Object.defineProperty(exports, "findPhaseInternal", {
		enumerable: true,
		get: function() {
			return core_js_1.findPhaseInternal;
		}
	});
	Object.defineProperty(exports, "getArchivedPhaseDirs", {
		enumerable: true,
		get: function() {
			return core_js_1.getArchivedPhaseDirs;
		}
	});
	Object.defineProperty(exports, "getRoadmapPhaseInternal", {
		enumerable: true,
		get: function() {
			return core_js_1.getRoadmapPhaseInternal;
		}
	});
	Object.defineProperty(exports, "resolveModelInternal", {
		enumerable: true,
		get: function() {
			return core_js_1.resolveModelInternal;
		}
	});
	Object.defineProperty(exports, "pathExistsInternal", {
		enumerable: true,
		get: function() {
			return core_js_1.pathExistsInternal;
		}
	});
	Object.defineProperty(exports, "generateSlugInternal", {
		enumerable: true,
		get: function() {
			return core_js_1.generateSlugInternal;
		}
	});
	Object.defineProperty(exports, "getMilestoneInfo", {
		enumerable: true,
		get: function() {
			return core_js_1.getMilestoneInfo;
		}
	});
	var frontmatter_js_1 = require_frontmatter();
	Object.defineProperty(exports, "extractFrontmatter", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.extractFrontmatter;
		}
	});
	Object.defineProperty(exports, "reconstructFrontmatter", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.reconstructFrontmatter;
		}
	});
	Object.defineProperty(exports, "spliceFrontmatter", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.spliceFrontmatter;
		}
	});
	Object.defineProperty(exports, "parseMustHavesBlock", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.parseMustHavesBlock;
		}
	});
	Object.defineProperty(exports, "FRONTMATTER_SCHEMAS", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.FRONTMATTER_SCHEMAS;
		}
	});
	Object.defineProperty(exports, "cmdFrontmatterGet", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.cmdFrontmatterGet;
		}
	});
	Object.defineProperty(exports, "cmdFrontmatterSet", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.cmdFrontmatterSet;
		}
	});
	Object.defineProperty(exports, "cmdFrontmatterMerge", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.cmdFrontmatterMerge;
		}
	});
	Object.defineProperty(exports, "cmdFrontmatterValidate", {
		enumerable: true,
		get: function() {
			return frontmatter_js_1.cmdFrontmatterValidate;
		}
	});
	var config_js_1 = require_config();
	Object.defineProperty(exports, "cmdConfigEnsureSection", {
		enumerable: true,
		get: function() {
			return config_js_1.cmdConfigEnsureSection;
		}
	});
	Object.defineProperty(exports, "cmdConfigSet", {
		enumerable: true,
		get: function() {
			return config_js_1.cmdConfigSet;
		}
	});
	Object.defineProperty(exports, "cmdConfigGet", {
		enumerable: true,
		get: function() {
			return config_js_1.cmdConfigGet;
		}
	});
	var state_js_1 = require_state();
	Object.defineProperty(exports, "stateExtractField", {
		enumerable: true,
		get: function() {
			return state_js_1.stateExtractField;
		}
	});
	Object.defineProperty(exports, "stateReplaceField", {
		enumerable: true,
		get: function() {
			return state_js_1.stateReplaceField;
		}
	});
	Object.defineProperty(exports, "cmdStateLoad", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateLoad;
		}
	});
	Object.defineProperty(exports, "cmdStateGet", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateGet;
		}
	});
	Object.defineProperty(exports, "cmdStatePatch", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStatePatch;
		}
	});
	Object.defineProperty(exports, "cmdStateUpdate", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateUpdate;
		}
	});
	Object.defineProperty(exports, "cmdStateAdvancePlan", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateAdvancePlan;
		}
	});
	Object.defineProperty(exports, "cmdStateRecordMetric", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateRecordMetric;
		}
	});
	Object.defineProperty(exports, "cmdStateUpdateProgress", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateUpdateProgress;
		}
	});
	Object.defineProperty(exports, "cmdStateAddDecision", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateAddDecision;
		}
	});
	Object.defineProperty(exports, "cmdStateAddBlocker", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateAddBlocker;
		}
	});
	Object.defineProperty(exports, "cmdStateResolveBlocker", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateResolveBlocker;
		}
	});
	Object.defineProperty(exports, "cmdStateRecordSession", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateRecordSession;
		}
	});
	Object.defineProperty(exports, "cmdStateSnapshot", {
		enumerable: true,
		get: function() {
			return state_js_1.cmdStateSnapshot;
		}
	});
	var roadmap_js_1 = require_roadmap();
	Object.defineProperty(exports, "cmdRoadmapGetPhase", {
		enumerable: true,
		get: function() {
			return roadmap_js_1.cmdRoadmapGetPhase;
		}
	});
	Object.defineProperty(exports, "cmdRoadmapAnalyze", {
		enumerable: true,
		get: function() {
			return roadmap_js_1.cmdRoadmapAnalyze;
		}
	});
	Object.defineProperty(exports, "cmdRoadmapUpdatePlanProgress", {
		enumerable: true,
		get: function() {
			return roadmap_js_1.cmdRoadmapUpdatePlanProgress;
		}
	});
	var milestone_js_1 = require_milestone();
	Object.defineProperty(exports, "cmdRequirementsMarkComplete", {
		enumerable: true,
		get: function() {
			return milestone_js_1.cmdRequirementsMarkComplete;
		}
	});
	Object.defineProperty(exports, "cmdMilestoneComplete", {
		enumerable: true,
		get: function() {
			return milestone_js_1.cmdMilestoneComplete;
		}
	});
	var commands_js_1 = require_commands();
	Object.defineProperty(exports, "cmdGenerateSlug", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdGenerateSlug;
		}
	});
	Object.defineProperty(exports, "cmdCurrentTimestamp", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdCurrentTimestamp;
		}
	});
	Object.defineProperty(exports, "cmdListTodos", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdListTodos;
		}
	});
	Object.defineProperty(exports, "cmdVerifyPathExists", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdVerifyPathExists;
		}
	});
	Object.defineProperty(exports, "cmdHistoryDigest", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdHistoryDigest;
		}
	});
	Object.defineProperty(exports, "cmdResolveModel", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdResolveModel;
		}
	});
	Object.defineProperty(exports, "cmdCommit", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdCommit;
		}
	});
	Object.defineProperty(exports, "cmdSummaryExtract", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdSummaryExtract;
		}
	});
	Object.defineProperty(exports, "cmdWebsearch", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdWebsearch;
		}
	});
	Object.defineProperty(exports, "cmdProgressRender", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdProgressRender;
		}
	});
	Object.defineProperty(exports, "cmdTodoComplete", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdTodoComplete;
		}
	});
	Object.defineProperty(exports, "cmdScaffold", {
		enumerable: true,
		get: function() {
			return commands_js_1.cmdScaffold;
		}
	});
	var verify_js_1 = require_verify();
	Object.defineProperty(exports, "cmdVerifySummary", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifySummary;
		}
	});
	Object.defineProperty(exports, "cmdVerifyPlanStructure", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyPlanStructure;
		}
	});
	Object.defineProperty(exports, "cmdVerifyPhaseCompleteness", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyPhaseCompleteness;
		}
	});
	Object.defineProperty(exports, "cmdVerifyReferences", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyReferences;
		}
	});
	Object.defineProperty(exports, "cmdVerifyCommits", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyCommits;
		}
	});
	Object.defineProperty(exports, "cmdVerifyArtifacts", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyArtifacts;
		}
	});
	Object.defineProperty(exports, "cmdVerifyKeyLinks", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdVerifyKeyLinks;
		}
	});
	Object.defineProperty(exports, "cmdValidateConsistency", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdValidateConsistency;
		}
	});
	Object.defineProperty(exports, "cmdValidateHealth", {
		enumerable: true,
		get: function() {
			return verify_js_1.cmdValidateHealth;
		}
	});
	var phase_js_1 = require_phase();
	Object.defineProperty(exports, "cmdPhasesList", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhasesList;
		}
	});
	Object.defineProperty(exports, "cmdPhaseNextDecimal", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhaseNextDecimal;
		}
	});
	Object.defineProperty(exports, "cmdFindPhase", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdFindPhase;
		}
	});
	Object.defineProperty(exports, "cmdPhasePlanIndex", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhasePlanIndex;
		}
	});
	Object.defineProperty(exports, "cmdPhaseAdd", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhaseAdd;
		}
	});
	Object.defineProperty(exports, "cmdPhaseInsert", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhaseInsert;
		}
	});
	Object.defineProperty(exports, "cmdPhaseRemove", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhaseRemove;
		}
	});
	Object.defineProperty(exports, "cmdPhaseComplete", {
		enumerable: true,
		get: function() {
			return phase_js_1.cmdPhaseComplete;
		}
	});
	var template_js_1 = require_template();
	Object.defineProperty(exports, "cmdTemplateSelect", {
		enumerable: true,
		get: function() {
			return template_js_1.cmdTemplateSelect;
		}
	});
	Object.defineProperty(exports, "cmdTemplateFill", {
		enumerable: true,
		get: function() {
			return template_js_1.cmdTemplateFill;
		}
	});
	var init_js_1 = require_init();
	Object.defineProperty(exports, "cmdInitExecutePhase", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitExecutePhase;
		}
	});
	Object.defineProperty(exports, "cmdInitPlanPhase", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitPlanPhase;
		}
	});
	Object.defineProperty(exports, "cmdInitNewProject", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitNewProject;
		}
	});
	Object.defineProperty(exports, "cmdInitNewMilestone", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitNewMilestone;
		}
	});
	Object.defineProperty(exports, "cmdInitQuick", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitQuick;
		}
	});
	Object.defineProperty(exports, "cmdInitResume", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitResume;
		}
	});
	Object.defineProperty(exports, "cmdInitVerifyWork", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitVerifyWork;
		}
	});
	Object.defineProperty(exports, "cmdInitPhaseOp", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitPhaseOp;
		}
	});
	Object.defineProperty(exports, "cmdInitTodos", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitTodos;
		}
	});
	Object.defineProperty(exports, "cmdInitMilestoneOp", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitMilestoneOp;
		}
	});
	Object.defineProperty(exports, "cmdInitMapCodebase", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitMapCodebase;
		}
	});
	Object.defineProperty(exports, "cmdInitProgress", {
		enumerable: true,
		get: function() {
			return init_js_1.cmdInitProgress;
		}
	});
}));

//#endregion
//#region ../../node_modules/.pnpm/readdirp@4.1.2/node_modules/readdirp/esm/index.js
var import_dist = require_dist();
const EntryTypes = {
	FILE_TYPE: "files",
	DIR_TYPE: "directories",
	FILE_DIR_TYPE: "files_directories",
	EVERYTHING_TYPE: "all"
};
const defaultOptions = {
	root: ".",
	fileFilter: (_entryInfo) => true,
	directoryFilter: (_entryInfo) => true,
	type: EntryTypes.FILE_TYPE,
	lstat: false,
	depth: 2147483648,
	alwaysStat: false,
	highWaterMark: 4096
};
Object.freeze(defaultOptions);
const RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
const NORMAL_FLOW_ERRORS = new Set([
	"ENOENT",
	"EPERM",
	"EACCES",
	"ELOOP",
	RECURSIVE_ERROR_CODE
]);
const ALL_TYPES = [
	EntryTypes.DIR_TYPE,
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE,
	EntryTypes.FILE_TYPE
];
const DIR_TYPES = new Set([
	EntryTypes.DIR_TYPE,
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE
]);
const FILE_TYPES = new Set([
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE,
	EntryTypes.FILE_TYPE
]);
const isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
const wantBigintFsStats = process.platform === "win32";
const emptyFn = (_entryInfo) => true;
const normalizeFilter = (filter) => {
	if (filter === void 0) return emptyFn;
	if (typeof filter === "function") return filter;
	if (typeof filter === "string") {
		const fl = filter.trim();
		return (entry) => entry.basename === fl;
	}
	if (Array.isArray(filter)) {
		const trItems = filter.map((item) => item.trim());
		return (entry) => trItems.some((f) => entry.basename === f);
	}
	return emptyFn;
};
/** Readable readdir stream, emitting new files as they're being listed. */
var ReaddirpStream = class extends node_stream.Readable {
	constructor(options = {}) {
		super({
			objectMode: true,
			autoDestroy: true,
			highWaterMark: options.highWaterMark
		});
		const opts = {
			...defaultOptions,
			...options
		};
		const { root, type } = opts;
		this._fileFilter = normalizeFilter(opts.fileFilter);
		this._directoryFilter = normalizeFilter(opts.directoryFilter);
		const statMethod = opts.lstat ? node_fs_promises.lstat : node_fs_promises.stat;
		if (wantBigintFsStats) this._stat = (path) => statMethod(path, { bigint: true });
		else this._stat = statMethod;
		this._maxDepth = opts.depth ?? defaultOptions.depth;
		this._wantsDir = type ? DIR_TYPES.has(type) : false;
		this._wantsFile = type ? FILE_TYPES.has(type) : false;
		this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;
		this._root = (0, node_path.resolve)(root);
		this._isDirent = !opts.alwaysStat;
		this._statsProp = this._isDirent ? "dirent" : "stats";
		this._rdOptions = {
			encoding: "utf8",
			withFileTypes: this._isDirent
		};
		this.parents = [this._exploreDir(root, 1)];
		this.reading = false;
		this.parent = void 0;
	}
	async _read(batch) {
		if (this.reading) return;
		this.reading = true;
		try {
			while (!this.destroyed && batch > 0) {
				const par = this.parent;
				const fil = par && par.files;
				if (fil && fil.length > 0) {
					const { path, depth } = par;
					const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
					const awaited = await Promise.all(slice);
					for (const entry of awaited) {
						if (!entry) continue;
						if (this.destroyed) return;
						const entryType = await this._getEntryType(entry);
						if (entryType === "directory" && this._directoryFilter(entry)) {
							if (depth <= this._maxDepth) this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
							if (this._wantsDir) {
								this.push(entry);
								batch--;
							}
						} else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
							if (this._wantsFile) {
								this.push(entry);
								batch--;
							}
						}
					}
				} else {
					const parent = this.parents.pop();
					if (!parent) {
						this.push(null);
						break;
					}
					this.parent = await parent;
					if (this.destroyed) return;
				}
			}
		} catch (error) {
			this.destroy(error);
		} finally {
			this.reading = false;
		}
	}
	async _exploreDir(path, depth) {
		let files;
		try {
			files = await (0, node_fs_promises.readdir)(path, this._rdOptions);
		} catch (error) {
			this._onError(error);
		}
		return {
			files,
			depth,
			path
		};
	}
	async _formatEntry(dirent, path) {
		let entry;
		const basename = this._isDirent ? dirent.name : dirent;
		try {
			const fullPath = (0, node_path.resolve)((0, node_path.join)(path, basename));
			entry = {
				path: (0, node_path.relative)(this._root, fullPath),
				fullPath,
				basename
			};
			entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
		} catch (err) {
			this._onError(err);
			return;
		}
		return entry;
	}
	_onError(err) {
		if (isNormalFlowError(err) && !this.destroyed) this.emit("warn", err);
		else this.destroy(err);
	}
	async _getEntryType(entry) {
		if (!entry && this._statsProp in entry) return "";
		const stats = entry[this._statsProp];
		if (stats.isFile()) return "file";
		if (stats.isDirectory()) return "directory";
		if (stats && stats.isSymbolicLink()) {
			const full = entry.fullPath;
			try {
				const entryRealPath = await (0, node_fs_promises.realpath)(full);
				const entryRealPathStats = await (0, node_fs_promises.lstat)(entryRealPath);
				if (entryRealPathStats.isFile()) return "file";
				if (entryRealPathStats.isDirectory()) {
					const len = entryRealPath.length;
					if (full.startsWith(entryRealPath) && full.substr(len, 1) === node_path.sep) {
						const recursiveError = /* @__PURE__ */ new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
						recursiveError.code = RECURSIVE_ERROR_CODE;
						return this._onError(recursiveError);
					}
					return "directory";
				}
			} catch (error) {
				this._onError(error);
				return "";
			}
		}
	}
	_includeAsFile(entry) {
		const stats = entry && entry[this._statsProp];
		return stats && this._wantsEverything && !stats.isDirectory();
	}
};
/**
* Streaming version: Reads all files and directories in given root recursively.
* Consumes ~constant small amount of RAM.
* @param root Root directory
* @param options Options to specify root (start directory), filters and recursion depth
*/
function readdirp(root, options = {}) {
	let type = options.entryType || options.type;
	if (type === "both") type = EntryTypes.FILE_DIR_TYPE;
	if (type) options.type = type;
	if (!root) throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
	else if (typeof root !== "string") throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
	else if (type && !ALL_TYPES.includes(type)) throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
	options.root = root;
	return new ReaddirpStream(options);
}

//#endregion
//#region ../../node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/handler.js
const STR_DATA = "data";
const STR_END = "end";
const STR_CLOSE = "close";
const EMPTY_FN = () => {};
const pl = process.platform;
const isWindows = pl === "win32";
const isMacos = pl === "darwin";
const isLinux = pl === "linux";
const isFreeBSD = pl === "freebsd";
const isIBMi = (0, os.type)() === "OS400";
const EVENTS = {
	ALL: "all",
	READY: "ready",
	ADD: "add",
	CHANGE: "change",
	ADD_DIR: "addDir",
	UNLINK: "unlink",
	UNLINK_DIR: "unlinkDir",
	RAW: "raw",
	ERROR: "error"
};
const EV = EVENTS;
const THROTTLE_MODE_WATCH = "watch";
const statMethods = {
	lstat: fs_promises.lstat,
	stat: fs_promises.stat
};
const KEY_LISTENERS = "listeners";
const KEY_ERR = "errHandlers";
const KEY_RAW = "rawEmitters";
const HANDLER_KEYS = [
	KEY_LISTENERS,
	KEY_ERR,
	KEY_RAW
];
const binaryExtensions = new Set([
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"afdesign",
	"afphoto",
	"afpub",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"appimage",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"flatpak",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"odp",
	"ods",
	"odt",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"ott",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rpm",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"snap",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
]);
const isBinaryPath = (filePath) => binaryExtensions.has(path.extname(filePath).slice(1).toLowerCase());
const foreach = (val, fn) => {
	if (val instanceof Set) val.forEach(fn);
	else fn(val);
};
const addAndConvert = (main, prop, item) => {
	let container = main[prop];
	if (!(container instanceof Set)) main[prop] = container = new Set([container]);
	container.add(item);
};
const clearItem = (cont) => (key) => {
	const set = cont[key];
	if (set instanceof Set) set.clear();
	else delete cont[key];
};
const delFromSet = (main, prop, item) => {
	const container = main[prop];
	if (container instanceof Set) container.delete(item);
	else if (container === item) delete main[prop];
};
const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
const FsWatchInstances = /* @__PURE__ */ new Map();
/**
* Instantiates the fs_watch interface
* @param path to be watched
* @param options to be passed to fs_watch
* @param listener main event handler
* @param errHandler emits info about errors
* @param emitRaw emits raw event data
* @returns {NativeFsWatcher}
*/
function createFsWatchInstance(path$26, options, listener, errHandler, emitRaw) {
	const handleEvent = (rawEvent, evPath) => {
		listener(path$26);
		emitRaw(rawEvent, evPath, { watchedPath: path$26 });
		if (evPath && path$26 !== evPath) fsWatchBroadcast(path.resolve(path$26, evPath), KEY_LISTENERS, path.join(path$26, evPath));
	};
	try {
		return (0, fs.watch)(path$26, { persistent: options.persistent }, handleEvent);
	} catch (error) {
		errHandler(error);
		return;
	}
}
/**
* Helper for passing fs_watch event data to a collection of listeners
* @param fullPath absolute path bound to fs_watch instance
*/
const fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
	const cont = FsWatchInstances.get(fullPath);
	if (!cont) return;
	foreach(cont[listenerType], (listener) => {
		listener(val1, val2, val3);
	});
};
/**
* Instantiates the fs_watch interface or binds listeners
* to an existing one covering the same file system entry
* @param path
* @param fullPath absolute path
* @param options to be passed to fs_watch
* @param handlers container for event listener functions
*/
const setFsWatchListener = (path$30, fullPath, options, handlers) => {
	const { listener, errHandler, rawEmitter } = handlers;
	let cont = FsWatchInstances.get(fullPath);
	let watcher;
	if (!options.persistent) {
		watcher = createFsWatchInstance(path$30, options, listener, errHandler, rawEmitter);
		if (!watcher) return;
		return watcher.close.bind(watcher);
	}
	if (cont) {
		addAndConvert(cont, KEY_LISTENERS, listener);
		addAndConvert(cont, KEY_ERR, errHandler);
		addAndConvert(cont, KEY_RAW, rawEmitter);
	} else {
		watcher = createFsWatchInstance(path$30, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
		if (!watcher) return;
		watcher.on(EV.ERROR, async (error) => {
			const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
			if (cont) cont.watcherUnusable = true;
			if (isWindows && error.code === "EPERM") try {
				await (await (0, fs_promises.open)(path$30, "r")).close();
				broadcastErr(error);
			} catch (err) {}
			else broadcastErr(error);
		});
		cont = {
			listeners: listener,
			errHandlers: errHandler,
			rawEmitters: rawEmitter,
			watcher
		};
		FsWatchInstances.set(fullPath, cont);
	}
	return () => {
		delFromSet(cont, KEY_LISTENERS, listener);
		delFromSet(cont, KEY_ERR, errHandler);
		delFromSet(cont, KEY_RAW, rawEmitter);
		if (isEmptySet(cont.listeners)) {
			cont.watcher.close();
			FsWatchInstances.delete(fullPath);
			HANDLER_KEYS.forEach(clearItem(cont));
			cont.watcher = void 0;
			Object.freeze(cont);
		}
	};
};
const FsWatchFileInstances = /* @__PURE__ */ new Map();
/**
* Instantiates the fs_watchFile interface or binds listeners
* to an existing one covering the same file system entry
* @param path to be watched
* @param fullPath absolute path
* @param options options to be passed to fs_watchFile
* @param handlers container for event listener functions
* @returns closer
*/
const setFsWatchFileListener = (path$31, fullPath, options, handlers) => {
	const { listener, rawEmitter } = handlers;
	let cont = FsWatchFileInstances.get(fullPath);
	const copts = cont && cont.options;
	if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
		(0, fs.unwatchFile)(fullPath);
		cont = void 0;
	}
	if (cont) {
		addAndConvert(cont, KEY_LISTENERS, listener);
		addAndConvert(cont, KEY_RAW, rawEmitter);
	} else {
		cont = {
			listeners: listener,
			rawEmitters: rawEmitter,
			options,
			watcher: (0, fs.watchFile)(fullPath, options, (curr, prev) => {
				foreach(cont.rawEmitters, (rawEmitter) => {
					rawEmitter(EV.CHANGE, fullPath, {
						curr,
						prev
					});
				});
				const currmtime = curr.mtimeMs;
				if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) foreach(cont.listeners, (listener) => listener(path$31, curr));
			})
		};
		FsWatchFileInstances.set(fullPath, cont);
	}
	return () => {
		delFromSet(cont, KEY_LISTENERS, listener);
		delFromSet(cont, KEY_RAW, rawEmitter);
		if (isEmptySet(cont.listeners)) {
			FsWatchFileInstances.delete(fullPath);
			(0, fs.unwatchFile)(fullPath);
			cont.options = cont.watcher = void 0;
			Object.freeze(cont);
		}
	};
};
/**
* @mixin
*/
var NodeFsHandler = class {
	constructor(fsW) {
		this.fsw = fsW;
		this._boundHandleError = (error) => fsW._handleError(error);
	}
	/**
	* Watch file for changes with fs_watchFile or fs_watch.
	* @param path to file or dir
	* @param listener on fs change
	* @returns closer for the watcher instance
	*/
	_watchWithNodeFs(path$27, listener) {
		const opts = this.fsw.options;
		const directory = path.dirname(path$27);
		const basename = path.basename(path$27);
		this.fsw._getWatchedDir(directory).add(basename);
		const absolutePath = path.resolve(path$27);
		const options = { persistent: opts.persistent };
		if (!listener) listener = EMPTY_FN;
		let closer;
		if (opts.usePolling) {
			options.interval = opts.interval !== opts.binaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
			closer = setFsWatchFileListener(path$27, absolutePath, options, {
				listener,
				rawEmitter: this.fsw._emitRaw
			});
		} else closer = setFsWatchListener(path$27, absolutePath, options, {
			listener,
			errHandler: this._boundHandleError,
			rawEmitter: this.fsw._emitRaw
		});
		return closer;
	}
	/**
	* Watch a file and emit add event if warranted.
	* @returns closer for the watcher instance
	*/
	_handleFile(file, stats, initialAdd) {
		if (this.fsw.closed) return;
		const dirname = path.dirname(file);
		const basename = path.basename(file);
		const parent = this.fsw._getWatchedDir(dirname);
		let prevStats = stats;
		if (parent.has(basename)) return;
		const listener = async (path$32, newStats) => {
			if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
			if (!newStats || newStats.mtimeMs === 0) try {
				const newStats = await (0, fs_promises.stat)(file);
				if (this.fsw.closed) return;
				const at = newStats.atimeMs;
				const mt = newStats.mtimeMs;
				if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV.CHANGE, file, newStats);
				if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {
					this.fsw._closeFile(path$32);
					prevStats = newStats;
					const closer = this._watchWithNodeFs(file, listener);
					if (closer) this.fsw._addPathCloser(path$32, closer);
				} else prevStats = newStats;
			} catch (error) {
				this.fsw._remove(dirname, basename);
			}
			else if (parent.has(basename)) {
				const at = newStats.atimeMs;
				const mt = newStats.mtimeMs;
				if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV.CHANGE, file, newStats);
				prevStats = newStats;
			}
		};
		const closer = this._watchWithNodeFs(file, listener);
		if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
			if (!this.fsw._throttle(EV.ADD, file, 0)) return;
			this.fsw._emit(EV.ADD, file, stats);
		}
		return closer;
	}
	/**
	* Handle symlinks encountered while reading a dir.
	* @param entry returned by readdirp
	* @param directory path of dir being read
	* @param path of this item
	* @param item basename of this item
	* @returns true if no more processing is needed for this entry.
	*/
	async _handleSymlink(entry, directory, path$33, item) {
		if (this.fsw.closed) return;
		const full = entry.fullPath;
		const dir = this.fsw._getWatchedDir(directory);
		if (!this.fsw.options.followSymlinks) {
			this.fsw._incrReadyCount();
			let linkPath;
			try {
				linkPath = await (0, fs_promises.realpath)(path$33);
			} catch (e) {
				this.fsw._emitReady();
				return true;
			}
			if (this.fsw.closed) return;
			if (dir.has(item)) {
				if (this.fsw._symlinkPaths.get(full) !== linkPath) {
					this.fsw._symlinkPaths.set(full, linkPath);
					this.fsw._emit(EV.CHANGE, path$33, entry.stats);
				}
			} else {
				dir.add(item);
				this.fsw._symlinkPaths.set(full, linkPath);
				this.fsw._emit(EV.ADD, path$33, entry.stats);
			}
			this.fsw._emitReady();
			return true;
		}
		if (this.fsw._symlinkPaths.has(full)) return true;
		this.fsw._symlinkPaths.set(full, true);
	}
	_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
		directory = path.join(directory, "");
		throttler = this.fsw._throttle("readdir", directory, 1e3);
		if (!throttler) return;
		const previous = this.fsw._getWatchedDir(wh.path);
		const current = /* @__PURE__ */ new Set();
		let stream = this.fsw._readdirp(directory, {
			fileFilter: (entry) => wh.filterPath(entry),
			directoryFilter: (entry) => wh.filterDir(entry)
		});
		if (!stream) return;
		stream.on(STR_DATA, async (entry) => {
			if (this.fsw.closed) {
				stream = void 0;
				return;
			}
			const item = entry.path;
			let path$28 = path.join(directory, item);
			current.add(item);
			if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path$28, item)) return;
			if (this.fsw.closed) {
				stream = void 0;
				return;
			}
			if (item === target || !target && !previous.has(item)) {
				this.fsw._incrReadyCount();
				path$28 = path.join(dir, path.relative(dir, path$28));
				this._addToNodeFs(path$28, initialAdd, wh, depth + 1);
			}
		}).on(EV.ERROR, this._boundHandleError);
		return new Promise((resolve, reject) => {
			if (!stream) return reject();
			stream.once(STR_END, () => {
				if (this.fsw.closed) {
					stream = void 0;
					return;
				}
				const wasThrottled = throttler ? throttler.clear() : false;
				resolve(void 0);
				previous.getChildren().filter((item) => {
					return item !== directory && !current.has(item);
				}).forEach((item) => {
					this.fsw._remove(directory, item);
				});
				stream = void 0;
				if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
			});
		});
	}
	/**
	* Read directory to add / remove files from `@watched` list and re-read it on change.
	* @param dir fs path
	* @param stats
	* @param initialAdd
	* @param depth relative to user-supplied path
	* @param target child path targeted for watch
	* @param wh Common watch helpers for this path
	* @param realpath
	* @returns closer for the watcher instance.
	*/
	async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
		const parentDir = this.fsw._getWatchedDir(path.dirname(dir));
		const tracked = parentDir.has(path.basename(dir));
		if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) this.fsw._emit(EV.ADD_DIR, dir, stats);
		parentDir.add(path.basename(dir));
		this.fsw._getWatchedDir(dir);
		let throttler;
		let closer;
		const oDepth = this.fsw.options.depth;
		if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
			if (!target) {
				await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
				if (this.fsw.closed) return;
			}
			closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
				if (stats && stats.mtimeMs === 0) return;
				this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
			});
		}
		return closer;
	}
	/**
	* Handle added file, directory, or glob pattern.
	* Delegates call to _handleFile / _handleDir after checks.
	* @param path to file or ir
	* @param initialAdd was the file added at watch instantiation?
	* @param priorWh depth relative to user-supplied path
	* @param depth Child path actually targeted for watch
	* @param target Child path actually targeted for watch
	*/
	async _addToNodeFs(path$29, initialAdd, priorWh, depth, target) {
		const ready = this.fsw._emitReady;
		if (this.fsw._isIgnored(path$29) || this.fsw.closed) {
			ready();
			return false;
		}
		const wh = this.fsw._getWatchHelpers(path$29);
		if (priorWh) {
			wh.filterPath = (entry) => priorWh.filterPath(entry);
			wh.filterDir = (entry) => priorWh.filterDir(entry);
		}
		try {
			const stats = await statMethods[wh.statMethod](wh.watchPath);
			if (this.fsw.closed) return;
			if (this.fsw._isIgnored(wh.watchPath, stats)) {
				ready();
				return false;
			}
			const follow = this.fsw.options.followSymlinks;
			let closer;
			if (stats.isDirectory()) {
				const absPath = path.resolve(path$29);
				const targetPath = follow ? await (0, fs_promises.realpath)(path$29) : path$29;
				if (this.fsw.closed) return;
				closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
				if (this.fsw.closed) return;
				if (absPath !== targetPath && targetPath !== void 0) this.fsw._symlinkPaths.set(absPath, targetPath);
			} else if (stats.isSymbolicLink()) {
				const targetPath = follow ? await (0, fs_promises.realpath)(path$29) : path$29;
				if (this.fsw.closed) return;
				const parent = path.dirname(wh.watchPath);
				this.fsw._getWatchedDir(parent).add(wh.watchPath);
				this.fsw._emit(EV.ADD, wh.watchPath, stats);
				closer = await this._handleDir(parent, stats, initialAdd, depth, path$29, wh, targetPath);
				if (this.fsw.closed) return;
				if (targetPath !== void 0) this.fsw._symlinkPaths.set(path.resolve(path$29), targetPath);
			} else closer = this._handleFile(wh.watchPath, stats, initialAdd);
			ready();
			if (closer) this.fsw._addPathCloser(path$29, closer);
			return false;
		} catch (error) {
			if (this.fsw._handleError(error)) {
				ready();
				return path$29;
			}
		}
	}
};

//#endregion
//#region ../../node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/index.js
/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */
const SLASH = "/";
const SLASH_SLASH = "//";
const ONE_DOT = ".";
const TWO_DOTS = "..";
const STRING_TYPE = "string";
const BACK_SLASH_RE = /\\/g;
const DOUBLE_SLASH_RE = /\/\//;
const DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
const REPLACER_RE = /^\.[/\\]/;
function arrify(item) {
	return Array.isArray(item) ? item : [item];
}
const isMatcherObject = (matcher) => typeof matcher === "object" && matcher !== null && !(matcher instanceof RegExp);
function createPattern(matcher) {
	if (typeof matcher === "function") return matcher;
	if (typeof matcher === "string") return (string) => matcher === string;
	if (matcher instanceof RegExp) return (string) => matcher.test(string);
	if (typeof matcher === "object" && matcher !== null) return (string) => {
		if (matcher.path === string) return true;
		if (matcher.recursive) {
			const relative = path.relative(matcher.path, string);
			if (!relative) return false;
			return !relative.startsWith("..") && !path.isAbsolute(relative);
		}
		return false;
	};
	return () => false;
}
function normalizePath(path$5) {
	if (typeof path$5 !== "string") throw new Error("string expected");
	path$5 = path.normalize(path$5);
	path$5 = path$5.replace(/\\/g, "/");
	let prepend = false;
	if (path$5.startsWith("//")) prepend = true;
	const DOUBLE_SLASH_RE = /\/\//;
	while (path$5.match(DOUBLE_SLASH_RE)) path$5 = path$5.replace(DOUBLE_SLASH_RE, "/");
	if (prepend) path$5 = "/" + path$5;
	return path$5;
}
function matchPatterns(patterns, testString, stats) {
	const path$15 = normalizePath(testString);
	for (let index = 0; index < patterns.length; index++) {
		const pattern = patterns[index];
		if (pattern(path$15, stats)) return true;
	}
	return false;
}
function anymatch(matchers, testString) {
	if (matchers == null) throw new TypeError("anymatch: specify first argument");
	const patterns = arrify(matchers).map((matcher) => createPattern(matcher));
	if (testString == null) return (testString, stats) => {
		return matchPatterns(patterns, testString, stats);
	};
	return matchPatterns(patterns, testString);
}
const unifyPaths = (paths_) => {
	const paths = arrify(paths_).flat();
	if (!paths.every((p) => typeof p === STRING_TYPE)) throw new TypeError(`Non-string provided as watch path: ${paths}`);
	return paths.map(normalizePathToUnix);
};
const toUnix = (string) => {
	let str = string.replace(BACK_SLASH_RE, SLASH);
	let prepend = false;
	if (str.startsWith(SLASH_SLASH)) prepend = true;
	while (str.match(DOUBLE_SLASH_RE)) str = str.replace(DOUBLE_SLASH_RE, SLASH);
	if (prepend) str = SLASH + str;
	return str;
};
const normalizePathToUnix = (path$6) => toUnix(path.normalize(toUnix(path$6)));
const normalizeIgnored = (cwd = "") => (path$7) => {
	if (typeof path$7 === "string") return normalizePathToUnix(path.isAbsolute(path$7) ? path$7 : path.join(cwd, path$7));
	else return path$7;
};
const getAbsolutePath = (path$8, cwd) => {
	if (path.isAbsolute(path$8)) return path$8;
	return path.join(cwd, path$8);
};
const EMPTY_SET = Object.freeze(/* @__PURE__ */ new Set());
/**
* Directory entry.
*/
var DirEntry = class {
	constructor(dir, removeWatcher) {
		this.path = dir;
		this._removeWatcher = removeWatcher;
		this.items = /* @__PURE__ */ new Set();
	}
	add(item) {
		const { items } = this;
		if (!items) return;
		if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
	}
	async remove(item) {
		const { items } = this;
		if (!items) return;
		items.delete(item);
		if (items.size > 0) return;
		const dir = this.path;
		try {
			await (0, fs_promises.readdir)(dir);
		} catch (err) {
			if (this._removeWatcher) this._removeWatcher(path.dirname(dir), path.basename(dir));
		}
	}
	has(item) {
		const { items } = this;
		if (!items) return;
		return items.has(item);
	}
	getChildren() {
		const { items } = this;
		if (!items) return [];
		return [...items.values()];
	}
	dispose() {
		this.items.clear();
		this.path = "";
		this._removeWatcher = EMPTY_FN;
		this.items = EMPTY_SET;
		Object.freeze(this);
	}
};
const STAT_METHOD_F = "stat";
const STAT_METHOD_L = "lstat";
var WatchHelper = class {
	constructor(path$9, follow, fsw) {
		this.fsw = fsw;
		const watchPath = path$9;
		this.path = path$9 = path$9.replace(REPLACER_RE, "");
		this.watchPath = watchPath;
		this.fullWatchPath = path.resolve(watchPath);
		this.dirParts = [];
		this.dirParts.forEach((parts) => {
			if (parts.length > 1) parts.pop();
		});
		this.followSymlinks = follow;
		this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
	}
	entryPath(entry) {
		return path.join(this.watchPath, path.relative(this.watchPath, entry.fullPath));
	}
	filterPath(entry) {
		const { stats } = entry;
		if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
		const resolvedPath = this.entryPath(entry);
		return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
	}
	filterDir(entry) {
		return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
	}
};
/**
* Watches files & directories for changes. Emitted events:
* `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
*
*     new FSWatcher()
*       .add(directories)
*       .on('add', path => log('File', path, 'was added'))
*/
var FSWatcher = class extends events.EventEmitter {
	constructor(_opts = {}) {
		super();
		this.closed = false;
		this._closers = /* @__PURE__ */ new Map();
		this._ignoredPaths = /* @__PURE__ */ new Set();
		this._throttled = /* @__PURE__ */ new Map();
		this._streams = /* @__PURE__ */ new Set();
		this._symlinkPaths = /* @__PURE__ */ new Map();
		this._watched = /* @__PURE__ */ new Map();
		this._pendingWrites = /* @__PURE__ */ new Map();
		this._pendingUnlinks = /* @__PURE__ */ new Map();
		this._readyCount = 0;
		this._readyEmitted = false;
		const awf = _opts.awaitWriteFinish;
		const DEF_AWF = {
			stabilityThreshold: 2e3,
			pollInterval: 100
		};
		const opts = {
			persistent: true,
			ignoreInitial: false,
			ignorePermissionErrors: false,
			interval: 100,
			binaryInterval: 300,
			followSymlinks: true,
			usePolling: false,
			atomic: true,
			..._opts,
			ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
			awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === "object" ? {
				...DEF_AWF,
				...awf
			} : false
		};
		if (isIBMi) opts.usePolling = true;
		if (opts.atomic === void 0) opts.atomic = !opts.usePolling;
		const envPoll = process.env.CHOKIDAR_USEPOLLING;
		if (envPoll !== void 0) {
			const envLower = envPoll.toLowerCase();
			if (envLower === "false" || envLower === "0") opts.usePolling = false;
			else if (envLower === "true" || envLower === "1") opts.usePolling = true;
			else opts.usePolling = !!envLower;
		}
		const envInterval = process.env.CHOKIDAR_INTERVAL;
		if (envInterval) opts.interval = Number.parseInt(envInterval, 10);
		let readyCalls = 0;
		this._emitReady = () => {
			readyCalls++;
			if (readyCalls >= this._readyCount) {
				this._emitReady = EMPTY_FN;
				this._readyEmitted = true;
				process.nextTick(() => this.emit(EVENTS.READY));
			}
		};
		this._emitRaw = (...args) => this.emit(EVENTS.RAW, ...args);
		this._boundRemove = this._remove.bind(this);
		this.options = opts;
		this._nodeFsHandler = new NodeFsHandler(this);
		Object.freeze(opts);
	}
	_addIgnoredPath(matcher) {
		if (isMatcherObject(matcher)) {
			for (const ignored of this._ignoredPaths) if (isMatcherObject(ignored) && ignored.path === matcher.path && ignored.recursive === matcher.recursive) return;
		}
		this._ignoredPaths.add(matcher);
	}
	_removeIgnoredPath(matcher) {
		this._ignoredPaths.delete(matcher);
		if (typeof matcher === "string") {
			for (const ignored of this._ignoredPaths) if (isMatcherObject(ignored) && ignored.path === matcher) this._ignoredPaths.delete(ignored);
		}
	}
	/**
	* Adds paths to be watched on an existing FSWatcher instance.
	* @param paths_ file or file list. Other arguments are unused
	*/
	add(paths_, _origAdd, _internal) {
		const { cwd } = this.options;
		this.closed = false;
		this._closePromise = void 0;
		let paths = unifyPaths(paths_);
		if (cwd) paths = paths.map((path$16) => {
			return getAbsolutePath(path$16, cwd);
		});
		paths.forEach((path$17) => {
			this._removeIgnoredPath(path$17);
		});
		this._userIgnored = void 0;
		if (!this._readyCount) this._readyCount = 0;
		this._readyCount += paths.length;
		Promise.all(paths.map(async (path$18) => {
			const res = await this._nodeFsHandler._addToNodeFs(path$18, !_internal, void 0, 0, _origAdd);
			if (res) this._emitReady();
			return res;
		})).then((results) => {
			if (this.closed) return;
			results.forEach((item) => {
				if (item) this.add(path.dirname(item), path.basename(_origAdd || item));
			});
		});
		return this;
	}
	/**
	* Close watchers or start ignoring events from specified paths.
	*/
	unwatch(paths_) {
		if (this.closed) return this;
		const paths = unifyPaths(paths_);
		const { cwd } = this.options;
		paths.forEach((path$10) => {
			if (!path.isAbsolute(path$10) && !this._closers.has(path$10)) {
				if (cwd) path$10 = path.join(cwd, path$10);
				path$10 = path.resolve(path$10);
			}
			this._closePath(path$10);
			this._addIgnoredPath(path$10);
			if (this._watched.has(path$10)) this._addIgnoredPath({
				path: path$10,
				recursive: true
			});
			this._userIgnored = void 0;
		});
		return this;
	}
	/**
	* Close watchers and remove all listeners from watched paths.
	*/
	close() {
		if (this._closePromise) return this._closePromise;
		this.closed = true;
		this.removeAllListeners();
		const closers = [];
		this._closers.forEach((closerList) => closerList.forEach((closer) => {
			const promise = closer();
			if (promise instanceof Promise) closers.push(promise);
		}));
		this._streams.forEach((stream) => stream.destroy());
		this._userIgnored = void 0;
		this._readyCount = 0;
		this._readyEmitted = false;
		this._watched.forEach((dirent) => dirent.dispose());
		this._closers.clear();
		this._watched.clear();
		this._streams.clear();
		this._symlinkPaths.clear();
		this._throttled.clear();
		this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
		return this._closePromise;
	}
	/**
	* Expose list of watched paths
	* @returns for chaining
	*/
	getWatched() {
		const watchList = {};
		this._watched.forEach((entry, dir) => {
			const index = (this.options.cwd ? path.relative(this.options.cwd, dir) : dir) || ONE_DOT;
			watchList[index] = entry.getChildren().sort();
		});
		return watchList;
	}
	emitWithAll(event, args) {
		this.emit(event, ...args);
		if (event !== EVENTS.ERROR) this.emit(EVENTS.ALL, event, ...args);
	}
	/**
	* Normalize and emit events.
	* Calling _emit DOES NOT MEAN emit() would be called!
	* @param event Type of event
	* @param path File or directory path
	* @param stats arguments to be passed with event
	* @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
	*/
	async _emit(event, path$11, stats) {
		if (this.closed) return;
		const opts = this.options;
		if (isWindows) path$11 = path.normalize(path$11);
		if (opts.cwd) path$11 = path.relative(opts.cwd, path$11);
		const args = [path$11];
		if (stats != null) args.push(stats);
		const awf = opts.awaitWriteFinish;
		let pw;
		if (awf && (pw = this._pendingWrites.get(path$11))) {
			pw.lastChange = /* @__PURE__ */ new Date();
			return this;
		}
		if (opts.atomic) {
			if (event === EVENTS.UNLINK) {
				this._pendingUnlinks.set(path$11, [event, ...args]);
				setTimeout(() => {
					this._pendingUnlinks.forEach((entry, path$19) => {
						this.emit(...entry);
						this.emit(EVENTS.ALL, ...entry);
						this._pendingUnlinks.delete(path$19);
					});
				}, typeof opts.atomic === "number" ? opts.atomic : 100);
				return this;
			}
			if (event === EVENTS.ADD && this._pendingUnlinks.has(path$11)) {
				event = EVENTS.CHANGE;
				this._pendingUnlinks.delete(path$11);
			}
		}
		if (awf && (event === EVENTS.ADD || event === EVENTS.CHANGE) && this._readyEmitted) {
			const awfEmit = (err, stats) => {
				if (err) {
					event = EVENTS.ERROR;
					args[0] = err;
					this.emitWithAll(event, args);
				} else if (stats) {
					if (args.length > 1) args[1] = stats;
					else args.push(stats);
					this.emitWithAll(event, args);
				}
			};
			this._awaitWriteFinish(path$11, awf.stabilityThreshold, event, awfEmit);
			return this;
		}
		if (event === EVENTS.CHANGE) {
			if (!this._throttle(EVENTS.CHANGE, path$11, 50)) return this;
		}
		if (opts.alwaysStat && stats === void 0 && (event === EVENTS.ADD || event === EVENTS.ADD_DIR || event === EVENTS.CHANGE)) {
			const fullPath = opts.cwd ? path.join(opts.cwd, path$11) : path$11;
			let stats;
			try {
				stats = await (0, fs_promises.stat)(fullPath);
			} catch (err) {}
			if (!stats || this.closed) return;
			args.push(stats);
		}
		this.emitWithAll(event, args);
		return this;
	}
	/**
	* Common handler for errors
	* @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
	*/
	_handleError(error) {
		const code = error && error.code;
		if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) this.emit(EVENTS.ERROR, error);
		return error || this.closed;
	}
	/**
	* Helper utility for throttling
	* @param actionType type being throttled
	* @param path being acted upon
	* @param timeout duration of time to suppress duplicate actions
	* @returns tracking object or false if action should be suppressed
	*/
	_throttle(actionType, path$20, timeout) {
		if (!this._throttled.has(actionType)) this._throttled.set(actionType, /* @__PURE__ */ new Map());
		const action = this._throttled.get(actionType);
		if (!action) throw new Error("invalid throttle");
		const actionPath = action.get(path$20);
		if (actionPath) {
			actionPath.count++;
			return false;
		}
		let timeoutObject;
		const clear = () => {
			const item = action.get(path$20);
			const count = item ? item.count : 0;
			action.delete(path$20);
			clearTimeout(timeoutObject);
			if (item) clearTimeout(item.timeoutObject);
			return count;
		};
		timeoutObject = setTimeout(clear, timeout);
		const thr = {
			timeoutObject,
			clear,
			count: 0
		};
		action.set(path$20, thr);
		return thr;
	}
	_incrReadyCount() {
		return this._readyCount++;
	}
	/**
	* Awaits write operation to finish.
	* Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
	* @param path being acted upon
	* @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
	* @param event
	* @param awfEmit Callback to be called when ready for event to be emitted.
	*/
	_awaitWriteFinish(path$12, threshold, event, awfEmit) {
		const awf = this.options.awaitWriteFinish;
		if (typeof awf !== "object") return;
		const pollInterval = awf.pollInterval;
		let timeoutHandler;
		let fullPath = path$12;
		if (this.options.cwd && !path.isAbsolute(path$12)) fullPath = path.join(this.options.cwd, path$12);
		const now = /* @__PURE__ */ new Date();
		const writes = this._pendingWrites;
		function awaitWriteFinishFn(prevStat) {
			(0, fs.stat)(fullPath, (err, curStat) => {
				if (err || !writes.has(path$12)) {
					if (err && err.code !== "ENOENT") awfEmit(err);
					return;
				}
				const now = Number(/* @__PURE__ */ new Date());
				if (prevStat && curStat.size !== prevStat.size) writes.get(path$12).lastChange = now;
				if (now - writes.get(path$12).lastChange >= threshold) {
					writes.delete(path$12);
					awfEmit(void 0, curStat);
				} else timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
			});
		}
		if (!writes.has(path$12)) {
			writes.set(path$12, {
				lastChange: now,
				cancelWait: () => {
					writes.delete(path$12);
					clearTimeout(timeoutHandler);
					return event;
				}
			});
			timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
		}
	}
	/**
	* Determines whether user has asked to ignore this path.
	*/
	_isIgnored(path$21, stats) {
		if (this.options.atomic && DOT_RE.test(path$21)) return true;
		if (!this._userIgnored) {
			const { cwd } = this.options;
			const ignored = (this.options.ignored || []).map(normalizeIgnored(cwd));
			this._userIgnored = anymatch([...[...this._ignoredPaths].map(normalizeIgnored(cwd)), ...ignored], void 0);
		}
		return this._userIgnored(path$21, stats);
	}
	_isntIgnored(path$22, stat) {
		return !this._isIgnored(path$22, stat);
	}
	/**
	* Provides a set of common helpers and properties relating to symlink handling.
	* @param path file or directory pattern being watched
	*/
	_getWatchHelpers(path$23) {
		return new WatchHelper(path$23, this.options.followSymlinks, this);
	}
	/**
	* Provides directory tracking objects
	* @param directory path of the directory
	*/
	_getWatchedDir(directory) {
		const dir = path.resolve(directory);
		if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
		return this._watched.get(dir);
	}
	/**
	* Check for read permissions: https://stackoverflow.com/a/11781404/1358405
	*/
	_hasReadPermissions(stats) {
		if (this.options.ignorePermissionErrors) return true;
		return Boolean(Number(stats.mode) & 256);
	}
	/**
	* Handles emitting unlink events for
	* files and directories, and via recursion, for
	* files and directories within directories that are unlinked
	* @param directory within which the following item is located
	* @param item      base path of item/directory
	*/
	_remove(directory, item, isDirectory) {
		const path$13 = path.join(directory, item);
		const fullPath = path.resolve(path$13);
		isDirectory = isDirectory != null ? isDirectory : this._watched.has(path$13) || this._watched.has(fullPath);
		if (!this._throttle("remove", path$13, 100)) return;
		if (!isDirectory && this._watched.size === 1) this.add(directory, item, true);
		this._getWatchedDir(path$13).getChildren().forEach((nested) => this._remove(path$13, nested));
		const parent = this._getWatchedDir(directory);
		const wasTracked = parent.has(item);
		parent.remove(item);
		if (this._symlinkPaths.has(fullPath)) this._symlinkPaths.delete(fullPath);
		let relPath = path$13;
		if (this.options.cwd) relPath = path.relative(this.options.cwd, path$13);
		if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
			if (this._pendingWrites.get(relPath).cancelWait() === EVENTS.ADD) return;
		}
		this._watched.delete(path$13);
		this._watched.delete(fullPath);
		const eventName = isDirectory ? EVENTS.UNLINK_DIR : EVENTS.UNLINK;
		if (wasTracked && !this._isIgnored(path$13)) this._emit(eventName, path$13);
		this._closePath(path$13);
	}
	/**
	* Closes all watchers for a path
	*/
	_closePath(path$14) {
		this._closeFile(path$14);
		const dir = path.dirname(path$14);
		this._getWatchedDir(dir).remove(path.basename(path$14));
	}
	/**
	* Closes only file-specific watchers
	*/
	_closeFile(path$24) {
		const closers = this._closers.get(path$24);
		if (!closers) return;
		closers.forEach((closer) => closer());
		this._closers.delete(path$24);
	}
	_addPathCloser(path$25, closer) {
		if (!closer) return;
		let list = this._closers.get(path$25);
		if (!list) {
			list = [];
			this._closers.set(path$25, list);
		}
		list.push(closer);
	}
	_readdirp(root, opts) {
		if (this.closed) return;
		let stream = readdirp(root, {
			type: EVENTS.ALL,
			alwaysStat: true,
			lstat: true,
			...opts,
			depth: 0
		});
		this._streams.add(stream);
		stream.once(STR_CLOSE, () => {
			stream = void 0;
		});
		stream.once(STR_END, () => {
			if (stream) {
				this._streams.delete(stream);
				stream = void 0;
			}
		});
		return stream;
	}
};
/**
* Instantiates watcher with paths to be tracked.
* @param paths file / directory paths
* @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others
* @returns an instance of FSWatcher for chaining.
* @example
* const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });
* watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })
*/
function watch(paths, options = {}) {
	const watcher = new FSWatcher(options);
	watcher.add(paths);
	return watcher;
}

//#endregion
//#region src/terminal/session-store.ts
const MAX_SCROLLBACK = 5e4;
var SessionStore = class {
	scrollback = [];
	append(data) {
		this.scrollback.push(data);
		if (this.scrollback.length > MAX_SCROLLBACK) this.scrollback = this.scrollback.slice(-MAX_SCROLLBACK);
	}
	getAll() {
		return this.scrollback.join("");
	}
	clear() {
		this.scrollback = [];
	}
};

//#endregion
//#region src/terminal/pty-manager.ts
let pty = null;
try {
	pty = require("node-pty");
} catch {}
const DISCONNECT_TIMEOUT_MS = 6e4;
const STATUS_INTERVAL_MS = 1e3;
const ACTIVE_THRESHOLD_MS = 2e3;
var PtyManager = class PtyManager {
	static instance = null;
	session = null;
	connectedClients = /* @__PURE__ */ new Set();
	lastOutputTime = 0;
	statusInterval = null;
	static getInstance() {
		if (!PtyManager.instance) PtyManager.instance = new PtyManager();
		return PtyManager.instance;
	}
	spawn(opts) {
		if (!pty) {
			this.broadcastToClients({
				type: "output",
				data: "\r\n\x1B[31mTerminal unavailable: node-pty is not installed.\r\nRun: npm install node-pty\x1B[0m\r\n"
			});
			return;
		}
		if (this.session) this.kill();
		const shell = process.platform === "win32" ? "claude.cmd" : "claude";
		const args = [];
		if (opts.skipPermissions) args.push("--dangerously-skip-permissions");
		const proc = pty.spawn(shell, args, {
			name: "xterm-256color",
			cols: opts.cols ?? 120,
			rows: opts.rows ?? 30,
			cwd: opts.cwd,
			env: process.env
		});
		const store = new SessionStore();
		this.session = {
			process: proc,
			pid: proc.pid,
			startTime: Date.now(),
			cwd: opts.cwd,
			skipPermissions: opts.skipPermissions,
			disconnectTimer: null,
			store
		};
		this.lastOutputTime = Date.now();
		proc.onData((data) => {
			this.lastOutputTime = Date.now();
			store.append(data);
			this.broadcastToClients({
				type: "output",
				data
			});
		});
		proc.onExit(({ exitCode }) => {
			this.broadcastToClients({
				type: "exit",
				code: exitCode
			});
			this.stopStatusBroadcast();
			this.session = null;
		});
		this.broadcastToClients({
			type: "started",
			pid: proc.pid
		});
		this.startStatusBroadcast();
	}
	write(data) {
		if (this.session) this.session.process.write(data);
	}
	resize(cols, rows) {
		if (this.session) this.session.process.resize(cols, rows);
	}
	kill() {
		if (this.session) {
			this.stopStatusBroadcast();
			try {
				this.session.process.kill();
			} catch {}
			if (this.session.disconnectTimer) clearTimeout(this.session.disconnectTimer);
			this.session = null;
		}
	}
	getStatus() {
		if (!this.session) return null;
		return {
			pid: this.session.pid,
			uptime: Math.floor((Date.now() - this.session.startTime) / 1e3),
			cwd: this.session.cwd,
			memoryMB: Math.round(process.memoryUsage().rss / 1024 / 1024 * 10) / 10,
			isActive: Date.now() - this.lastOutputTime < ACTIVE_THRESHOLD_MS,
			skipPermissions: this.session.skipPermissions,
			alive: true
		};
	}
	addClient(ws) {
		this.connectedClients.add(ws);
		if (this.session?.disconnectTimer) {
			clearTimeout(this.session.disconnectTimer);
			this.session.disconnectTimer = null;
		}
		if (this.session) {
			const scrollback = this.session.store.getAll();
			if (scrollback) ws.send(JSON.stringify({
				type: "scrollback",
				data: scrollback
			}));
			const status = this.getStatus();
			if (status) ws.send(JSON.stringify({
				type: "status",
				...status
			}));
		}
	}
	removeClient(ws) {
		this.connectedClients.delete(ws);
		if (this.connectedClients.size === 0 && this.session) this.session.disconnectTimer = setTimeout(() => {
			console.error("[pty] No clients connected for 60s, killing process");
			this.kill();
		}, DISCONNECT_TIMEOUT_MS);
	}
	isAlive() {
		return this.session !== null;
	}
	isAvailable() {
		return pty !== null;
	}
	broadcastToClients(message) {
		const data = JSON.stringify(message);
		for (const client of this.connectedClients) if (client.readyState === import_websocket.default.OPEN) client.send(data);
	}
	startStatusBroadcast() {
		this.stopStatusBroadcast();
		this.statusInterval = setInterval(() => {
			const status = this.getStatus();
			if (status) this.broadcastToClients({
				type: "status",
				...status
			});
		}, STATUS_INTERVAL_MS);
	}
	stopStatusBroadcast() {
		if (this.statusInterval) {
			clearInterval(this.statusInterval);
			this.statusInterval = null;
		}
	}
};

//#endregion
//#region src/server.ts
const projectCwd = process.env.MAXSIM_PROJECT_CWD || process.cwd();
const clientDir = node_path.join(__dirname, "client");
function isWithinPlanning(cwd, targetPath) {
	const planningDir = node_path.resolve(cwd, ".planning");
	return node_path.resolve(cwd, targetPath).startsWith(planningDir);
}
const suppressedPaths = /* @__PURE__ */ new Map();
const SUPPRESS_TTL_MS = 500;
function suppressPath(filePath) {
	suppressedPaths.set(normalizeFsPath(filePath), Date.now());
}
function isSuppressed(filePath) {
	const normalized = normalizeFsPath(filePath);
	const timestamp = suppressedPaths.get(normalized);
	if (timestamp === void 0) return false;
	if (Date.now() - timestamp > SUPPRESS_TTL_MS) {
		suppressedPaths.delete(normalized);
		return false;
	}
	return true;
}
function normalizeFsPath(p) {
	return p.replace(/\\/g, "/");
}
let clientCount = 0;
function createWSS() {
	const wss = new import_websocket_server.default({ noServer: true });
	wss.on("connection", (ws) => {
		clientCount++;
		console.error(`[ws] Client connected (${clientCount} total)`);
		ws.on("close", () => {
			clientCount--;
			console.error(`[ws] Client disconnected (${clientCount} total)`);
		});
		ws.on("error", (err) => {
			console.error("[ws] Client error:", err.message);
		});
		ws.send(JSON.stringify({
			type: "connected",
			timestamp: Date.now()
		}));
	});
	return wss;
}
function broadcast(wss, message) {
	const data = JSON.stringify(message);
	let sent = 0;
	for (const client of wss.clients) if (client.readyState === import_websocket.default.OPEN) {
		client.send(data);
		sent++;
	}
	if (sent > 0) console.error(`[ws] Broadcast to ${sent} client(s)`);
}
function setupWatcher(cwd, wss) {
	const planningDir = normalizeFsPath(`${cwd}/.planning`);
	console.error(`[watcher] Watching ${planningDir}`);
	const watcher = watch(planningDir, {
		persistent: true,
		ignoreInitial: true,
		awaitWriteFinish: {
			stabilityThreshold: 300,
			pollInterval: 100
		},
		depth: 5
	});
	let changedPaths = /* @__PURE__ */ new Set();
	let debounceTimer = null;
	function onFileChange(filePath) {
		const normalized = normalizeFsPath(filePath);
		if (isSuppressed(normalized)) {
			console.error(`[watcher] Suppressed: ${normalized}`);
			return;
		}
		changedPaths.add(normalized);
		if (debounceTimer !== null) clearTimeout(debounceTimer);
		debounceTimer = setTimeout(() => {
			if (changedPaths.size > 0) {
				const changes = Array.from(changedPaths);
				changedPaths = /* @__PURE__ */ new Set();
				console.error(`[watcher] Broadcasting ${changes.length} change(s)`);
				broadcast(wss, {
					type: "file-changes",
					changes,
					timestamp: Date.now()
				});
			}
			debounceTimer = null;
		}, 200);
	}
	watcher.on("add", onFileChange);
	watcher.on("change", onFileChange);
	watcher.on("unlink", onFileChange);
	watcher.on("error", (err) => {
		console.error("[watcher] Error:", err.message);
	});
	return watcher;
}
function parseRoadmap(cwd) {
	const roadmapPath = node_path.join(cwd, ".planning", "ROADMAP.md");
	if (!node_fs.existsSync(roadmapPath)) return null;
	const content = node_fs.readFileSync(roadmapPath, "utf-8");
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	const phasePattern = (0, import_dist.getPhasePattern)();
	const phases = [];
	let match;
	while ((match = phasePattern.exec(content)) !== null) {
		const phaseNum = match[1];
		const phaseName = match[2].replace(/\(INSERTED\)/i, "").trim();
		const sectionStart = match.index;
		const nextHeader = content.slice(sectionStart).match(/\n#{2,4}\s+Phase\s+\d/i);
		const sectionEnd = nextHeader ? sectionStart + nextHeader.index : content.length;
		const section = content.slice(sectionStart, sectionEnd);
		const goalMatch = section.match(/\*\*Goal:\*\*\s*([^\n]+)/i);
		const goal = goalMatch ? goalMatch[1].trim() : null;
		const dependsMatch = section.match(/\*\*Depends on:\*\*\s*([^\n]+)/i);
		const depends_on = dependsMatch ? dependsMatch[1].trim() : null;
		const normalized = (0, import_dist.normalizePhaseName)(phaseNum);
		let diskStatus = "no_directory";
		let planCount = 0;
		let summaryCount = 0;
		let hasContext = false;
		let hasResearch = false;
		try {
			const dirMatch = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).find((d) => d.startsWith(normalized + "-") || d === normalized);
			if (dirMatch) {
				const phaseFiles = node_fs.readdirSync(node_path.join(phasesDir, dirMatch));
				planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
				summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
				hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
				hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
				if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
				else if (summaryCount > 0) diskStatus = "partial";
				else if (planCount > 0) diskStatus = "planned";
				else if (hasResearch) diskStatus = "researched";
				else if (hasContext) diskStatus = "discussed";
				else diskStatus = "empty";
			}
		} catch {}
		const checkboxPattern = new RegExp(`-\\s*\\[(x| )\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}`, "i");
		const checkboxMatch = content.match(checkboxPattern);
		const roadmapComplete = checkboxMatch ? checkboxMatch[1] === "x" : false;
		phases.push({
			number: phaseNum,
			name: phaseName,
			goal,
			depends_on,
			plan_count: planCount,
			summary_count: summaryCount,
			has_context: hasContext,
			has_research: hasResearch,
			disk_status: diskStatus,
			roadmap_complete: roadmapComplete
		});
	}
	const milestones = [];
	const milestonePattern = /##\s*(.*v(\d+\.\d+)[^(\n]*)/gi;
	let mMatch;
	while ((mMatch = milestonePattern.exec(content)) !== null) milestones.push({
		heading: mMatch[1].trim(),
		version: "v" + mMatch[2]
	});
	const currentPhase = phases.find((p) => p.disk_status === "planned" || p.disk_status === "partial") || null;
	const nextPhase = phases.find((p) => p.disk_status === "empty" || p.disk_status === "no_directory" || p.disk_status === "discussed" || p.disk_status === "researched") || null;
	const totalPlans = phases.reduce((sum, p) => sum + p.plan_count, 0);
	const totalSummaries = phases.reduce((sum, p) => sum + p.summary_count, 0);
	const completedPhases = phases.filter((p) => p.disk_status === "complete").length;
	return {
		milestones,
		phases,
		phase_count: phases.length,
		completed_phases: completedPhases,
		total_plans: totalPlans,
		total_summaries: totalSummaries,
		progress_percent: totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0,
		current_phase: currentPhase ? currentPhase.number : null,
		next_phase: nextPhase ? nextPhase.number : null,
		missing_phase_details: null
	};
}
function parseState(cwd) {
	const statePath = node_path.join(cwd, ".planning", "STATE.md");
	if (!node_fs.existsSync(statePath)) return null;
	const content = node_fs.readFileSync(statePath, "utf-8");
	const position = (0, import_dist.stateExtractField)(content, "Current Position") || (0, import_dist.stateExtractField)(content, "Phase");
	const lastActivity = (0, import_dist.stateExtractField)(content, "Last activity") || (0, import_dist.stateExtractField)(content, "Last Activity");
	const currentPhase = (0, import_dist.stateExtractField)(content, "Current Phase") || (0, import_dist.stateExtractField)(content, "Phase");
	const currentPlan = (0, import_dist.stateExtractField)(content, "Current Plan") || (0, import_dist.stateExtractField)(content, "Plan");
	const status = (0, import_dist.stateExtractField)(content, "Status");
	const progress = (0, import_dist.stateExtractField)(content, "Progress");
	const decisions = [];
	const decisionsMatch = content.match(/###?\s*Decisions\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
	if (decisionsMatch) {
		const items = decisionsMatch[1].match(/^-\s+(.+)$/gm) || [];
		for (const item of items) decisions.push(item.replace(/^-\s+/, "").trim());
	}
	const blockers = [];
	const blockersMatch = content.match(/###?\s*(?:Blockers|Blockers\/Concerns)\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
	if (blockersMatch) {
		const items = blockersMatch[1].match(/^-\s+(.+)$/gm) || [];
		for (const item of items) blockers.push(item.replace(/^-\s+/, "").trim());
	}
	return {
		position,
		lastActivity,
		currentPhase,
		currentPlan,
		status,
		progress,
		decisions,
		blockers,
		content
	};
}
function parsePhases(cwd) {
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	if (!node_fs.existsSync(phasesDir)) return [];
	const phases = [];
	try {
		const dirs = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => (0, import_dist.comparePhaseNum)(a, b));
		for (const dir of dirs) {
			const dm = dir.match(/^(\d+[A-Z]?(?:\.\d+)?)-?(.*)/i);
			const phaseNum = dm ? dm[1] : dir;
			const phaseName = dm && dm[2] ? dm[2].replace(/-/g, " ") : "";
			const phaseFiles = node_fs.readdirSync(node_path.join(phasesDir, dir));
			const planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
			const summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
			const hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
			const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
			let diskStatus = "no_directory";
			if (planCount === 0 && summaryCount === 0) diskStatus = "empty";
			else if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
			else if (summaryCount > 0) diskStatus = "partial";
			else if (planCount > 0) diskStatus = "planned";
			else diskStatus = "empty";
			phases.push({
				number: phaseNum,
				name: phaseName,
				goal: "",
				dependsOn: [],
				planCount,
				summaryCount,
				diskStatus,
				roadmapComplete: diskStatus === "complete",
				hasContext,
				hasResearch
			});
		}
	} catch {}
	return phases;
}
function parsePhaseDetail(cwd, phaseId) {
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	if (!node_fs.existsSync(phasesDir)) return null;
	const normalized = (0, import_dist.normalizePhaseName)(phaseId);
	try {
		const dirMatch = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).find((d) => d.startsWith(normalized + "-") || d === normalized);
		if (!dirMatch) return null;
		const phaseDir = node_path.join(phasesDir, dirMatch);
		const phaseFiles = node_fs.readdirSync(phaseDir);
		const planFileNames = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
		const plans = [];
		for (const planFileName of planFileNames) {
			const planPath = node_path.join(phaseDir, planFileName);
			const content = node_fs.readFileSync(planPath, "utf-8");
			const frontmatter = (0, import_dist.extractFrontmatter)(content);
			const tasks = [];
			const taskRegex = /<task\s+type="([^"]*)"[^>]*>\s*<name>([^<]+)<\/name>([\s\S]*?)<\/task>/g;
			let taskMatch;
			while ((taskMatch = taskRegex.exec(content)) !== null) {
				const taskType = taskMatch[1];
				const taskName = taskMatch[2].trim();
				const taskBody = taskMatch[3];
				const filesMatch = taskBody.match(/<files>([\s\S]*?)<\/files>/);
				const actionMatch = taskBody.match(/<action>([\s\S]*?)<\/action>/);
				const verifyMatch = taskBody.match(/<verify>([\s\S]*?)<\/verify>/);
				const doneMatch = taskBody.match(/<done>([\s\S]*?)<\/done>/);
				const files = filesMatch ? filesMatch[1].trim().split("\n").map((f) => f.trim()).filter(Boolean) : [];
				tasks.push({
					name: taskName,
					type: taskType,
					files,
					action: actionMatch ? actionMatch[1].trim() : "",
					verify: verifyMatch ? verifyMatch[1].trim() : "",
					done: doneMatch ? doneMatch[1].trim() : "",
					completed: false
				});
			}
			plans.push({
				path: node_path.join(".planning", "phases", dirMatch, planFileName),
				content,
				frontmatter,
				tasks
			});
		}
		let context = null;
		const contextFile = phaseFiles.find((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
		if (contextFile) context = node_fs.readFileSync(node_path.join(phaseDir, contextFile), "utf-8");
		let research = null;
		const researchFile = phaseFiles.find((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
		if (researchFile) research = node_fs.readFileSync(node_path.join(phaseDir, researchFile), "utf-8");
		return {
			plans,
			context,
			research
		};
	} catch {
		return null;
	}
}
function parseTodos(cwd) {
	const pendingDir = node_path.join(cwd, ".planning", "todos", "pending");
	const completedDir = node_path.join(cwd, ".planning", "todos", "completed");
	const pending = [];
	const completed = [];
	if (node_fs.existsSync(pendingDir)) try {
		const files = node_fs.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
		for (const file of files) try {
			const titleMatch = node_fs.readFileSync(node_path.join(pendingDir, file), "utf-8").match(/^title:\s*(.+)$/m);
			pending.push({
				text: titleMatch ? titleMatch[1].trim() : file.replace(".md", ""),
				completed: false,
				file
			});
		} catch {}
	} catch {}
	if (node_fs.existsSync(completedDir)) try {
		const files = node_fs.readdirSync(completedDir).filter((f) => f.endsWith(".md"));
		for (const file of files) try {
			const titleMatch = node_fs.readFileSync(node_path.join(completedDir, file), "utf-8").match(/^title:\s*(.+)$/m);
			completed.push({
				text: titleMatch ? titleMatch[1].trim() : file.replace(".md", ""),
				completed: true,
				file
			});
		} catch {}
	} catch {}
	return {
		pending,
		completed
	};
}
function parseProject(cwd) {
	const projectPath = node_path.join(cwd, ".planning", "PROJECT.md");
	const requirementsPath = node_path.join(cwd, ".planning", "REQUIREMENTS.md");
	return {
		project: node_fs.existsSync(projectPath) ? node_fs.readFileSync(projectPath, "utf-8") : null,
		requirements: node_fs.existsSync(requirementsPath) ? node_fs.readFileSync(requirementsPath, "utf-8") : null
	};
}
const app = (0, import_express.default)();
app.use(import_express.json());
app.get("/api/health", (_req, res) => {
	res.json({
		status: "ok",
		port: process.env.PORT || 3333,
		cwd: projectCwd,
		uptime: process.uptime()
	});
});
app.get("/api/roadmap", (_req, res) => {
	const data = parseRoadmap(projectCwd);
	if (!data) return res.status(404).json({ error: "ROADMAP.md not found" });
	return res.json(data);
});
app.get("/api/state", (_req, res) => {
	const data = parseState(projectCwd);
	if (!data) return res.status(404).json({ error: "STATE.md not found" });
	return res.json(data);
});
app.patch("/api/state", (req, res) => {
	const statePath = node_path.join(projectCwd, ".planning", "STATE.md");
	if (!node_fs.existsSync(statePath)) return res.status(404).json({ error: "STATE.md not found" });
	if (!isWithinPlanning(projectCwd, ".planning/STATE.md")) return res.status(400).json({ error: "Invalid path" });
	const { field, value } = req.body;
	if (!field || value === void 0) return res.status(400).json({ error: "field and value are required" });
	const updated = (0, import_dist.stateReplaceField)(node_fs.readFileSync(statePath, "utf-8"), field, value);
	if (!updated) return res.status(404).json({ error: `Field "${field}" not found in STATE.md` });
	suppressPath(statePath);
	node_fs.writeFileSync(statePath, updated, "utf-8");
	return res.json({
		updated: true,
		field
	});
});
app.get("/api/phases", (_req, res) => {
	const phases = parsePhases(projectCwd);
	return res.json(phases);
});
app.get("/api/phase/:id", (req, res) => {
	const phaseId = req.params.id;
	const data = parsePhaseDetail(projectCwd, phaseId);
	if (!data) return res.status(404).json({ error: `Phase ${phaseId} not found` });
	return res.json(data);
});
app.get("/api/todos", (_req, res) => {
	const data = parseTodos(projectCwd);
	return res.json(data);
});
app.post("/api/todos", (req, res) => {
	const pendingDir = node_path.join(projectCwd, ".planning", "todos", "pending");
	const { text } = req.body;
	if (!text) return res.status(400).json({ error: "text is required" });
	node_fs.mkdirSync(pendingDir, { recursive: true });
	const timestamp = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
	const filename = `${timestamp}-${text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").slice(0, 40)}.md`;
	const filePath = node_path.join(pendingDir, filename);
	const content = `title: ${text}\ncreated: ${timestamp}\narea: general\n\n${text}\n`;
	suppressPath(filePath);
	node_fs.writeFileSync(filePath, content, "utf-8");
	return res.json({
		created: true,
		file: filename,
		text
	});
});
app.patch("/api/todos", (req, res) => {
	const pendingDir = node_path.join(projectCwd, ".planning", "todos", "pending");
	const completedDir = node_path.join(projectCwd, ".planning", "todos", "completed");
	const { file, completed } = req.body;
	if (!file) return res.status(400).json({ error: "file is required" });
	if (file.includes("/") || file.includes("\\") || file.includes("..")) return res.status(400).json({ error: "Invalid filename" });
	if (completed) {
		const sourcePath = node_path.join(pendingDir, file);
		if (!node_fs.existsSync(sourcePath)) return res.status(404).json({ error: "Todo not found in pending" });
		if (!isWithinPlanning(projectCwd, node_path.relative(projectCwd, sourcePath))) return res.status(400).json({ error: "Invalid path" });
		node_fs.mkdirSync(completedDir, { recursive: true });
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		let content = node_fs.readFileSync(sourcePath, "utf-8");
		content = `completed: ${today}\n` + content;
		const destPath = node_path.join(completedDir, file);
		suppressPath(sourcePath);
		suppressPath(destPath);
		node_fs.writeFileSync(destPath, content, "utf-8");
		node_fs.unlinkSync(sourcePath);
		return res.json({
			completed: true,
			file,
			date: today
		});
	} else {
		const sourcePath = node_path.join(completedDir, file);
		if (!node_fs.existsSync(sourcePath)) return res.status(404).json({ error: "Todo not found in completed" });
		if (!isWithinPlanning(projectCwd, node_path.relative(projectCwd, sourcePath))) return res.status(400).json({ error: "Invalid path" });
		node_fs.mkdirSync(pendingDir, { recursive: true });
		let content = node_fs.readFileSync(sourcePath, "utf-8");
		content = content.replace(/^completed:\s*.+\n/m, "");
		const destPath = node_path.join(pendingDir, file);
		suppressPath(sourcePath);
		suppressPath(destPath);
		node_fs.writeFileSync(destPath, content, "utf-8");
		node_fs.unlinkSync(sourcePath);
		return res.json({
			completed: false,
			file
		});
	}
});
app.get("/api/project", (_req, res) => {
	const data = parseProject(projectCwd);
	return res.json(data);
});
app.get("/api/plan/*", (req, res) => {
	const pathSegments = req.params["0"].split("/");
	const relativePath = node_path.join(".planning", ...pathSegments);
	if (!isWithinPlanning(projectCwd, relativePath)) return res.status(403).json({ error: "Path traversal not allowed" });
	const fullPath = node_path.join(projectCwd, relativePath);
	if (!node_fs.existsSync(fullPath)) return res.status(404).json({ error: "File not found" });
	try {
		const content = node_fs.readFileSync(fullPath, "utf-8");
		return res.json({
			path: relativePath,
			content
		});
	} catch {
		return res.status(500).json({ error: "Failed to read file" });
	}
});
app.put("/api/plan/*", (req, res) => {
	const pathSegments = req.params["0"].split("/");
	const relativePath = node_path.join(".planning", ...pathSegments);
	if (!isWithinPlanning(projectCwd, relativePath)) return res.status(403).json({ error: "Path traversal not allowed" });
	const { content } = req.body;
	if (content === void 0) return res.status(400).json({ error: "content is required" });
	const fullPath = node_path.join(projectCwd, relativePath);
	const dir = node_path.dirname(fullPath);
	if (!node_fs.existsSync(dir)) node_fs.mkdirSync(dir, { recursive: true });
	suppressPath(fullPath);
	node_fs.writeFileSync(fullPath, content, "utf-8");
	return res.json({
		written: true,
		path: relativePath
	});
});
if (node_fs.existsSync(clientDir)) app.use(build_default(clientDir, { single: true }));
else app.get("/", (_req, res) => {
	res.send("<html><body><p>Dashboard client not found. Run <code>pnpm run build</code> first.</p></body></html>");
});
async function main() {
	const wss = createWSS();
	const terminalWss = new import_websocket_server.default({ noServer: true });
	const ptyManager = PtyManager.getInstance();
	if (!ptyManager.isAvailable()) console.error("[server] node-pty not available  terminal features disabled");
	terminalWss.on("connection", (ws) => {
		ptyManager.addClient(ws);
		if (!ptyManager.isAvailable()) ws.send(JSON.stringify({
			type: "unavailable",
			reason: "node-pty is not installed  terminal features disabled"
		}));
		ws.on("message", (raw) => {
			try {
				const msg = JSON.parse(typeof raw === "string" ? raw : raw.toString());
				switch (msg.type) {
					case "input":
						ptyManager.write(msg.data);
						break;
					case "resize":
						ptyManager.resize(msg.cols, msg.rows);
						break;
					case "spawn":
						ptyManager.spawn({
							skipPermissions: !!msg.skipPermissions,
							cwd: projectCwd,
							cols: msg.cols,
							rows: msg.rows
						});
						break;
					case "kill":
						ptyManager.kill();
						break;
				}
			} catch {}
		});
		ws.on("close", () => {
			ptyManager.removeClient(ws);
		});
		ws.on("error", (err) => {
			console.error("[terminal-ws] Client error:", err.message);
		});
	});
	const server = (0, node_http.createServer)(app);
	server.on("upgrade", (req, socket, head) => {
		const url = req.url || "/";
		if (url === "/ws/terminal" || url.startsWith("/ws/terminal?")) terminalWss.handleUpgrade(req, socket, head, (ws) => {
			terminalWss.emit("connection", ws, req);
		});
		else if (url === "/api/ws" || url.startsWith("/api/ws?")) wss.handleUpgrade(req, socket, head, (ws) => {
			wss.emit("connection", ws, req);
		});
		else socket.destroy();
	});
	let watcher;
	try {
		watcher = setupWatcher(projectCwd, wss);
	} catch (err) {
		console.error("[server] Failed to start file watcher:", err.message);
	}
	const port = await esm_default(3333);
	const url = `http://localhost:${port}`;
	server.listen(port, () => {
		console.error(`Dashboard ready at ${url}`);
		open$1(url).catch(() => {});
	});
	function shutdown() {
		console.error("\n[server] Shutting down...");
		ptyManager.kill();
		if (watcher) watcher.close().catch(() => {});
		terminalWss.close(() => {});
		wss.close(() => {
			server.close(() => {
				process.exit(0);
			});
		});
		setTimeout(() => {
			console.error("[server] Forced exit after timeout");
			process.exit(1);
		}, 5e3);
	}
	process.on("SIGINT", shutdown);
	process.on("SIGTERM", shutdown);
	process.on("exit", () => {
		ptyManager.kill();
	});
}
main().catch((err) => {
	console.error("[server] Fatal error:", err);
	process.exit(1);
});

//#endregion