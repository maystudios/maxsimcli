{"version":3,"file":"index.cjs","names":["path","os","fs","path","fs","path","fs","os","path","fs","path","fs","path","fs","path","fs","path","fs","path","fs","path","fs","path","fs","os"],"sources":["../src/types.ts","../src/core.ts","../src/frontmatter.ts","../src/config.ts","../src/state.ts","../src/roadmap.ts","../src/milestone.ts","../src/commands.ts","../src/verify.ts","../src/phase.ts","../src/template.ts","../src/init.ts"],"sourcesContent":["/**\r\n * @maxsim/core — Shared type definitions\r\n */\r\n\r\n// ─── Brand utility ───────────────────────────────────────────────────────────\r\n\r\ndeclare const __brand: unique symbol;\r\ntype Brand<T, B extends string> = T & { readonly [__brand]: B };\r\n\r\n// ─── Branded types ───────────────────────────────────────────────────────────\r\n\r\nexport type PhaseNumber = Brand<string, 'PhaseNumber'>;\r\nexport type PhasePath = Brand<string, 'PhasePath'>;\r\nexport type PhaseSlug = Brand<string, 'PhaseSlug'>;\r\n\r\nexport function phaseNumber(value: string): PhaseNumber {\r\n  const match = value.match(/^\\d+[A-Z]?(\\.\\d+)?$/i);\r\n  if (!match) {\r\n    throw new Error(`Invalid phase number: ${value}`);\r\n  }\r\n  return value as PhaseNumber;\r\n}\r\n\r\nexport function phasePath(value: string): PhasePath {\r\n  if (!value || typeof value !== 'string') {\r\n    throw new Error(`Invalid phase path: ${value}`);\r\n  }\r\n  return value as PhasePath;\r\n}\r\n\r\nexport function phaseSlug(value: string): PhaseSlug {\r\n  if (!value || typeof value !== 'string') {\r\n    throw new Error(`Invalid phase slug: ${value}`);\r\n  }\r\n  return value as PhaseSlug;\r\n}\r\n\r\n// ─── Result type ─────────────────────────────────────────────────────────────\r\n\r\nexport type Result<T> =\r\n  | { success: true; data: T }\r\n  | { success: false; error: string };\r\n\r\nexport function ok<T>(data: T): Result<T> {\r\n  return { success: true, data };\r\n}\r\n\r\nexport function err<T = never>(error: string): Result<T> {\r\n  return { success: false, error };\r\n}\r\n\r\n// ─── Core interfaces ─────────────────────────────────────────────────────────\r\n\r\nexport type ModelTier = 'opus' | 'sonnet' | 'haiku';\r\nexport type ModelProfileName = 'quality' | 'balanced' | 'budget' | 'tokenburner';\r\nexport type ModelResolution = 'inherit' | ModelTier;\r\n\r\nexport interface ModelProfileEntry {\r\n  quality: ModelTier;\r\n  balanced: ModelTier;\r\n  budget: ModelTier;\r\n  tokenburner: ModelTier;\r\n}\r\n\r\nexport type AgentType =\r\n  | 'maxsim-planner'\r\n  | 'maxsim-roadmapper'\r\n  | 'maxsim-executor'\r\n  | 'maxsim-phase-researcher'\r\n  | 'maxsim-project-researcher'\r\n  | 'maxsim-research-synthesizer'\r\n  | 'maxsim-debugger'\r\n  | 'maxsim-codebase-mapper'\r\n  | 'maxsim-verifier'\r\n  | 'maxsim-plan-checker'\r\n  | 'maxsim-integration-checker';\r\n\r\nexport type ModelProfiles = Record<AgentType, ModelProfileEntry>;\r\n\r\nexport interface PhaseSearchResult {\r\n  found: true;\r\n  directory: string;\r\n  phase_number: string;\r\n  phase_name: string | null;\r\n  phase_slug: string | null;\r\n  plans: string[];\r\n  summaries: string[];\r\n  incomplete_plans: string[];\r\n  has_research: boolean;\r\n  has_context: boolean;\r\n  has_verification: boolean;\r\n  archived?: string;\r\n}\r\n\r\nexport interface RoadmapPhaseInfo {\r\n  found: true;\r\n  phase_number: string;\r\n  phase_name: string;\r\n  goal: string | null;\r\n  section: string;\r\n}\r\n\r\nexport interface ArchivedPhaseDir {\r\n  name: string;\r\n  milestone: string;\r\n  basePath: string;\r\n  fullPath: string;\r\n}\r\n\r\nexport interface GitResult {\r\n  exitCode: number;\r\n  stdout: string;\r\n  stderr: string;\r\n}\r\n\r\nexport interface MilestoneInfo {\r\n  version: string;\r\n  name: string;\r\n}\r\n\r\nexport interface AppConfig {\r\n  model_profile: ModelProfileName;\r\n  commit_docs: boolean;\r\n  search_gitignored: boolean;\r\n  branching_strategy: string;\r\n  phase_branch_template: string;\r\n  milestone_branch_template: string;\r\n  research: boolean;\r\n  plan_checker: boolean;\r\n  verifier: boolean;\r\n  parallelization: boolean;\r\n  brave_search: boolean;\r\n  model_overrides?: Partial<Record<AgentType, ModelTier>>;\r\n}\r\n\r\n// ─── Frontmatter interfaces ────────────────────────────────────────────────\r\n\r\nexport type FrontmatterData = Record<string, FrontmatterValue>;\r\n\r\nexport type FrontmatterValue =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | FrontmatterValue[]\r\n  | { [key: string]: FrontmatterValue };\r\n\r\nexport interface FrontmatterParseResult {\r\n  frontmatter: FrontmatterData;\r\n  body: string;\r\n  hasFrontmatter: boolean;\r\n}\r\n\r\nexport interface FrontmatterValidationResult {\r\n  valid: boolean;\r\n  missing: string[];\r\n  present: string[];\r\n  schema: string;\r\n}\r\n\r\nexport interface FrontmatterSchema {\r\n  required: string[];\r\n}\r\n\r\n// ─── Config interfaces ──────────────────────────────────────────────────────\r\n\r\nexport interface PlanningConfig {\r\n  model_profile: ModelProfileName;\r\n  commit_docs: boolean;\r\n  search_gitignored: boolean;\r\n  branching_strategy: string;\r\n  phase_branch_template: string;\r\n  milestone_branch_template: string;\r\n  workflow: WorkflowConfig;\r\n  parallelization: boolean;\r\n  brave_search: boolean;\r\n  [key: string]: unknown;\r\n}\r\n\r\nexport interface WorkflowConfig {\r\n  research: boolean;\r\n  plan_check: boolean;\r\n  verifier: boolean;\r\n  nyquist_validation: boolean;\r\n  [key: string]: boolean;\r\n}\r\n\r\nexport const PLANNING_CONFIG_DEFAULTS: PlanningConfig = {\r\n  model_profile: 'balanced',\r\n  commit_docs: true,\r\n  search_gitignored: false,\r\n  branching_strategy: 'none',\r\n  phase_branch_template: 'maxsim/phase-{phase}-{slug}',\r\n  milestone_branch_template: 'maxsim/{milestone}-{slug}',\r\n  workflow: {\r\n    research: true,\r\n    plan_check: true,\r\n    verifier: true,\r\n    nyquist_validation: false,\r\n  },\r\n  parallelization: true,\r\n  brave_search: false,\r\n};\r\n\r\n// ─── State interfaces ────────────────────────────────────────────────────────\r\n\r\nexport interface StateSection {\r\n  header: string;\r\n  body: string;\r\n}\r\n\r\nexport interface Decision {\r\n  phase: string;\r\n  summary: string;\r\n  rationale: string;\r\n}\r\n\r\nexport interface Blocker {\r\n  text: string;\r\n  resolved: boolean;\r\n}\r\n\r\nexport interface PerformanceMetric {\r\n  phase: string;\r\n  plan: string;\r\n  duration: string;\r\n  tasks: string;\r\n  files: string;\r\n}\r\n\r\nexport interface StateData {\r\n  content: string;\r\n  fields: Record<string, string>;\r\n  decisions: Decision[];\r\n  blockers: Blocker[];\r\n  metrics: PerformanceMetric[];\r\n}\r\n\r\nexport interface StatePatchResult {\r\n  updated: string[];\r\n  failed: string[];\r\n}\r\n\r\nexport interface StateSessionOptions {\r\n  stopped_at?: string;\r\n  resume_file?: string;\r\n}\r\n\r\nexport interface StateMetricOptions {\r\n  phase: string;\r\n  plan: string;\r\n  duration: string;\r\n  tasks?: string;\r\n  files?: string;\r\n}\r\n\r\nexport interface StateDecisionOptions {\r\n  phase?: string;\r\n  summary?: string;\r\n  summary_file?: string;\r\n  rationale?: string;\r\n  rationale_file?: string;\r\n}\r\n\r\nexport interface StateBlockerOptions {\r\n  text?: string;\r\n  text_file?: string;\r\n}\r\n\r\nexport interface StateSnapshot {\r\n  current_phase: string | null;\r\n  current_phase_name: string | null;\r\n  total_phases: number | null;\r\n  current_plan: string | null;\r\n  total_plans_in_phase: number | null;\r\n  status: string | null;\r\n  progress_percent: number | null;\r\n  last_activity: string | null;\r\n  last_activity_desc: string | null;\r\n  decisions: Decision[];\r\n  blockers: string[];\r\n  paused_at: string | null;\r\n  session: {\r\n    last_date: string | null;\r\n    stopped_at: string | null;\r\n    resume_file: string | null;\r\n  };\r\n}\r\n\r\n// ─── Roadmap interfaces ─────────────────────────────────────────────────────\r\n\r\nexport type PhaseStatus = 'no_directory' | 'empty' | 'discussed' | 'researched' | 'planned' | 'partial' | 'complete';\r\n\r\nexport interface RoadmapPhase {\r\n  number: string;\r\n  name: string;\r\n  goal: string | null;\r\n  depends_on: string | null;\r\n  plan_count: number;\r\n  summary_count: number;\r\n  has_context: boolean;\r\n  has_research: boolean;\r\n  disk_status: PhaseStatus;\r\n  roadmap_complete: boolean;\r\n}\r\n\r\nexport interface RoadmapMilestone {\r\n  heading: string;\r\n  version: string;\r\n}\r\n\r\nexport interface RoadmapAnalysis {\r\n  milestones: RoadmapMilestone[];\r\n  phases: RoadmapPhase[];\r\n  phase_count: number;\r\n  completed_phases: number;\r\n  total_plans: number;\r\n  total_summaries: number;\r\n  progress_percent: number;\r\n  current_phase: string | null;\r\n  next_phase: string | null;\r\n  missing_phase_details: string[] | null;\r\n}\r\n\r\nexport interface RoadmapPhaseDetail {\r\n  found: true;\r\n  phase_number: string;\r\n  phase_name: string;\r\n  goal: string | null;\r\n  success_criteria: string[];\r\n  section: string;\r\n}\r\n\r\nexport interface RoadmapPhaseNotFound {\r\n  found: false;\r\n  phase_number: string;\r\n  phase_name?: string;\r\n  error?: string;\r\n  message?: string;\r\n}\r\n\r\nexport type RoadmapGetPhaseResult = RoadmapPhaseDetail | RoadmapPhaseNotFound;\r\n\r\n// ─── Milestone interfaces ────────────────────────────────────────────────────\r\n\r\nexport interface MilestoneCompleteOptions {\r\n  name?: string;\r\n  archivePhases?: boolean;\r\n}\r\n\r\nexport interface MilestoneResult {\r\n  version: string;\r\n  name: string;\r\n  date: string;\r\n  phases: number;\r\n  plans: number;\r\n  tasks: number;\r\n  accomplishments: string[];\r\n  archived: {\r\n    roadmap: boolean;\r\n    requirements: boolean;\r\n    audit: boolean;\r\n    phases: boolean;\r\n  };\r\n  milestones_updated: boolean;\r\n  state_updated: boolean;\r\n}\r\n\r\nexport interface ArchiveResult {\r\n  updated: boolean;\r\n  marked_complete: string[];\r\n  not_found: string[];\r\n  total: number;\r\n}\r\n\r\n// ─── Commands interfaces ────────────────────────────────────────────────────\r\n\r\nexport interface TodoItem {\r\n  file: string;\r\n  created: string;\r\n  title: string;\r\n  area: string;\r\n  path: string;\r\n}\r\n\r\nexport interface HistoryPhaseDigest {\r\n  name: string;\r\n  provides: string[];\r\n  affects: string[];\r\n  patterns: string[];\r\n}\r\n\r\nexport interface HistoryDigest {\r\n  phases: Record<string, HistoryPhaseDigest>;\r\n  decisions: Array<{ phase: string; decision: string }>;\r\n  tech_stack: string[];\r\n}\r\n\r\nexport interface SlugResult {\r\n  slug: string;\r\n}\r\n\r\nexport interface WebSearchOptions {\r\n  limit?: number;\r\n  freshness?: string | null;\r\n}\r\n\r\nexport interface WebSearchResult {\r\n  title: string;\r\n  url: string;\r\n  description: string;\r\n  age: string | null;\r\n}\r\n\r\nexport interface ScaffoldOptions {\r\n  phase: string | null;\r\n  name: string | null;\r\n}\r\n\r\nexport type TimestampFormat = 'full' | 'date' | 'filename';\r\n\r\n// ─── Phase lifecycle interfaces ─────────────────────────────────────────────\r\n\r\nexport interface PhaseAddResult {\r\n  phase_number: number;\r\n  padded: string;\r\n  name: string;\r\n  slug: string | null;\r\n  directory: string;\r\n}\r\n\r\nexport interface PhaseInsertResult {\r\n  phase_number: string;\r\n  after_phase: string;\r\n  name: string;\r\n  slug: string | null;\r\n  directory: string;\r\n}\r\n\r\nexport interface PhaseRemoveResult {\r\n  removed: string;\r\n  directory_deleted: string | null;\r\n  renamed_directories: Array<{ from: string; to: string }>;\r\n  renamed_files: Array<{ from: string; to: string }>;\r\n  roadmap_updated: boolean;\r\n  state_updated: boolean;\r\n}\r\n\r\nexport interface PhaseCompleteResult {\r\n  completed_phase: string;\r\n  phase_name: string | null;\r\n  plans_executed: string;\r\n  next_phase: string | null;\r\n  next_phase_name: string | null;\r\n  is_last_phase: boolean;\r\n  date: string;\r\n  roadmap_updated: boolean;\r\n  state_updated: boolean;\r\n}\r\n\r\nexport interface PhasePlanIndexResult {\r\n  phase: string;\r\n  plans: Array<{\r\n    id: string;\r\n    wave: number;\r\n    autonomous: boolean;\r\n    objective: string | null;\r\n    files_modified: string[];\r\n    task_count: number;\r\n    has_summary: boolean;\r\n  }>;\r\n  waves: Record<string, string[]>;\r\n  incomplete: string[];\r\n  has_checkpoints: boolean;\r\n}\r\n\r\nexport interface PhasesListOptions {\r\n  type: string | null;\r\n  phase: string | null;\r\n  includeArchived: boolean;\r\n}\r\n\r\n// ─── Adapter interfaces ─────────────────────────────────────────────────────\r\n\r\nexport type RuntimeName = 'claude' | 'opencode' | 'gemini' | 'codex';\r\n\r\nexport interface AdapterConfig {\r\n  runtime: RuntimeName;\r\n  dirName: string;\r\n  getGlobalDir(explicitDir?: string | null): string;\r\n  getConfigDirFromHome(isGlobal: boolean): string;\r\n  transformContent(content: string, pathPrefix: string): string;\r\n  commandStructure: 'nested' | 'flat' | 'skills';\r\n}\r\n","/**\r\n * Core — Shared utilities, constants, and internal helpers\r\n *\r\n * Ported from maxsim/bin/lib/core.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport os from 'node:os';\r\nimport { execSync } from 'node:child_process';\r\n\r\nimport type {\r\n  ModelProfiles,\r\n  ModelProfileName,\r\n  ModelResolution,\r\n  AgentType,\r\n  PhaseSearchResult,\r\n  RoadmapPhaseInfo,\r\n  ArchivedPhaseDir,\r\n  GitResult,\r\n  MilestoneInfo,\r\n  AppConfig,\r\n} from './types.js';\r\n\r\n// ─── Model Profile Table ─────────────────────────────────────────────────────\r\n\r\nexport const MODEL_PROFILES: ModelProfiles = {\r\n  'maxsim-planner':              { quality: 'opus', balanced: 'opus',   budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-roadmapper':           { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-executor':             { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-phase-researcher':     { quality: 'opus', balanced: 'sonnet', budget: 'haiku',  tokenburner: 'opus' },\r\n  'maxsim-project-researcher':   { quality: 'opus', balanced: 'sonnet', budget: 'haiku',  tokenburner: 'opus' },\r\n  'maxsim-research-synthesizer': { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-debugger':             { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-codebase-mapper':      { quality: 'sonnet', balanced: 'haiku', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-verifier':             { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-plan-checker':         { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-integration-checker':  { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n};\r\n\r\n// ─── Output helpers ──────────────────────────────────────────────────────────\r\n// DEPRECATION: output() and error() call process.exit() and belong in the CLI\r\n// layer. They are kept here for backward compatibility during the port. Future\r\n// plans should move these to @maxsim/cli.\r\n\r\nexport function output(result: unknown, raw?: boolean, rawValue?: unknown): never {\r\n  if (raw && rawValue !== undefined) {\r\n    process.stdout.write(String(rawValue));\r\n  } else {\r\n    const json = JSON.stringify(result, null, 2);\r\n    if (json.length > 50000) {\r\n      const tmpPath = path.join(os.tmpdir(), `maxsim-${Date.now()}.json`);\r\n      fs.writeFileSync(tmpPath, json, 'utf-8');\r\n      process.stdout.write('@file:' + tmpPath);\r\n    } else {\r\n      process.stdout.write(json);\r\n    }\r\n  }\r\n  process.exit(0);\r\n}\r\n\r\nexport function error(message: string): never {\r\n  process.stderr.write('Error: ' + message + '\\n');\r\n  process.exit(1);\r\n}\r\n\r\n// ─── File & Config utilities ─────────────────────────────────────────────────\r\n\r\nexport function safeReadFile(filePath: string): string | null {\r\n  try {\r\n    return fs.readFileSync(filePath, 'utf-8');\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function loadConfig(cwd: string): AppConfig {\r\n  const configPath = path.join(cwd, '.planning', 'config.json');\r\n  const defaults: AppConfig = {\r\n    model_profile: 'balanced',\r\n    commit_docs: true,\r\n    search_gitignored: false,\r\n    branching_strategy: 'none',\r\n    phase_branch_template: 'maxsim/phase-{phase}-{slug}',\r\n    milestone_branch_template: 'maxsim/{milestone}-{slug}',\r\n    research: true,\r\n    plan_checker: true,\r\n    verifier: true,\r\n    parallelization: true,\r\n    brave_search: false,\r\n  };\r\n\r\n  try {\r\n    const raw = fs.readFileSync(configPath, 'utf-8');\r\n    const parsed: Record<string, unknown> = JSON.parse(raw) as Record<string, unknown>;\r\n\r\n    const get = (key: string, nested?: { section: string; field: string }): unknown => {\r\n      if (parsed[key] !== undefined) return parsed[key];\r\n      if (nested) {\r\n        const section = parsed[nested.section];\r\n        if (section && typeof section === 'object' && section !== null && nested.field in section) {\r\n          return (section as Record<string, unknown>)[nested.field];\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n\r\n    const parallelization = ((): boolean => {\r\n      const val = get('parallelization');\r\n      if (typeof val === 'boolean') return val;\r\n      if (typeof val === 'object' && val !== null && 'enabled' in val) {\r\n        return (val as { enabled: boolean }).enabled;\r\n      }\r\n      return defaults.parallelization;\r\n    })();\r\n\r\n    return {\r\n      model_profile: (get('model_profile') as ModelProfileName | undefined) ?? defaults.model_profile,\r\n      commit_docs: (get('commit_docs', { section: 'planning', field: 'commit_docs' }) as boolean | undefined) ?? defaults.commit_docs,\r\n      search_gitignored: (get('search_gitignored', { section: 'planning', field: 'search_gitignored' }) as boolean | undefined) ?? defaults.search_gitignored,\r\n      branching_strategy: (get('branching_strategy', { section: 'git', field: 'branching_strategy' }) as string | undefined) ?? defaults.branching_strategy,\r\n      phase_branch_template: (get('phase_branch_template', { section: 'git', field: 'phase_branch_template' }) as string | undefined) ?? defaults.phase_branch_template,\r\n      milestone_branch_template: (get('milestone_branch_template', { section: 'git', field: 'milestone_branch_template' }) as string | undefined) ?? defaults.milestone_branch_template,\r\n      research: (get('research', { section: 'workflow', field: 'research' }) as boolean | undefined) ?? defaults.research,\r\n      plan_checker: (get('plan_checker', { section: 'workflow', field: 'plan_check' }) as boolean | undefined) ?? defaults.plan_checker,\r\n      verifier: (get('verifier', { section: 'workflow', field: 'verifier' }) as boolean | undefined) ?? defaults.verifier,\r\n      parallelization,\r\n      brave_search: (get('brave_search') as boolean | undefined) ?? defaults.brave_search,\r\n      model_overrides: parsed['model_overrides'] as AppConfig['model_overrides'],\r\n    };\r\n  } catch {\r\n    return defaults;\r\n  }\r\n}\r\n\r\n// ─── Git utilities ───────────────────────────────────────────────────────────\r\n\r\nexport function isGitIgnored(cwd: string, targetPath: string): boolean {\r\n  try {\r\n    execSync('git check-ignore -q -- ' + targetPath.replace(/[^a-zA-Z0-9._\\-/]/g, ''), {\r\n      cwd,\r\n      stdio: 'pipe',\r\n    });\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function execGit(cwd: string, args: string[]): GitResult {\r\n  try {\r\n    const escaped = args.map(a => {\r\n      if (/^[a-zA-Z0-9._\\-/=:@]+$/.test(a)) return a;\r\n      return \"'\" + a.replace(/'/g, \"'\\\\''\") + \"'\";\r\n    });\r\n    const stdout = execSync('git ' + escaped.join(' '), {\r\n      cwd,\r\n      stdio: 'pipe',\r\n      encoding: 'utf-8',\r\n    });\r\n    return { exitCode: 0, stdout: stdout.trim(), stderr: '' };\r\n  } catch (thrown: unknown) {\r\n    const err = thrown as { status?: number; stdout?: string | Buffer; stderr?: string | Buffer };\r\n    return {\r\n      exitCode: err.status ?? 1,\r\n      stdout: (err.stdout ?? '').toString().trim(),\r\n      stderr: (err.stderr ?? '').toString().trim(),\r\n    };\r\n  }\r\n}\r\n\r\n// ─── Phase utilities ─────────────────────────────────────────────────────────\r\n\r\nexport function normalizePhaseName(phase: string): string {\r\n  const match = phase.match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  if (!match) return phase;\r\n  const padded = match[1].padStart(2, '0');\r\n  const letter = match[2] ? match[2].toUpperCase() : '';\r\n  const decimal = match[3] || '';\r\n  return padded + letter + decimal;\r\n}\r\n\r\nexport function comparePhaseNum(a: string | number, b: string | number): number {\r\n  const pa = String(a).match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  const pb = String(b).match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  if (!pa || !pb) return String(a).localeCompare(String(b));\r\n  const intDiff = parseInt(pa[1], 10) - parseInt(pb[1], 10);\r\n  if (intDiff !== 0) return intDiff;\r\n  const la = (pa[2] || '').toUpperCase();\r\n  const lb = (pb[2] || '').toUpperCase();\r\n  if (la !== lb) {\r\n    if (!la) return -1;\r\n    if (!lb) return 1;\r\n    return la < lb ? -1 : 1;\r\n  }\r\n  const da = pa[3] ? parseFloat(pa[3]) : -1;\r\n  const db = pb[3] ? parseFloat(pb[3]) : -1;\r\n  return da - db;\r\n}\r\n\r\n// ─── Phase regex helper ──────────────────────────────────────────────────────\r\n\r\n/**\r\n * Returns the canonical regex for matching Phase heading lines in ROADMAP.md.\r\n *\r\n * General form (no escapedPhaseNum):\r\n *   Matches: ## Phase 03: Name Here\r\n *   Group 1: phase number string (e.g. \"03\", \"3A\", \"2.1\")\r\n *   Group 2: phase name string (e.g. \"Name Here\")\r\n *\r\n * Specific form (with escapedPhaseNum):\r\n *   Matches: ## Phase 03: Name Here\r\n *   Group 1: phase name string only\r\n *\r\n * @param escapedPhaseNum - regex-escaped phase number string to match a specific phase\r\n * @param flags - regex flags (default: 'gi')\r\n */\r\nexport function getPhasePattern(escapedPhaseNum?: string, flags = 'gi'): RegExp {\r\n  if (escapedPhaseNum) {\r\n    return new RegExp(\r\n      `#{2,4}\\\\s*Phase\\\\s+${escapedPhaseNum}:\\\\s*([^\\\\n]+)`,\r\n      flags,\r\n    );\r\n  }\r\n  return new RegExp(\r\n    `#{2,4}\\\\s*Phase\\\\s+(\\\\d+[A-Z]?(?:\\\\.\\\\d+)?)\\\\s*:\\\\s*([^\\\\n]+)`,\r\n    flags,\r\n  );\r\n}\r\n\r\nfunction searchPhaseInDir(baseDir: string, relBase: string, normalized: string): PhaseSearchResult | null {\r\n  try {\r\n    const entries = fs.readdirSync(baseDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (!match) return null;\r\n\r\n    const dirMatch = match.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n    const phaseNumber = dirMatch ? dirMatch[1] : normalized;\r\n    const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;\r\n    const phaseDir = path.join(baseDir, match);\r\n    const phaseFiles = fs.readdirSync(phaseDir);\r\n\r\n    const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md').sort();\r\n    const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md').sort();\r\n    const hasResearch = phaseFiles.some(f => f.endsWith('-RESEARCH.md') || f === 'RESEARCH.md');\r\n    const hasContext = phaseFiles.some(f => f.endsWith('-CONTEXT.md') || f === 'CONTEXT.md');\r\n    const hasVerification = phaseFiles.some(f => f.endsWith('-VERIFICATION.md') || f === 'VERIFICATION.md');\r\n\r\n    const completedPlanIds = new Set(\r\n      summaries.map(s => s.replace('-SUMMARY.md', '').replace('SUMMARY.md', ''))\r\n    );\r\n    const incompletePlans = plans.filter(p => {\r\n      const planId = p.replace('-PLAN.md', '').replace('PLAN.md', '');\r\n      return !completedPlanIds.has(planId);\r\n    });\r\n\r\n    return {\r\n      found: true,\r\n      directory: path.join(relBase, match),\r\n      phase_number: phaseNumber,\r\n      phase_name: phaseName,\r\n      phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : null,\r\n      plans,\r\n      summaries,\r\n      incomplete_plans: incompletePlans,\r\n      has_research: hasResearch,\r\n      has_context: hasContext,\r\n      has_verification: hasVerification,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function findPhaseInternal(cwd: string, phase: string): PhaseSearchResult | null {\r\n  if (!phase) return null;\r\n\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  const current = searchPhaseInDir(phasesDir, path.join('.planning', 'phases'), normalized);\r\n  if (current) return current;\r\n\r\n  const milestonesDir = path.join(cwd, '.planning', 'milestones');\r\n  if (!fs.existsSync(milestonesDir)) return null;\r\n\r\n  try {\r\n    const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });\r\n    const archiveDirs = milestoneEntries\r\n      .filter(e => e.isDirectory() && /^v[\\d.]+-phases$/.test(e.name))\r\n      .map(e => e.name)\r\n      .sort()\r\n      .reverse();\r\n\r\n    for (const archiveName of archiveDirs) {\r\n      const versionMatch = archiveName.match(/^(v[\\d.]+)-phases$/);\r\n      if (!versionMatch) continue;\r\n      const version = versionMatch[1];\r\n      const archivePath = path.join(milestonesDir, archiveName);\r\n      const relBase = path.join('.planning', 'milestones', archiveName);\r\n      const result = searchPhaseInDir(archivePath, relBase, normalized);\r\n      if (result) {\r\n        result.archived = version;\r\n        return result;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getArchivedPhaseDirs(cwd: string): ArchivedPhaseDir[] {\r\n  const milestonesDir = path.join(cwd, '.planning', 'milestones');\r\n  const results: ArchivedPhaseDir[] = [];\r\n\r\n  if (!fs.existsSync(milestonesDir)) return results;\r\n\r\n  try {\r\n    const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });\r\n    const phaseDirs = milestoneEntries\r\n      .filter(e => e.isDirectory() && /^v[\\d.]+-phases$/.test(e.name))\r\n      .map(e => e.name)\r\n      .sort()\r\n      .reverse();\r\n\r\n    for (const archiveName of phaseDirs) {\r\n      const versionMatch = archiveName.match(/^(v[\\d.]+)-phases$/);\r\n      if (!versionMatch) continue;\r\n      const version = versionMatch[1];\r\n      const archivePath = path.join(milestonesDir, archiveName);\r\n      const entries = fs.readdirSync(archivePath, { withFileTypes: true });\r\n      const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n\r\n      for (const dir of dirs) {\r\n        results.push({\r\n          name: dir,\r\n          milestone: version,\r\n          basePath: path.join('.planning', 'milestones', archiveName),\r\n          fullPath: path.join(archivePath, dir),\r\n        });\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n// ─── Roadmap & model utilities ───────────────────────────────────────────────\r\n\r\nexport function getRoadmapPhaseInternal(cwd: string, phaseNum: string | number): RoadmapPhaseInfo | null {\r\n  if (!phaseNum) return null;\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  if (!fs.existsSync(roadmapPath)) return null;\r\n\r\n  try {\r\n    const content = fs.readFileSync(roadmapPath, 'utf-8');\r\n    const escapedPhase = phaseNum.toString().replace(/\\./g, '\\\\.');\r\n    const phasePattern = getPhasePattern(escapedPhase, 'i');\r\n    const headerMatch = content.match(phasePattern);\r\n    if (!headerMatch) return null;\r\n\r\n    const phaseName = headerMatch[1].trim();\r\n    const headerIndex = headerMatch.index!;\r\n    const restOfContent = content.slice(headerIndex);\r\n    const nextHeaderMatch = restOfContent.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\r\n    const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index! : content.length;\r\n    const section = content.slice(headerIndex, sectionEnd).trim();\r\n\r\n    const goalMatch = section.match(/\\*\\*Goal:\\*\\*\\s*([^\\n]+)/i);\r\n    const goal = goalMatch ? goalMatch[1].trim() : null;\r\n\r\n    return {\r\n      found: true,\r\n      phase_number: phaseNum.toString(),\r\n      phase_name: phaseName,\r\n      goal,\r\n      section,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function resolveModelInternal(cwd: string, agentType: AgentType): ModelResolution {\r\n  const config = loadConfig(cwd);\r\n\r\n  const override = config.model_overrides?.[agentType];\r\n  if (override) {\r\n    return override === 'opus' ? 'inherit' : override;\r\n  }\r\n\r\n  const profile: ModelProfileName = config.model_profile || 'balanced';\r\n  const agentModels = MODEL_PROFILES[agentType];\r\n  if (!agentModels) return 'sonnet';\r\n  const resolved = agentModels[profile] || agentModels['balanced'] || 'sonnet';\r\n  return resolved === 'opus' ? 'inherit' : resolved;\r\n}\r\n\r\n// ─── Misc utilities ──────────────────────────────────────────────────────────\r\n\r\nexport function pathExistsInternal(cwd: string, targetPath: string): boolean {\r\n  const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);\r\n  try {\r\n    fs.statSync(fullPath);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function generateSlugInternal(text: string | null | undefined): string | null {\r\n  if (!text) return null;\r\n  return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');\r\n}\r\n\r\nexport function getMilestoneInfo(cwd: string): MilestoneInfo {\r\n  try {\r\n    const roadmap = fs.readFileSync(path.join(cwd, '.planning', 'ROADMAP.md'), 'utf-8');\r\n    const versionMatch = roadmap.match(/v(\\d+\\.\\d+)/);\r\n    const nameMatch = roadmap.match(/## .*v\\d+\\.\\d+[:\\s]+([^\\n(]+)/);\r\n    return {\r\n      version: versionMatch ? versionMatch[0] : 'v1.0',\r\n      name: nameMatch ? nameMatch[1].trim() : 'milestone',\r\n    };\r\n  } catch {\r\n    return { version: 'v1.0', name: 'milestone' };\r\n  }\r\n}\r\n","/**\n * Frontmatter — YAML frontmatter parsing, serialization, and CRUD commands\n *\n * Ported from maxsim/bin/lib/frontmatter.cjs\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport { safeReadFile, output, error } from './core.js';\nimport type {\n  FrontmatterData,\n  FrontmatterValue,\n  FrontmatterValidationResult,\n  FrontmatterSchema,\n} from './types.js';\n\n// ─── Parsing engine ───────────────────────────────────────────────────────────\n\ninterface StackFrame {\n  obj: FrontmatterData | FrontmatterValue[];\n  key: string | null;\n  indent: number;\n}\n\n/**\n * Extract YAML frontmatter from markdown content into a typed object.\n */\nexport function extractFrontmatter(content: string): FrontmatterData {\n  const frontmatter: FrontmatterData = {};\n  const match = content.match(/^---\\n([\\s\\S]+?)\\n---/);\n  if (!match) return frontmatter;\n\n  const yaml = match[1];\n  const lines = yaml.split('\\n');\n\n  const stack: StackFrame[] = [{ obj: frontmatter, key: null, indent: -1 }];\n\n  for (const line of lines) {\n    if (line.trim() === '') continue;\n\n    const indentMatch = line.match(/^(\\s*)/);\n    const indent = indentMatch ? indentMatch[1].length : 0;\n\n    // Pop stack back to appropriate level\n    while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {\n      stack.pop();\n    }\n\n    const current = stack[stack.length - 1];\n\n    // Check for key: value pattern\n    const keyMatch = line.match(/^(\\s*)([a-zA-Z0-9_-]+):\\s*(.*)/);\n    if (keyMatch) {\n      const key = keyMatch[2];\n      const value = keyMatch[3].trim();\n\n      if (value === '' || value === '[') {\n        // Key with no value or opening bracket\n        const newObj: FrontmatterData | FrontmatterValue[] = value === '[' ? [] : {};\n        (current.obj as FrontmatterData)[key] = newObj;\n        current.key = null;\n        stack.push({ obj: newObj, key: null, indent });\n      } else if (value.startsWith('[') && value.endsWith(']')) {\n        // Inline array: key: [a, b, c]\n        (current.obj as FrontmatterData)[key] = value\n          .slice(1, -1)\n          .split(',')\n          .map(s => s.trim().replace(/^[\"']|[\"']$/g, ''))\n          .filter(Boolean);\n        current.key = null;\n      } else {\n        // Simple key: value\n        (current.obj as FrontmatterData)[key] = value.replace(/^[\"']|[\"']$/g, '');\n        current.key = null;\n      }\n    } else if (line.trim().startsWith('- ')) {\n      // Array item\n      const itemValue = line.trim().slice(2).replace(/^[\"']|[\"']$/g, '');\n\n      if (\n        typeof current.obj === 'object' &&\n        !Array.isArray(current.obj) &&\n        Object.keys(current.obj).length === 0\n      ) {\n        // Convert empty object to array\n        const parent = stack.length > 1 ? stack[stack.length - 2] : null;\n        if (parent && !Array.isArray(parent.obj)) {\n          for (const k of Object.keys(parent.obj as FrontmatterData)) {\n            if ((parent.obj as FrontmatterData)[k] === current.obj) {\n              const arr = [itemValue];\n              (parent.obj as FrontmatterData)[k] = arr;\n              current.obj = arr;\n              break;\n            }\n          }\n        }\n      } else if (Array.isArray(current.obj)) {\n        current.obj.push(itemValue);\n      }\n    }\n  }\n\n  return frontmatter;\n}\n\n/**\n * Reconstruct YAML frontmatter string from an object.\n */\nexport function reconstructFrontmatter(obj: FrontmatterData): string {\n  const lines: string[] = [];\n  for (const [key, value] of Object.entries(obj)) {\n    if (value === null || value === undefined) continue;\n    if (Array.isArray(value)) {\n      formatArray(lines, key, value, 0);\n    } else if (typeof value === 'object') {\n      lines.push(`${key}:`);\n      for (const [subkey, subval] of Object.entries(value as FrontmatterData)) {\n        if (subval === null || subval === undefined) continue;\n        if (Array.isArray(subval)) {\n          formatArray(lines, subkey, subval, 2);\n        } else if (typeof subval === 'object') {\n          lines.push(`  ${subkey}:`);\n          for (const [subsubkey, subsubval] of Object.entries(subval as FrontmatterData)) {\n            if (subsubval === null || subsubval === undefined) continue;\n            if (Array.isArray(subsubval)) {\n              if (subsubval.length === 0) {\n                lines.push(`    ${subsubkey}: []`);\n              } else {\n                lines.push(`    ${subsubkey}:`);\n                for (const item of subsubval) {\n                  lines.push(`      - ${item}`);\n                }\n              }\n            } else {\n              lines.push(`    ${subsubkey}: ${subsubval}`);\n            }\n          }\n        } else {\n          const sv = String(subval);\n          lines.push(\n            `  ${subkey}: ${sv.includes(':') || sv.includes('#') ? `\"${sv}\"` : sv}`,\n          );\n        }\n      }\n    } else {\n      const sv = String(value);\n      if (sv.includes(':') || sv.includes('#') || sv.startsWith('[') || sv.startsWith('{')) {\n        lines.push(`${key}: \"${sv}\"`);\n      } else {\n        lines.push(`${key}: ${sv}`);\n      }\n    }\n  }\n  return lines.join('\\n');\n}\n\nfunction formatArray(lines: string[], key: string, value: FrontmatterValue[], indentLevel: number): void {\n  const prefix = ' '.repeat(indentLevel);\n  if (value.length === 0) {\n    lines.push(`${prefix}${key}: []`);\n  } else if (\n    value.every(v => typeof v === 'string') &&\n    value.length <= 3 &&\n    value.join(', ').length < 60\n  ) {\n    lines.push(`${prefix}${key}: [${value.join(', ')}]`);\n  } else {\n    lines.push(`${prefix}${key}:`);\n    for (const item of value) {\n      const itemStr = String(item);\n      lines.push(\n        `${prefix}  - ${typeof item === 'string' && (itemStr.includes(':') || itemStr.includes('#')) ? `\"${itemStr}\"` : itemStr}`,\n      );\n    }\n  }\n}\n\n/**\n * Replace or insert frontmatter in markdown content.\n */\nexport function spliceFrontmatter(content: string, newObj: FrontmatterData): string {\n  const yamlStr = reconstructFrontmatter(newObj);\n  const match = content.match(/^---\\n[\\s\\S]+?\\n---/);\n  if (match) {\n    return `---\\n${yamlStr}\\n---` + content.slice(match[0].length);\n  }\n  return `---\\n${yamlStr}\\n---\\n\\n` + content;\n}\n\ninterface MustHaveItem {\n  [key: string]: string | number | string[];\n}\n\n/**\n * Parse a specific block from must_haves in raw frontmatter YAML.\n */\nexport function parseMustHavesBlock(content: string, blockName: string): (string | MustHaveItem)[] {\n  const fmMatch = content.match(/^---\\n([\\s\\S]+?)\\n---/);\n  if (!fmMatch) return [];\n\n  const yaml = fmMatch[1];\n  const blockPattern = new RegExp(`^\\\\s{4}${blockName}:\\\\s*$`, 'm');\n  const blockStart = yaml.search(blockPattern);\n  if (blockStart === -1) return [];\n\n  const afterBlock = yaml.slice(blockStart);\n  const blockLines = afterBlock.split('\\n').slice(1);\n\n  const items: (string | MustHaveItem)[] = [];\n  let current: string | MustHaveItem | null = null;\n\n  for (const line of blockLines) {\n    if (line.trim() === '') continue;\n    const indent = line.match(/^(\\s*)/)![1].length;\n    if (indent <= 4 && line.trim() !== '') break;\n\n    if (line.match(/^\\s{6}-\\s+/)) {\n      if (current !== null) items.push(current);\n      current = {};\n      const simpleMatch = line.match(/^\\s{6}-\\s+\"?([^\"]+)\"?\\s*$/);\n      if (simpleMatch && !line.includes(':')) {\n        current = simpleMatch[1];\n      } else {\n        const kvMatch = line.match(/^\\s{6}-\\s+(\\w+):\\s*\"?([^\"]*)\"?\\s*$/);\n        if (kvMatch) {\n          current = { [kvMatch[1]]: kvMatch[2] };\n        }\n      }\n    } else if (current !== null && typeof current === 'object') {\n      const kvMatch = line.match(/^\\s{8,}(\\w+):\\s*\"?([^\"]*)\"?\\s*$/);\n      if (kvMatch) {\n        const val = kvMatch[2];\n        current[kvMatch[1]] = /^\\d+$/.test(val) ? parseInt(val, 10) : val;\n      }\n      const arrMatch = line.match(/^\\s{10,}-\\s+\"?([^\"]+)\"?\\s*$/);\n      if (arrMatch) {\n        const keys = Object.keys(current);\n        const lastKey = keys[keys.length - 1];\n        if (lastKey && !Array.isArray(current[lastKey])) {\n          current[lastKey] = current[lastKey] ? [String(current[lastKey])] : [];\n        }\n        if (lastKey) (current[lastKey] as string[]).push(arrMatch[1]);\n      }\n    }\n  }\n  if (current !== null) items.push(current);\n\n  return items;\n}\n\n// ─── Frontmatter schema validation ──────────────────────────────────────────\n\nexport const FRONTMATTER_SCHEMAS: Record<string, FrontmatterSchema> = {\n  plan: {\n    required: ['phase', 'plan', 'type', 'wave', 'depends_on', 'files_modified', 'autonomous', 'must_haves'],\n  },\n  summary: {\n    required: ['phase', 'plan', 'subsystem', 'tags', 'duration', 'completed'],\n  },\n  verification: {\n    required: ['phase', 'verified', 'status', 'score'],\n  },\n};\n\n// ─── Frontmatter CRUD commands ──────────────────────────────────────────────\n\nexport function cmdFrontmatterGet(\n  cwd: string,\n  filePath: string | null,\n  field: string | null,\n  raw: boolean,\n): void {\n  if (!filePath) {\n    error('file path required');\n  }\n  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\n  const content = safeReadFile(fullPath);\n  if (!content) {\n    output({ error: 'File not found', path: filePath }, raw);\n    return;\n  }\n  const fm = extractFrontmatter(content);\n  if (field) {\n    const value = fm[field];\n    if (value === undefined) {\n      output({ error: 'Field not found', field }, raw);\n      return;\n    }\n    output({ [field]: value }, raw, JSON.stringify(value));\n  } else {\n    output(fm, raw);\n  }\n}\n\nexport function cmdFrontmatterSet(\n  cwd: string,\n  filePath: string | null,\n  field: string | null,\n  value: string | undefined,\n  raw: boolean,\n): void {\n  if (!filePath || !field || value === undefined) {\n    error('file, field, and value required');\n  }\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\n  if (!fs.existsSync(fullPath)) {\n    output({ error: 'File not found', path: filePath }, raw);\n    return;\n  }\n  const content = fs.readFileSync(fullPath, 'utf-8');\n  const fm = extractFrontmatter(content);\n  let parsedValue: FrontmatterValue;\n  try {\n    parsedValue = JSON.parse(value!) as FrontmatterValue;\n  } catch {\n    parsedValue = value!;\n  }\n  fm[field!] = parsedValue;\n  const newContent = spliceFrontmatter(content, fm);\n  fs.writeFileSync(fullPath, newContent, 'utf-8');\n  output({ updated: true, field, value: parsedValue }, raw, 'true');\n}\n\nexport function cmdFrontmatterMerge(\n  cwd: string,\n  filePath: string | null,\n  data: string | null,\n  raw: boolean,\n): void {\n  if (!filePath || !data) {\n    error('file and data required');\n  }\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\n  if (!fs.existsSync(fullPath)) {\n    output({ error: 'File not found', path: filePath }, raw);\n    return;\n  }\n  const content = fs.readFileSync(fullPath, 'utf-8');\n  const fm = extractFrontmatter(content);\n  let mergeData: FrontmatterData;\n  try {\n    mergeData = JSON.parse(data!) as FrontmatterData;\n  } catch {\n    error('Invalid JSON for --data');\n    return;\n  }\n  Object.assign(fm, mergeData);\n  const newContent = spliceFrontmatter(content, fm);\n  fs.writeFileSync(fullPath, newContent, 'utf-8');\n  output({ merged: true, fields: Object.keys(mergeData) }, raw, 'true');\n}\n\nexport function cmdFrontmatterValidate(\n  cwd: string,\n  filePath: string | null,\n  schemaName: string | null,\n  raw: boolean,\n): void {\n  if (!filePath || !schemaName) {\n    error('file and schema required');\n  }\n  const schema = FRONTMATTER_SCHEMAS[schemaName!];\n  if (!schema) {\n    error(\n      `Unknown schema: ${schemaName}. Available: ${Object.keys(FRONTMATTER_SCHEMAS).join(', ')}`,\n    );\n  }\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\n  const content = safeReadFile(fullPath);\n  if (!content) {\n    output({ error: 'File not found', path: filePath }, raw);\n    return;\n  }\n  const fm = extractFrontmatter(content);\n  const missing = schema.required.filter(f => fm[f] === undefined);\n  const present = schema.required.filter(f => fm[f] !== undefined);\n  const result: FrontmatterValidationResult = {\n    valid: missing.length === 0,\n    missing,\n    present,\n    schema: schemaName!,\n  };\n  output(result, raw, missing.length === 0 ? 'valid' : 'invalid');\n}\n","/**\n * Config — Planning config CRUD operations\n *\n * Ported from maxsim/bin/lib/config.cjs\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport os from 'node:os';\n\nimport { output, error } from './core.js';\nimport type { PlanningConfig, WorkflowConfig } from './types.js';\nimport { PLANNING_CONFIG_DEFAULTS } from './types.js';\n\n// ─── Config CRUD commands ───────────────────────────────────────────────────\n\nexport function cmdConfigEnsureSection(cwd: string, raw: boolean): void {\n  const configPath = path.join(cwd, '.planning', 'config.json');\n  const planningDir = path.join(cwd, '.planning');\n\n  try {\n    if (!fs.existsSync(planningDir)) {\n      fs.mkdirSync(planningDir, { recursive: true });\n    }\n  } catch (err: unknown) {\n    error('Failed to create .planning directory: ' + (err as Error).message);\n  }\n\n  if (fs.existsSync(configPath)) {\n    const result = { created: false, reason: 'already_exists' };\n    output(result, raw, 'exists');\n    return;\n  }\n\n  // Detect Brave Search API key availability\n  const homedir = os.homedir();\n  const braveKeyFile = path.join(homedir, '.maxsim', 'brave_api_key');\n  const hasBraveSearch = !!(process.env.BRAVE_API_KEY || fs.existsSync(braveKeyFile));\n\n  // Load user-level defaults from ~/.maxsim/defaults.json if available\n  const globalDefaultsPath = path.join(homedir, '.maxsim', 'defaults.json');\n  let userDefaults: Partial<PlanningConfig> = {};\n  try {\n    if (fs.existsSync(globalDefaultsPath)) {\n      userDefaults = JSON.parse(fs.readFileSync(globalDefaultsPath, 'utf-8')) as Partial<PlanningConfig>;\n    }\n  } catch {\n    // Ignore malformed global defaults, fall back to hardcoded\n  }\n\n  const hardcoded: PlanningConfig = {\n    ...PLANNING_CONFIG_DEFAULTS,\n    brave_search: hasBraveSearch,\n  };\n\n  const defaults: PlanningConfig = {\n    ...hardcoded,\n    ...userDefaults,\n    workflow: {\n      ...hardcoded.workflow,\n      ...(userDefaults.workflow || {}),\n    } as WorkflowConfig,\n  };\n\n  try {\n    fs.writeFileSync(configPath, JSON.stringify(defaults, null, 2), 'utf-8');\n    const result = { created: true, path: '.planning/config.json' };\n    output(result, raw, 'created');\n  } catch (err: unknown) {\n    error('Failed to create config.json: ' + (err as Error).message);\n  }\n}\n\nexport function cmdConfigSet(cwd: string, keyPath: string | undefined, value: string | undefined, raw: boolean): void {\n  const configPath = path.join(cwd, '.planning', 'config.json');\n\n  if (!keyPath) {\n    error('Usage: config-set <key.path> <value>');\n  }\n\n  // Parse value (handle booleans and numbers)\n  let parsedValue: string | boolean | number | undefined = value;\n  if (value === 'true') parsedValue = true;\n  else if (value === 'false') parsedValue = false;\n  else if (value !== undefined && !isNaN(Number(value)) && value !== '') parsedValue = Number(value);\n\n  // Load existing config or start with empty object\n  let config: Record<string, unknown> = {};\n  try {\n    if (fs.existsSync(configPath)) {\n      config = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as Record<string, unknown>;\n    }\n  } catch (err: unknown) {\n    error('Failed to read config.json: ' + (err as Error).message);\n  }\n\n  // Set nested value using dot notation\n  const keys = keyPath!.split('.');\n  let current: Record<string, unknown> = config;\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (current[key] === undefined || typeof current[key] !== 'object') {\n      current[key] = {};\n    }\n    current = current[key] as Record<string, unknown>;\n  }\n  current[keys[keys.length - 1]] = parsedValue;\n\n  try {\n    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');\n    const result = { updated: true, key: keyPath, value: parsedValue };\n    output(result, raw, `${keyPath}=${parsedValue}`);\n  } catch (err: unknown) {\n    error('Failed to write config.json: ' + (err as Error).message);\n  }\n}\n\nexport function cmdConfigGet(cwd: string, keyPath: string | undefined, raw: boolean): void {\n  const configPath = path.join(cwd, '.planning', 'config.json');\n\n  if (!keyPath) {\n    error('Usage: config-get <key.path>');\n  }\n\n  let config: Record<string, unknown> = {};\n  try {\n    if (fs.existsSync(configPath)) {\n      config = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as Record<string, unknown>;\n    } else {\n      error('No config.json found at ' + configPath);\n    }\n  } catch (err: unknown) {\n    if ((err as Error).message.startsWith('No config.json')) throw err;\n    error('Failed to read config.json: ' + (err as Error).message);\n  }\n\n  const keys = keyPath!.split('.');\n  let current: unknown = config;\n  for (const key of keys) {\n    if (current === undefined || current === null || typeof current !== 'object') {\n      error(`Key not found: ${keyPath}`);\n    }\n    current = (current as Record<string, unknown>)[key];\n  }\n\n  if (current === undefined) {\n    error(`Key not found: ${keyPath}`);\n  }\n\n  output(current, raw, String(current));\n}\n","/**\n * State — STATE.md operations and progression engine\n *\n * Ported from maxsim/bin/lib/state.cjs\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport { loadConfig, output, error, safeReadFile } from './core.js';\nimport type {\n  AppConfig,\n  StatePatchResult,\n  StateMetricOptions,\n  StateDecisionOptions,\n  StateBlockerOptions,\n  StateSessionOptions,\n  StateSnapshot,\n  Decision,\n} from './types.js';\n\n// ─── Internal helpers ────────────────────────────────────────────────────────\n\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function stateExtractField(content: string, fieldName: string): string | null {\n  const pattern = new RegExp(`\\\\*\\\\*${fieldName}:\\\\*\\\\*\\\\s*(.+)`, 'i');\n  const match = content.match(pattern);\n  return match ? match[1].trim() : null;\n}\n\nexport function stateReplaceField(content: string, fieldName: string, newValue: string): string | null {\n  const escaped = escapeRegex(fieldName);\n  const pattern = new RegExp(`(\\\\*\\\\*${escaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\n  if (pattern.test(content)) {\n    return content.replace(pattern, (_match, prefix: string) => `${prefix}${newValue}`);\n  }\n  return null;\n}\n\nfunction readTextArgOrFile(cwd: string, value: string | undefined, filePath: string | undefined, label: string): string | undefined {\n  if (!filePath) return value;\n  const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\n  try {\n    return fs.readFileSync(resolvedPath, 'utf-8').trimEnd();\n  } catch {\n    throw new Error(`${label} file not found: ${filePath}`);\n  }\n}\n\n// ─── State commands ──────────────────────────────────────────────────────────\n\nexport function cmdStateLoad(cwd: string, raw: boolean): void {\n  const config: AppConfig = loadConfig(cwd);\n  const planningDir = path.join(cwd, '.planning');\n\n  let stateRaw = '';\n  try {\n    stateRaw = fs.readFileSync(path.join(planningDir, 'STATE.md'), 'utf-8');\n  } catch (e) {\n    /* optional op, ignore */\n    if (process.env.MAXSIM_DEBUG) console.error(e);\n  }\n\n  const configExists = fs.existsSync(path.join(planningDir, 'config.json'));\n  const roadmapExists = fs.existsSync(path.join(planningDir, 'ROADMAP.md'));\n  const stateExists = stateRaw.length > 0;\n\n  const result = {\n    config,\n    state_raw: stateRaw,\n    state_exists: stateExists,\n    roadmap_exists: roadmapExists,\n    config_exists: configExists,\n  };\n\n  if (raw) {\n    const c = config;\n    const lines = [\n      `model_profile=${c.model_profile}`,\n      `commit_docs=${c.commit_docs}`,\n      `branching_strategy=${c.branching_strategy}`,\n      `phase_branch_template=${c.phase_branch_template}`,\n      `milestone_branch_template=${c.milestone_branch_template}`,\n      `parallelization=${c.parallelization}`,\n      `research=${c.research}`,\n      `plan_checker=${c.plan_checker}`,\n      `verifier=${c.verifier}`,\n      `config_exists=${configExists}`,\n      `roadmap_exists=${roadmapExists}`,\n      `state_exists=${stateExists}`,\n    ];\n    process.stdout.write(lines.join('\\n'));\n    process.exit(0);\n  }\n\n  output(result);\n}\n\nexport function cmdStateGet(cwd: string, section: string | null, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  try {\n    const content = fs.readFileSync(statePath, 'utf-8');\n\n    if (!section) {\n      output({ content }, raw, content);\n      return;\n    }\n\n    const fieldEscaped = escapeRegex(section);\n\n    // Check for **field:** value\n    const fieldPattern = new RegExp(`\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*(.*)`, 'i');\n    const fieldMatch = content.match(fieldPattern);\n    if (fieldMatch) {\n      output({ [section]: fieldMatch[1].trim() }, raw, fieldMatch[1].trim());\n      return;\n    }\n\n    // Check for ## Section\n    const sectionPattern = new RegExp(`##\\\\s*${fieldEscaped}\\\\s*\\n([\\\\s\\\\S]*?)(?=\\\\n##|$)`, 'i');\n    const sectionMatch = content.match(sectionPattern);\n    if (sectionMatch) {\n      output({ [section]: sectionMatch[1].trim() }, raw, sectionMatch[1].trim());\n      return;\n    }\n\n    output({ error: `Section or field \"${section}\" not found` }, raw, '');\n  } catch {\n    error('STATE.md not found');\n  }\n}\n\nexport function cmdStatePatch(cwd: string, patches: Record<string, string>, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  try {\n    let content = fs.readFileSync(statePath, 'utf-8');\n    const results: StatePatchResult = { updated: [], failed: [] };\n\n    for (const [field, value] of Object.entries(patches)) {\n      const fieldEscaped = escapeRegex(field);\n      const pattern = new RegExp(`(\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\n\n      if (pattern.test(content)) {\n        content = content.replace(pattern, (_match, prefix: string) => `${prefix}${value}`);\n        results.updated.push(field);\n      } else {\n        results.failed.push(field);\n      }\n    }\n\n    if (results.updated.length > 0) {\n      fs.writeFileSync(statePath, content, 'utf-8');\n    }\n\n    output(results, raw, results.updated.length > 0 ? 'true' : 'false');\n  } catch {\n    error('STATE.md not found');\n  }\n}\n\nexport function cmdStateUpdate(cwd: string, field: string | undefined, value: string | undefined): void {\n  if (!field || value === undefined) {\n    error('field and value required for state update');\n  }\n\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  try {\n    let content = fs.readFileSync(statePath, 'utf-8');\n    const fieldEscaped = escapeRegex(field);\n    const pattern = new RegExp(`(\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\n    if (pattern.test(content)) {\n      content = content.replace(pattern, (_match, prefix: string) => `${prefix}${value}`);\n      fs.writeFileSync(statePath, content, 'utf-8');\n      output({ updated: true });\n    } else {\n      output({ updated: false, reason: `Field \"${field}\" not found in STATE.md` });\n    }\n  } catch {\n    output({ updated: false, reason: 'STATE.md not found' });\n  }\n}\n\n// ─── State Progression Engine ────────────────────────────────────────────────\n\nexport function cmdStateAdvancePlan(cwd: string, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n  const currentPlan = parseInt(stateExtractField(content, 'Current Plan') ?? '', 10);\n  const totalPlans = parseInt(stateExtractField(content, 'Total Plans in Phase') ?? '', 10);\n  const today = new Date().toISOString().split('T')[0];\n\n  if (isNaN(currentPlan) || isNaN(totalPlans)) {\n    output({ error: 'Cannot parse Current Plan or Total Plans in Phase from STATE.md' }, raw);\n    return;\n  }\n\n  if (currentPlan >= totalPlans) {\n    content = stateReplaceField(content, 'Status', 'Phase complete — ready for verification') || content;\n    content = stateReplaceField(content, 'Last Activity', today) || content;\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ advanced: false, reason: 'last_plan', current_plan: currentPlan, total_plans: totalPlans, status: 'ready_for_verification' }, raw, 'false');\n  } else {\n    const newPlan = currentPlan + 1;\n    content = stateReplaceField(content, 'Current Plan', String(newPlan)) || content;\n    content = stateReplaceField(content, 'Status', 'Ready to execute') || content;\n    content = stateReplaceField(content, 'Last Activity', today) || content;\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ advanced: true, previous_plan: currentPlan, current_plan: newPlan, total_plans: totalPlans }, raw, 'true');\n  }\n}\n\nexport function cmdStateRecordMetric(cwd: string, options: StateMetricOptions, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n  const { phase, plan, duration, tasks, files } = options;\n\n  if (!phase || !plan || !duration) {\n    output({ error: 'phase, plan, and duration required' }, raw);\n    return;\n  }\n\n  const metricsPattern = /(##\\s*Performance Metrics[\\s\\S]*?\\n\\|[^\\n]+\\n\\|[-|\\s]+\\n)([\\s\\S]*?)(?=\\n##|\\n$|$)/i;\n  const metricsMatch = content.match(metricsPattern);\n\n  if (metricsMatch) {\n    let tableBody = metricsMatch[2].trimEnd();\n    const newRow = `| Phase ${phase} P${plan} | ${duration} | ${tasks || '-'} tasks | ${files || '-'} files |`;\n\n    if (tableBody.trim() === '' || tableBody.includes('None yet')) {\n      tableBody = newRow;\n    } else {\n      tableBody = tableBody + '\\n' + newRow;\n    }\n\n    content = content.replace(metricsPattern, (_match, header: string) => `${header}${tableBody}\\n`);\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ recorded: true, phase, plan, duration }, raw, 'true');\n  } else {\n    output({ recorded: false, reason: 'Performance Metrics section not found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateUpdateProgress(cwd: string, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n\n  const phasesDir = path.join(cwd, '.planning', 'phases');\n  let totalPlans = 0;\n  let totalSummaries = 0;\n\n  if (fs.existsSync(phasesDir)) {\n    const phaseDirs = fs.readdirSync(phasesDir, { withFileTypes: true })\n      .filter(e => e.isDirectory()).map(e => e.name);\n    for (const dir of phaseDirs) {\n      const files = fs.readdirSync(path.join(phasesDir, dir));\n      totalPlans += files.filter(f => f.match(/-PLAN\\.md$/i)).length;\n      totalSummaries += files.filter(f => f.match(/-SUMMARY\\.md$/i)).length;\n    }\n  }\n\n  const percent = totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0;\n  const barWidth = 10;\n  const filled = Math.round(percent / 100 * barWidth);\n  const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\n  const progressStr = `[${bar}] ${percent}%`;\n\n  const progressPattern = /(\\*\\*Progress:\\*\\*\\s*).*/i;\n  if (progressPattern.test(content)) {\n    content = content.replace(progressPattern, (_match, prefix: string) => `${prefix}${progressStr}`);\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ updated: true, percent, completed: totalSummaries, total: totalPlans, bar: progressStr }, raw, progressStr);\n  } else {\n    output({ updated: false, reason: 'Progress field not found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateAddDecision(cwd: string, options: StateDecisionOptions, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n\n  const { phase, summary, summary_file, rationale, rationale_file } = options;\n  let summaryText: string | undefined;\n  let rationaleText = '';\n\n  try {\n    summaryText = readTextArgOrFile(cwd, summary, summary_file, 'summary');\n    rationaleText = readTextArgOrFile(cwd, rationale || '', rationale_file, 'rationale') || '';\n  } catch (thrown: unknown) {\n    const e = thrown as Error;\n    output({ added: false, reason: e.message }, raw, 'false');\n    return;\n  }\n\n  if (!summaryText) { output({ error: 'summary required' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n  const entry = `- [Phase ${phase || '?'}]: ${summaryText}${rationaleText ? ` — ${rationaleText}` : ''}`;\n\n  const sectionPattern = /(###?\\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\n  const match = content.match(sectionPattern);\n\n  if (match) {\n    let sectionBody = match[2];\n    sectionBody = sectionBody.replace(/None yet\\.?\\s*\\n?/gi, '').replace(/No decisions yet\\.?\\s*\\n?/gi, '');\n    sectionBody = sectionBody.trimEnd() + '\\n' + entry + '\\n';\n    content = content.replace(sectionPattern, (_match, header: string) => `${header}${sectionBody}`);\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ added: true, decision: entry }, raw, 'true');\n  } else {\n    output({ added: false, reason: 'Decisions section not found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateAddBlocker(cwd: string, text: string | StateBlockerOptions, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n  const blockerOptions: StateBlockerOptions = typeof text === 'object' && text !== null ? text : { text: text as string };\n  let blockerText: string | undefined;\n\n  try {\n    blockerText = readTextArgOrFile(cwd, blockerOptions.text, blockerOptions.text_file, 'blocker');\n  } catch (thrown: unknown) {\n    const e = thrown as Error;\n    output({ added: false, reason: e.message }, raw, 'false');\n    return;\n  }\n\n  if (!blockerText) { output({ error: 'text required' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n  const entry = `- ${blockerText}`;\n\n  const sectionPattern = /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\n  const match = content.match(sectionPattern);\n\n  if (match) {\n    let sectionBody = match[2];\n    sectionBody = sectionBody.replace(/None\\.?\\s*\\n?/gi, '').replace(/None yet\\.?\\s*\\n?/gi, '');\n    sectionBody = sectionBody.trimEnd() + '\\n' + entry + '\\n';\n    content = content.replace(sectionPattern, (_match, header: string) => `${header}${sectionBody}`);\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ added: true, blocker: blockerText }, raw, 'true');\n  } else {\n    output({ added: false, reason: 'Blockers section not found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateResolveBlocker(cwd: string, text: string | null, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n  if (!text) { output({ error: 'text required' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n\n  const sectionPattern = /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\n  const match = content.match(sectionPattern);\n\n  if (match) {\n    const sectionBody = match[2];\n    const lines = sectionBody.split('\\n');\n    const filtered = lines.filter(line => {\n      if (!line.startsWith('- ')) return true;\n      return !line.toLowerCase().includes(text.toLowerCase());\n    });\n\n    let newBody = filtered.join('\\n');\n    if (!newBody.trim() || !newBody.includes('- ')) {\n      newBody = 'None\\n';\n    }\n\n    content = content.replace(sectionPattern, (_match, header: string) => `${header}${newBody}`);\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ resolved: true, blocker: text }, raw, 'true');\n  } else {\n    output({ resolved: false, reason: 'Blockers section not found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateRecordSession(cwd: string, options: StateSessionOptions, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\n\n  let content = fs.readFileSync(statePath, 'utf-8');\n  const now = new Date().toISOString();\n  const updated: string[] = [];\n\n  let result = stateReplaceField(content, 'Last session', now);\n  if (result) { content = result; updated.push('Last session'); }\n  result = stateReplaceField(content, 'Last Date', now);\n  if (result) { content = result; updated.push('Last Date'); }\n\n  if (options.stopped_at) {\n    result = stateReplaceField(content, 'Stopped At', options.stopped_at);\n    if (!result) result = stateReplaceField(content, 'Stopped at', options.stopped_at);\n    if (result) { content = result; updated.push('Stopped At'); }\n  }\n\n  const resumeFile = options.resume_file || 'None';\n  result = stateReplaceField(content, 'Resume File', resumeFile);\n  if (!result) result = stateReplaceField(content, 'Resume file', resumeFile);\n  if (result) { content = result; updated.push('Resume File'); }\n\n  if (updated.length > 0) {\n    fs.writeFileSync(statePath, content, 'utf-8');\n    output({ recorded: true, updated }, raw, 'true');\n  } else {\n    output({ recorded: false, reason: 'No session fields found in STATE.md' }, raw, 'false');\n  }\n}\n\nexport function cmdStateSnapshot(cwd: string, raw: boolean): void {\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\n\n  if (!fs.existsSync(statePath)) {\n    output({ error: 'STATE.md not found' }, raw);\n    return;\n  }\n\n  const content = fs.readFileSync(statePath, 'utf-8');\n\n  const extractField = (fieldName: string): string | null => {\n    const pattern = new RegExp(`\\\\*\\\\*${fieldName}:\\\\*\\\\*\\\\s*(.+)`, 'i');\n    const match = content.match(pattern);\n    return match ? match[1].trim() : null;\n  };\n\n  const currentPhase = extractField('Current Phase');\n  const currentPhaseName = extractField('Current Phase Name');\n  const totalPhasesRaw = extractField('Total Phases');\n  const currentPlan = extractField('Current Plan');\n  const totalPlansRaw = extractField('Total Plans in Phase');\n  const status = extractField('Status');\n  const progressRaw = extractField('Progress');\n  const lastActivity = extractField('Last Activity');\n  const lastActivityDesc = extractField('Last Activity Description');\n  const pausedAt = extractField('Paused At');\n\n  const totalPhases = totalPhasesRaw ? parseInt(totalPhasesRaw, 10) : null;\n  const totalPlansInPhase = totalPlansRaw ? parseInt(totalPlansRaw, 10) : null;\n  const progressPercent = progressRaw ? parseInt(progressRaw.replace('%', ''), 10) : null;\n\n  const decisions: Decision[] = [];\n  const decisionsMatch = content.match(/##\\s*Decisions Made[\\s\\S]*?\\n\\|[^\\n]+\\n\\|[-|\\s]+\\n([\\s\\S]*?)(?=\\n##|\\n$|$)/i);\n  if (decisionsMatch) {\n    const tableBody = decisionsMatch[1];\n    const rows = tableBody.trim().split('\\n').filter(r => r.includes('|'));\n    for (const row of rows) {\n      const cells = row.split('|').map(c => c.trim()).filter(Boolean);\n      if (cells.length >= 3) {\n        decisions.push({\n          phase: cells[0],\n          summary: cells[1],\n          rationale: cells[2],\n        });\n      }\n    }\n  }\n\n  const blockers: string[] = [];\n  const blockersMatch = content.match(/##\\s*Blockers\\s*\\n([\\s\\S]*?)(?=\\n##|$)/i);\n  if (blockersMatch) {\n    const blockersSection = blockersMatch[1];\n    const items = blockersSection.match(/^-\\s+(.+)$/gm) || [];\n    for (const item of items) {\n      blockers.push(item.replace(/^-\\s+/, '').trim());\n    }\n  }\n\n  const session: StateSnapshot['session'] = {\n    last_date: null,\n    stopped_at: null,\n    resume_file: null,\n  };\n\n  const sessionMatch = content.match(/##\\s*Session\\s*\\n([\\s\\S]*?)(?=\\n##|$)/i);\n  if (sessionMatch) {\n    const sessionSection = sessionMatch[1];\n    const lastDateMatch = sessionSection.match(/\\*\\*Last Date:\\*\\*\\s*(.+)/i);\n    const stoppedAtMatch = sessionSection.match(/\\*\\*Stopped At:\\*\\*\\s*(.+)/i);\n    const resumeFileMatch = sessionSection.match(/\\*\\*Resume File:\\*\\*\\s*(.+)/i);\n\n    if (lastDateMatch) session.last_date = lastDateMatch[1].trim();\n    if (stoppedAtMatch) session.stopped_at = stoppedAtMatch[1].trim();\n    if (resumeFileMatch) session.resume_file = resumeFileMatch[1].trim();\n  }\n\n  const snapshot: StateSnapshot = {\n    current_phase: currentPhase,\n    current_phase_name: currentPhaseName,\n    total_phases: totalPhases,\n    current_plan: currentPlan,\n    total_plans_in_phase: totalPlansInPhase,\n    status,\n    progress_percent: progressPercent,\n    last_activity: lastActivity,\n    last_activity_desc: lastActivityDesc,\n    decisions,\n    blockers,\n    paused_at: pausedAt,\n    session,\n  };\n\n  output(snapshot, raw);\n}\n","/**\n * Roadmap — Roadmap parsing and update operations\n *\n * Ported from maxsim/bin/lib/roadmap.cjs\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport { normalizePhaseName, getPhasePattern, output, error, findPhaseInternal } from './core.js';\nimport type {\n  PhaseStatus,\n  RoadmapPhase,\n  RoadmapMilestone,\n  RoadmapAnalysis,\n  RoadmapGetPhaseResult,\n} from './types.js';\n\n// ─── Roadmap commands ────────────────────────────────────────────────────────\n\nexport function cmdRoadmapGetPhase(cwd: string, phaseNum: string, raw: boolean): void {\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\n\n  if (!fs.existsSync(roadmapPath)) {\n    output({ found: false, error: 'ROADMAP.md not found' }, raw, '');\n    return;\n  }\n\n  try {\n    const content = fs.readFileSync(roadmapPath, 'utf-8');\n\n    const escapedPhase = phaseNum.replace(/\\./g, '\\\\.');\n\n    const phasePattern = getPhasePattern(escapedPhase, 'i');\n    const headerMatch = content.match(phasePattern);\n\n    if (!headerMatch) {\n      const checklistPattern = new RegExp(\n        `-\\\\s*\\\\[[ x]\\\\]\\\\s*\\\\*\\\\*Phase\\\\s+${escapedPhase}:\\\\s*([^*]+)\\\\*\\\\*`,\n        'i'\n      );\n      const checklistMatch = content.match(checklistPattern);\n\n      if (checklistMatch) {\n        output({\n          found: false,\n          phase_number: phaseNum,\n          phase_name: checklistMatch[1].trim(),\n          error: 'malformed_roadmap',\n          message: `Phase ${phaseNum} exists in summary list but missing \"### Phase ${phaseNum}:\" detail section. ROADMAP.md needs both formats.`\n        }, raw, '');\n        return;\n      }\n\n      output({ found: false, phase_number: phaseNum }, raw, '');\n      return;\n    }\n\n    const phaseName = headerMatch[1].trim();\n    const headerIndex = headerMatch.index!;\n\n    const restOfContent = content.slice(headerIndex);\n    const nextHeaderMatch = restOfContent.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\n    const sectionEnd = nextHeaderMatch\n      ? headerIndex + nextHeaderMatch.index!\n      : content.length;\n\n    const section = content.slice(headerIndex, sectionEnd).trim();\n\n    const goalMatch = section.match(/\\*\\*Goal:\\*\\*\\s*([^\\n]+)/i);\n    const goal = goalMatch ? goalMatch[1].trim() : null;\n\n    const criteriaMatch = section.match(/\\*\\*Success Criteria\\*\\*[^\\n]*:\\s*\\n((?:\\s*\\d+\\.\\s*[^\\n]+\\n?)+)/i);\n    const success_criteria = criteriaMatch\n      ? criteriaMatch[1].trim().split('\\n').map(line => line.replace(/^\\s*\\d+\\.\\s*/, '').trim()).filter(Boolean)\n      : [];\n\n    output(\n      {\n        found: true,\n        phase_number: phaseNum,\n        phase_name: phaseName,\n        goal,\n        success_criteria,\n        section,\n      },\n      raw,\n      section\n    );\n  } catch (e: unknown) {\n    error('Failed to read ROADMAP.md: ' + (e as Error).message);\n  }\n}\n\nexport function cmdRoadmapAnalyze(cwd: string, raw: boolean): void {\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\n\n  if (!fs.existsSync(roadmapPath)) {\n    output({ error: 'ROADMAP.md not found', milestones: [], phases: [], current_phase: null }, raw);\n    return;\n  }\n\n  const content = fs.readFileSync(roadmapPath, 'utf-8');\n  const phasesDir = path.join(cwd, '.planning', 'phases');\n\n  const phasePattern = getPhasePattern();\n  const phases: RoadmapPhase[] = [];\n  let match: RegExpExecArray | null;\n\n  while ((match = phasePattern.exec(content)) !== null) {\n    const phaseNum = match[1];\n    const phaseName = match[2].replace(/\\(INSERTED\\)/i, '').trim();\n\n    const sectionStart = match.index;\n    const restOfContent = content.slice(sectionStart);\n    const nextHeader = restOfContent.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\n    const sectionEnd = nextHeader ? sectionStart + nextHeader.index! : content.length;\n    const section = content.slice(sectionStart, sectionEnd);\n\n    const goalMatch = section.match(/\\*\\*Goal:\\*\\*\\s*([^\\n]+)/i);\n    const goal = goalMatch ? goalMatch[1].trim() : null;\n\n    const dependsMatch = section.match(/\\*\\*Depends on:\\*\\*\\s*([^\\n]+)/i);\n    const depends_on = dependsMatch ? dependsMatch[1].trim() : null;\n\n    const normalized = normalizePhaseName(phaseNum);\n    let diskStatus: PhaseStatus = 'no_directory';\n    let planCount = 0;\n    let summaryCount = 0;\n    let hasContext = false;\n    let hasResearch = false;\n\n    try {\n      const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\n      const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\n      const dirMatch = dirs.find(d => d.startsWith(normalized + '-') || d === normalized);\n\n      if (dirMatch) {\n        const phaseFiles = fs.readdirSync(path.join(phasesDir, dirMatch));\n        planCount = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md').length;\n        summaryCount = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md').length;\n        hasContext = phaseFiles.some(f => f.endsWith('-CONTEXT.md') || f === 'CONTEXT.md');\n        hasResearch = phaseFiles.some(f => f.endsWith('-RESEARCH.md') || f === 'RESEARCH.md');\n\n        if (summaryCount >= planCount && planCount > 0) diskStatus = 'complete';\n        else if (summaryCount > 0) diskStatus = 'partial';\n        else if (planCount > 0) diskStatus = 'planned';\n        else if (hasResearch) diskStatus = 'researched';\n        else if (hasContext) diskStatus = 'discussed';\n        else diskStatus = 'empty';\n      }\n    } catch (e) {\n      /* optional op, ignore */\n      if (process.env.MAXSIM_DEBUG) console.error(e);\n    }\n\n    const checkboxPattern = new RegExp(`-\\\\s*\\\\[(x| )\\\\]\\\\s*.*Phase\\\\s+${phaseNum.replace('.', '\\\\.')}`, 'i');\n    const checkboxMatch = content.match(checkboxPattern);\n    const roadmapComplete = checkboxMatch ? checkboxMatch[1] === 'x' : false;\n\n    phases.push({\n      number: phaseNum,\n      name: phaseName,\n      goal,\n      depends_on,\n      plan_count: planCount,\n      summary_count: summaryCount,\n      has_context: hasContext,\n      has_research: hasResearch,\n      disk_status: diskStatus,\n      roadmap_complete: roadmapComplete,\n    });\n  }\n\n  const milestones: RoadmapMilestone[] = [];\n  const milestonePattern = /##\\s*(.*v(\\d+\\.\\d+)[^(\\n]*)/gi;\n  let mMatch: RegExpExecArray | null;\n  while ((mMatch = milestonePattern.exec(content)) !== null) {\n    milestones.push({\n      heading: mMatch[1].trim(),\n      version: 'v' + mMatch[2],\n    });\n  }\n\n  const currentPhase = phases.find(p => p.disk_status === 'planned' || p.disk_status === 'partial') || null;\n  const nextPhase = phases.find(p => p.disk_status === 'empty' || p.disk_status === 'no_directory' || p.disk_status === 'discussed' || p.disk_status === 'researched') || null;\n\n  const totalPlans = phases.reduce((sum, p) => sum + p.plan_count, 0);\n  const totalSummaries = phases.reduce((sum, p) => sum + p.summary_count, 0);\n  const completedPhases = phases.filter(p => p.disk_status === 'complete').length;\n\n  const checklistPattern = /-\\s*\\[[ x]\\]\\s*\\*\\*Phase\\s+(\\d+[A-Z]?(?:\\.\\d+)?)/gi;\n  const checklistPhases = new Set<string>();\n  let checklistMatch: RegExpExecArray | null;\n  while ((checklistMatch = checklistPattern.exec(content)) !== null) {\n    checklistPhases.add(checklistMatch[1]);\n  }\n  const detailPhases = new Set(phases.map(p => p.number));\n  const missingDetails = [...checklistPhases].filter(p => !detailPhases.has(p));\n\n  const result: RoadmapAnalysis = {\n    milestones,\n    phases,\n    phase_count: phases.length,\n    completed_phases: completedPhases,\n    total_plans: totalPlans,\n    total_summaries: totalSummaries,\n    progress_percent: totalPlans > 0 ? Math.min(100, Math.round((totalSummaries / totalPlans) * 100)) : 0,\n    current_phase: currentPhase ? currentPhase.number : null,\n    next_phase: nextPhase ? nextPhase.number : null,\n    missing_phase_details: missingDetails.length > 0 ? missingDetails : null,\n  };\n\n  output(result, raw);\n}\n\nexport function cmdRoadmapUpdatePlanProgress(cwd: string, phaseNum: string, raw: boolean): void {\n  if (!phaseNum) {\n    error('phase number required for roadmap update-plan-progress');\n  }\n\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\n\n  const phaseInfo = findPhaseInternal(cwd, phaseNum);\n  if (!phaseInfo) {\n    error(`Phase ${phaseNum} not found`);\n  }\n\n  const planCount = phaseInfo.plans.length;\n  const summaryCount = phaseInfo.summaries.length;\n\n  if (planCount === 0) {\n    output({ updated: false, reason: 'No plans found', plan_count: 0, summary_count: 0 }, raw, 'no plans');\n    return;\n  }\n\n  const isComplete = summaryCount >= planCount;\n  const status = isComplete ? 'Complete' : summaryCount > 0 ? 'In Progress' : 'Planned';\n  const today = new Date().toISOString().split('T')[0];\n\n  if (!fs.existsSync(roadmapPath)) {\n    output({ updated: false, reason: 'ROADMAP.md not found', plan_count: planCount, summary_count: summaryCount }, raw, 'no roadmap');\n    return;\n  }\n\n  let roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\n  const phaseEscaped = phaseNum.replace('.', '\\\\.');\n\n  const tablePattern = new RegExp(\n    `(\\\\|\\\\s*${phaseEscaped}\\\\.?\\\\s[^|]*\\\\|)[^|]*(\\\\|)\\\\s*[^|]*(\\\\|)\\\\s*[^|]*(\\\\|)`,\n    'i'\n  );\n  const dateField = isComplete ? ` ${today} ` : '  ';\n  roadmapContent = roadmapContent.replace(\n    tablePattern,\n    `$1 ${summaryCount}/${planCount} $2 ${status.padEnd(11)}$3${dateField}$4`\n  );\n\n  const planCountPattern = new RegExp(\n    `(#{2,4}\\\\s*Phase\\\\s+${phaseEscaped}[\\\\s\\\\S]*?\\\\*\\\\*Plans:\\\\*\\\\*\\\\s*)[^\\\\n]+`,\n    'i'\n  );\n  const planCountText = isComplete\n    ? `${summaryCount}/${planCount} plans complete`\n    : `${summaryCount}/${planCount} plans executed`;\n  roadmapContent = roadmapContent.replace(planCountPattern, `$1${planCountText}`);\n\n  if (isComplete) {\n    const checkboxPattern = new RegExp(\n      `(-\\\\s*\\\\[)[ ](\\\\]\\\\s*.*Phase\\\\s+${phaseEscaped}[:\\\\s][^\\\\n]*)`,\n      'i'\n    );\n    roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);\n  }\n\n  fs.writeFileSync(roadmapPath, roadmapContent, 'utf-8');\n\n  output({\n    updated: true,\n    phase: phaseNum,\n    plan_count: planCount,\n    summary_count: summaryCount,\n    status,\n    complete: isComplete,\n  }, raw, `${summaryCount}/${planCount} ${status}`);\n}\n","/**\r\n * Milestone — Milestone and requirements lifecycle operations\r\n *\r\n * Ported from maxsim/bin/lib/milestone.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport { output, error } from './core.js';\r\nimport { extractFrontmatter } from './frontmatter.js';\r\nimport type {\r\n  MilestoneCompleteOptions,\r\n  MilestoneResult,\r\n  ArchiveResult,\r\n} from './types.js';\r\n\r\n// ─── Requirements commands ───────────────────────────────────────────────────\r\n\r\nexport function cmdRequirementsMarkComplete(cwd: string, reqIdsRaw: string[], raw: boolean): void {\r\n  if (!reqIdsRaw || reqIdsRaw.length === 0) {\r\n    error('requirement IDs required. Usage: requirements mark-complete REQ-01,REQ-02 or REQ-01 REQ-02');\r\n  }\r\n\r\n  const reqIds = reqIdsRaw\r\n    .join(' ')\r\n    .replace(/[\\[\\]]/g, '')\r\n    .split(/[,\\s]+/)\r\n    .map(r => r.trim())\r\n    .filter(Boolean);\r\n\r\n  if (reqIds.length === 0) {\r\n    error('no valid requirement IDs found');\r\n  }\r\n\r\n  const reqPath = path.join(cwd, '.planning', 'REQUIREMENTS.md');\r\n  if (!fs.existsSync(reqPath)) {\r\n    output({ updated: false, reason: 'REQUIREMENTS.md not found', ids: reqIds }, raw, 'no requirements file');\r\n    return;\r\n  }\r\n\r\n  let reqContent = fs.readFileSync(reqPath, 'utf-8');\r\n  const updated: string[] = [];\r\n  const notFound: string[] = [];\r\n\r\n  for (const reqId of reqIds) {\r\n    let found = false;\r\n\r\n    const checkboxPattern = new RegExp(`(-\\\\s*\\\\[)[ ](\\\\]\\\\s*\\\\*\\\\*${reqId}\\\\*\\\\*)`, 'gi');\r\n    if (checkboxPattern.test(reqContent)) {\r\n      reqContent = reqContent.replace(checkboxPattern, '$1x$2');\r\n      found = true;\r\n    }\r\n\r\n    const tablePattern = new RegExp(`(\\\\|\\\\s*${reqId}\\\\s*\\\\|[^|]+\\\\|)\\\\s*Pending\\\\s*(\\\\|)`, 'gi');\r\n    if (tablePattern.test(reqContent)) {\r\n      reqContent = reqContent.replace(\r\n        new RegExp(`(\\\\|\\\\s*${reqId}\\\\s*\\\\|[^|]+\\\\|)\\\\s*Pending\\\\s*(\\\\|)`, 'gi'),\r\n        '$1 Complete $2'\r\n      );\r\n      found = true;\r\n    }\r\n\r\n    if (found) {\r\n      updated.push(reqId);\r\n    } else {\r\n      notFound.push(reqId);\r\n    }\r\n  }\r\n\r\n  if (updated.length > 0) {\r\n    fs.writeFileSync(reqPath, reqContent, 'utf-8');\r\n  }\r\n\r\n  const result: ArchiveResult = {\r\n    updated: updated.length > 0,\r\n    marked_complete: updated,\r\n    not_found: notFound,\r\n    total: reqIds.length,\r\n  };\r\n\r\n  output(result, raw, `${updated.length}/${reqIds.length} requirements marked complete`);\r\n}\r\n\r\n// ─── Milestone commands ──────────────────────────────────────────────────────\r\n\r\nexport function cmdMilestoneComplete(\r\n  cwd: string,\r\n  version: string | undefined,\r\n  options: MilestoneCompleteOptions,\r\n  raw: boolean,\r\n): void {\r\n  if (!version) {\r\n    error('version required for milestone complete (e.g., v1.0)');\r\n  }\r\n\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  const reqPath = path.join(cwd, '.planning', 'REQUIREMENTS.md');\r\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\r\n  const milestonesPath = path.join(cwd, '.planning', 'MILESTONES.md');\r\n  const archiveDir = path.join(cwd, '.planning', 'milestones');\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const milestoneName = options.name || version;\r\n\r\n  fs.mkdirSync(archiveDir, { recursive: true });\r\n\r\n  let phaseCount = 0;\r\n  let totalPlans = 0;\r\n  let totalTasks = 0;\r\n  const accomplishments: string[] = [];\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort();\r\n\r\n    for (const dir of dirs) {\r\n      phaseCount++;\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n      const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md');\r\n      const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n      totalPlans += plans.length;\r\n\r\n      for (const s of summaries) {\r\n        try {\r\n          const content = fs.readFileSync(path.join(phasesDir, dir, s), 'utf-8');\r\n          const fm = extractFrontmatter(content);\r\n          if (fm['one-liner']) {\r\n            accomplishments.push(String(fm['one-liner']));\r\n          }\r\n          const taskMatches = content.match(/##\\s*Task\\s*\\d+/gi) || [];\r\n          totalTasks += taskMatches.length;\r\n        } catch (e) {\r\n          /* optional op, ignore */\r\n          if (process.env.MAXSIM_DEBUG) console.error(e);\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  // Archive ROADMAP.md\r\n  if (fs.existsSync(roadmapPath)) {\r\n    const roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\r\n    fs.writeFileSync(path.join(archiveDir, `${version}-ROADMAP.md`), roadmapContent, 'utf-8');\r\n  }\r\n\r\n  // Archive REQUIREMENTS.md\r\n  if (fs.existsSync(reqPath)) {\r\n    const reqContent = fs.readFileSync(reqPath, 'utf-8');\r\n    const archiveHeader = `# Requirements Archive: ${version} ${milestoneName}\\n\\n**Archived:** ${today}\\n**Status:** SHIPPED\\n\\nFor current requirements, see \\`.planning/REQUIREMENTS.md\\`.\\n\\n---\\n\\n`;\r\n    fs.writeFileSync(path.join(archiveDir, `${version}-REQUIREMENTS.md`), archiveHeader + reqContent, 'utf-8');\r\n  }\r\n\r\n  // Archive audit file if exists\r\n  const auditFile = path.join(cwd, '.planning', `${version}-MILESTONE-AUDIT.md`);\r\n  if (fs.existsSync(auditFile)) {\r\n    fs.renameSync(auditFile, path.join(archiveDir, `${version}-MILESTONE-AUDIT.md`));\r\n  }\r\n\r\n  // Create/append MILESTONES.md entry\r\n  const accomplishmentsList = accomplishments.map(a => `- ${a}`).join('\\n');\r\n  const milestoneEntry = `## ${version} ${milestoneName} (Shipped: ${today})\\n\\n**Phases completed:** ${phaseCount} phases, ${totalPlans} plans, ${totalTasks} tasks\\n\\n**Key accomplishments:**\\n${accomplishmentsList || '- (none recorded)'}\\n\\n---\\n\\n`;\r\n\r\n  if (fs.existsSync(milestonesPath)) {\r\n    const existing = fs.readFileSync(milestonesPath, 'utf-8');\r\n    fs.writeFileSync(milestonesPath, existing + '\\n' + milestoneEntry, 'utf-8');\r\n  } else {\r\n    fs.writeFileSync(milestonesPath, `# Milestones\\n\\n${milestoneEntry}`, 'utf-8');\r\n  }\r\n\r\n  // Update STATE.md\r\n  if (fs.existsSync(statePath)) {\r\n    let stateContent = fs.readFileSync(statePath, 'utf-8');\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Status:\\*\\*\\s*).*/,\r\n      `$1${version} milestone complete`\r\n    );\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity:\\*\\*\\s*).*/,\r\n      `$1${today}`\r\n    );\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity Description:\\*\\*\\s*).*/,\r\n      `$1${version} milestone completed and archived`\r\n    );\r\n    fs.writeFileSync(statePath, stateContent, 'utf-8');\r\n  }\r\n\r\n  // Archive phase directories if requested\r\n  let phasesArchived = false;\r\n  if (options.archivePhases) {\r\n    try {\r\n      const phaseArchiveDir = path.join(archiveDir, `${version}-phases`);\r\n      fs.mkdirSync(phaseArchiveDir, { recursive: true });\r\n\r\n      const phaseEntries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n      const phaseDirNames = phaseEntries.filter(e => e.isDirectory()).map(e => e.name);\r\n      for (const dir of phaseDirNames) {\r\n        fs.renameSync(path.join(phasesDir, dir), path.join(phaseArchiveDir, dir));\r\n      }\r\n      phasesArchived = phaseDirNames.length > 0;\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n  }\r\n\r\n  const result: MilestoneResult = {\r\n    version,\r\n    name: milestoneName,\r\n    date: today,\r\n    phases: phaseCount,\r\n    plans: totalPlans,\r\n    tasks: totalTasks,\r\n    accomplishments,\r\n    archived: {\r\n      roadmap: fs.existsSync(path.join(archiveDir, `${version}-ROADMAP.md`)),\r\n      requirements: fs.existsSync(path.join(archiveDir, `${version}-REQUIREMENTS.md`)),\r\n      audit: fs.existsSync(path.join(archiveDir, `${version}-MILESTONE-AUDIT.md`)),\r\n      phases: phasesArchived,\r\n    },\r\n    milestones_updated: true,\r\n    state_updated: fs.existsSync(statePath),\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n","/**\r\n * Commands — Standalone utility commands\r\n *\r\n * Ported from maxsim/bin/lib/commands.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport chalk from 'chalk';\r\nimport {\r\n  safeReadFile,\r\n  loadConfig,\r\n  isGitIgnored,\r\n  execGit,\r\n  normalizePhaseName,\r\n  getArchivedPhaseDirs,\r\n  generateSlugInternal,\r\n  getMilestoneInfo,\r\n  resolveModelInternal,\r\n  MODEL_PROFILES,\r\n  output,\r\n  error,\r\n  findPhaseInternal,\r\n} from './core.js';\r\nimport { extractFrontmatter } from './frontmatter.js';\r\nimport type {\r\n  TodoItem,\r\n  HistoryDigest,\r\n  HistoryPhaseDigest,\r\n  WebSearchOptions,\r\n  WebSearchResult,\r\n  ScaffoldOptions,\r\n  TimestampFormat,\r\n  ModelProfileName,\r\n  AgentType,\r\n  FrontmatterData,\r\n} from './types.js';\r\n\r\n// ─── Slug generation ────────────────────────────────────────────────────────\r\n\r\nexport function cmdGenerateSlug(text: string | undefined, raw: boolean): void {\r\n  if (!text) {\r\n    error('text required for slug generation');\r\n  }\r\n\r\n  const slug = text\r\n    .toLowerCase()\r\n    .replace(/[^a-z0-9]+/g, '-')\r\n    .replace(/^-+|-+$/g, '');\r\n\r\n  const result = { slug };\r\n  output(result, raw, slug);\r\n}\r\n\r\n// ─── Timestamp ──────────────────────────────────────────────────────────────\r\n\r\nexport function cmdCurrentTimestamp(format: TimestampFormat, raw: boolean): void {\r\n  const now = new Date();\r\n  let result: string;\r\n\r\n  switch (format) {\r\n    case 'date':\r\n      result = now.toISOString().split('T')[0];\r\n      break;\r\n    case 'filename':\r\n      result = now.toISOString().replace(/:/g, '-').replace(/\\..+/, '');\r\n      break;\r\n    case 'full':\r\n    default:\r\n      result = now.toISOString();\r\n      break;\r\n  }\r\n\r\n  output({ timestamp: result }, raw, result);\r\n}\r\n\r\n// ─── Todos ──────────────────────────────────────────────────────────────────\r\n\r\nexport function cmdListTodos(cwd: string, area: string | undefined, raw: boolean): void {\r\n  const pendingDir = path.join(cwd, '.planning', 'todos', 'pending');\r\n\r\n  let count = 0;\r\n  const todos: TodoItem[] = [];\r\n\r\n  try {\r\n    const files = fs.readdirSync(pendingDir).filter(f => f.endsWith('.md'));\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const content = fs.readFileSync(path.join(pendingDir, file), 'utf-8');\r\n        const createdMatch = content.match(/^created:\\s*(.+)$/m);\r\n        const titleMatch = content.match(/^title:\\s*(.+)$/m);\r\n        const areaMatch = content.match(/^area:\\s*(.+)$/m);\r\n\r\n        const todoArea = areaMatch ? areaMatch[1].trim() : 'general';\r\n\r\n        // Apply area filter if specified\r\n        if (area && todoArea !== area) continue;\r\n\r\n        count++;\r\n        todos.push({\r\n          file,\r\n          created: createdMatch ? createdMatch[1].trim() : 'unknown',\r\n          title: titleMatch ? titleMatch[1].trim() : 'Untitled',\r\n          area: todoArea,\r\n          path: path.join('.planning', 'todos', 'pending', file),\r\n        });\r\n      } catch (e) {\r\n        /* optional op, ignore */\r\n        if (process.env.MAXSIM_DEBUG) console.error(e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result = { count, todos };\r\n  output(result, raw, count.toString());\r\n}\r\n\r\n// ─── Path verification ──────────────────────────────────────────────────────\r\n\r\nexport function cmdVerifyPathExists(cwd: string, targetPath: string | undefined, raw: boolean): void {\r\n  if (!targetPath) {\r\n    error('path required for verification');\r\n  }\r\n\r\n  const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);\r\n\r\n  try {\r\n    const stats = fs.statSync(fullPath);\r\n    const type = stats.isDirectory() ? 'directory' : stats.isFile() ? 'file' : 'other';\r\n    const result = { exists: true, type };\r\n    output(result, raw, 'true');\r\n  } catch {\r\n    const result = { exists: false, type: null };\r\n    output(result, raw, 'false');\r\n  }\r\n}\r\n\r\n// ─── History digest ─────────────────────────────────────────────────────────\r\n\r\nexport function cmdHistoryDigest(cwd: string, raw: boolean): void {\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const digest: {\r\n    phases: Record<string, { name: string; provides: Set<string>; affects: Set<string>; patterns: Set<string> }>;\r\n    decisions: Array<{ phase: string; decision: string }>;\r\n    tech_stack: Set<string> | string[];\r\n  } = { phases: {}, decisions: [], tech_stack: new Set<string>() };\r\n\r\n  // Collect all phase directories: archived + current\r\n  const allPhaseDirs: Array<{ name: string; fullPath: string; milestone: string | null }> = [];\r\n\r\n  // Add archived phases first (oldest milestones first)\r\n  const archived = getArchivedPhaseDirs(cwd);\r\n  for (const a of archived) {\r\n    allPhaseDirs.push({ name: a.name, fullPath: a.fullPath, milestone: a.milestone });\r\n  }\r\n\r\n  // Add current phases\r\n  if (fs.existsSync(phasesDir)) {\r\n    try {\r\n      const currentDirs = fs.readdirSync(phasesDir, { withFileTypes: true })\r\n        .filter(e => e.isDirectory())\r\n        .map(e => e.name)\r\n        .sort();\r\n      for (const dir of currentDirs) {\r\n        allPhaseDirs.push({ name: dir, fullPath: path.join(phasesDir, dir), milestone: null });\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n  }\r\n\r\n  if (allPhaseDirs.length === 0) {\r\n    const emptyDigest: HistoryDigest = { phases: {}, decisions: [], tech_stack: [] };\r\n    output(emptyDigest, raw);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    for (const { name: dir, fullPath: dirPath } of allPhaseDirs) {\r\n      const summaries = fs.readdirSync(dirPath).filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n\r\n      for (const summary of summaries) {\r\n        try {\r\n          const content = fs.readFileSync(path.join(dirPath, summary), 'utf-8');\r\n          const fm = extractFrontmatter(content);\r\n\r\n          const phaseNum = (fm.phase as string) || dir.split('-')[0];\r\n\r\n          if (!digest.phases[phaseNum]) {\r\n            digest.phases[phaseNum] = {\r\n              name: (fm.name as string) || dir.split('-').slice(1).join(' ') || 'Unknown',\r\n              provides: new Set<string>(),\r\n              affects: new Set<string>(),\r\n              patterns: new Set<string>(),\r\n            };\r\n          }\r\n\r\n          // Merge provides\r\n          const depGraph = fm['dependency-graph'] as FrontmatterData | undefined;\r\n          if (depGraph && depGraph.provides) {\r\n            (depGraph.provides as string[]).forEach(p => digest.phases[phaseNum].provides.add(p));\r\n          } else if (fm.provides) {\r\n            (fm.provides as string[]).forEach(p => digest.phases[phaseNum].provides.add(p));\r\n          }\r\n\r\n          // Merge affects\r\n          if (depGraph && depGraph.affects) {\r\n            (depGraph.affects as string[]).forEach(a => digest.phases[phaseNum].affects.add(a));\r\n          }\r\n\r\n          // Merge patterns\r\n          if (fm['patterns-established']) {\r\n            (fm['patterns-established'] as string[]).forEach(p => digest.phases[phaseNum].patterns.add(p));\r\n          }\r\n\r\n          // Merge decisions\r\n          if (fm['key-decisions']) {\r\n            (fm['key-decisions'] as string[]).forEach(d => {\r\n              digest.decisions.push({ phase: phaseNum, decision: d });\r\n            });\r\n          }\r\n\r\n          // Merge tech stack\r\n          const techStack = fm['tech-stack'] as FrontmatterData | undefined;\r\n          if (techStack && techStack.added) {\r\n            (techStack.added as Array<string | FrontmatterData>).forEach(t =>\r\n              (digest.tech_stack as Set<string>).add(typeof t === 'string' ? t : (t as FrontmatterData).name as string)\r\n            );\r\n          }\r\n        } catch (e) {\r\n          /* optional op, ignore */\r\n          if (process.env.MAXSIM_DEBUG) console.error(e);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Convert Sets to Arrays for JSON output\r\n    const outputDigest: HistoryDigest = {\r\n      phases: {},\r\n      decisions: digest.decisions,\r\n      tech_stack: [...(digest.tech_stack as Set<string>)],\r\n    };\r\n    for (const [p, data] of Object.entries(digest.phases)) {\r\n      outputDigest.phases[p] = {\r\n        name: data.name,\r\n        provides: [...data.provides],\r\n        affects: [...data.affects],\r\n        patterns: [...data.patterns],\r\n      };\r\n    }\r\n\r\n    output(outputDigest, raw);\r\n  } catch (e: unknown) {\r\n    error('Failed to generate history digest: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n// ─── Model resolution ───────────────────────────────────────────────────────\r\n\r\nexport function cmdResolveModel(cwd: string, agentType: string | undefined, raw: boolean): void {\r\n  if (!agentType) {\r\n    error('agent-type required');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n  const profile: ModelProfileName = config.model_profile || 'balanced';\r\n\r\n  const agentModels = MODEL_PROFILES[agentType as AgentType];\r\n  if (!agentModels) {\r\n    const result = { model: 'sonnet', profile, unknown_agent: true };\r\n    output(result, raw, 'sonnet');\r\n    return;\r\n  }\r\n\r\n  const resolved = agentModels[profile] || agentModels['balanced'] || 'sonnet';\r\n  const model = resolved === 'opus' ? 'inherit' : resolved;\r\n  const result = { model, profile };\r\n  output(result, raw, model);\r\n}\r\n\r\n// ─── Commit ─────────────────────────────────────────────────────────────────\r\n\r\nexport function cmdCommit(\r\n  cwd: string,\r\n  message: string | undefined,\r\n  files: string[],\r\n  raw: boolean,\r\n  amend: boolean,\r\n): void {\r\n  if (!message && !amend) {\r\n    error('commit message required');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n\r\n  // Check commit_docs config\r\n  if (!config.commit_docs) {\r\n    const result = { committed: false, hash: null, reason: 'skipped_commit_docs_false' };\r\n    output(result, raw, 'skipped');\r\n    return;\r\n  }\r\n\r\n  // Check if .planning is gitignored\r\n  if (isGitIgnored(cwd, '.planning')) {\r\n    const result = { committed: false, hash: null, reason: 'skipped_gitignored' };\r\n    output(result, raw, 'skipped');\r\n    return;\r\n  }\r\n\r\n  // Stage files\r\n  const filesToStage = files && files.length > 0 ? files : ['.planning/'];\r\n  for (const file of filesToStage) {\r\n    execGit(cwd, ['add', file]);\r\n  }\r\n\r\n  // Commit\r\n  const commitArgs = amend ? ['commit', '--amend', '--no-edit'] : ['commit', '-m', message!];\r\n  const commitResult = execGit(cwd, commitArgs);\r\n  if (commitResult.exitCode !== 0) {\r\n    if (commitResult.stdout.includes('nothing to commit') || commitResult.stderr.includes('nothing to commit')) {\r\n      const result = { committed: false, hash: null, reason: 'nothing_to_commit' };\r\n      output(result, raw, 'nothing');\r\n      return;\r\n    }\r\n    const result = { committed: false, hash: null, reason: 'nothing_to_commit', error: commitResult.stderr };\r\n    output(result, raw, 'nothing');\r\n    return;\r\n  }\r\n\r\n  // Get short hash\r\n  const hashResult = execGit(cwd, ['rev-parse', '--short', 'HEAD']);\r\n  const hash = hashResult.exitCode === 0 ? hashResult.stdout : null;\r\n  const result = { committed: true, hash, reason: 'committed' };\r\n  output(result, raw, hash || 'committed');\r\n}\r\n\r\n// ─── Summary extract ────────────────────────────────────────────────────────\r\n\r\nexport function cmdSummaryExtract(\r\n  cwd: string,\r\n  summaryPath: string | undefined,\r\n  fields: string[] | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!summaryPath) {\r\n    error('summary-path required for summary-extract');\r\n  }\r\n\r\n  const fullPath = path.join(cwd, summaryPath);\r\n\r\n  if (!fs.existsSync(fullPath)) {\r\n    output({ error: 'File not found', path: summaryPath }, raw);\r\n    return;\r\n  }\r\n\r\n  const content = fs.readFileSync(fullPath, 'utf-8');\r\n  const fm = extractFrontmatter(content);\r\n\r\n  // Parse key-decisions into structured format\r\n  const parseDecisions = (decisionsList: unknown): Array<{ summary: string; rationale: string | null }> => {\r\n    if (!decisionsList || !Array.isArray(decisionsList)) return [];\r\n    return decisionsList.map((d: string) => {\r\n      const colonIdx = d.indexOf(':');\r\n      if (colonIdx > 0) {\r\n        return {\r\n          summary: d.substring(0, colonIdx).trim(),\r\n          rationale: d.substring(colonIdx + 1).trim(),\r\n        };\r\n      }\r\n      return { summary: d, rationale: null };\r\n    });\r\n  };\r\n\r\n  const techStack = fm['tech-stack'] as FrontmatterData | undefined;\r\n\r\n  // Build full result\r\n  const fullResult: Record<string, unknown> = {\r\n    path: summaryPath,\r\n    one_liner: fm['one-liner'] || null,\r\n    key_files: fm['key-files'] || [],\r\n    tech_added: (techStack && techStack.added) || [],\r\n    patterns: fm['patterns-established'] || [],\r\n    decisions: parseDecisions(fm['key-decisions']),\r\n    requirements_completed: fm['requirements-completed'] || [],\r\n  };\r\n\r\n  // If fields specified, filter to only those fields\r\n  if (fields && fields.length > 0) {\r\n    const filtered: Record<string, unknown> = { path: summaryPath };\r\n    for (const field of fields) {\r\n      if (fullResult[field] !== undefined) {\r\n        filtered[field] = fullResult[field];\r\n      }\r\n    }\r\n    output(filtered, raw);\r\n    return;\r\n  }\r\n\r\n  output(fullResult, raw);\r\n}\r\n\r\n// ─── Web search ─────────────────────────────────────────────────────────────\r\n\r\nexport async function cmdWebsearch(\r\n  query: string | undefined,\r\n  options: WebSearchOptions,\r\n  raw: boolean,\r\n): Promise<void> {\r\n  const apiKey = process.env.BRAVE_API_KEY;\r\n\r\n  if (!apiKey) {\r\n    output({ available: false, reason: 'BRAVE_API_KEY not set' }, raw, '');\r\n    return;\r\n  }\r\n\r\n  if (!query) {\r\n    output({ available: false, error: 'Query required' }, raw, '');\r\n    return;\r\n  }\r\n\r\n  const params = new URLSearchParams({\r\n    q: query,\r\n    count: String(options.limit || 10),\r\n    country: 'us',\r\n    search_lang: 'en',\r\n    text_decorations: 'false',\r\n  });\r\n\r\n  if (options.freshness) {\r\n    params.set('freshness', options.freshness);\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `https://api.search.brave.com/res/v1/web/search?${params}`,\r\n      {\r\n        headers: {\r\n          Accept: 'application/json',\r\n          'X-Subscription-Token': apiKey,\r\n        },\r\n      },\r\n    );\r\n\r\n    if (!response.ok) {\r\n      output({ available: false, error: `API error: ${response.status}` }, raw, '');\r\n      return;\r\n    }\r\n\r\n    const data = (await response.json()) as { web?: { results?: Array<{ title: string; url: string; description: string; age?: string }> } };\r\n\r\n    const results: WebSearchResult[] = (data.web?.results || []).map(r => ({\r\n      title: r.title,\r\n      url: r.url,\r\n      description: r.description,\r\n      age: r.age || null,\r\n    }));\r\n\r\n    output(\r\n      {\r\n        available: true,\r\n        query,\r\n        count: results.length,\r\n        results,\r\n      },\r\n      raw,\r\n      results.map(r => `${r.title}\\n${r.url}\\n${r.description}`).join('\\n\\n'),\r\n    );\r\n  } catch (err: unknown) {\r\n    output({ available: false, error: (err as Error).message }, raw, '');\r\n  }\r\n}\r\n\r\n// ─── Progress render ────────────────────────────────────────────────────────\r\n\r\nexport function cmdProgressRender(cwd: string, format: string, raw: boolean): void {\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const milestone = getMilestoneInfo(cwd);\r\n\r\n  const phases: Array<{ number: string; name: string; plans: number; summaries: number; status: string }> = [];\r\n  let totalPlans = 0;\r\n  let totalSummaries = 0;\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries\r\n      .filter(e => e.isDirectory())\r\n      .map(e => e.name)\r\n      .sort((a, b) => {\r\n        const aNum = parseFloat(a.match(/^(\\d+(?:\\.\\d+)?)/)?.[1] || '0');\r\n        const bNum = parseFloat(b.match(/^(\\d+(?:\\.\\d+)?)/)?.[1] || '0');\r\n        return aNum - bNum;\r\n      });\r\n\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(/^(\\d+(?:\\.\\d+)?)-?(.*)/);\r\n      const phaseNum = dm ? dm[1] : dir;\r\n      const phaseName = dm && dm[2] ? dm[2].replace(/-/g, ' ') : '';\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n      const planCount = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md').length;\r\n      const summaryCount = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md').length;\r\n\r\n      totalPlans += planCount;\r\n      totalSummaries += summaryCount;\r\n\r\n      let status: string;\r\n      if (planCount === 0) status = 'Pending';\r\n      else if (summaryCount >= planCount) status = 'Complete';\r\n      else if (summaryCount > 0) status = 'In Progress';\r\n      else status = 'Planned';\r\n\r\n      phases.push({ number: phaseNum, name: phaseName, plans: planCount, summaries: summaryCount, status });\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const percent = totalPlans > 0 ? Math.min(100, Math.round((totalSummaries / totalPlans) * 100)) : 0;\r\n\r\n  if (format === 'table') {\r\n    const barWidth = 10;\r\n    const filled = Math.round((percent / 100) * barWidth);\r\n    const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n    let out = `# ${milestone.version} ${milestone.name}\\n\\n`;\r\n    out += `**Progress:** [${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)\\n\\n`;\r\n    out += `| Phase | Name | Plans | Status |\\n`;\r\n    out += `|-------|------|-------|--------|\\n`;\r\n    for (const p of phases) {\r\n      out += `| ${p.number} | ${p.name} | ${p.summaries}/${p.plans} | ${p.status} |\\n`;\r\n    }\r\n    output({ rendered: out }, raw, out);\r\n  } else if (format === 'bar') {\r\n    const barWidth = 20;\r\n    const filled = Math.round((percent / 100) * barWidth);\r\n    const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n    const text = `[${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)`;\r\n    output({ bar: text, percent, completed: totalSummaries, total: totalPlans }, raw, text);\r\n  } else if (format === 'phase-bars') {\r\n    const doneCount = phases.filter(p => p.status === 'Complete').length;\r\n    const inProgressCount = phases.filter(p => p.status === 'In Progress').length;\r\n    const totalCount = phases.length;\r\n    const header = chalk.bold(\r\n      `Milestone: ${milestone.name} — ${doneCount}/${totalCount} phases complete (${percent}%)`\r\n    );\r\n    const lines: string[] = [header, ''];\r\n\r\n    for (const p of phases) {\r\n      const pPercent =\r\n        p.plans > 0 ? Math.min(100, Math.round((p.summaries / p.plans) * 100)) : 0;\r\n      const barWidth = 10;\r\n      const filled = Math.round((pPercent / 100) * barWidth);\r\n      const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n      const phaseLabel = `Phase ${p.number.padStart(2, '0')}`;\r\n      const statusLabel =\r\n        p.status === 'Complete'\r\n          ? 'DONE'\r\n          : p.status === 'In Progress'\r\n          ? 'IN PROGRESS'\r\n          : 'PLANNED';\r\n\r\n      let line = `${phaseLabel} [${bar}] ${String(pPercent).padStart(3, ' ')}% — ${statusLabel}`;\r\n      if (p.status === 'Complete') line = chalk.green(line);\r\n      else if (p.status === 'In Progress') line = chalk.yellow(line);\r\n      else line = chalk.dim(line);\r\n\r\n      lines.push(line);\r\n    }\r\n\r\n    const rendered = lines.join('\\n');\r\n    output({ rendered, done: doneCount, in_progress: inProgressCount, total: totalCount, percent }, raw, rendered);\r\n  } else {\r\n    output({\r\n      milestone_version: milestone.version,\r\n      milestone_name: milestone.name,\r\n      phases,\r\n      total_plans: totalPlans,\r\n      total_summaries: totalSummaries,\r\n      percent,\r\n    }, raw);\r\n  }\r\n}\r\n\r\n// ─── Todo complete ──────────────────────────────────────────────────────────\r\n\r\nexport function cmdTodoComplete(cwd: string, filename: string | undefined, raw: boolean): void {\r\n  if (!filename) {\r\n    error('filename required for todo complete');\r\n  }\r\n\r\n  const pendingDir = path.join(cwd, '.planning', 'todos', 'pending');\r\n  const completedDir = path.join(cwd, '.planning', 'todos', 'completed');\r\n  const sourcePath = path.join(pendingDir, filename);\r\n\r\n  if (!fs.existsSync(sourcePath)) {\r\n    error(`Todo not found: ${filename}`);\r\n  }\r\n\r\n  // Ensure completed directory exists\r\n  fs.mkdirSync(completedDir, { recursive: true });\r\n\r\n  // Read, add completion timestamp, move\r\n  let content = fs.readFileSync(sourcePath, 'utf-8');\r\n  const today = new Date().toISOString().split('T')[0];\r\n  content = `completed: ${today}\\n` + content;\r\n\r\n  fs.writeFileSync(path.join(completedDir, filename), content, 'utf-8');\r\n  fs.unlinkSync(sourcePath);\r\n\r\n  output({ completed: true, file: filename, date: today }, raw, 'completed');\r\n}\r\n\r\n// ─── Scaffold ───────────────────────────────────────────────────────────────\r\n\r\nexport function cmdScaffold(\r\n  cwd: string,\r\n  type: string | undefined,\r\n  options: ScaffoldOptions,\r\n  raw: boolean,\r\n): void {\r\n  const { phase, name } = options;\r\n  const padded = phase ? normalizePhaseName(phase) : '00';\r\n  const today = new Date().toISOString().split('T')[0];\r\n\r\n  // Find phase directory\r\n  const phaseInfo = phase ? findPhaseInternal(cwd, phase) : null;\r\n  const phaseDir = phaseInfo ? path.join(cwd, phaseInfo.directory) : null;\r\n\r\n  if (phase && !phaseDir && type !== 'phase-dir') {\r\n    error(`Phase ${phase} directory not found`);\r\n  }\r\n\r\n  let filePath: string;\r\n  let content: string;\r\n\r\n  switch (type) {\r\n    case 'context': {\r\n      filePath = path.join(phaseDir!, `${padded}-CONTEXT.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'} — Context\\n\\n## Decisions\\n\\n_Decisions will be captured during /maxsim:discuss-phase ${phase}_\\n\\n## Discretion Areas\\n\\n_Areas where the executor can use judgment_\\n\\n## Deferred Ideas\\n\\n_Ideas to consider later_\\n`;\r\n      break;\r\n    }\r\n    case 'uat': {\r\n      filePath = path.join(phaseDir!, `${padded}-UAT.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\nstatus: pending\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'} — User Acceptance Testing\\n\\n## Test Results\\n\\n| # | Test | Status | Notes |\\n|---|------|--------|-------|\\n\\n## Summary\\n\\n_Pending UAT_\\n`;\r\n      break;\r\n    }\r\n    case 'verification': {\r\n      filePath = path.join(phaseDir!, `${padded}-VERIFICATION.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\nstatus: pending\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'} — Verification\\n\\n## Goal-Backward Verification\\n\\n**Phase Goal:** [From ROADMAP.md]\\n\\n## Checks\\n\\n| # | Requirement | Status | Evidence |\\n|---|------------|--------|----------|\\n\\n## Result\\n\\n_Pending verification_\\n`;\r\n      break;\r\n    }\r\n    case 'phase-dir': {\r\n      if (!phase || !name) {\r\n        error('phase and name required for phase-dir scaffold');\r\n      }\r\n      const slug = generateSlugInternal(name);\r\n      const dirName = `${padded}-${slug}`;\r\n      const phasesParent = path.join(cwd, '.planning', 'phases');\r\n      fs.mkdirSync(phasesParent, { recursive: true });\r\n      const dirPath = path.join(phasesParent, dirName);\r\n      fs.mkdirSync(dirPath, { recursive: true });\r\n      output({ created: true, directory: `.planning/phases/${dirName}`, path: dirPath }, raw, dirPath);\r\n      return;\r\n    }\r\n    default:\r\n      error(`Unknown scaffold type: ${type}. Available: context, uat, verification, phase-dir`);\r\n      return; // unreachable but satisfies TS\r\n  }\r\n\r\n  if (fs.existsSync(filePath)) {\r\n    output({ created: false, reason: 'already_exists', path: filePath }, raw, 'exists');\r\n    return;\r\n  }\r\n\r\n  fs.writeFileSync(filePath, content, 'utf-8');\r\n  const relPath = path.relative(cwd, filePath);\r\n  output({ created: true, path: relPath }, raw, relPath);\r\n}\r\n","/**\r\n * Verify — Verification suite, consistency, and health validation\r\n *\r\n * Ported from maxsim/bin/lib/verify.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport {\r\n  safeReadFile,\r\n  normalizePhaseName,\r\n  getPhasePattern,\r\n  execGit,\r\n  findPhaseInternal,\r\n  getMilestoneInfo,\r\n  output,\r\n  error,\r\n} from './core.js';\r\nimport { extractFrontmatter, parseMustHavesBlock } from './frontmatter.js';\r\nimport type { FrontmatterData } from './types.js';\r\n\r\n// ─── Interfaces ──────────────────────────────────────────────────────────────\r\n\r\nexport interface ValidationError {\r\n  code?: string;\r\n  message: string;\r\n  fix?: string;\r\n  repairable?: boolean;\r\n}\r\n\r\nexport interface ValidationWarning {\r\n  code?: string;\r\n  message: string;\r\n  fix?: string;\r\n  repairable?: boolean;\r\n}\r\n\r\nexport interface TaskInfo {\r\n  name: string;\r\n  hasFiles: boolean;\r\n  hasAction: boolean;\r\n  hasVerify: boolean;\r\n  hasDone: boolean;\r\n}\r\n\r\nexport interface VerificationResult {\r\n  passed: boolean;\r\n  checks: {\r\n    summary_exists: boolean;\r\n    files_created: { checked: number; found: number; missing: string[] };\r\n    commits_exist: boolean;\r\n    self_check: 'not_found' | 'passed' | 'failed';\r\n  };\r\n  errors: string[];\r\n}\r\n\r\nexport interface PlanStructureResult {\r\n  valid: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n  task_count: number;\r\n  tasks: TaskInfo[];\r\n  frontmatter_fields: string[];\r\n}\r\n\r\nexport interface PhaseCompletenessResult {\r\n  complete: boolean;\r\n  phase: string;\r\n  plan_count: number;\r\n  summary_count: number;\r\n  incomplete_plans: string[];\r\n  orphan_summaries: string[];\r\n  errors: string[];\r\n  warnings: string[];\r\n}\r\n\r\nexport interface ReferencesResult {\r\n  valid: boolean;\r\n  found: number;\r\n  missing: string[];\r\n  total: number;\r\n}\r\n\r\nexport interface CommitsResult {\r\n  all_valid: boolean;\r\n  valid: string[];\r\n  invalid: string[];\r\n  total: number;\r\n}\r\n\r\nexport interface ArtifactCheck {\r\n  path: string;\r\n  exists: boolean;\r\n  issues: string[];\r\n  passed: boolean;\r\n}\r\n\r\nexport interface ArtifactsResult {\r\n  all_passed: boolean;\r\n  passed: number;\r\n  total: number;\r\n  artifacts: ArtifactCheck[];\r\n}\r\n\r\nexport interface KeyLinkCheck {\r\n  from: string;\r\n  to: string;\r\n  via: string;\r\n  verified: boolean;\r\n  detail: string;\r\n}\r\n\r\nexport interface KeyLinksResult {\r\n  all_verified: boolean;\r\n  verified: number;\r\n  total: number;\r\n  links: KeyLinkCheck[];\r\n}\r\n\r\nexport interface ConsistencyResult {\r\n  passed: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n  warning_count: number;\r\n}\r\n\r\nexport interface HealthResult {\r\n  status: 'healthy' | 'degraded' | 'broken';\r\n  errors: ValidationError[];\r\n  warnings: ValidationWarning[];\r\n  info: ValidationError[];\r\n  repairable_count: number;\r\n  repairs_performed?: RepairAction[];\r\n}\r\n\r\ninterface RepairAction {\r\n  action: string;\r\n  success: boolean;\r\n  path?: string;\r\n  error?: string;\r\n}\r\n\r\ninterface HealthOptions {\r\n  repair?: boolean;\r\n}\r\n\r\n// ─── Verify Summary ──────────────────────────────────────────────────────────\r\n\r\nexport function cmdVerifySummary(\r\n  cwd: string,\r\n  summaryPath: string | null,\r\n  checkFileCount: number | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!summaryPath) {\r\n    error('summary-path required');\r\n  }\r\n\r\n  const fullPath = path.join(cwd, summaryPath);\r\n  const checkCount = checkFileCount || 2;\r\n\r\n  if (!fs.existsSync(fullPath)) {\r\n    const result: VerificationResult = {\r\n      passed: false,\r\n      checks: {\r\n        summary_exists: false,\r\n        files_created: { checked: 0, found: 0, missing: [] },\r\n        commits_exist: false,\r\n        self_check: 'not_found',\r\n      },\r\n      errors: ['SUMMARY.md not found'],\r\n    };\r\n    output(result, raw, 'failed');\r\n    return;\r\n  }\r\n\r\n  const content = fs.readFileSync(fullPath, 'utf-8');\r\n  const errors: string[] = [];\r\n\r\n  // Spot-check files mentioned in summary\r\n  const mentionedFiles = new Set<string>();\r\n  const patterns: RegExp[] = [\r\n    /`([^`]+\\.[a-zA-Z]+)`/g,\r\n    /(?:Created|Modified|Added|Updated|Edited):\\s*`?([^\\s`]+\\.[a-zA-Z]+)`?/gi,\r\n  ];\r\n\r\n  for (const pattern of patterns) {\r\n    let m: RegExpExecArray | null;\r\n    while ((m = pattern.exec(content)) !== null) {\r\n      const filePath = m[1];\r\n      if (filePath && !filePath.startsWith('http') && filePath.includes('/')) {\r\n        mentionedFiles.add(filePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  const filesToCheck = Array.from(mentionedFiles).slice(0, checkCount);\r\n  const missing: string[] = [];\r\n  for (const file of filesToCheck) {\r\n    if (!fs.existsSync(path.join(cwd, file))) {\r\n      missing.push(file);\r\n    }\r\n  }\r\n\r\n  // Check commits exist\r\n  const commitHashPattern = /\\b[0-9a-f]{7,40}\\b/g;\r\n  const hashes = content.match(commitHashPattern) || [];\r\n  let commitsExist = false;\r\n  if (hashes.length > 0) {\r\n    for (const hash of hashes.slice(0, 3)) {\r\n      const result = execGit(cwd, ['cat-file', '-t', hash]);\r\n      if (result.exitCode === 0 && result.stdout === 'commit') {\r\n        commitsExist = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Self-check section\r\n  let selfCheck: 'not_found' | 'passed' | 'failed' = 'not_found';\r\n  const selfCheckPattern = /##\\s*(?:Self[- ]?Check|Verification|Quality Check)/i;\r\n  if (selfCheckPattern.test(content)) {\r\n    const passPattern = /(?:all\\s+)?(?:pass|✓|✅|complete|succeeded)/i;\r\n    const failPattern = /(?:fail|✗|❌|incomplete|blocked)/i;\r\n    const checkSection = content.slice(content.search(selfCheckPattern));\r\n    if (failPattern.test(checkSection)) {\r\n      selfCheck = 'failed';\r\n    } else if (passPattern.test(checkSection)) {\r\n      selfCheck = 'passed';\r\n    }\r\n  }\r\n\r\n  if (missing.length > 0) errors.push('Missing files: ' + missing.join(', '));\r\n  if (!commitsExist && hashes.length > 0) errors.push('Referenced commit hashes not found in git history');\r\n  if (selfCheck === 'failed') errors.push('Self-check section indicates failure');\r\n\r\n  const checks = {\r\n    summary_exists: true,\r\n    files_created: { checked: filesToCheck.length, found: filesToCheck.length - missing.length, missing },\r\n    commits_exist: commitsExist,\r\n    self_check: selfCheck,\r\n  };\r\n\r\n  const passed = missing.length === 0 && selfCheck !== 'failed';\r\n  const result: VerificationResult = { passed, checks, errors };\r\n  output(result, raw, passed ? 'passed' : 'failed');\r\n}\r\n\r\n// ─── Verify Plan Structure ───────────────────────────────────────────────────\r\n\r\nexport function cmdVerifyPlanStructure(cwd: string, filePath: string | null, raw: boolean): void {\r\n  if (!filePath) {\r\n    error('file path required');\r\n  }\r\n  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const fm = extractFrontmatter(content);\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n\r\n  const required = ['phase', 'plan', 'type', 'wave', 'depends_on', 'files_modified', 'autonomous', 'must_haves'];\r\n  for (const field of required) {\r\n    if (fm[field] === undefined) errors.push(`Missing required frontmatter field: ${field}`);\r\n  }\r\n\r\n  const taskPattern = /<task[^>]*>([\\s\\S]*?)<\\/task>/g;\r\n  const tasks: TaskInfo[] = [];\r\n  let taskMatch: RegExpExecArray | null;\r\n  while ((taskMatch = taskPattern.exec(content)) !== null) {\r\n    const taskContent = taskMatch[1];\r\n    const nameMatch = taskContent.match(/<name>([\\s\\S]*?)<\\/name>/);\r\n    const taskName = nameMatch ? nameMatch[1].trim() : 'unnamed';\r\n    const hasFiles = /<files>/.test(taskContent);\r\n    const hasAction = /<action>/.test(taskContent);\r\n    const hasVerify = /<verify>/.test(taskContent);\r\n    const hasDone = /<done>/.test(taskContent);\r\n\r\n    if (!nameMatch) errors.push('Task missing <name> element');\r\n    if (!hasAction) errors.push(`Task '${taskName}' missing <action>`);\r\n    if (!hasVerify) warnings.push(`Task '${taskName}' missing <verify>`);\r\n    if (!hasDone) warnings.push(`Task '${taskName}' missing <done>`);\r\n    if (!hasFiles) warnings.push(`Task '${taskName}' missing <files>`);\r\n\r\n    tasks.push({ name: taskName, hasFiles, hasAction, hasVerify, hasDone });\r\n  }\r\n\r\n  if (tasks.length === 0) warnings.push('No <task> elements found');\r\n\r\n  if (fm.wave && parseInt(String(fm.wave)) > 1 && (!fm.depends_on || (Array.isArray(fm.depends_on) && fm.depends_on.length === 0))) {\r\n    warnings.push('Wave > 1 but depends_on is empty');\r\n  }\r\n\r\n  const hasCheckpoints = /<task\\s+type=[\"']?checkpoint/.test(content);\r\n  if (hasCheckpoints && fm.autonomous !== 'false' && fm.autonomous !== false) {\r\n    errors.push('Has checkpoint tasks but autonomous is not false');\r\n  }\r\n\r\n  const result: PlanStructureResult = {\r\n    valid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    task_count: tasks.length,\r\n    tasks,\r\n    frontmatter_fields: Object.keys(fm),\r\n  };\r\n  output(result, raw, errors.length === 0 ? 'valid' : 'invalid');\r\n}\r\n\r\n// ─── Verify Phase Completeness ───────────────────────────────────────────────\r\n\r\nexport function cmdVerifyPhaseCompleteness(cwd: string, phase: string | null, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required');\r\n  }\r\n  const phaseInfo = findPhaseInternal(cwd, phase);\r\n  if (!phaseInfo) {\r\n    output({ error: 'Phase not found', phase }, raw);\r\n    return;\r\n  }\r\n\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n  const phaseDir = path.join(cwd, phaseInfo.directory);\r\n\r\n  let files: string[];\r\n  try {\r\n    files = fs.readdirSync(phaseDir);\r\n  } catch {\r\n    output({ error: 'Cannot read phase directory' }, raw);\r\n    return;\r\n  }\r\n\r\n  const plans = files.filter(f => /-PLAN\\.md$/i.test(f));\r\n  const summaries = files.filter(f => /-SUMMARY\\.md$/i.test(f));\r\n\r\n  const planIds = new Set(plans.map(p => p.replace(/-PLAN\\.md$/i, '')));\r\n  const summaryIds = new Set(summaries.map(s => s.replace(/-SUMMARY\\.md$/i, '')));\r\n\r\n  const incompletePlans = [...planIds].filter(id => !summaryIds.has(id));\r\n  if (incompletePlans.length > 0) {\r\n    errors.push(`Plans without summaries: ${incompletePlans.join(', ')}`);\r\n  }\r\n\r\n  const orphanSummaries = [...summaryIds].filter(id => !planIds.has(id));\r\n  if (orphanSummaries.length > 0) {\r\n    warnings.push(`Summaries without plans: ${orphanSummaries.join(', ')}`);\r\n  }\r\n\r\n  const result: PhaseCompletenessResult = {\r\n    complete: errors.length === 0,\r\n    phase: phaseInfo.phase_number,\r\n    plan_count: plans.length,\r\n    summary_count: summaries.length,\r\n    incomplete_plans: incompletePlans,\r\n    orphan_summaries: orphanSummaries,\r\n    errors,\r\n    warnings,\r\n  };\r\n  output(result, raw, errors.length === 0 ? 'complete' : 'incomplete');\r\n}\r\n\r\n// ─── Verify References ───────────────────────────────────────────────────────\r\n\r\nexport function cmdVerifyReferences(cwd: string, filePath: string | null, raw: boolean): void {\r\n  if (!filePath) {\r\n    error('file path required');\r\n  }\r\n  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const found: string[] = [];\r\n  const missing: string[] = [];\r\n\r\n  const atRefs = content.match(/@([^\\s\\n,)]+\\/[^\\s\\n,)]+)/g) || [];\r\n  for (const ref of atRefs) {\r\n    const cleanRef = ref.slice(1);\r\n    const resolved = cleanRef.startsWith('~/')\r\n      ? path.join(process.env.HOME || '', cleanRef.slice(2))\r\n      : path.join(cwd, cleanRef);\r\n    if (fs.existsSync(resolved)) {\r\n      found.push(cleanRef);\r\n    } else {\r\n      missing.push(cleanRef);\r\n    }\r\n  }\r\n\r\n  const backtickRefs = content.match(/`([^`]+\\/[^`]+\\.[a-zA-Z]{1,10})`/g) || [];\r\n  for (const ref of backtickRefs) {\r\n    const cleanRef = ref.slice(1, -1);\r\n    if (cleanRef.startsWith('http') || cleanRef.includes('${') || cleanRef.includes('{{')) continue;\r\n    if (found.includes(cleanRef) || missing.includes(cleanRef)) continue;\r\n    const resolved = path.join(cwd, cleanRef);\r\n    if (fs.existsSync(resolved)) {\r\n      found.push(cleanRef);\r\n    } else {\r\n      missing.push(cleanRef);\r\n    }\r\n  }\r\n\r\n  const result: ReferencesResult = {\r\n    valid: missing.length === 0,\r\n    found: found.length,\r\n    missing,\r\n    total: found.length + missing.length,\r\n  };\r\n  output(result, raw, missing.length === 0 ? 'valid' : 'invalid');\r\n}\r\n\r\n// ─── Verify Commits ──────────────────────────────────────────────────────────\r\n\r\nexport function cmdVerifyCommits(cwd: string, hashes: string[], raw: boolean): void {\r\n  if (!hashes || hashes.length === 0) {\r\n    error('At least one commit hash required');\r\n  }\r\n\r\n  const valid: string[] = [];\r\n  const invalid: string[] = [];\r\n  for (const hash of hashes) {\r\n    const result = execGit(cwd, ['cat-file', '-t', hash]);\r\n    if (result.exitCode === 0 && result.stdout.trim() === 'commit') {\r\n      valid.push(hash);\r\n    } else {\r\n      invalid.push(hash);\r\n    }\r\n  }\r\n\r\n  const commitResult: CommitsResult = {\r\n    all_valid: invalid.length === 0,\r\n    valid,\r\n    invalid,\r\n    total: hashes.length,\r\n  };\r\n  output(commitResult, raw, invalid.length === 0 ? 'valid' : 'invalid');\r\n}\r\n\r\n// ─── Verify Artifacts ────────────────────────────────────────────────────────\r\n\r\ninterface MustHaveArtifact {\r\n  path?: string;\r\n  min_lines?: number;\r\n  contains?: string;\r\n  exports?: string | string[];\r\n  [key: string]: string | number | string[] | undefined;\r\n}\r\n\r\nexport function cmdVerifyArtifacts(cwd: string, planFilePath: string | null, raw: boolean): void {\r\n  if (!planFilePath) {\r\n    error('plan file path required');\r\n  }\r\n  const fullPath = path.isAbsolute(planFilePath) ? planFilePath : path.join(cwd, planFilePath);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: planFilePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const artifacts = parseMustHavesBlock(content, 'artifacts');\r\n  if (artifacts.length === 0) {\r\n    output({ error: 'No must_haves.artifacts found in frontmatter', path: planFilePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const results: ArtifactCheck[] = [];\r\n  for (const artifact of artifacts) {\r\n    if (typeof artifact === 'string') continue;\r\n    const artObj = artifact as MustHaveArtifact;\r\n    const artPath = artObj.path;\r\n    if (!artPath) continue;\r\n\r\n    const artFullPath = path.join(cwd, artPath);\r\n    const exists = fs.existsSync(artFullPath);\r\n    const check: ArtifactCheck = { path: artPath, exists, issues: [], passed: false };\r\n\r\n    if (exists) {\r\n      const fileContent = safeReadFile(artFullPath) || '';\r\n      const lineCount = fileContent.split('\\n').length;\r\n\r\n      if (artObj.min_lines && lineCount < artObj.min_lines) {\r\n        check.issues.push(`Only ${lineCount} lines, need ${artObj.min_lines}`);\r\n      }\r\n      if (artObj.contains && !fileContent.includes(artObj.contains)) {\r\n        check.issues.push(`Missing pattern: ${artObj.contains}`);\r\n      }\r\n      if (artObj.exports) {\r\n        const exportList = Array.isArray(artObj.exports) ? artObj.exports : [artObj.exports];\r\n        for (const exp of exportList) {\r\n          if (!fileContent.includes(exp)) check.issues.push(`Missing export: ${exp}`);\r\n        }\r\n      }\r\n      check.passed = check.issues.length === 0;\r\n    } else {\r\n      check.issues.push('File not found');\r\n    }\r\n\r\n    results.push(check);\r\n  }\r\n\r\n  const passed = results.filter(r => r.passed).length;\r\n  const artifactsResult: ArtifactsResult = {\r\n    all_passed: passed === results.length,\r\n    passed,\r\n    total: results.length,\r\n    artifacts: results,\r\n  };\r\n  output(artifactsResult, raw, passed === results.length ? 'valid' : 'invalid');\r\n}\r\n\r\n// ─── Verify Key Links ────────────────────────────────────────────────────────\r\n\r\ninterface MustHaveKeyLink {\r\n  from?: string;\r\n  to?: string;\r\n  via?: string;\r\n  pattern?: string;\r\n  [key: string]: string | number | string[] | undefined;\r\n}\r\n\r\nexport function cmdVerifyKeyLinks(cwd: string, planFilePath: string | null, raw: boolean): void {\r\n  if (!planFilePath) {\r\n    error('plan file path required');\r\n  }\r\n  const fullPath = path.isAbsolute(planFilePath) ? planFilePath : path.join(cwd, planFilePath);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: planFilePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const keyLinks = parseMustHavesBlock(content, 'key_links');\r\n  if (keyLinks.length === 0) {\r\n    output({ error: 'No must_haves.key_links found in frontmatter', path: planFilePath }, raw);\r\n    return;\r\n  }\r\n\r\n  const results: KeyLinkCheck[] = [];\r\n  for (const link of keyLinks) {\r\n    if (typeof link === 'string') continue;\r\n    const linkObj = link as MustHaveKeyLink;\r\n    const check: KeyLinkCheck = {\r\n      from: linkObj.from || '',\r\n      to: linkObj.to || '',\r\n      via: linkObj.via || '',\r\n      verified: false,\r\n      detail: '',\r\n    };\r\n\r\n    const sourceContent = safeReadFile(path.join(cwd, linkObj.from || ''));\r\n    if (!sourceContent) {\r\n      check.detail = 'Source file not found';\r\n    } else if (linkObj.pattern) {\r\n      try {\r\n        const regex = new RegExp(linkObj.pattern);\r\n        if (regex.test(sourceContent)) {\r\n          check.verified = true;\r\n          check.detail = 'Pattern found in source';\r\n        } else {\r\n          const targetContent = safeReadFile(path.join(cwd, linkObj.to || ''));\r\n          if (targetContent && regex.test(targetContent)) {\r\n            check.verified = true;\r\n            check.detail = 'Pattern found in target';\r\n          } else {\r\n            check.detail = `Pattern \"${linkObj.pattern}\" not found in source or target`;\r\n          }\r\n        }\r\n      } catch {\r\n        check.detail = `Invalid regex pattern: ${linkObj.pattern}`;\r\n      }\r\n    } else {\r\n      if (sourceContent.includes(linkObj.to || '')) {\r\n        check.verified = true;\r\n        check.detail = 'Target referenced in source';\r\n      } else {\r\n        check.detail = 'Target not referenced in source';\r\n      }\r\n    }\r\n\r\n    results.push(check);\r\n  }\r\n\r\n  const verified = results.filter(r => r.verified).length;\r\n  const linksResult: KeyLinksResult = {\r\n    all_verified: verified === results.length,\r\n    verified,\r\n    total: results.length,\r\n    links: results,\r\n  };\r\n  output(linksResult, raw, verified === results.length ? 'valid' : 'invalid');\r\n}\r\n\r\n// ─── Validate Consistency ────────────────────────────────────────────────────\r\n\r\nexport function cmdValidateConsistency(cwd: string, raw: boolean): void {\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n\r\n  if (!fs.existsSync(roadmapPath)) {\r\n    errors.push('ROADMAP.md not found');\r\n    output({ passed: false, errors, warnings }, raw, 'failed');\r\n    return;\r\n  }\r\n\r\n  const roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\r\n\r\n  const roadmapPhases = new Set<string>();\r\n  const phasePattern = getPhasePattern();\r\n  let m: RegExpExecArray | null;\r\n  while ((m = phasePattern.exec(roadmapContent)) !== null) {\r\n    roadmapPhases.add(m[1]);\r\n  }\r\n\r\n  const diskPhases = new Set<string>();\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)/i);\r\n      if (dm) diskPhases.add(dm[1]);\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  for (const p of roadmapPhases) {\r\n    if (!diskPhases.has(p) && !diskPhases.has(normalizePhaseName(p))) {\r\n      warnings.push(`Phase ${p} in ROADMAP.md but no directory on disk`);\r\n    }\r\n  }\r\n\r\n  for (const p of diskPhases) {\r\n    const unpadded = String(parseInt(p, 10));\r\n    if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) {\r\n      warnings.push(`Phase ${p} exists on disk but not in ROADMAP.md`);\r\n    }\r\n  }\r\n\r\n  const integerPhases = [...diskPhases]\r\n    .filter(p => !p.includes('.'))\r\n    .map(p => parseInt(p, 10))\r\n    .sort((a, b) => a - b);\r\n\r\n  for (let i = 1; i < integerPhases.length; i++) {\r\n    if (integerPhases[i] !== integerPhases[i - 1] + 1) {\r\n      warnings.push(`Gap in phase numbering: ${integerPhases[i - 1]} → ${integerPhases[i]}`);\r\n    }\r\n  }\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort();\r\n\r\n    for (const dir of dirs) {\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n      const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md')).sort();\r\n\r\n      const planNums = plans.map(p => {\r\n        const pm = p.match(/-(\\d{2})-PLAN\\.md$/);\r\n        return pm ? parseInt(pm[1], 10) : null;\r\n      }).filter((n): n is number => n !== null);\r\n\r\n      for (let i = 1; i < planNums.length; i++) {\r\n        if (planNums[i] !== planNums[i - 1] + 1) {\r\n          warnings.push(`Gap in plan numbering in ${dir}: plan ${planNums[i - 1]} → ${planNums[i]}`);\r\n        }\r\n      }\r\n\r\n      const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md'));\r\n      const planIdsSet = new Set(plans.map(p => p.replace('-PLAN.md', '')));\r\n      const summaryIdsSet = new Set(summaries.map(s => s.replace('-SUMMARY.md', '')));\r\n\r\n      for (const sid of summaryIdsSet) {\r\n        if (!planIdsSet.has(sid)) {\r\n          warnings.push(`Summary ${sid}-SUMMARY.md in ${dir} has no matching PLAN.md`);\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n\r\n    for (const dir of dirs) {\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n      const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md'));\r\n\r\n      for (const plan of plans) {\r\n        const content = fs.readFileSync(path.join(phasesDir, dir, plan), 'utf-8');\r\n        const fm = extractFrontmatter(content);\r\n\r\n        if (!fm.wave) {\r\n          warnings.push(`${dir}/${plan}: missing 'wave' in frontmatter`);\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const passed = errors.length === 0;\r\n  const result: ConsistencyResult = { passed, errors, warnings, warning_count: warnings.length };\r\n  output(result, raw, passed ? 'passed' : 'failed');\r\n}\r\n\r\n// ─── Validate Health ─────────────────────────────────────────────────────────\r\n\r\nexport function cmdValidateHealth(cwd: string, options: HealthOptions, raw: boolean): void {\r\n  const planningDir = path.join(cwd, '.planning');\r\n  const projectPath = path.join(planningDir, 'PROJECT.md');\r\n  const roadmapPath = path.join(planningDir, 'ROADMAP.md');\r\n  const statePath = path.join(planningDir, 'STATE.md');\r\n  const configPath = path.join(planningDir, 'config.json');\r\n  const phasesDir = path.join(planningDir, 'phases');\r\n\r\n  const errors: ValidationError[] = [];\r\n  const warnings: ValidationWarning[] = [];\r\n  const info: ValidationError[] = [];\r\n  const repairs: string[] = [];\r\n\r\n  const addIssue = (\r\n    severity: 'error' | 'warning' | 'info',\r\n    code: string,\r\n    message: string,\r\n    fix: string,\r\n    repairable = false,\r\n  ): void => {\r\n    const issue: ValidationError = { code, message, fix, repairable };\r\n    if (severity === 'error') errors.push(issue);\r\n    else if (severity === 'warning') warnings.push(issue);\r\n    else info.push(issue);\r\n  };\r\n\r\n  // Check 1: .planning/ exists\r\n  if (!fs.existsSync(planningDir)) {\r\n    addIssue('error', 'E001', '.planning/ directory not found', 'Run /maxsim:new-project to initialize');\r\n    output({\r\n      status: 'broken',\r\n      errors,\r\n      warnings,\r\n      info,\r\n      repairable_count: 0,\r\n    }, raw);\r\n    return;\r\n  }\r\n\r\n  // Check 2: PROJECT.md\r\n  if (!fs.existsSync(projectPath)) {\r\n    addIssue('error', 'E002', 'PROJECT.md not found', 'Run /maxsim:new-project to create');\r\n  } else {\r\n    const content = fs.readFileSync(projectPath, 'utf-8');\r\n    const requiredSections = ['## What This Is', '## Core Value', '## Requirements'];\r\n    for (const section of requiredSections) {\r\n      if (!content.includes(section)) {\r\n        addIssue('warning', 'W001', `PROJECT.md missing section: ${section}`, 'Add section manually');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check 3: ROADMAP.md\r\n  if (!fs.existsSync(roadmapPath)) {\r\n    addIssue('error', 'E003', 'ROADMAP.md not found', 'Run /maxsim:new-milestone to create roadmap');\r\n  }\r\n\r\n  // Check 4: STATE.md\r\n  if (!fs.existsSync(statePath)) {\r\n    addIssue('error', 'E004', 'STATE.md not found', 'Run /maxsim:health --repair to regenerate', true);\r\n    repairs.push('regenerateState');\r\n  } else {\r\n    const stateContent = fs.readFileSync(statePath, 'utf-8');\r\n    const phaseRefs = [...stateContent.matchAll(/[Pp]hase\\s+(\\d+(?:\\.\\d+)?)/g)].map(m => m[1]);\r\n    const diskPhases = new Set<string>();\r\n    try {\r\n      const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n      for (const e of entries) {\r\n        if (e.isDirectory()) {\r\n          const dm = e.name.match(/^(\\d+(?:\\.\\d+)?)/);\r\n          if (dm) diskPhases.add(dm[1]);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n    for (const ref of phaseRefs) {\r\n      const normalizedRef = String(parseInt(ref, 10)).padStart(2, '0');\r\n      if (!diskPhases.has(ref) && !diskPhases.has(normalizedRef) && !diskPhases.has(String(parseInt(ref, 10)))) {\r\n        if (diskPhases.size > 0) {\r\n          addIssue('warning', 'W002', `STATE.md references phase ${ref}, but only phases ${[...diskPhases].sort().join(', ')} exist`, 'Run /maxsim:health --repair to regenerate STATE.md', true);\r\n          if (!repairs.includes('regenerateState')) repairs.push('regenerateState');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check 5: config.json\r\n  if (!fs.existsSync(configPath)) {\r\n    addIssue('warning', 'W003', 'config.json not found', 'Run /maxsim:health --repair to create with defaults', true);\r\n    repairs.push('createConfig');\r\n  } else {\r\n    try {\r\n      const rawContent = fs.readFileSync(configPath, 'utf-8');\r\n      const parsed: Record<string, unknown> = JSON.parse(rawContent) as Record<string, unknown>;\r\n      const validProfiles = ['quality', 'balanced', 'budget', 'tokenburner'];\r\n      if (parsed.model_profile && !validProfiles.includes(parsed.model_profile as string)) {\r\n        addIssue('warning', 'W004', `config.json: invalid model_profile \"${parsed.model_profile}\"`, `Valid values: ${validProfiles.join(', ')}`);\r\n      }\r\n    } catch (thrown: unknown) {\r\n      const parseErr = thrown as Error;\r\n      addIssue('error', 'E005', `config.json: JSON parse error - ${parseErr.message}`, 'Run /maxsim:health --repair to reset to defaults', true);\r\n      repairs.push('resetConfig');\r\n    }\r\n  }\r\n\r\n  // Check 6: Phase directory naming\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    for (const e of entries) {\r\n      if (e.isDirectory() && !e.name.match(/^\\d{2}(?:\\.\\d+)?-[\\w-]+$/)) {\r\n        addIssue('warning', 'W005', `Phase directory \"${e.name}\" doesn't follow NN-name format`, 'Rename to match pattern (e.g., 01-setup)');\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  // Check 7: Orphaned plans\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    for (const e of entries) {\r\n      if (!e.isDirectory()) continue;\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, e.name));\r\n      const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md');\r\n      const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n      const summaryBases = new Set(summaries.map(s => s.replace('-SUMMARY.md', '').replace('SUMMARY.md', '')));\r\n\r\n      for (const plan of plans) {\r\n        const planBase = plan.replace('-PLAN.md', '').replace('PLAN.md', '');\r\n        if (!summaryBases.has(planBase)) {\r\n          addIssue('info', 'I001', `${e.name}/${plan} has no SUMMARY.md`, 'May be in progress');\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  // Check 8: Roadmap consistency\r\n  if (fs.existsSync(roadmapPath)) {\r\n    const roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\r\n    const roadmapPhases = new Set<string>();\r\n    const phasePattern = getPhasePattern();\r\n    let m: RegExpExecArray | null;\r\n    while ((m = phasePattern.exec(roadmapContent)) !== null) {\r\n      roadmapPhases.add(m[1]);\r\n    }\r\n\r\n    const diskPhases = new Set<string>();\r\n    try {\r\n      const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n      for (const e of entries) {\r\n        if (e.isDirectory()) {\r\n          const dm = e.name.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)/i);\r\n          if (dm) diskPhases.add(dm[1]);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n\r\n    for (const p of roadmapPhases) {\r\n      const padded = String(parseInt(p, 10)).padStart(2, '0');\r\n      if (!diskPhases.has(p) && !diskPhases.has(padded)) {\r\n        addIssue('warning', 'W006', `Phase ${p} in ROADMAP.md but no directory on disk`, 'Create phase directory or remove from roadmap');\r\n      }\r\n    }\r\n\r\n    for (const p of diskPhases) {\r\n      const unpadded = String(parseInt(p, 10));\r\n      if (!roadmapPhases.has(p) && !roadmapPhases.has(unpadded)) {\r\n        addIssue('warning', 'W007', `Phase ${p} exists on disk but not in ROADMAP.md`, 'Add to roadmap or remove directory');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Perform repairs if requested\r\n  const repairActions: RepairAction[] = [];\r\n  if (options.repair && repairs.length > 0) {\r\n    for (const repair of repairs) {\r\n      try {\r\n        switch (repair) {\r\n          case 'createConfig':\r\n          case 'resetConfig': {\r\n            const defaults = {\r\n              model_profile: 'balanced',\r\n              commit_docs: true,\r\n              search_gitignored: false,\r\n              branching_strategy: 'none',\r\n              research: true,\r\n              plan_checker: true,\r\n              verifier: true,\r\n              parallelization: true,\r\n            };\r\n            fs.writeFileSync(configPath, JSON.stringify(defaults, null, 2), 'utf-8');\r\n            repairActions.push({ action: repair, success: true, path: 'config.json' });\r\n            break;\r\n          }\r\n          case 'regenerateState': {\r\n            if (fs.existsSync(statePath)) {\r\n              const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\r\n              const backupPath = `${statePath}.bak-${timestamp}`;\r\n              fs.copyFileSync(statePath, backupPath);\r\n              repairActions.push({ action: 'backupState', success: true, path: backupPath });\r\n            }\r\n            const milestone = getMilestoneInfo(cwd);\r\n            let stateContent = `# Session State\\n\\n`;\r\n            stateContent += `## Project Reference\\n\\n`;\r\n            stateContent += `See: .planning/PROJECT.md\\n\\n`;\r\n            stateContent += `## Position\\n\\n`;\r\n            stateContent += `**Milestone:** ${milestone.version} ${milestone.name}\\n`;\r\n            stateContent += `**Current phase:** (determining...)\\n`;\r\n            stateContent += `**Status:** Resuming\\n\\n`;\r\n            stateContent += `## Session Log\\n\\n`;\r\n            stateContent += `- ${new Date().toISOString().split('T')[0]}: STATE.md regenerated by /maxsim:health --repair\\n`;\r\n            fs.writeFileSync(statePath, stateContent, 'utf-8');\r\n            repairActions.push({ action: repair, success: true, path: 'STATE.md' });\r\n            break;\r\n          }\r\n        }\r\n      } catch (thrown: unknown) {\r\n        const repairErr = thrown as Error;\r\n        repairActions.push({ action: repair, success: false, error: repairErr.message });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Determine overall status\r\n  let status: 'healthy' | 'degraded' | 'broken';\r\n  if (errors.length > 0) {\r\n    status = 'broken';\r\n  } else if (warnings.length > 0) {\r\n    status = 'degraded';\r\n  } else {\r\n    status = 'healthy';\r\n  }\r\n\r\n  const repairableCount = errors.filter(e => e.repairable).length +\r\n                           warnings.filter(w => w.repairable).length;\r\n\r\n  const result: HealthResult = {\r\n    status,\r\n    errors,\r\n    warnings,\r\n    info,\r\n    repairable_count: repairableCount,\r\n    repairs_performed: repairActions.length > 0 ? repairActions : undefined,\r\n  };\r\n  output(result, raw);\r\n}\r\n","/**\r\n * Phase — Phase CRUD, query, and lifecycle operations\r\n *\r\n * Ported from maxsim/bin/lib/phase.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport {\r\n  normalizePhaseName,\r\n  comparePhaseNum,\r\n  getPhasePattern,\r\n  findPhaseInternal,\r\n  getArchivedPhaseDirs,\r\n  generateSlugInternal,\r\n  output,\r\n  error,\r\n} from './core.js';\r\nimport { extractFrontmatter } from './frontmatter.js';\r\nimport type {\r\n  PhaseNumber,\r\n  PhasesListOptions,\r\n  FrontmatterData,\r\n} from './types.js';\r\n\r\n// ─── Phase list ─────────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhasesList(cwd: string, options: PhasesListOptions, raw: boolean): void {\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const { type, phase, includeArchived } = options;\r\n\r\n  if (!fs.existsSync(phasesDir)) {\r\n    if (type) {\r\n      output({ files: [], count: 0 }, raw, '');\r\n    } else {\r\n      output({ directories: [], count: 0 }, raw, '');\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    let dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n\r\n    if (includeArchived) {\r\n      const archived = getArchivedPhaseDirs(cwd);\r\n      for (const a of archived) {\r\n        dirs.push(`${a.name} [${a.milestone}]`);\r\n      }\r\n    }\r\n\r\n    dirs.sort((a, b) => comparePhaseNum(a, b));\r\n\r\n    if (phase) {\r\n      const normalized = normalizePhaseName(phase);\r\n      const match = dirs.find(d => d.startsWith(normalized));\r\n      if (!match) {\r\n        output({ files: [], count: 0, phase_dir: null, error: 'Phase not found' }, raw, '');\r\n        return;\r\n      }\r\n      dirs = [match];\r\n    }\r\n\r\n    if (type) {\r\n      const files: string[] = [];\r\n      for (const dir of dirs) {\r\n        const dirPath = path.join(phasesDir, dir);\r\n        const dirFiles = fs.readdirSync(dirPath);\r\n\r\n        let filtered: string[];\r\n        if (type === 'plans') {\r\n          filtered = dirFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md');\r\n        } else if (type === 'summaries') {\r\n          filtered = dirFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n        } else {\r\n          filtered = dirFiles;\r\n        }\r\n\r\n        files.push(...filtered.sort());\r\n      }\r\n\r\n      const result = {\r\n        files,\r\n        count: files.length,\r\n        phase_dir: phase ? dirs[0].replace(/^\\d+(?:\\.\\d+)?-?/, '') : null,\r\n      };\r\n      output(result, raw, files.join('\\n'));\r\n      return;\r\n    }\r\n\r\n    output({ directories: dirs, count: dirs.length }, raw, dirs.join('\\n'));\r\n  } catch (e: unknown) {\r\n    error('Failed to list phases: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n// ─── Next decimal ───────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhaseNextDecimal(cwd: string, basePhase: string, raw: boolean): void {\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalized = normalizePhaseName(basePhase);\r\n\r\n  if (!fs.existsSync(phasesDir)) {\r\n    output(\r\n      { found: false, base_phase: normalized, next: `${normalized}.1`, existing: [] },\r\n      raw,\r\n      `${normalized}.1`,\r\n    );\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n\r\n    const baseExists = dirs.some(d => d.startsWith(normalized + '-') || d === normalized);\r\n\r\n    const decimalPattern = new RegExp(`^${normalized}\\\\.(\\\\d+)`);\r\n    const existingDecimals: string[] = [];\r\n\r\n    for (const dir of dirs) {\r\n      const match = dir.match(decimalPattern);\r\n      if (match) {\r\n        existingDecimals.push(`${normalized}.${match[1]}`);\r\n      }\r\n    }\r\n\r\n    existingDecimals.sort((a, b) => {\r\n      const aNum = parseFloat(a);\r\n      const bNum = parseFloat(b);\r\n      return aNum - bNum;\r\n    });\r\n\r\n    let nextDecimal: string;\r\n    if (existingDecimals.length === 0) {\r\n      nextDecimal = `${normalized}.1`;\r\n    } else {\r\n      const lastDecimal = existingDecimals[existingDecimals.length - 1];\r\n      const lastNum = parseInt(lastDecimal.split('.')[1], 10);\r\n      nextDecimal = `${normalized}.${lastNum + 1}`;\r\n    }\r\n\r\n    output(\r\n      { found: baseExists, base_phase: normalized, next: nextDecimal, existing: existingDecimals },\r\n      raw,\r\n      nextDecimal,\r\n    );\r\n  } catch (e: unknown) {\r\n    error('Failed to calculate next decimal phase: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n// ─── Find phase ─────────────────────────────────────────────────────────────\r\n\r\nexport function cmdFindPhase(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase identifier required');\r\n  }\r\n\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  const notFound = { found: false, directory: null, phase_number: null, phase_name: null, plans: [] as string[], summaries: [] as string[] };\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (!match) {\r\n      output(notFound, raw, '');\r\n      return;\r\n    }\r\n\r\n    const dirMatch = match.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n    const phaseNumber = dirMatch ? dirMatch[1] : normalized;\r\n    const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;\r\n\r\n    const phaseDir = path.join(phasesDir, match);\r\n    const phaseFiles = fs.readdirSync(phaseDir);\r\n    const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md').sort();\r\n    const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md').sort();\r\n\r\n    const result = {\r\n      found: true,\r\n      directory: path.join('.planning', 'phases', match),\r\n      phase_number: phaseNumber,\r\n      phase_name: phaseName,\r\n      plans,\r\n      summaries,\r\n    };\r\n\r\n    output(result, raw, result.directory);\r\n  } catch {\r\n    output(notFound, raw, '');\r\n  }\r\n}\r\n\r\n// ─── Phase plan index ───────────────────────────────────────────────────────\r\n\r\nexport function cmdPhasePlanIndex(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required for phase-plan-index');\r\n  }\r\n\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  let phaseDir: string | null = null;\r\n  let phaseDirName: string | null = null;\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (match) {\r\n      phaseDir = path.join(phasesDir, match);\r\n      phaseDirName = match;\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  if (!phaseDir) {\r\n    output({ phase: normalized, error: 'Phase not found', plans: [], waves: {}, incomplete: [], has_checkpoints: false }, raw);\r\n    return;\r\n  }\r\n\r\n  const phaseFiles = fs.readdirSync(phaseDir);\r\n  const planFiles = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md').sort();\r\n  const summaryFiles = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n\r\n  const completedPlanIds = new Set(\r\n    summaryFiles.map(s => s.replace('-SUMMARY.md', '').replace('SUMMARY.md', '')),\r\n  );\r\n\r\n  const plans: Array<{\r\n    id: string;\r\n    wave: number;\r\n    autonomous: boolean;\r\n    objective: string | null;\r\n    files_modified: string[];\r\n    task_count: number;\r\n    has_summary: boolean;\r\n  }> = [];\r\n  const waves: Record<string, string[]> = {};\r\n  const incomplete: string[] = [];\r\n  let hasCheckpoints = false;\r\n\r\n  for (const planFile of planFiles) {\r\n    const planId = planFile.replace('-PLAN.md', '').replace('PLAN.md', '');\r\n    const planPath = path.join(phaseDir, planFile);\r\n    const content = fs.readFileSync(planPath, 'utf-8');\r\n    const fm = extractFrontmatter(content);\r\n\r\n    const taskMatches = content.match(/##\\s*Task\\s*\\d+/gi) || [];\r\n    const taskCount = taskMatches.length;\r\n\r\n    const wave = parseInt(fm.wave as string, 10) || 1;\r\n\r\n    let autonomous = true;\r\n    if (fm.autonomous !== undefined) {\r\n      autonomous = fm.autonomous === 'true' || fm.autonomous === true;\r\n    }\r\n\r\n    if (!autonomous) {\r\n      hasCheckpoints = true;\r\n    }\r\n\r\n    let filesModified: string[] = [];\r\n    if (fm['files-modified']) {\r\n      filesModified = Array.isArray(fm['files-modified']) ? fm['files-modified'] as string[] : [fm['files-modified'] as string];\r\n    }\r\n\r\n    const hasSummary = completedPlanIds.has(planId);\r\n    if (!hasSummary) {\r\n      incomplete.push(planId);\r\n    }\r\n\r\n    const plan = {\r\n      id: planId,\r\n      wave,\r\n      autonomous,\r\n      objective: (fm.objective as string) || null,\r\n      files_modified: filesModified,\r\n      task_count: taskCount,\r\n      has_summary: hasSummary,\r\n    };\r\n\r\n    plans.push(plan);\r\n\r\n    const waveKey = String(wave);\r\n    if (!waves[waveKey]) {\r\n      waves[waveKey] = [];\r\n    }\r\n    waves[waveKey].push(planId);\r\n  }\r\n\r\n  output({ phase: normalized, plans, waves, incomplete, has_checkpoints: hasCheckpoints }, raw);\r\n}\r\n\r\n// ─── Phase add ──────────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhaseAdd(cwd: string, description: string | undefined, raw: boolean): void {\r\n  if (!description) {\r\n    error('description required for phase add');\r\n  }\r\n\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  if (!fs.existsSync(roadmapPath)) {\r\n    error('ROADMAP.md not found');\r\n  }\r\n\r\n  const content = fs.readFileSync(roadmapPath, 'utf-8');\r\n  const slug = generateSlugInternal(description);\r\n\r\n  const phasePattern = getPhasePattern();\r\n  let maxPhase = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = phasePattern.exec(content)) !== null) {\r\n    const num = parseInt(m[1], 10);\r\n    if (num > maxPhase) maxPhase = num;\r\n  }\r\n\r\n  const newPhaseNum = maxPhase + 1;\r\n  const paddedNum = String(newPhaseNum).padStart(2, '0');\r\n  const dirName = `${paddedNum}-${slug}`;\r\n  const dirPath = path.join(cwd, '.planning', 'phases', dirName);\r\n\r\n  fs.mkdirSync(dirPath, { recursive: true });\r\n  fs.writeFileSync(path.join(dirPath, '.gitkeep'), '');\r\n\r\n  const phaseEntry = `\\n### Phase ${newPhaseNum}: ${description}\\n\\n**Goal:** [To be planned]\\n**Requirements**: TBD\\n**Depends on:** Phase ${maxPhase}\\n**Plans:** 0 plans\\n\\nPlans:\\n- [ ] TBD (run /maxsim:plan-phase ${newPhaseNum} to break down)\\n`;\r\n\r\n  let updatedContent: string;\r\n  const lastSeparator = content.lastIndexOf('\\n---');\r\n  if (lastSeparator > 0) {\r\n    updatedContent = content.slice(0, lastSeparator) + phaseEntry + content.slice(lastSeparator);\r\n  } else {\r\n    updatedContent = content + phaseEntry;\r\n  }\r\n\r\n  fs.writeFileSync(roadmapPath, updatedContent, 'utf-8');\r\n\r\n  output(\r\n    { phase_number: newPhaseNum, padded: paddedNum, name: description, slug, directory: `.planning/phases/${dirName}` },\r\n    raw,\r\n    paddedNum,\r\n  );\r\n}\r\n\r\n// ─── Phase insert ───────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhaseInsert(cwd: string, afterPhase: string | undefined, description: string | undefined, raw: boolean): void {\r\n  if (!afterPhase || !description) {\r\n    error('after-phase and description required for phase insert');\r\n  }\r\n\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  if (!fs.existsSync(roadmapPath)) {\r\n    error('ROADMAP.md not found');\r\n  }\r\n\r\n  const content = fs.readFileSync(roadmapPath, 'utf-8');\r\n  const slug = generateSlugInternal(description);\r\n\r\n  const normalizedAfter = normalizePhaseName(afterPhase);\r\n  const unpadded = normalizedAfter.replace(/^0+/, '');\r\n  const afterPhaseEscaped = '0*' + unpadded.replace(/\\./g, '\\\\.');\r\n  const targetPattern = getPhasePattern(afterPhaseEscaped, 'i');\r\n  if (!targetPattern.test(content)) {\r\n    error(`Phase ${afterPhase} not found in ROADMAP.md`);\r\n  }\r\n\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalizedBase = normalizePhaseName(afterPhase);\r\n  const existingDecimals: number[] = [];\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n    const decimalPattern = new RegExp(`^${normalizedBase}\\\\.(\\\\d+)`);\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(decimalPattern);\r\n      if (dm) existingDecimals.push(parseInt(dm[1], 10));\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const nextDecimal = existingDecimals.length === 0 ? 1 : Math.max(...existingDecimals) + 1;\r\n  const decimalPhase = `${normalizedBase}.${nextDecimal}`;\r\n  const dirName = `${decimalPhase}-${slug}`;\r\n  const dirPath = path.join(cwd, '.planning', 'phases', dirName);\r\n\r\n  fs.mkdirSync(dirPath, { recursive: true });\r\n  fs.writeFileSync(path.join(dirPath, '.gitkeep'), '');\r\n\r\n  const phaseEntry = `\\n### Phase ${decimalPhase}: ${description} (INSERTED)\\n\\n**Goal:** [Urgent work - to be planned]\\n**Requirements**: TBD\\n**Depends on:** Phase ${afterPhase}\\n**Plans:** 0 plans\\n\\nPlans:\\n- [ ] TBD (run /maxsim:plan-phase ${decimalPhase} to break down)\\n`;\r\n\r\n  const headerPattern = new RegExp(`(#{2,4}\\\\s*Phase\\\\s+0*${afterPhaseEscaped}:[^\\\\n]*\\\\n)`, 'i');\r\n  const headerMatch = content.match(headerPattern);\r\n  if (!headerMatch) {\r\n    error(`Could not find Phase ${afterPhase} header`);\r\n  }\r\n\r\n  const headerIdx = content.indexOf(headerMatch![0]);\r\n  const afterHeader = content.slice(headerIdx + headerMatch![0].length);\r\n  const nextPhaseMatch = afterHeader.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\r\n\r\n  let insertIdx: number;\r\n  if (nextPhaseMatch) {\r\n    insertIdx = headerIdx + headerMatch![0].length + nextPhaseMatch.index!;\r\n  } else {\r\n    insertIdx = content.length;\r\n  }\r\n\r\n  const updatedContent = content.slice(0, insertIdx) + phaseEntry + content.slice(insertIdx);\r\n  fs.writeFileSync(roadmapPath, updatedContent, 'utf-8');\r\n\r\n  output(\r\n    { phase_number: decimalPhase, after_phase: afterPhase, name: description, slug, directory: `.planning/phases/${dirName}` },\r\n    raw,\r\n    decimalPhase,\r\n  );\r\n}\r\n\r\n// ─── Phase remove ───────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhaseRemove(\r\n  cwd: string,\r\n  targetPhase: string | undefined,\r\n  options: { force: boolean },\r\n  raw: boolean,\r\n): void {\r\n  if (!targetPhase) {\r\n    error('phase number required for phase remove');\r\n  }\r\n\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const force = options.force || false;\r\n\r\n  if (!fs.existsSync(roadmapPath)) {\r\n    error('ROADMAP.md not found');\r\n  }\r\n\r\n  const normalized = normalizePhaseName(targetPhase);\r\n  const isDecimal = targetPhase.includes('.');\r\n\r\n  let targetDir: string | null = null;\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n    targetDir = dirs.find(d => d.startsWith(normalized + '-') || d === normalized) || null;\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  if (targetDir && !force) {\r\n    const targetPath = path.join(phasesDir, targetDir);\r\n    const files = fs.readdirSync(targetPath);\r\n    const summaries = files.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n    if (summaries.length > 0) {\r\n      error(`Phase ${targetPhase} has ${summaries.length} executed plan(s). Use --force to remove anyway.`);\r\n    }\r\n  }\r\n\r\n  if (targetDir) {\r\n    fs.rmSync(path.join(phasesDir, targetDir), { recursive: true, force: true });\r\n  }\r\n\r\n  const renamedDirs: Array<{ from: string; to: string }> = [];\r\n  const renamedFiles: Array<{ from: string; to: string }> = [];\r\n\r\n  if (isDecimal) {\r\n    const baseParts = normalized.split('.');\r\n    const baseInt = baseParts[0];\r\n    const removedDecimal = parseInt(baseParts[1], 10);\r\n\r\n    try {\r\n      const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n      const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n\r\n      const decPattern = new RegExp(`^${baseInt}\\\\.(\\\\d+)-(.+)$`);\r\n      const toRename: Array<{ dir: string; oldDecimal: number; slug: string }> = [];\r\n      for (const dir of dirs) {\r\n        const dm = dir.match(decPattern);\r\n        if (dm && parseInt(dm[1], 10) > removedDecimal) {\r\n          toRename.push({ dir, oldDecimal: parseInt(dm[1], 10), slug: dm[2] });\r\n        }\r\n      }\r\n\r\n      toRename.sort((a, b) => b.oldDecimal - a.oldDecimal);\r\n\r\n      for (const item of toRename) {\r\n        const newDecimal = item.oldDecimal - 1;\r\n        const oldPhaseId = `${baseInt}.${item.oldDecimal}`;\r\n        const newPhaseId = `${baseInt}.${newDecimal}`;\r\n        const newDirName = `${baseInt}.${newDecimal}-${item.slug}`;\r\n\r\n        fs.renameSync(path.join(phasesDir, item.dir), path.join(phasesDir, newDirName));\r\n        renamedDirs.push({ from: item.dir, to: newDirName });\r\n\r\n        const dirFiles = fs.readdirSync(path.join(phasesDir, newDirName));\r\n        for (const f of dirFiles) {\r\n          if (f.includes(oldPhaseId)) {\r\n            const newFileName = f.replace(oldPhaseId, newPhaseId);\r\n            fs.renameSync(\r\n              path.join(phasesDir, newDirName, f),\r\n              path.join(phasesDir, newDirName, newFileName),\r\n            );\r\n            renamedFiles.push({ from: f, to: newFileName });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n  } else {\r\n    const removedInt = parseInt(normalized, 10);\r\n\r\n    try {\r\n      const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n      const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n\r\n      const toRename: Array<{ dir: string; oldInt: number; letter: string; decimal: number | null; slug: string }> = [];\r\n      for (const dir of dirs) {\r\n        const dm = dir.match(/^(\\d+)([A-Z])?(?:\\.(\\d+))?-(.+)$/i);\r\n        if (!dm) continue;\r\n        const dirInt = parseInt(dm[1], 10);\r\n        if (dirInt > removedInt) {\r\n          toRename.push({\r\n            dir,\r\n            oldInt: dirInt,\r\n            letter: dm[2] ? dm[2].toUpperCase() : '',\r\n            decimal: dm[3] ? parseInt(dm[3], 10) : null,\r\n            slug: dm[4],\r\n          });\r\n        }\r\n      }\r\n\r\n      toRename.sort((a, b) => {\r\n        if (a.oldInt !== b.oldInt) return b.oldInt - a.oldInt;\r\n        return (b.decimal || 0) - (a.decimal || 0);\r\n      });\r\n\r\n      for (const item of toRename) {\r\n        const newInt = item.oldInt - 1;\r\n        const newPadded = String(newInt).padStart(2, '0');\r\n        const oldPadded = String(item.oldInt).padStart(2, '0');\r\n        const letterSuffix = item.letter || '';\r\n        const decimalSuffix = item.decimal !== null ? `.${item.decimal}` : '';\r\n        const oldPrefix = `${oldPadded}${letterSuffix}${decimalSuffix}`;\r\n        const newPrefix = `${newPadded}${letterSuffix}${decimalSuffix}`;\r\n        const newDirName = `${newPrefix}-${item.slug}`;\r\n\r\n        fs.renameSync(path.join(phasesDir, item.dir), path.join(phasesDir, newDirName));\r\n        renamedDirs.push({ from: item.dir, to: newDirName });\r\n\r\n        const dirFiles = fs.readdirSync(path.join(phasesDir, newDirName));\r\n        for (const f of dirFiles) {\r\n          if (f.startsWith(oldPrefix)) {\r\n            const newFileName = newPrefix + f.slice(oldPrefix.length);\r\n            fs.renameSync(\r\n              path.join(phasesDir, newDirName, f),\r\n              path.join(phasesDir, newDirName, newFileName),\r\n            );\r\n            renamedFiles.push({ from: f, to: newFileName });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      if (process.env.MAXSIM_DEBUG) console.error(e);\r\n    }\r\n  }\r\n\r\n  // Update ROADMAP.md\r\n  let roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\r\n\r\n  const targetEscaped = targetPhase.replace(/\\./g, '\\\\.');\r\n  const sectionPattern = new RegExp(\r\n    `\\\\n?#{2,4}\\\\s*Phase\\\\s+${targetEscaped}\\\\s*:[\\\\s\\\\S]*?(?=\\\\n#{2,4}\\\\s+Phase\\\\s+\\\\d|$)`,\r\n    'i',\r\n  );\r\n  roadmapContent = roadmapContent.replace(sectionPattern, '');\r\n\r\n  const checkboxPattern = new RegExp(`\\\\n?-\\\\s*\\\\[[ x]\\\\]\\\\s*.*Phase\\\\s+${targetEscaped}[:\\\\s][^\\\\n]*`, 'gi');\r\n  roadmapContent = roadmapContent.replace(checkboxPattern, '');\r\n\r\n  const tableRowPattern = new RegExp(`\\\\n?\\\\|\\\\s*${targetEscaped}\\\\.?\\\\s[^|]*\\\\|[^\\\\n]*`, 'gi');\r\n  roadmapContent = roadmapContent.replace(tableRowPattern, '');\r\n\r\n  if (!isDecimal) {\r\n    const removedInt = parseInt(normalized, 10);\r\n    const maxPhase = 99;\r\n    for (let oldNum = maxPhase; oldNum > removedInt; oldNum--) {\r\n      const newNum = oldNum - 1;\r\n      const oldStr = String(oldNum);\r\n      const newStr = String(newNum);\r\n      const oldPad = oldStr.padStart(2, '0');\r\n      const newPad = newStr.padStart(2, '0');\r\n\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(#{2,4}\\\\s*Phase\\\\s+)${oldStr}(\\\\s*:)`, 'gi'),\r\n        `$1${newStr}$2`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(Phase\\\\s+)${oldStr}([:\\\\s])`, 'g'),\r\n        `$1${newStr}$2`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`${oldPad}-(\\\\d{2})`, 'g'),\r\n        `${newPad}-$1`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(\\\\|\\\\s*)${oldStr}\\\\.\\\\s`, 'g'),\r\n        `$1${newStr}. `,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(Depends on:\\\\*\\\\*\\\\s*Phase\\\\s+)${oldStr}\\\\b`, 'gi'),\r\n        `$1${newStr}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  fs.writeFileSync(roadmapPath, roadmapContent, 'utf-8');\r\n\r\n  // Update STATE.md phase count\r\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\r\n  if (fs.existsSync(statePath)) {\r\n    let stateContent = fs.readFileSync(statePath, 'utf-8');\r\n    const totalPattern = /(\\*\\*Total Phases:\\*\\*\\s*)(\\d+)/;\r\n    const totalMatch = stateContent.match(totalPattern);\r\n    if (totalMatch) {\r\n      const oldTotal = parseInt(totalMatch[2], 10);\r\n      stateContent = stateContent.replace(totalPattern, `$1${oldTotal - 1}`);\r\n    }\r\n    const ofPattern = /(\\bof\\s+)(\\d+)(\\s*(?:\\(|phases?))/i;\r\n    const ofMatch = stateContent.match(ofPattern);\r\n    if (ofMatch) {\r\n      const oldTotal = parseInt(ofMatch[2], 10);\r\n      stateContent = stateContent.replace(ofPattern, `$1${oldTotal - 1}$3`);\r\n    }\r\n    fs.writeFileSync(statePath, stateContent, 'utf-8');\r\n  }\r\n\r\n  output({\r\n    removed: targetPhase,\r\n    directory_deleted: targetDir || null,\r\n    renamed_directories: renamedDirs,\r\n    renamed_files: renamedFiles,\r\n    roadmap_updated: true,\r\n    state_updated: fs.existsSync(statePath),\r\n  }, raw);\r\n}\r\n\r\n// ─── Phase complete ─────────────────────────────────────────────────────────\r\n\r\nexport function cmdPhaseComplete(cwd: string, phaseNum: string | undefined, raw: boolean): void {\r\n  if (!phaseNum) {\r\n    error('phase number required for phase complete');\r\n  }\r\n\r\n  const roadmapPath = path.join(cwd, '.planning', 'ROADMAP.md');\r\n  const statePath = path.join(cwd, '.planning', 'STATE.md');\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const normalized = normalizePhaseName(phaseNum);\r\n  const today = new Date().toISOString().split('T')[0];\r\n\r\n  const phaseInfo = findPhaseInternal(cwd, phaseNum);\r\n  if (!phaseInfo) {\r\n    error(`Phase ${phaseNum} not found`);\r\n  }\r\n\r\n  const planCount = phaseInfo!.plans.length;\r\n  const summaryCount = phaseInfo!.summaries.length;\r\n\r\n  if (fs.existsSync(roadmapPath)) {\r\n    let roadmapContent = fs.readFileSync(roadmapPath, 'utf-8');\r\n\r\n    const checkboxPattern = new RegExp(\r\n      `(-\\\\s*\\\\[)[ ](\\\\]\\\\s*.*Phase\\\\s+${phaseNum.replace('.', '\\\\.')}[:\\\\s][^\\\\n]*)`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);\r\n\r\n    const phaseEscaped = phaseNum.replace('.', '\\\\.');\r\n    const tablePattern = new RegExp(\r\n      `(\\\\|\\\\s*${phaseEscaped}\\\\.?\\\\s[^|]*\\\\|[^|]*\\\\|)\\\\s*[^|]*(\\\\|)\\\\s*[^|]*(\\\\|)`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(\r\n      tablePattern,\r\n      `$1 Complete    $2 ${today} $3`,\r\n    );\r\n\r\n    const planCountPattern = new RegExp(\r\n      `(#{2,4}\\\\s*Phase\\\\s+${phaseEscaped}[\\\\s\\\\S]*?\\\\*\\\\*Plans:\\\\*\\\\*\\\\s*)[^\\\\n]+`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(\r\n      planCountPattern,\r\n      `$1${summaryCount}/${planCount} plans complete`,\r\n    );\r\n\r\n    fs.writeFileSync(roadmapPath, roadmapContent, 'utf-8');\r\n\r\n    // Update REQUIREMENTS.md\r\n    const reqPath = path.join(cwd, '.planning', 'REQUIREMENTS.md');\r\n    if (fs.existsSync(reqPath)) {\r\n      const reqMatch = roadmapContent.match(\r\n        new RegExp(`Phase\\\\s+${phaseNum.replace('.', '\\\\.')}[\\\\s\\\\S]*?\\\\*\\\\*Requirements:\\\\*\\\\*\\\\s*([^\\\\n]+)`, 'i'),\r\n      );\r\n\r\n      if (reqMatch) {\r\n        const reqIds = reqMatch[1].replace(/[\\[\\]]/g, '').split(/[,\\s]+/).map(r => r.trim()).filter(Boolean);\r\n        let reqContent = fs.readFileSync(reqPath, 'utf-8');\r\n\r\n        for (const reqId of reqIds) {\r\n          reqContent = reqContent.replace(\r\n            new RegExp(`(-\\\\s*\\\\[)[ ](\\\\]\\\\s*\\\\*\\\\*${reqId}\\\\*\\\\*)`, 'gi'),\r\n            '$1x$2',\r\n          );\r\n          reqContent = reqContent.replace(\r\n            new RegExp(`(\\\\|\\\\s*${reqId}\\\\s*\\\\|[^|]+\\\\|)\\\\s*Pending\\\\s*(\\\\|)`, 'gi'),\r\n            '$1 Complete $2',\r\n          );\r\n        }\r\n\r\n        fs.writeFileSync(reqPath, reqContent, 'utf-8');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find next phase\r\n  let nextPhaseNum: string | null = null;\r\n  let nextPhaseName: string | null = null;\r\n  let isLastPhase = true;\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort((a, b) => comparePhaseNum(a, b));\r\n\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n      if (dm) {\r\n        if (comparePhaseNum(dm[1], phaseNum) > 0) {\r\n          nextPhaseNum = dm[1];\r\n          nextPhaseName = dm[2] || null;\r\n          isLastPhase = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  // Update STATE.md\r\n  if (fs.existsSync(statePath)) {\r\n    let stateContent = fs.readFileSync(statePath, 'utf-8');\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Current Phase:\\*\\*\\s*).*/,\r\n      `$1${nextPhaseNum || phaseNum}`,\r\n    );\r\n\r\n    if (nextPhaseName) {\r\n      stateContent = stateContent.replace(\r\n        /(\\*\\*Current Phase Name:\\*\\*\\s*).*/,\r\n        `$1${nextPhaseName.replace(/-/g, ' ')}`,\r\n      );\r\n    }\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Status:\\*\\*\\s*).*/,\r\n      `$1${isLastPhase ? 'Milestone complete' : 'Ready to plan'}`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Current Plan:\\*\\*\\s*).*/,\r\n      `$1Not started`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity:\\*\\*\\s*).*/,\r\n      `$1${today}`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity Description:\\*\\*\\s*).*/,\r\n      `$1Phase ${phaseNum} complete${nextPhaseNum ? `, transitioned to Phase ${nextPhaseNum}` : ''}`,\r\n    );\r\n\r\n    fs.writeFileSync(statePath, stateContent, 'utf-8');\r\n  }\r\n\r\n  output({\r\n    completed_phase: phaseNum,\r\n    phase_name: phaseInfo!.phase_name,\r\n    plans_executed: `${summaryCount}/${planCount}`,\r\n    next_phase: nextPhaseNum,\r\n    next_phase_name: nextPhaseName,\r\n    is_last_phase: isLastPhase,\r\n    date: today,\r\n    roadmap_updated: fs.existsSync(roadmapPath),\r\n    state_updated: fs.existsSync(statePath),\r\n  }, raw);\r\n}\r\n","/**\n * Template — Template selection and fill operations\n *\n * Ported from maxsim/bin/lib/template.cjs\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport {\n  normalizePhaseName,\n  findPhaseInternal,\n  generateSlugInternal,\n  output,\n  error,\n} from './core.js';\nimport { reconstructFrontmatter } from './frontmatter.js';\nimport type { FrontmatterData } from './types.js';\n\n// ─── Interfaces ──────────────────────────────────────────────────────────────\n\nexport interface TemplateSelectResult {\n  template: string;\n  type: 'minimal' | 'standard' | 'complex';\n  taskCount: number;\n  fileCount: number;\n  hasDecisions: boolean;\n  error?: string;\n}\n\nexport interface TemplateFillOptions {\n  phase: string;\n  name?: string;\n  plan?: string;\n  type?: string;\n  wave?: string;\n  fields?: FrontmatterData;\n}\n\nexport interface TemplateFillResult {\n  created: boolean;\n  path: string;\n  template: string;\n}\n\n// ─── Template Select ─────────────────────────────────────────────────────────\n\nexport function cmdTemplateSelect(cwd: string, planPath: string | null, raw: boolean): void {\n  if (!planPath) {\n    error('plan-path required');\n  }\n\n  try {\n    const fullPath = path.join(cwd, planPath);\n    const content = fs.readFileSync(fullPath, 'utf-8');\n\n    const taskMatch = content.match(/###\\s*Task\\s*\\d+/g) || [];\n    const taskCount = taskMatch.length;\n\n    const decisionMatch = content.match(/decision/gi) || [];\n    const hasDecisions = decisionMatch.length > 0;\n\n    const fileMentions = new Set<string>();\n    const filePattern = /`([^`]+\\.[a-zA-Z]+)`/g;\n    let m: RegExpExecArray | null;\n    while ((m = filePattern.exec(content)) !== null) {\n      if (m[1].includes('/') && !m[1].startsWith('http')) {\n        fileMentions.add(m[1]);\n      }\n    }\n    const fileCount = fileMentions.size;\n\n    let template = 'templates/summary-standard.md';\n    let type: 'minimal' | 'standard' | 'complex' = 'standard';\n\n    if (taskCount <= 2 && fileCount <= 3 && !hasDecisions) {\n      template = 'templates/summary-minimal.md';\n      type = 'minimal';\n    } else if (hasDecisions || fileCount > 6 || taskCount > 5) {\n      template = 'templates/summary-complex.md';\n      type = 'complex';\n    }\n\n    const result: TemplateSelectResult = { template, type, taskCount, fileCount, hasDecisions };\n    output(result, raw, template);\n  } catch (thrown: unknown) {\n    const selectErr = thrown as Error;\n    output(\n      { template: 'templates/summary-standard.md', type: 'standard', error: selectErr.message } as TemplateSelectResult,\n      raw,\n      'templates/summary-standard.md',\n    );\n  }\n}\n\n// ─── Template Fill ───────────────────────────────────────────────────────────\n\nexport function cmdTemplateFill(\n  cwd: string,\n  templateType: string | null,\n  options: TemplateFillOptions,\n  raw: boolean,\n): void {\n  if (!templateType) {\n    error('template type required: summary, plan, or verification');\n  }\n  if (!options.phase) {\n    error('--phase required');\n  }\n\n  const phaseInfo = findPhaseInternal(cwd, options.phase);\n  if (!phaseInfo) {\n    output({ error: 'Phase not found', phase: options.phase }, raw);\n    return;\n  }\n\n  const padded = normalizePhaseName(options.phase);\n  const today = new Date().toISOString().split('T')[0];\n  const phaseName = options.name || phaseInfo.phase_name || 'Unnamed';\n  const phaseSlug = phaseInfo.phase_slug || generateSlugInternal(phaseName);\n  const phaseId = `${padded}-${phaseSlug}`;\n  const planNum = (options.plan || '01').padStart(2, '0');\n  const fields = options.fields || {};\n\n  let frontmatter: FrontmatterData;\n  let body: string;\n  let fileName: string;\n\n  switch (templateType) {\n    case 'summary': {\n      frontmatter = {\n        phase: phaseId,\n        plan: planNum,\n        subsystem: '[primary category]',\n        tags: [],\n        provides: [],\n        affects: [],\n        'tech-stack': { added: [], patterns: [] },\n        'key-files': { created: [], modified: [] },\n        'key-decisions': [],\n        'patterns-established': [],\n        duration: '[X]min',\n        completed: today,\n        ...fields,\n      };\n      body = [\n        `# Phase ${options.phase}: ${phaseName} Summary`,\n        '',\n        '**[Substantive one-liner describing outcome]**',\n        '',\n        '## Performance',\n        '- **Duration:** [time]',\n        '- **Tasks:** [count completed]',\n        '- **Files modified:** [count]',\n        '',\n        '## Accomplishments',\n        '- [Key outcome 1]',\n        '- [Key outcome 2]',\n        '',\n        '## Task Commits',\n        '1. **Task 1: [task name]** - `hash`',\n        '',\n        '## Files Created/Modified',\n        '- `path/to/file.ts` - What it does',\n        '',\n        '## Decisions & Deviations',\n        '[Key decisions or \"None - followed plan as specified\"]',\n        '',\n        '## Next Phase Readiness',\n        '[What\\'s ready for next phase]',\n      ].join('\\n');\n      fileName = `${padded}-${planNum}-SUMMARY.md`;\n      break;\n    }\n    case 'plan': {\n      const planType = options.type || 'execute';\n      const wave = parseInt(options.wave || '1') || 1;\n      frontmatter = {\n        phase: phaseId,\n        plan: planNum,\n        type: planType,\n        wave,\n        depends_on: [],\n        files_modified: [],\n        autonomous: true,\n        user_setup: [],\n        must_haves: { truths: [], artifacts: [], key_links: [] },\n        ...fields,\n      };\n      body = [\n        `# Phase ${options.phase} Plan ${planNum}: [Title]`,\n        '',\n        '## Objective',\n        '- **What:** [What this plan builds]',\n        '- **Why:** [Why it matters for the phase goal]',\n        '- **Output:** [Concrete deliverable]',\n        '',\n        '## Context',\n        '@.planning/PROJECT.md',\n        '@.planning/ROADMAP.md',\n        '@.planning/STATE.md',\n        '',\n        '## Tasks',\n        '',\n        '<task type=\"code\">',\n        '  <name>[Task name]</name>',\n        '  <files>[file paths]</files>',\n        '  <action>[What to do]</action>',\n        '  <verify>[How to verify]</verify>',\n        '  <done>[Definition of done]</done>',\n        '</task>',\n        '',\n        '## Verification',\n        '[How to verify this plan achieved its objective]',\n        '',\n        '## Success Criteria',\n        '- [ ] [Criterion 1]',\n        '- [ ] [Criterion 2]',\n      ].join('\\n');\n      fileName = `${padded}-${planNum}-PLAN.md`;\n      break;\n    }\n    case 'verification': {\n      frontmatter = {\n        phase: phaseId,\n        verified: new Date().toISOString(),\n        status: 'pending',\n        score: '0/0 must-haves verified',\n        ...fields,\n      };\n      body = [\n        `# Phase ${options.phase}: ${phaseName} — Verification`,\n        '',\n        '## Observable Truths',\n        '| # | Truth | Status | Evidence |',\n        '|---|-------|--------|----------|',\n        '| 1 | [Truth] | pending | |',\n        '',\n        '## Required Artifacts',\n        '| Artifact | Expected | Status | Details |',\n        '|----------|----------|--------|---------|',\n        '| [path] | [what] | pending | |',\n        '',\n        '## Key Link Verification',\n        '| From | To | Via | Status | Details |',\n        '|------|----|----|--------|---------|',\n        '| [source] | [target] | [connection] | pending | |',\n        '',\n        '## Requirements Coverage',\n        '| Requirement | Status | Blocking Issue |',\n        '|-------------|--------|----------------|',\n        '| [req] | pending | |',\n        '',\n        '## Result',\n        '[Pending verification]',\n      ].join('\\n');\n      fileName = `${padded}-VERIFICATION.md`;\n      break;\n    }\n    default:\n      error(`Unknown template type: ${templateType}. Available: summary, plan, verification`);\n      return;\n  }\n\n  const fullContent = `---\\n${reconstructFrontmatter(frontmatter)}\\n---\\n\\n${body}\\n`;\n  const outPath = path.join(cwd, phaseInfo.directory, fileName);\n\n  if (fs.existsSync(outPath)) {\n    output({ error: 'File already exists', path: path.relative(cwd, outPath) }, raw);\n    return;\n  }\n\n  fs.writeFileSync(outPath, fullContent, 'utf-8');\n  const relPath = path.relative(cwd, outPath);\n  const result: TemplateFillResult = { created: true, path: relPath, template: templateType };\n  output(result, raw, relPath);\n}\n","/**\r\n * Init — Compound init commands for workflow bootstrapping\r\n *\r\n * Ported from maxsim/bin/lib/init.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport os from 'node:os';\r\nimport { execSync } from 'node:child_process';\r\n\r\nimport {\r\n  loadConfig,\r\n  resolveModelInternal,\r\n  findPhaseInternal,\r\n  getRoadmapPhaseInternal,\r\n  pathExistsInternal,\r\n  generateSlugInternal,\r\n  getMilestoneInfo,\r\n  output,\r\n  error,\r\n} from './core.js';\r\n\r\nimport type {\r\n  AgentType,\r\n  ModelResolution,\r\n  PhaseSearchResult,\r\n  MilestoneInfo,\r\n  AppConfig,\r\n} from './types.js';\r\n\r\n// ─── Init result types ──────────────────────────────────────────────────────\r\n\r\nexport type WorkflowType =\r\n  | 'execute-phase'\r\n  | 'plan-phase'\r\n  | 'new-project'\r\n  | 'new-milestone'\r\n  | 'quick'\r\n  | 'resume'\r\n  | 'verify-work'\r\n  | 'phase-op'\r\n  | 'todos'\r\n  | 'milestone-op'\r\n  | 'map-codebase'\r\n  | 'progress';\r\n\r\nexport interface ExecutePhaseContext {\r\n  executor_model: ModelResolution;\r\n  verifier_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  parallelization: boolean;\r\n  branching_strategy: string;\r\n  phase_branch_template: string;\r\n  milestone_branch_template: string;\r\n  verifier_enabled: boolean;\r\n  phase_found: boolean;\r\n  phase_dir: string | null;\r\n  phase_number: string | null;\r\n  phase_name: string | null;\r\n  phase_slug: string | null;\r\n  phase_req_ids: string | null;\r\n  plans: string[];\r\n  summaries: string[];\r\n  incomplete_plans: string[];\r\n  plan_count: number;\r\n  incomplete_count: number;\r\n  branch_name: string | null;\r\n  milestone_version: string;\r\n  milestone_name: string;\r\n  milestone_slug: string | null;\r\n  state_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  config_exists: boolean;\r\n  state_path: string;\r\n  roadmap_path: string;\r\n  config_path: string;\r\n}\r\n\r\nexport interface PlanPhaseContext {\r\n  researcher_model: ModelResolution;\r\n  planner_model: ModelResolution;\r\n  checker_model: ModelResolution;\r\n  research_enabled: boolean;\r\n  plan_checker_enabled: boolean;\r\n  nyquist_validation_enabled: boolean;\r\n  commit_docs: boolean;\r\n  phase_found: boolean;\r\n  phase_dir: string | null;\r\n  phase_number: string | null;\r\n  phase_name: string | null;\r\n  phase_slug: string | null;\r\n  padded_phase: string | null;\r\n  phase_req_ids: string | null;\r\n  has_research: boolean;\r\n  has_context: boolean;\r\n  has_plans: boolean;\r\n  plan_count: number;\r\n  planning_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  state_path: string;\r\n  roadmap_path: string;\r\n  requirements_path: string;\r\n  context_path?: string;\r\n  research_path?: string;\r\n  verification_path?: string;\r\n  uat_path?: string;\r\n}\r\n\r\nexport interface NewProjectContext {\r\n  researcher_model: ModelResolution;\r\n  synthesizer_model: ModelResolution;\r\n  roadmapper_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  project_exists: boolean;\r\n  has_codebase_map: boolean;\r\n  planning_exists: boolean;\r\n  has_existing_code: boolean;\r\n  has_package_file: boolean;\r\n  is_brownfield: boolean;\r\n  needs_codebase_map: boolean;\r\n  has_git: boolean;\r\n  brave_search_available: boolean;\r\n  project_path: string;\r\n}\r\n\r\nexport interface NewMilestoneContext {\r\n  researcher_model: ModelResolution;\r\n  synthesizer_model: ModelResolution;\r\n  roadmapper_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  research_enabled: boolean;\r\n  current_milestone: string;\r\n  current_milestone_name: string;\r\n  project_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  state_exists: boolean;\r\n  project_path: string;\r\n  roadmap_path: string;\r\n  state_path: string;\r\n}\r\n\r\nexport interface QuickContext {\r\n  planner_model: ModelResolution;\r\n  executor_model: ModelResolution;\r\n  checker_model: ModelResolution;\r\n  verifier_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  next_num: number;\r\n  slug: string | null;\r\n  description: string | null;\r\n  date: string;\r\n  timestamp: string;\r\n  quick_dir: string;\r\n  task_dir: string | null;\r\n  roadmap_exists: boolean;\r\n  planning_exists: boolean;\r\n}\r\n\r\nexport interface ResumeContext {\r\n  state_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  project_exists: boolean;\r\n  planning_exists: boolean;\r\n  state_path: string;\r\n  roadmap_path: string;\r\n  project_path: string;\r\n  has_interrupted_agent: boolean;\r\n  interrupted_agent_id: string | null;\r\n  commit_docs: boolean;\r\n}\r\n\r\nexport interface VerifyWorkContext {\r\n  planner_model: ModelResolution;\r\n  checker_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  phase_found: boolean;\r\n  phase_dir: string | null;\r\n  phase_number: string | null;\r\n  phase_name: string | null;\r\n  has_verification: boolean;\r\n}\r\n\r\nexport interface PhaseOpContext {\r\n  commit_docs: boolean;\r\n  brave_search: boolean;\r\n  phase_found: boolean;\r\n  phase_dir: string | null;\r\n  phase_number: string | null;\r\n  phase_name: string | null;\r\n  phase_slug: string | null;\r\n  padded_phase: string | null;\r\n  has_research: boolean;\r\n  has_context: boolean;\r\n  has_plans: boolean;\r\n  has_verification: boolean;\r\n  plan_count: number;\r\n  roadmap_exists: boolean;\r\n  planning_exists: boolean;\r\n  state_path: string;\r\n  roadmap_path: string;\r\n  requirements_path: string;\r\n  context_path?: string;\r\n  research_path?: string;\r\n  verification_path?: string;\r\n  uat_path?: string;\r\n}\r\n\r\nexport interface TodosContext {\r\n  commit_docs: boolean;\r\n  date: string;\r\n  timestamp: string;\r\n  todo_count: number;\r\n  todos: Array<{\r\n    file: string;\r\n    created: string;\r\n    title: string;\r\n    area: string;\r\n    path: string;\r\n  }>;\r\n  area_filter: string | null;\r\n  pending_dir: string;\r\n  completed_dir: string;\r\n  planning_exists: boolean;\r\n  todos_dir_exists: boolean;\r\n  pending_dir_exists: boolean;\r\n}\r\n\r\nexport interface MilestoneOpContext {\r\n  commit_docs: boolean;\r\n  milestone_version: string;\r\n  milestone_name: string;\r\n  milestone_slug: string | null;\r\n  phase_count: number;\r\n  completed_phases: number;\r\n  all_phases_complete: boolean;\r\n  archived_milestones: string[];\r\n  archive_count: number;\r\n  project_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  state_exists: boolean;\r\n  archive_exists: boolean;\r\n  phases_dir_exists: boolean;\r\n}\r\n\r\nexport interface MapCodebaseContext {\r\n  mapper_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  search_gitignored: boolean;\r\n  parallelization: boolean;\r\n  codebase_dir: string;\r\n  existing_maps: string[];\r\n  has_maps: boolean;\r\n  planning_exists: boolean;\r\n  codebase_dir_exists: boolean;\r\n}\r\n\r\ninterface ProgressPhaseInfo {\r\n  number: string;\r\n  name: string | null;\r\n  directory: string;\r\n  status: string;\r\n  plan_count: number;\r\n  summary_count: number;\r\n  has_research: boolean;\r\n}\r\n\r\nexport interface ProgressContext {\r\n  executor_model: ModelResolution;\r\n  planner_model: ModelResolution;\r\n  commit_docs: boolean;\r\n  milestone_version: string;\r\n  milestone_name: string;\r\n  phases: ProgressPhaseInfo[];\r\n  phase_count: number;\r\n  completed_count: number;\r\n  in_progress_count: number;\r\n  current_phase: ProgressPhaseInfo | null;\r\n  next_phase: ProgressPhaseInfo | null;\r\n  paused_at: string | null;\r\n  has_work_in_progress: boolean;\r\n  project_exists: boolean;\r\n  roadmap_exists: boolean;\r\n  state_exists: boolean;\r\n  state_path: string;\r\n  roadmap_path: string;\r\n  project_path: string;\r\n  config_path: string;\r\n}\r\n\r\nexport type InitContext =\r\n  | ExecutePhaseContext\r\n  | PlanPhaseContext\r\n  | NewProjectContext\r\n  | NewMilestoneContext\r\n  | QuickContext\r\n  | ResumeContext\r\n  | VerifyWorkContext\r\n  | PhaseOpContext\r\n  | TodosContext\r\n  | MilestoneOpContext\r\n  | MapCodebaseContext\r\n  | ProgressContext;\r\n\r\n// ─── Helper: extract requirement IDs from roadmap phase section ─────────────\r\n\r\nfunction extractReqIds(cwd: string, phase: string): string | null {\r\n  const roadmapPhase = getRoadmapPhaseInternal(cwd, phase);\r\n  const reqMatch = roadmapPhase?.section?.match(/^\\*\\*Requirements\\*\\*:[^\\S\\n]*([^\\n]*)$/m);\r\n  const reqExtracted = reqMatch\r\n    ? reqMatch[1].replace(/[\\[\\]]/g, '').split(',').map((s: string) => s.trim()).filter(Boolean).join(', ')\r\n    : null;\r\n  return (reqExtracted && reqExtracted !== 'TBD') ? reqExtracted : null;\r\n}\r\n\r\n// ─── Helper: scan phase dir for artifact files ──────────────────────────────\r\n\r\ninterface PhaseArtifacts {\r\n  context_path?: string;\r\n  research_path?: string;\r\n  verification_path?: string;\r\n  uat_path?: string;\r\n}\r\n\r\nfunction scanPhaseArtifacts(cwd: string, phaseDirectory: string): PhaseArtifacts {\r\n  const result: PhaseArtifacts = {};\r\n  const phaseDirFull = path.join(cwd, phaseDirectory);\r\n  try {\r\n    const files = fs.readdirSync(phaseDirFull);\r\n    const contextFile = files.find(f => f.endsWith('-CONTEXT.md') || f === 'CONTEXT.md');\r\n    if (contextFile) {\r\n      result.context_path = path.join(phaseDirectory, contextFile);\r\n    }\r\n    const researchFile = files.find(f => f.endsWith('-RESEARCH.md') || f === 'RESEARCH.md');\r\n    if (researchFile) {\r\n      result.research_path = path.join(phaseDirectory, researchFile);\r\n    }\r\n    const verificationFile = files.find(f => f.endsWith('-VERIFICATION.md') || f === 'VERIFICATION.md');\r\n    if (verificationFile) {\r\n      result.verification_path = path.join(phaseDirectory, verificationFile);\r\n    }\r\n    const uatFile = files.find(f => f.endsWith('-UAT.md') || f === 'UAT.md');\r\n    if (uatFile) {\r\n      result.uat_path = path.join(phaseDirectory, uatFile);\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n  return result;\r\n}\r\n\r\n// ─── Init commands ──────────────────────────────────────────────────────────\r\n\r\nexport function cmdInitExecutePhase(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required for init execute-phase');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n  const phaseInfo = findPhaseInternal(cwd, phase!);\r\n  const milestone = getMilestoneInfo(cwd);\r\n  const phase_req_ids = extractReqIds(cwd, phase!);\r\n\r\n  const result: ExecutePhaseContext = {\r\n    executor_model: resolveModelInternal(cwd, 'maxsim-executor'),\r\n    verifier_model: resolveModelInternal(cwd, 'maxsim-verifier'),\r\n    commit_docs: config.commit_docs,\r\n    parallelization: config.parallelization,\r\n    branching_strategy: config.branching_strategy,\r\n    phase_branch_template: config.phase_branch_template,\r\n    milestone_branch_template: config.milestone_branch_template,\r\n    verifier_enabled: config.verifier,\r\n    phase_found: !!phaseInfo,\r\n    phase_dir: phaseInfo?.directory ?? null,\r\n    phase_number: phaseInfo?.phase_number ?? null,\r\n    phase_name: phaseInfo?.phase_name ?? null,\r\n    phase_slug: phaseInfo?.phase_slug ?? null,\r\n    phase_req_ids,\r\n    plans: phaseInfo?.plans ?? [],\r\n    summaries: phaseInfo?.summaries ?? [],\r\n    incomplete_plans: phaseInfo?.incomplete_plans ?? [],\r\n    plan_count: phaseInfo?.plans?.length ?? 0,\r\n    incomplete_count: phaseInfo?.incomplete_plans?.length ?? 0,\r\n    branch_name: config.branching_strategy === 'phase' && phaseInfo\r\n      ? config.phase_branch_template\r\n          .replace('{phase}', phaseInfo.phase_number)\r\n          .replace('{slug}', phaseInfo.phase_slug || 'phase')\r\n      : config.branching_strategy === 'milestone'\r\n        ? config.milestone_branch_template\r\n            .replace('{milestone}', milestone.version)\r\n            .replace('{slug}', generateSlugInternal(milestone.name) || 'milestone')\r\n        : null,\r\n    milestone_version: milestone.version,\r\n    milestone_name: milestone.name,\r\n    milestone_slug: generateSlugInternal(milestone.name),\r\n    state_exists: pathExistsInternal(cwd, '.planning/STATE.md'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    config_exists: pathExistsInternal(cwd, '.planning/config.json'),\r\n    state_path: '.planning/STATE.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    config_path: '.planning/config.json',\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitPlanPhase(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required for init plan-phase');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n  const phaseInfo = findPhaseInternal(cwd, phase!);\r\n  const phase_req_ids = extractReqIds(cwd, phase!);\r\n\r\n  const result: PlanPhaseContext = {\r\n    researcher_model: resolveModelInternal(cwd, 'maxsim-phase-researcher'),\r\n    planner_model: resolveModelInternal(cwd, 'maxsim-planner'),\r\n    checker_model: resolveModelInternal(cwd, 'maxsim-plan-checker'),\r\n    research_enabled: config.research,\r\n    plan_checker_enabled: config.plan_checker,\r\n    nyquist_validation_enabled: false, // config doesn't have nyquist_validation directly\r\n    commit_docs: config.commit_docs,\r\n    phase_found: !!phaseInfo,\r\n    phase_dir: phaseInfo?.directory ?? null,\r\n    phase_number: phaseInfo?.phase_number ?? null,\r\n    phase_name: phaseInfo?.phase_name ?? null,\r\n    phase_slug: phaseInfo?.phase_slug ?? null,\r\n    padded_phase: phaseInfo?.phase_number?.padStart(2, '0') ?? null,\r\n    phase_req_ids,\r\n    has_research: phaseInfo?.has_research ?? false,\r\n    has_context: phaseInfo?.has_context ?? false,\r\n    has_plans: (phaseInfo?.plans?.length ?? 0) > 0,\r\n    plan_count: phaseInfo?.plans?.length ?? 0,\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    state_path: '.planning/STATE.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    requirements_path: '.planning/REQUIREMENTS.md',\r\n  };\r\n\r\n  if (phaseInfo?.directory) {\r\n    const artifacts = scanPhaseArtifacts(cwd, phaseInfo.directory);\r\n    if (artifacts.context_path) result.context_path = artifacts.context_path;\r\n    if (artifacts.research_path) result.research_path = artifacts.research_path;\r\n    if (artifacts.verification_path) result.verification_path = artifacts.verification_path;\r\n    if (artifacts.uat_path) result.uat_path = artifacts.uat_path;\r\n  }\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitNewProject(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n\r\n  const homedir = os.homedir();\r\n  const braveKeyFile = path.join(homedir, '.maxsim', 'brave_api_key');\r\n  const hasBraveSearch = !!(process.env.BRAVE_API_KEY || fs.existsSync(braveKeyFile));\r\n\r\n  let hasCode = false;\r\n  let hasPackageFile = false;\r\n  try {\r\n    const files = execSync('find . -maxdepth 3 \\\\( -name \"*.ts\" -o -name \"*.js\" -o -name \"*.py\" -o -name \"*.go\" -o -name \"*.rs\" -o -name \"*.swift\" -o -name \"*.java\" \\\\) 2>/dev/null | grep -v node_modules | grep -v .git | head -5', {\r\n      cwd,\r\n      encoding: 'utf-8',\r\n      stdio: ['pipe', 'pipe', 'pipe'],\r\n    });\r\n    hasCode = files.trim().length > 0;\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  hasPackageFile = pathExistsInternal(cwd, 'package.json') ||\r\n                   pathExistsInternal(cwd, 'requirements.txt') ||\r\n                   pathExistsInternal(cwd, 'Cargo.toml') ||\r\n                   pathExistsInternal(cwd, 'go.mod') ||\r\n                   pathExistsInternal(cwd, 'Package.swift');\r\n\r\n  const result: NewProjectContext = {\r\n    researcher_model: resolveModelInternal(cwd, 'maxsim-project-researcher'),\r\n    synthesizer_model: resolveModelInternal(cwd, 'maxsim-research-synthesizer'),\r\n    roadmapper_model: resolveModelInternal(cwd, 'maxsim-roadmapper'),\r\n    commit_docs: config.commit_docs,\r\n    project_exists: pathExistsInternal(cwd, '.planning/PROJECT.md'),\r\n    has_codebase_map: pathExistsInternal(cwd, '.planning/codebase'),\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    has_existing_code: hasCode,\r\n    has_package_file: hasPackageFile,\r\n    is_brownfield: hasCode || hasPackageFile,\r\n    needs_codebase_map: (hasCode || hasPackageFile) && !pathExistsInternal(cwd, '.planning/codebase'),\r\n    has_git: pathExistsInternal(cwd, '.git'),\r\n    brave_search_available: hasBraveSearch,\r\n    project_path: '.planning/PROJECT.md',\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitNewMilestone(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  const milestone = getMilestoneInfo(cwd);\r\n\r\n  const result: NewMilestoneContext = {\r\n    researcher_model: resolveModelInternal(cwd, 'maxsim-project-researcher'),\r\n    synthesizer_model: resolveModelInternal(cwd, 'maxsim-research-synthesizer'),\r\n    roadmapper_model: resolveModelInternal(cwd, 'maxsim-roadmapper'),\r\n    commit_docs: config.commit_docs,\r\n    research_enabled: config.research,\r\n    current_milestone: milestone.version,\r\n    current_milestone_name: milestone.name,\r\n    project_exists: pathExistsInternal(cwd, '.planning/PROJECT.md'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    state_exists: pathExistsInternal(cwd, '.planning/STATE.md'),\r\n    project_path: '.planning/PROJECT.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    state_path: '.planning/STATE.md',\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitQuick(cwd: string, description: string | undefined, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  const now = new Date();\r\n  const slug = description ? generateSlugInternal(description)?.substring(0, 40) ?? null : null;\r\n\r\n  const quickDir = path.join(cwd, '.planning', 'quick');\r\n  let nextNum = 1;\r\n  try {\r\n    const existing = fs.readdirSync(quickDir)\r\n      .filter(f => /^\\d+-/.test(f))\r\n      .map(f => parseInt(f.split('-')[0], 10))\r\n      .filter(n => !isNaN(n));\r\n    if (existing.length > 0) {\r\n      nextNum = Math.max(...existing) + 1;\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: QuickContext = {\r\n    planner_model: resolveModelInternal(cwd, 'maxsim-planner'),\r\n    executor_model: resolveModelInternal(cwd, 'maxsim-executor'),\r\n    checker_model: resolveModelInternal(cwd, 'maxsim-plan-checker'),\r\n    verifier_model: resolveModelInternal(cwd, 'maxsim-verifier'),\r\n    commit_docs: config.commit_docs,\r\n    next_num: nextNum,\r\n    slug,\r\n    description: description ?? null,\r\n    date: now.toISOString().split('T')[0],\r\n    timestamp: now.toISOString(),\r\n    quick_dir: '.planning/quick',\r\n    task_dir: slug ? `.planning/quick/${nextNum}-${slug}` : null,\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitResume(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n\r\n  let interruptedAgentId: string | null = null;\r\n  try {\r\n    interruptedAgentId = fs.readFileSync(path.join(cwd, '.planning', 'current-agent-id.txt'), 'utf-8').trim();\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: ResumeContext = {\r\n    state_exists: pathExistsInternal(cwd, '.planning/STATE.md'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    project_exists: pathExistsInternal(cwd, '.planning/PROJECT.md'),\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    state_path: '.planning/STATE.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    project_path: '.planning/PROJECT.md',\r\n    has_interrupted_agent: !!interruptedAgentId,\r\n    interrupted_agent_id: interruptedAgentId,\r\n    commit_docs: config.commit_docs,\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitVerifyWork(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required for init verify-work');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n  const phaseInfo = findPhaseInternal(cwd, phase!);\r\n\r\n  const result: VerifyWorkContext = {\r\n    planner_model: resolveModelInternal(cwd, 'maxsim-planner'),\r\n    checker_model: resolveModelInternal(cwd, 'maxsim-plan-checker'),\r\n    commit_docs: config.commit_docs,\r\n    phase_found: !!phaseInfo,\r\n    phase_dir: phaseInfo?.directory ?? null,\r\n    phase_number: phaseInfo?.phase_number ?? null,\r\n    phase_name: phaseInfo?.phase_name ?? null,\r\n    has_verification: phaseInfo?.has_verification ?? false,\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitPhaseOp(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  let phaseInfo = findPhaseInternal(cwd, phase ?? '');\r\n\r\n  if (!phaseInfo) {\r\n    const roadmapPhase = getRoadmapPhaseInternal(cwd, phase ?? '');\r\n    if (roadmapPhase?.found) {\r\n      const phaseName = roadmapPhase.phase_name;\r\n      phaseInfo = {\r\n        found: true,\r\n        directory: '',  // no directory yet\r\n        phase_number: roadmapPhase.phase_number,\r\n        phase_name: phaseName,\r\n        phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : null,\r\n        plans: [],\r\n        summaries: [],\r\n        incomplete_plans: [],\r\n        has_research: false,\r\n        has_context: false,\r\n        has_verification: false,\r\n      };\r\n    }\r\n  }\r\n\r\n  const result: PhaseOpContext = {\r\n    commit_docs: config.commit_docs,\r\n    brave_search: config.brave_search,\r\n    phase_found: !!phaseInfo,\r\n    phase_dir: phaseInfo?.directory || null,\r\n    phase_number: phaseInfo?.phase_number ?? null,\r\n    phase_name: phaseInfo?.phase_name ?? null,\r\n    phase_slug: phaseInfo?.phase_slug ?? null,\r\n    padded_phase: phaseInfo?.phase_number?.padStart(2, '0') ?? null,\r\n    has_research: phaseInfo?.has_research ?? false,\r\n    has_context: phaseInfo?.has_context ?? false,\r\n    has_plans: (phaseInfo?.plans?.length ?? 0) > 0,\r\n    has_verification: phaseInfo?.has_verification ?? false,\r\n    plan_count: phaseInfo?.plans?.length ?? 0,\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    state_path: '.planning/STATE.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    requirements_path: '.planning/REQUIREMENTS.md',\r\n  };\r\n\r\n  if (phaseInfo?.directory) {\r\n    const artifacts = scanPhaseArtifacts(cwd, phaseInfo.directory);\r\n    if (artifacts.context_path) result.context_path = artifacts.context_path;\r\n    if (artifacts.research_path) result.research_path = artifacts.research_path;\r\n    if (artifacts.verification_path) result.verification_path = artifacts.verification_path;\r\n    if (artifacts.uat_path) result.uat_path = artifacts.uat_path;\r\n  }\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitTodos(cwd: string, area: string | undefined, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  const now = new Date();\r\n\r\n  const pendingDir = path.join(cwd, '.planning', 'todos', 'pending');\r\n  let count = 0;\r\n  const todos: Array<{ file: string; created: string; title: string; area: string; path: string }> = [];\r\n\r\n  try {\r\n    const files = fs.readdirSync(pendingDir).filter(f => f.endsWith('.md'));\r\n    for (const file of files) {\r\n      try {\r\n        const content = fs.readFileSync(path.join(pendingDir, file), 'utf-8');\r\n        const createdMatch = content.match(/^created:\\s*(.+)$/m);\r\n        const titleMatch = content.match(/^title:\\s*(.+)$/m);\r\n        const areaMatch = content.match(/^area:\\s*(.+)$/m);\r\n        const todoArea = areaMatch ? areaMatch[1].trim() : 'general';\r\n\r\n        if (area && todoArea !== area) continue;\r\n\r\n        count++;\r\n        todos.push({\r\n          file,\r\n          created: createdMatch ? createdMatch[1].trim() : 'unknown',\r\n          title: titleMatch ? titleMatch[1].trim() : 'Untitled',\r\n          area: todoArea,\r\n          path: path.join('.planning', 'todos', 'pending', file),\r\n        });\r\n      } catch (e) {\r\n        /* optional op, ignore */\r\n        if (process.env.MAXSIM_DEBUG) console.error(e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: TodosContext = {\r\n    commit_docs: config.commit_docs,\r\n    date: now.toISOString().split('T')[0],\r\n    timestamp: now.toISOString(),\r\n    todo_count: count,\r\n    todos,\r\n    area_filter: area ?? null,\r\n    pending_dir: '.planning/todos/pending',\r\n    completed_dir: '.planning/todos/completed',\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    todos_dir_exists: pathExistsInternal(cwd, '.planning/todos'),\r\n    pending_dir_exists: pathExistsInternal(cwd, '.planning/todos/pending'),\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitMilestoneOp(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  const milestone = getMilestoneInfo(cwd);\r\n\r\n  let phaseCount = 0;\r\n  let completedPhases = 0;\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name);\r\n    phaseCount = dirs.length;\r\n\r\n    for (const dir of dirs) {\r\n      try {\r\n        const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n        const hasSummary = phaseFiles.some(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n        if (hasSummary) completedPhases++;\r\n      } catch (e) {\r\n        /* optional op, ignore */\r\n        if (process.env.MAXSIM_DEBUG) console.error(e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const archiveDir = path.join(cwd, '.planning', 'archive');\r\n  let archivedMilestones: string[] = [];\r\n  try {\r\n    archivedMilestones = fs.readdirSync(archiveDir, { withFileTypes: true })\r\n      .filter(e => e.isDirectory())\r\n      .map(e => e.name);\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: MilestoneOpContext = {\r\n    commit_docs: config.commit_docs,\r\n    milestone_version: milestone.version,\r\n    milestone_name: milestone.name,\r\n    milestone_slug: generateSlugInternal(milestone.name),\r\n    phase_count: phaseCount,\r\n    completed_phases: completedPhases,\r\n    all_phases_complete: phaseCount > 0 && phaseCount === completedPhases,\r\n    archived_milestones: archivedMilestones,\r\n    archive_count: archivedMilestones.length,\r\n    project_exists: pathExistsInternal(cwd, '.planning/PROJECT.md'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    state_exists: pathExistsInternal(cwd, '.planning/STATE.md'),\r\n    archive_exists: pathExistsInternal(cwd, '.planning/archive'),\r\n    phases_dir_exists: pathExistsInternal(cwd, '.planning/phases'),\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitMapCodebase(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n\r\n  const codebaseDir = path.join(cwd, '.planning', 'codebase');\r\n  let existingMaps: string[] = [];\r\n  try {\r\n    existingMaps = fs.readdirSync(codebaseDir).filter(f => f.endsWith('.md'));\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: MapCodebaseContext = {\r\n    mapper_model: resolveModelInternal(cwd, 'maxsim-codebase-mapper'),\r\n    commit_docs: config.commit_docs,\r\n    search_gitignored: config.search_gitignored,\r\n    parallelization: config.parallelization,\r\n    codebase_dir: '.planning/codebase',\r\n    existing_maps: existingMaps,\r\n    has_maps: existingMaps.length > 0,\r\n    planning_exists: pathExistsInternal(cwd, '.planning'),\r\n    codebase_dir_exists: pathExistsInternal(cwd, '.planning/codebase'),\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n\r\nexport function cmdInitProgress(cwd: string, raw: boolean): void {\r\n  const config = loadConfig(cwd);\r\n  const milestone = getMilestoneInfo(cwd);\r\n\r\n  const phasesDir = path.join(cwd, '.planning', 'phases');\r\n  const phases: ProgressPhaseInfo[] = [];\r\n  let currentPhase: ProgressPhaseInfo | null = null;\r\n  let nextPhase: ProgressPhaseInfo | null = null;\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries.filter(e => e.isDirectory()).map(e => e.name).sort();\r\n\r\n    for (const dir of dirs) {\r\n      const match = dir.match(/^(\\d+(?:\\.\\d+)?)-?(.*)/);\r\n      const phaseNumber = match ? match[1] : dir;\r\n      const phaseName = match && match[2] ? match[2] : null;\r\n\r\n      const phasePath = path.join(phasesDir, dir);\r\n      const phaseFiles = fs.readdirSync(phasePath);\r\n\r\n      const plans = phaseFiles.filter(f => f.endsWith('-PLAN.md') || f === 'PLAN.md');\r\n      const summaries = phaseFiles.filter(f => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md');\r\n      const hasResearch = phaseFiles.some(f => f.endsWith('-RESEARCH.md') || f === 'RESEARCH.md');\r\n\r\n      const status = summaries.length >= plans.length && plans.length > 0 ? 'complete' :\r\n                     plans.length > 0 ? 'in_progress' :\r\n                     hasResearch ? 'researched' : 'pending';\r\n\r\n      const phaseInfo: ProgressPhaseInfo = {\r\n        number: phaseNumber,\r\n        name: phaseName,\r\n        directory: path.join('.planning', 'phases', dir),\r\n        status,\r\n        plan_count: plans.length,\r\n        summary_count: summaries.length,\r\n        has_research: hasResearch,\r\n      };\r\n\r\n      phases.push(phaseInfo);\r\n\r\n      if (!currentPhase && (status === 'in_progress' || status === 'researched')) {\r\n        currentPhase = phaseInfo;\r\n      }\r\n      if (!nextPhase && status === 'pending') {\r\n        nextPhase = phaseInfo;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  let pausedAt: string | null = null;\r\n  try {\r\n    const state = fs.readFileSync(path.join(cwd, '.planning', 'STATE.md'), 'utf-8');\r\n    const pauseMatch = state.match(/\\*\\*Paused At:\\*\\*\\s*(.+)/);\r\n    if (pauseMatch) pausedAt = pauseMatch[1].trim();\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    if (process.env.MAXSIM_DEBUG) console.error(e);\r\n  }\r\n\r\n  const result: ProgressContext = {\r\n    executor_model: resolveModelInternal(cwd, 'maxsim-executor'),\r\n    planner_model: resolveModelInternal(cwd, 'maxsim-planner'),\r\n    commit_docs: config.commit_docs,\r\n    milestone_version: milestone.version,\r\n    milestone_name: milestone.name,\r\n    phases,\r\n    phase_count: phases.length,\r\n    completed_count: phases.filter(p => p.status === 'complete').length,\r\n    in_progress_count: phases.filter(p => p.status === 'in_progress').length,\r\n    current_phase: currentPhase,\r\n    next_phase: nextPhase,\r\n    paused_at: pausedAt,\r\n    has_work_in_progress: !!currentPhase,\r\n    project_exists: pathExistsInternal(cwd, '.planning/PROJECT.md'),\r\n    roadmap_exists: pathExistsInternal(cwd, '.planning/ROADMAP.md'),\r\n    state_exists: pathExistsInternal(cwd, '.planning/STATE.md'),\r\n    state_path: '.planning/STATE.md',\r\n    roadmap_path: '.planning/ROADMAP.md',\r\n    project_path: '.planning/PROJECT.md',\r\n    config_path: '.planning/config.json',\r\n  };\r\n\r\n  output(result, raw);\r\n}\r\n"],"mappings":"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"}