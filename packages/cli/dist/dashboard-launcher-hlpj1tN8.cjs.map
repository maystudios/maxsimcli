{"version":3,"file":"dashboard-launcher-hlpj1tN8.cjs","names":["path","fs","os"],"sources":["../src/core/dashboard-launcher.ts"],"sourcesContent":["/**\r\n * Dashboard Launcher — Shared dashboard lifecycle utilities\r\n *\r\n * Used by both cli.ts (tool-router) and install.ts (npx entry point).\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport os from 'node:os';\r\nimport { spawn, execSync } from 'node:child_process';\r\nimport { createRequire } from 'node:module';\r\n\r\n// ─── Constants ──────────────────────────────────────────────────────────────\r\n\r\nexport const DEFAULT_PORT = 3333;\r\nexport const PORT_RANGE_END = 3343;\r\nexport const HEALTH_TIMEOUT_MS = 1500;\r\n\r\n// ─── Health check ───────────────────────────────────────────────────────────\r\n\r\n/**\r\n * Check if a dashboard health endpoint is responding on the given port.\r\n */\r\nexport async function checkHealth(port: number, timeoutMs: number = HEALTH_TIMEOUT_MS): Promise<boolean> {\r\n  try {\r\n    const controller = new AbortController();\r\n    const timer = setTimeout(() => controller.abort(), timeoutMs);\r\n    const res = await fetch(`http://localhost:${port}/api/health`, {\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(timer);\r\n    if (res.ok) {\r\n      const data = await res.json() as { status?: string };\r\n      return data.status === 'ok';\r\n    }\r\n    return false;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Scan the port range for a running dashboard instance.\r\n * Returns the port number if found, null otherwise.\r\n */\r\nexport async function findRunningDashboard(timeoutMs: number = HEALTH_TIMEOUT_MS): Promise<number | null> {\r\n  for (let port = DEFAULT_PORT; port <= PORT_RANGE_END; port++) {\r\n    const running = await checkHealth(port, timeoutMs);\r\n    if (running) return port;\r\n  }\r\n  return null;\r\n}\r\n\r\n// ─── Process management ─────────────────────────────────────────────────────\r\n\r\n/**\r\n * Kill processes listening on the given port. Cross-platform.\r\n */\r\nexport function killProcessOnPort(port: number): void {\r\n  if (process.platform === 'win32') {\r\n    try {\r\n      const result = execSync(`netstat -ano | findstr :${port} | findstr LISTENING`, {\r\n        encoding: 'utf-8',\r\n      }).trim();\r\n      const lines = result.split('\\n');\r\n      const pids = new Set<string>();\r\n      for (const line of lines) {\r\n        const parts = line.trim().split(/\\s+/);\r\n        const pid = parts[parts.length - 1];\r\n        if (pid && pid !== '0') pids.add(pid);\r\n      }\r\n      for (const pid of pids) {\r\n        try {\r\n          execSync(`taskkill /PID ${pid} /F`, { stdio: 'ignore' });\r\n        } catch {\r\n          // Process may have already exited\r\n        }\r\n      }\r\n    } catch {\r\n      // No process found on port or command failed\r\n    }\r\n  } else {\r\n    try {\r\n      execSync(`lsof -i :${port} -t | xargs kill -SIGTERM 2>/dev/null`, { stdio: 'ignore' });\r\n    } catch {\r\n      // No process found on port or command failed\r\n    }\r\n  }\r\n}\r\n\r\n// ─── Server resolution ──────────────────────────────────────────────────────\r\n\r\n/**\r\n * Resolve the dashboard server entry point path.\r\n * Tries: local project install, global install, @maxsim/dashboard package, monorepo walk.\r\n */\r\nexport function resolveDashboardServer(): string | null {\r\n  // Strategy 0: Installed standalone build (production path)\r\n  const localDashboard = path.join(process.cwd(), '.claude', 'dashboard', 'server.js');\r\n  if (fs.existsSync(localDashboard)) return localDashboard;\r\n  const globalDashboard = path.join(os.homedir(), '.claude', 'dashboard', 'server.js');\r\n  if (fs.existsSync(globalDashboard)) return globalDashboard;\r\n\r\n  // Strategy 1: Resolve from @maxsim/dashboard package\r\n  try {\r\n    const require_ = createRequire(import.meta.url);\r\n    const pkgPath = require_.resolve('@maxsim/dashboard/package.json');\r\n    const pkgDir = path.dirname(pkgPath);\r\n\r\n    const serverJs = path.join(pkgDir, 'server.js');\r\n    if (fs.existsSync(serverJs)) return serverJs;\r\n\r\n    const serverTs = path.join(pkgDir, 'server.ts');\r\n    if (fs.existsSync(serverTs)) return serverTs;\r\n  } catch {\r\n    // @maxsim/dashboard not resolvable\r\n  }\r\n\r\n  // Strategy 2: Walk up from this file to find the monorepo root\r\n  try {\r\n    let dir = path.dirname(new URL(import.meta.url).pathname);\r\n    // On Windows, remove leading / from /C:/...\r\n    if (process.platform === 'win32' && dir.startsWith('/')) {\r\n      dir = dir.slice(1);\r\n    }\r\n    for (let i = 0; i < 5; i++) {\r\n      const candidate = path.join(dir, 'packages', 'dashboard', 'server.ts');\r\n      if (fs.existsSync(candidate)) return candidate;\r\n      const candidateJs = path.join(dir, 'packages', 'dashboard', 'server.js');\r\n      if (fs.existsSync(candidateJs)) return candidateJs;\r\n      dir = path.dirname(dir);\r\n    }\r\n  } catch {\r\n    // Fallback walk failed\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// ─── node-pty installation ──────────────────────────────────────────────────\r\n\r\n/**\r\n * Ensure node-pty is installed in the dashboard directory.\r\n * Returns true if node-pty is available after this call.\r\n */\r\nexport function ensureNodePty(serverDir: string): boolean {\r\n  const ptyModulePath = path.join(serverDir, 'node_modules', 'node-pty');\r\n  if (fs.existsSync(ptyModulePath)) return true;\r\n\r\n  // Ensure a package.json exists so npm install works\r\n  const dashPkgPath = path.join(serverDir, 'package.json');\r\n  if (!fs.existsSync(dashPkgPath)) {\r\n    fs.writeFileSync(dashPkgPath, '{\"private\":true}\\n');\r\n  }\r\n\r\n  try {\r\n    execSync('npm install node-pty --save-optional --no-audit --no-fund --loglevel=error', {\r\n      cwd: serverDir,\r\n      stdio: 'inherit',\r\n      timeout: 120_000,\r\n    });\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// ─── Dashboard config ───────────────────────────────────────────────────────\r\n\r\nexport interface DashboardConfig {\r\n  projectCwd: string;\r\n  networkMode: boolean;\r\n}\r\n\r\n/**\r\n * Read dashboard.json config from the parent directory of the dashboard dir.\r\n */\r\nexport function readDashboardConfig(serverPath: string): DashboardConfig {\r\n  const dashboardDir = path.dirname(serverPath);\r\n  const dashboardConfigPath = path.join(path.dirname(dashboardDir), 'dashboard.json');\r\n  let projectCwd = process.cwd();\r\n  let networkMode = false;\r\n\r\n  if (fs.existsSync(dashboardConfigPath)) {\r\n    try {\r\n      const config = JSON.parse(fs.readFileSync(dashboardConfigPath, 'utf8')) as {\r\n        projectCwd?: string;\r\n        networkMode?: boolean;\r\n      };\r\n      if (config.projectCwd) projectCwd = config.projectCwd;\r\n      networkMode = config.networkMode ?? false;\r\n    } catch {\r\n      // Use defaults\r\n    }\r\n  }\r\n\r\n  return { projectCwd, networkMode };\r\n}\r\n\r\n// ─── Spawn ──────────────────────────────────────────────────────────────────\r\n\r\nexport interface SpawnDashboardOptions {\r\n  serverPath: string;\r\n  projectCwd: string;\r\n  networkMode?: boolean;\r\n  nodeEnv?: string;\r\n}\r\n\r\n/**\r\n * Spawn the dashboard server as a detached background process.\r\n * Returns the child process PID, or null if spawn failed.\r\n */\r\nexport function spawnDashboard(options: SpawnDashboardOptions): number | null {\r\n  const { serverPath, projectCwd, networkMode = false, nodeEnv = 'production' } = options;\r\n  const serverDir = path.dirname(serverPath);\r\n\r\n  const isTsFile = serverPath.endsWith('.ts');\r\n  const runner = 'node';\r\n  const runnerArgs: string[] = isTsFile ? ['--import', 'tsx', serverPath] : [serverPath];\r\n\r\n  const child = spawn(runner, runnerArgs, {\r\n    cwd: serverDir,\r\n    detached: true,\r\n    stdio: 'ignore',\r\n    env: {\r\n      ...process.env,\r\n      MAXSIM_PROJECT_CWD: projectCwd,\r\n      MAXSIM_NETWORK_MODE: networkMode ? '1' : '0',\r\n      NODE_ENV: isTsFile ? 'development' : nodeEnv,\r\n    },\r\n    // On Windows, use shell to ensure detached works correctly\r\n    ...(process.platform === 'win32' ? { shell: true } : {}),\r\n  });\r\n\r\n  child.unref();\r\n  return child.pid ?? null;\r\n}\r\n\r\n// ─── Poll for readiness ─────────────────────────────────────────────────────\r\n\r\n/**\r\n * Poll the port range until a dashboard health endpoint responds.\r\n * Returns the URL if found within the timeout, null otherwise.\r\n */\r\nexport async function waitForDashboard(\r\n  pollIntervalMs: number = 500,\r\n  pollTimeoutMs: number = 20000,\r\n  healthTimeoutMs: number = 1000,\r\n): Promise<string | null> {\r\n  const deadline = Date.now() + pollTimeoutMs;\r\n\r\n  while (Date.now() < deadline) {\r\n    await new Promise<void>(r => setTimeout(r, pollIntervalMs));\r\n    for (let p = DEFAULT_PORT; p <= PORT_RANGE_END; p++) {\r\n      const running = await checkHealth(p, healthTimeoutMs);\r\n      if (running) return `http://localhost:${p}`;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;AAcA,MAAa,eAAe;AAC5B,MAAa,iBAAiB;AAC9B,MAAa,oBAAoB;;;;AAOjC,eAAsB,YAAY,MAAc,YAAoB,mBAAqC;AACvG,KAAI;EACF,MAAM,aAAa,IAAI,iBAAiB;EACxC,MAAM,QAAQ,iBAAiB,WAAW,OAAO,EAAE,UAAU;EAC7D,MAAM,MAAM,MAAM,MAAM,oBAAoB,KAAK,cAAc,EAC7D,QAAQ,WAAW,QACpB,CAAC;AACF,eAAa,MAAM;AACnB,MAAI,IAAI,GAEN,SADa,MAAM,IAAI,MAAM,EACjB,WAAW;AAEzB,SAAO;SACD;AACN,SAAO;;;;;;;AA2DX,SAAgB,yBAAwC;CAEtD,MAAM,iBAAiBA,kBAAK,KAAK,QAAQ,KAAK,EAAE,WAAW,aAAa,YAAY;AACpF,KAAIC,gBAAG,WAAW,eAAe,CAAE,QAAO;CAC1C,MAAM,kBAAkBD,kBAAK,KAAKE,gBAAG,SAAS,EAAE,WAAW,aAAa,YAAY;AACpF,KAAID,gBAAG,WAAW,gBAAgB,CAAE,QAAO;AAG3C,KAAI;EAEF,MAAM,uFADyC,CACtB,QAAQ,iCAAiC;EAClE,MAAM,SAASD,kBAAK,QAAQ,QAAQ;EAEpC,MAAM,WAAWA,kBAAK,KAAK,QAAQ,YAAY;AAC/C,MAAIC,gBAAG,WAAW,SAAS,CAAE,QAAO;EAEpC,MAAM,WAAWD,kBAAK,KAAK,QAAQ,YAAY;AAC/C,MAAIC,gBAAG,WAAW,SAAS,CAAE,QAAO;SAC9B;AAKR,KAAI;EACF,IAAI,MAAMD,kBAAK,QAAQ,IAAI,kDAAoB,CAAC,SAAS;AAEzD,MAAI,QAAQ,aAAa,WAAW,IAAI,WAAW,IAAI,CACrD,OAAM,IAAI,MAAM,EAAE;AAEpB,OAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;GAC1B,MAAM,YAAYA,kBAAK,KAAK,KAAK,YAAY,aAAa,YAAY;AACtE,OAAIC,gBAAG,WAAW,UAAU,CAAE,QAAO;GACrC,MAAM,cAAcD,kBAAK,KAAK,KAAK,YAAY,aAAa,YAAY;AACxE,OAAIC,gBAAG,WAAW,YAAY,CAAE,QAAO;AACvC,SAAMD,kBAAK,QAAQ,IAAI;;SAEnB;AAIR,QAAO;;;;;;AAST,SAAgB,cAAc,WAA4B;CACxD,MAAM,gBAAgBA,kBAAK,KAAK,WAAW,gBAAgB,WAAW;AACtE,KAAIC,gBAAG,WAAW,cAAc,CAAE,QAAO;CAGzC,MAAM,cAAcD,kBAAK,KAAK,WAAW,eAAe;AACxD,KAAI,CAACC,gBAAG,WAAW,YAAY,CAC7B,iBAAG,cAAc,aAAa,uBAAqB;AAGrD,KAAI;AACF,mCAAS,8EAA8E;GACrF,KAAK;GACL,OAAO;GACP,SAAS;GACV,CAAC;AACF,SAAO;SACD;AACN,SAAO;;;;;;AAcX,SAAgB,oBAAoB,YAAqC;CACvE,MAAM,eAAeD,kBAAK,QAAQ,WAAW;CAC7C,MAAM,sBAAsBA,kBAAK,KAAKA,kBAAK,QAAQ,aAAa,EAAE,iBAAiB;CACnF,IAAI,aAAa,QAAQ,KAAK;CAC9B,IAAI,cAAc;AAElB,KAAIC,gBAAG,WAAW,oBAAoB,CACpC,KAAI;EACF,MAAM,SAAS,KAAK,MAAMA,gBAAG,aAAa,qBAAqB,OAAO,CAAC;AAIvE,MAAI,OAAO,WAAY,cAAa,OAAO;AAC3C,gBAAc,OAAO,eAAe;SAC9B;AAKV,QAAO;EAAE;EAAY;EAAa;;;;;;AAgBpC,SAAgB,eAAe,SAA+C;CAC5E,MAAM,EAAE,YAAY,YAAY,cAAc,OAAO,UAAU,iBAAiB;CAChF,MAAM,YAAYD,kBAAK,QAAQ,WAAW;CAE1C,MAAM,WAAW,WAAW,SAAS,MAAM;CAI3C,MAAM,sCAHS,QACc,WAAW;EAAC;EAAY;EAAO;EAAW,GAAG,CAAC,WAAW,EAE9C;EACtC,KAAK;EACL,UAAU;EACV,OAAO;EACP,KAAK;GACH,GAAG,QAAQ;GACX,oBAAoB;GACpB,qBAAqB,cAAc,MAAM;GACzC,UAAU,WAAW,gBAAgB;GACtC;EAED,GAAI,QAAQ,aAAa,UAAU,EAAE,OAAO,MAAM,GAAG,EAAE;EACxD,CAAC;AAEF,OAAM,OAAO;AACb,QAAO,MAAM,OAAO;;;;;;AAStB,eAAsB,iBACpB,iBAAyB,KACzB,gBAAwB,KACxB,kBAA0B,KACF;CACxB,MAAM,WAAW,KAAK,KAAK,GAAG;AAE9B,QAAO,KAAK,KAAK,GAAG,UAAU;AAC5B,QAAM,IAAI,SAAc,MAAK,WAAW,GAAG,eAAe,CAAC;AAC3D,OAAK,IAAI,IAAI,cAAc,KAAK,gBAAgB,IAE9C,KADgB,MAAM,YAAY,GAAG,gBAAgB,CACxC,QAAO,oBAAoB;;AAG5C,QAAO"}