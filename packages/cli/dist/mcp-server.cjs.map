{"version":3,"file":"mcp-server.cjs","names":["os","tty","FOLDER","Buffer2","path","fs","node_process","node_buffer","node_process","path","fs","path","fs","z","fs","z","path","fs","z","fs","McpServer","StdioServerTransport"],"sources":["../../../node_modules/ms/index.js","../../../node_modules/debug/src/common.js","../../../node_modules/debug/src/browser.js","../../../node_modules/has-flag/index.js","../../../node_modules/supports-color/index.js","../../../node_modules/debug/src/node.js","../../../node_modules/debug/src/index.js","../../../node_modules/@kwsites/file-exists/dist/src/index.js","../../../node_modules/@kwsites/file-exists/dist/index.js","../../../node_modules/@kwsites/promise-deferred/dist/index.js","../../../node_modules/simple-git/dist/esm/index.js","../../../node_modules/slugify/slugify.js","../src/core/core.ts","../../../node_modules/yaml/dist/nodes/identity.js","../../../node_modules/yaml/dist/visit.js","../../../node_modules/yaml/dist/doc/directives.js","../../../node_modules/yaml/dist/doc/anchors.js","../../../node_modules/yaml/dist/doc/applyReviver.js","../../../node_modules/yaml/dist/nodes/toJS.js","../../../node_modules/yaml/dist/nodes/Node.js","../../../node_modules/yaml/dist/nodes/Alias.js","../../../node_modules/yaml/dist/nodes/Scalar.js","../../../node_modules/yaml/dist/doc/createNode.js","../../../node_modules/yaml/dist/nodes/Collection.js","../../../node_modules/yaml/dist/stringify/stringifyComment.js","../../../node_modules/yaml/dist/stringify/foldFlowLines.js","../../../node_modules/yaml/dist/stringify/stringifyString.js","../../../node_modules/yaml/dist/stringify/stringify.js","../../../node_modules/yaml/dist/stringify/stringifyPair.js","../../../node_modules/yaml/dist/log.js","../../../node_modules/yaml/dist/schema/yaml-1.1/merge.js","../../../node_modules/yaml/dist/nodes/addPairToJSMap.js","../../../node_modules/yaml/dist/nodes/Pair.js","../../../node_modules/yaml/dist/stringify/stringifyCollection.js","../../../node_modules/yaml/dist/nodes/YAMLMap.js","../../../node_modules/yaml/dist/schema/common/map.js","../../../node_modules/yaml/dist/nodes/YAMLSeq.js","../../../node_modules/yaml/dist/schema/common/seq.js","../../../node_modules/yaml/dist/schema/common/string.js","../../../node_modules/yaml/dist/schema/common/null.js","../../../node_modules/yaml/dist/schema/core/bool.js","../../../node_modules/yaml/dist/stringify/stringifyNumber.js","../../../node_modules/yaml/dist/schema/core/float.js","../../../node_modules/yaml/dist/schema/core/int.js","../../../node_modules/yaml/dist/schema/core/schema.js","../../../node_modules/yaml/dist/schema/json/schema.js","../../../node_modules/yaml/dist/schema/yaml-1.1/binary.js","../../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js","../../../node_modules/yaml/dist/schema/yaml-1.1/omap.js","../../../node_modules/yaml/dist/schema/yaml-1.1/bool.js","../../../node_modules/yaml/dist/schema/yaml-1.1/float.js","../../../node_modules/yaml/dist/schema/yaml-1.1/int.js","../../../node_modules/yaml/dist/schema/yaml-1.1/set.js","../../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js","../../../node_modules/yaml/dist/schema/yaml-1.1/schema.js","../../../node_modules/yaml/dist/schema/tags.js","../../../node_modules/yaml/dist/schema/Schema.js","../../../node_modules/yaml/dist/stringify/stringifyDocument.js","../../../node_modules/yaml/dist/doc/Document.js","../../../node_modules/yaml/dist/errors.js","../../../node_modules/yaml/dist/compose/resolve-props.js","../../../node_modules/yaml/dist/compose/util-contains-newline.js","../../../node_modules/yaml/dist/compose/util-flow-indent-check.js","../../../node_modules/yaml/dist/compose/util-map-includes.js","../../../node_modules/yaml/dist/compose/resolve-block-map.js","../../../node_modules/yaml/dist/compose/resolve-block-seq.js","../../../node_modules/yaml/dist/compose/resolve-end.js","../../../node_modules/yaml/dist/compose/resolve-flow-collection.js","../../../node_modules/yaml/dist/compose/compose-collection.js","../../../node_modules/yaml/dist/compose/resolve-block-scalar.js","../../../node_modules/yaml/dist/compose/resolve-flow-scalar.js","../../../node_modules/yaml/dist/compose/compose-scalar.js","../../../node_modules/yaml/dist/compose/util-empty-scalar-position.js","../../../node_modules/yaml/dist/compose/compose-node.js","../../../node_modules/yaml/dist/compose/compose-doc.js","../../../node_modules/yaml/dist/compose/composer.js","../../../node_modules/yaml/dist/parse/cst-scalar.js","../../../node_modules/yaml/dist/parse/cst-stringify.js","../../../node_modules/yaml/dist/parse/cst-visit.js","../../../node_modules/yaml/dist/parse/cst.js","../../../node_modules/yaml/dist/parse/lexer.js","../../../node_modules/yaml/dist/parse/line-counter.js","../../../node_modules/yaml/dist/parse/parser.js","../../../node_modules/yaml/dist/public-api.js","../../../node_modules/yaml/dist/index.js","../src/core/frontmatter.ts","../src/core/phase.ts","../src/mcp/utils.ts","../src/mcp/phase-tools.ts","../src/core/commands.ts","../src/mcp/todo-tools.ts","../../../node_modules/escape-string-regexp/index.js","../src/core/state.ts","../src/mcp/state-tools.ts","../src/mcp/index.ts","../src/mcp-server.ts"],"sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = require(\"fs\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst log = debug_1.default('@kwsites/file-exists');\nfunction check(path, isFile, isDirectory) {\n    log(`checking %s`, path);\n    try {\n        const stat = fs_1.statSync(path);\n        if (stat.isFile() && isFile) {\n            log(`[OK] path represents a file`);\n            return true;\n        }\n        if (stat.isDirectory() && isDirectory) {\n            log(`[OK] path represents a directory`);\n            return true;\n        }\n        log(`[FAIL] path represents something other than a file or directory`);\n        return false;\n    }\n    catch (e) {\n        if (e.code === 'ENOENT') {\n            log(`[FAIL] path is not accessible: %o`, e);\n            return false;\n        }\n        log(`[FATAL] %o`, e);\n        throw e;\n    }\n}\n/**\n * Synchronous validation of a path existing either as a file or as a directory.\n *\n * @param {string} path The path to check\n * @param {number} type One or both of the exported numeric constants\n */\nfunction exists(path, type = exports.READABLE) {\n    return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);\n}\nexports.exists = exists;\n/**\n * Constant representing a file\n */\nexports.FILE = 1;\n/**\n * Constant representing a folder\n */\nexports.FOLDER = 2;\n/**\n * Constant representing either a file or a folder\n */\nexports.READABLE = exports.FILE + exports.FOLDER;\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./src\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDeferred = exports.deferred = void 0;\n/**\n * Creates a new `DeferredPromise`\n *\n * ```typescript\n import {deferred} from '@kwsites/promise-deferred`;\n ```\n */\nfunction deferred() {\n    let done;\n    let fail;\n    let status = 'pending';\n    const promise = new Promise((_done, _fail) => {\n        done = _done;\n        fail = _fail;\n    });\n    return {\n        promise,\n        done(result) {\n            if (status === 'pending') {\n                status = 'resolved';\n                done(result);\n            }\n        },\n        fail(error) {\n            if (status === 'pending') {\n                status = 'rejected';\n                fail(error);\n            }\n        },\n        get fulfilled() {\n            return status !== 'pending';\n        },\n        get status() {\n            return status;\n        },\n    };\n}\nexports.deferred = deferred;\n/**\n * Alias of the exported `deferred` function, to help consumers wanting to use `deferred` as the\n * local variable name rather than the factory import name, without needing to rename on import.\n *\n * ```typescript\n import {createDeferred} from '@kwsites/promise-deferred`;\n ```\n */\nexports.createDeferred = deferred;\n/**\n * Default export allows use as:\n *\n * ```typescript\n import deferred from '@kwsites/promise-deferred`;\n ```\n */\nexports.default = deferred;\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    \"use strict\";\n    cache = /* @__PURE__ */ new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    \"use strict\";\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\nimport { Buffer as Buffer2 } from \"node:buffer\";\nimport { exists, FOLDER } from \"@kwsites/file-exists\";\nfunction asFunction(source) {\n  if (typeof source !== \"function\") {\n    return NOOP;\n  }\n  return source;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return filterHasLength(input);\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return exists(path, FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asCamelCase(str) {\n  return str.replace(/[\\s-]+(.)/g, (_all, chr) => {\n    return chr.toUpperCase();\n  });\n}\nfunction asStringArray(source) {\n  return asArray(source).map((item) => {\n    return item instanceof String ? item : String(item);\n  });\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return Number.isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? Buffer2.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  const out = {};\n  properties.forEach((key) => {\n    if (source[key] !== void 0) {\n      out[key] = source[key];\n    }\n  });\n  return out;\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nfunction orVoid(input) {\n  if (input === false) {\n    return void 0;\n  }\n  return input;\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterNumber, filterString, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    \"use strict\";\n    init_pathspec();\n    init_util();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterNumber = (input) => {\n      return typeof input === \"number\";\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    \"use strict\";\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    \"use strict\";\n    GitOutputStreams = class _GitOutputStreams {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new _GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nfunction useMatchesDefault() {\n  throw new Error(`LineParser:useMatches not implemented`);\n}\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    \"use strict\";\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.useMatches = useMatchesDefault;\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(\n    { baseDir, ...defaultOptions },\n    ...options.filter((o) => typeof o === \"object\" && o)\n  );\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    \"use strict\";\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else if (Array.isArray(value)) {\n      for (const v of value) {\n        if (!filterPrimitives(v, [\"string\", \"number\"])) {\n          commands2.push(key + \"=\" + v);\n        }\n      }\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return asStringArray(filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []));\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser4, streams) {\n  return parser4(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    \"use strict\";\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asCamelCase: () => asCamelCase,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterNumber: () => filterNumber,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  orVoid: () => orVoid,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    \"use strict\";\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser4) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser4\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    \"use strict\";\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    \"use strict\";\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    \"use strict\";\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!Object.hasOwn(values, key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && Object.hasOwn(GitConfigScope, scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(\n        addConfigTask(\n          key,\n          value,\n          rest[0] === true,\n          asConfigScope(rest[1], \"local\" /* local */)\n        ),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    getConfig(key, scope) {\n      return this._runTask(\n        getConfigTask(key, asConfigScope(scope, void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    listConfig(...rest) {\n      return this._runTask(\n        listConfigTask(asConfigScope(rest[0], void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    \"use strict\";\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/diff-name-status.ts\nfunction isDiffNameStatus(input) {\n  return diffNameStatus.has(input);\n}\nvar DiffNameStatus, diffNameStatus;\nvar init_diff_name_status = __esm({\n  \"src/lib/tasks/diff-name-status.ts\"() {\n    \"use strict\";\n    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {\n      DiffNameStatus2[\"ADDED\"] = \"A\";\n      DiffNameStatus2[\"COPIED\"] = \"C\";\n      DiffNameStatus2[\"DELETED\"] = \"D\";\n      DiffNameStatus2[\"MODIFIED\"] = \"M\";\n      DiffNameStatus2[\"RENAMED\"] = \"R\";\n      DiffNameStatus2[\"CHANGED\"] = \"T\";\n      DiffNameStatus2[\"UNMERGED\"] = \"U\";\n      DiffNameStatus2[\"UNKNOWN\"] = \"X\";\n      DiffNameStatus2[\"BROKEN\"] = \"B\";\n      return DiffNameStatus2;\n    })(DiffNameStatus || {});\n    diffNameStatus = new Set(Object.values(DiffNameStatus));\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(\n            configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n            then\n          );\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask(\n        {\n          commands,\n          format: \"utf-8\",\n          parser(stdOut) {\n            return parseGrep(stdOut);\n          }\n        },\n        then\n      );\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return typeof mode === \"string\" && validResetModes.includes(mode);\n}\nvar ResetMode, validResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    validResetModes = asStringArray(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\nimport debug from \"debug\";\nfunction createLog() {\n  return debug(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(\n      spawned,\n      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n    );\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    \"use strict\";\n    init_utils();\n    debug.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    debug.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_git_logger();\n    TasksPendingQueue = class _TasksPendingQueue {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n          } else {\n            logger.info(\n              `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n              err.message\n            );\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n      static {\n        this.counter = 0;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\nimport { spawn } from \"child_process\";\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      async attemptTask(task) {\n        const onScheduleComplete = await this._scheduler.next();\n        const onQueueComplete = () => this._queue.complete(task);\n        try {\n          const { logger } = this._queue.attempt(task);\n          return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));\n        } catch (e) {\n          throw this.onFatalException(task, e);\n        } finally {\n          onQueueComplete();\n          onScheduleComplete();\n        }\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      async attemptRemoteTask(task, logger) {\n        const binary = this._plugins.exec(\"spawn.binary\", \"\", pluginContext(task, task.commands));\n        const args = this._plugins.exec(\n          \"spawn.args\",\n          [...task.commands],\n          pluginContext(task, task.commands)\n        );\n        const raw = await this.gitResponse(\n          task,\n          binary,\n          args,\n          this.outputHandler,\n          logger.step(\"SPAWN\")\n        );\n        const outputStreams = await this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n        logger(`passing response to task's parser as a %s`, task.format);\n        if (isBufferTask(task)) {\n          return callTaskParser(task.parser, outputStreams);\n        }\n        return callTaskParser(task.parser, outputStreams.asStrings());\n      }\n      async attemptEmptyTask(task, logger) {\n        logger(`empty task bypassing child process to call to task's parser`);\n        return task.parser(this);\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\n            \"task.error\",\n            { error: rejection },\n            {\n              ...pluginContext(task, args),\n              ...result\n            }\n          );\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(\n              result,\n              error,\n              (newStdOut) => {\n                logger.info(`custom error handler treated as success`);\n                logger(`custom error returned a %s`, objectToString(newStdOut));\n                done(\n                  new GitOutputStreams(\n                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                    Buffer.concat(stdErr)\n                  )\n                );\n              },\n              fail\n            );\n          }\n          if (error) {\n            logger.info(\n              `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n              exitCode,\n              stdErr.length,\n              rejection\n            );\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      async gitResponse(task, command, args, outputHandler, logger) {\n        const outputLogger = logger.sibling(\"output\");\n        const spawnOptions = this._plugins.exec(\n          \"spawn.options\",\n          {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true\n          },\n          pluginContext(task, task.commands)\n        );\n        return new Promise((done) => {\n          const stdOut = [];\n          const stdErr = [];\n          logger.info(`%s %o`, command, args);\n          logger(\"%O\", spawnOptions);\n          let rejection = this._beforeSpawn(task, args);\n          if (rejection) {\n            return done({\n              stdOut,\n              stdErr,\n              exitCode: 9901,\n              rejection\n            });\n          }\n          this._plugins.exec(\"spawn.before\", void 0, {\n            ...pluginContext(task, args),\n            kill(reason) {\n              rejection = reason || rejection;\n            }\n          });\n          const spawned = spawn(command, args, spawnOptions);\n          spawned.stdout.on(\n            \"data\",\n            onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\"))\n          );\n          spawned.stderr.on(\n            \"data\",\n            onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\"))\n          );\n          spawned.on(\"error\", onErrorReceived(stdErr, logger));\n          if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n          }\n          this._plugins.exec(\"spawn.after\", void 0, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode, reason) {\n              done({\n                stdOut,\n                stdErr,\n                exitCode,\n                rejection: rejection || reason\n              });\n            },\n            kill(reason) {\n              if (spawned.killed) {\n                return;\n              }\n              rejection = reason;\n              spawned.kill(\"SIGINT\");\n            }\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, {\n          ...pluginContext(task, args),\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        });\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    \"use strict\";\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(cwd, _scheduler, _plugins) {\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if (err?.task === task) {\n      callback(\n        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n        void 0\n      );\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(\n      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n    );\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(\n        checkoutTask(getTrailingOptions(arguments, 1)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/count-objects.ts\nfunction countObjectsResponse() {\n  return {\n    count: 0,\n    garbage: 0,\n    inPack: 0,\n    packs: 0,\n    prunePackable: 0,\n    size: 0,\n    sizeGarbage: 0,\n    sizePack: 0\n  };\n}\nfunction count_objects_default() {\n  return {\n    countObjects() {\n      return this._runTask({\n        commands: [\"count-objects\", \"--verbose\"],\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);\n        }\n      });\n    }\n  };\n}\nvar parser2;\nvar init_count_objects = __esm({\n  \"src/lib/tasks/count-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    parser2 = new LineParser(\n      /([a-z-]+): (\\d+)$/,\n      (result, [key, value]) => {\n        const property = asCamelCase(key);\n        if (Object.hasOwn(result, property)) {\n          result[property] = asNumber(value);\n        }\n      }\n    );\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(\n        /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n        (result, [changes, insertions, deletions]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          result.summary.insertions = parseInt(insertions, 10) || 0;\n          result.summary.deletions = parseInt(deletions, 10) || 0;\n        }\n      ),\n      new LineParser(\n        /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n        (result, [changes, lines, direction]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          const count = parseInt(lines, 10) || 0;\n          if (direction === \"-\") {\n            result.summary.deletions = count;\n          } else if (direction === \"+\") {\n            result.summary.insertions = count;\n          }\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(\n        asArray(message),\n        asArray(filterType(rest[0], filterStringOrStringArray, [])),\n        [\n          ...asStringArray(filterType(rest[1], filterArray, [])),\n          ...getTrailingOptions(arguments, 0, true)\n        ]\n      );\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(\n      `git.commit: requires the commit message to be supplied as a string/string[]`\n    );\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    \"use strict\";\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(\n        straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    \"use strict\";\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    \"use strict\";\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    \"use strict\";\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    \"use strict\";\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser4 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_DiffSummary();\n    init_diff_name_status();\n    init_utils();\n    statParser = [\n      new LineParser(\n        /^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n        (result, [file, changes, alterations = \"\"]) => {\n          result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, \"\").length,\n            deletions: alterations.replace(/[^-]/g, \"\").length,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(\n        /^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n        (result, [file, before, after]) => {\n          result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true\n          });\n        }\n      ),\n      new LineParser(\n        /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n        (result, [changed, summary]) => {\n          const inserted = /(\\d+) i/.exec(summary);\n          const deleted = /(\\d+) d/.exec(summary);\n          result.changed = asNumber(changed);\n          result.insertions = asNumber(inserted?.[1]);\n          result.deletions = asNumber(deleted?.[1]);\n        }\n      )\n    ];\n    numStatParser = [\n      new LineParser(\n        /(\\d+)\\t(\\d+)\\t(.+)$/,\n        (result, [changesInsert, changesDelete, file]) => {\n          const insertions = asNumber(changesInsert);\n          const deletions = asNumber(changesDelete);\n          result.changed++;\n          result.insertions += insertions;\n          result.deletions += deletions;\n          result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(\n        /([ACDMRTUXB])([0-9]{0,3})\\t(.[^\\t]*)(\\t(.[^\\t]*))?$/,\n        (result, [status, similarity, from, _to, to]) => {\n          result.changed++;\n          result.files.push({\n            file: to ?? from,\n            changes: 0,\n            insertions: 0,\n            deletions: 0,\n            binary: false,\n            status: orVoid(isDiffNameStatus(status) && status),\n            from: orVoid(!!to && from !== to && from),\n            similarity: asNumber(similarity)\n          });\n        }\n      )\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce(\n    (line, field, index) => {\n      line[field] = tokens[index] || \"\";\n      return line;\n    },\n    /* @__PURE__ */ Object.create({ diff: null })\n  );\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(\n      stdOut.trim(),\n      false,\n      START_BOUNDARY\n    ).map(function(item) {\n      const lineDetail = item.split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(\n      `Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`\n    );\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(\n      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n    );\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = filterPlainObject(opt.format) ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(\n        trailingOptionsArgument(arguments),\n        asStringArray(filterType(arguments[0], filterArray, []))\n      );\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(\n      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n    );\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    \"use strict\";\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    \"use strict\";\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n        (result, [total, reused, packReused]) => {\n          const objects = objectEnumerationResult(result.remoteMessages);\n          objects.total = asObjectCount(total);\n          objects.reused = asObjectCount(reused);\n          objects.packReused = asNumber(packReused);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n        [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [pullRequestUrl]) => {\n          result.remoteMessages.pullRequestUrl = pullRequestUrl;\n        }\n      ),\n      new RemoteLineParser(\n        [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [count, summary, url]) => {\n          result.remoteMessages.vulnerabilities = {\n            count: asNumber(count),\n            summary,\n            url\n          };\n        }\n      )\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    \"use strict\";\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(\n        /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n          result.branch.local = branchLocal;\n          result.hash.local = hashLocal;\n          result.branch.remote = branchRemote;\n          result.hash.remote = hashRemote;\n        }\n      )\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(\n        new PullSummary(),\n        parsePullDetail(stdOut, stdErr),\n        parseRemoteMessages(stdOut, stdErr)\n      );\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    \"use strict\";\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(\n        /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n        (summary, [reason, file, deleteRef]) => {\n          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n        }\n      ),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = {\n          ...result.ref || {},\n          local\n        };\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(\n        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n        (result, [local, remote, remoteName]) => {\n          result.branch = {\n            ...result.branch || {},\n            local,\n            remote,\n            remoteName\n          };\n        }\n      ),\n      new LineParser(\n        /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n        (result, [local, remote, from, to]) => {\n          result.update = {\n            head: {\n              local,\n              remote\n            },\n            hash: {\n              from,\n              to\n            }\n          };\n        }\n      )\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return {\n        ...pushDetail,\n        ...responseDetail\n      };\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    \"use strict\";\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(\n        straightThroughBufferTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(\n        straightThroughStringTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    \"use strict\";\n    fromPathRegex = /^(.+)\\0(.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index === \"R\" || working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[2] || \"\";\n          this.path = detail[1] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser3(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser3(indexX, y, (result, file) => result.conflicted.push(file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.slice(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.slice(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path, index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser3(\n        \" \" /* NONE */,\n        \"A\" /* ADDED */,\n        (result, file) => result.created.push(file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"D\" /* DELETED */,\n        (result, file) => result.deleted.push(file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"M\" /* MODIFIED */,\n        (result, file) => result.modified.push(file)\n      ),\n      parser3(\"A\" /* ADDED */, \" \" /* NONE */, (result, file) => {\n        result.created.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"A\" /* ADDED */, \"M\" /* MODIFIED */, (result, file) => {\n        result.created.push(file);\n        result.staged.push(file);\n        result.modified.push(file);\n      }),\n      parser3(\"D\" /* DELETED */, \" \" /* NONE */, (result, file) => {\n        result.deleted.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"M\" /* MODIFIED */, \" \" /* NONE */, (result, file) => {\n        result.modified.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"M\" /* MODIFIED */, \"M\" /* MODIFIED */, (result, file) => {\n        result.modified.push(file);\n        result.staged.push(file);\n      }),\n      parser3(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        result.renamed.push(renamedFile(file));\n      }),\n      parser3(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        result.renamed.push(renamed);\n        result.modified.push(renamed.to);\n      }),\n      parser3(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        (_result.ignored = _result.ignored || []).push(_file);\n      }),\n      parser3(\n        \"?\" /* UNTRACKED */,\n        \"?\" /* UNTRACKED */,\n        (result, file) => result.not_added.push(file)\n      ),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\n        \"D\" /* DELETED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      ...conflicts(\n        \"U\" /* UNMERGED */,\n        \"A\" /* ADDED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s(\\S+?)(?=\\.{3}|$)/;\n          let regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = filterType(regexResult?.[1], filterString, null);\n          regexResult = trackingReg.exec(line);\n          result.tracking = filterType(regexResult?.[1], filterString, null);\n          regexResult = onEmptyBranchReg.exec(line);\n          if (regexResult) {\n            result.current = filterType(regexResult?.[1], filterString, result.current);\n          }\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    \"use strict\";\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty(\n    {\n      major,\n      minor,\n      patch,\n      agent,\n      installed\n    },\n    \"toString\",\n    {\n      value() {\n        return `${this.major}.${this.minor}.${this.patch}`;\n      },\n      configurable: false,\n      enumerable: false\n    }\n  );\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    \"use strict\";\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n          );\n        }\n      ),\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    \"use strict\";\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_count_objects();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(\n          straightThroughStringTask([\"add\", ...asArray(files)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof directory?.path === \"string\") {\n          return this._runTask(\n            changeWorkingDirectoryTask(\n              directory.path,\n              directory.root && this._executor || void 0\n            ),\n            next\n          );\n        }\n        return this._runTask(\n          configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"),\n          next\n        );\n      }\n      hashObject(path, write) {\n        return this._runTask(\n          hashObjectTask(path, write === true),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      init(bare) {\n        return this._runTask(\n          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      merge() {\n        return this._runTask(\n          mergeTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(\n            configurationErrorTask(\n              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n          );\n        }\n        return this._runTask(\n          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments, false)\n        );\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask(\n          {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString)\n          },\n          getTrailingOptions(arguments)\n        );\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(\n          straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      status() {\n        return this._runTask(\n          statusTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n    };\n    Object.assign(\n      SimpleGitApi.prototype,\n      checkout_default(),\n      commit_default(),\n      config_default(),\n      count_objects_default(),\n      first_commit_default(),\n      grep_default(),\n      log_default(),\n      show_default(),\n      version_default()\n    );\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\nimport { createDeferred } from \"@kwsites/promise-deferred\";\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_git_logger();\n    createScheduledTask = /* @__PURE__ */ (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = createDeferred();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n          );\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    \"use strict\";\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    \"use strict\";\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    \"use strict\";\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut, currentOnly = false) {\n  return parseStringResponse(\n    new BranchSummaryResult(),\n    currentOnly ? [currentBranchParser] : parsers9,\n    stdOut\n  );\n}\nvar parsers9, currentBranchParser;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    \"use strict\";\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(\n        /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), true, name, commit, label);\n        }\n      ),\n      new LineParser(\n        /^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), false, name, commit, label);\n        }\n      )\n    ];\n    currentBranchParser = new LineParser(/^(\\S+)$/s, (result, [name]) => {\n      result.push(\"*\" /* CURRENT */, false, name, \"\", \"\");\n    });\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const isCurrentOnly = customArgs.includes(\"--show-current\");\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut, isCurrentOnly);\n    }\n  };\n}\nfunction branchLocalTask() {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser(stdOut) {\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(\n        task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n        String(error)\n      );\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\nimport { normalize } from \"node:path\";\nfunction toPath(input) {\n  const path = input.trim().replace(/^[\"']|[\"']$/g, \"\");\n  return path && normalize(path);\n}\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    \"use strict\";\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map(toPath).filter(Boolean);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    \"use strict\";\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    \"use strict\";\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(\n        /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n        (result, [from, to, name, tracking]) => {\n          result.updated.push({\n            name,\n            tracking,\n            to,\n            from\n          });\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    \"use strict\";\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    \"use strict\";\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(\n        bufferToString(result.stdOut),\n        bufferToString(result.stdErr)\n      );\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!Object.hasOwn(remotes, name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    \"use strict\";\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser4 = createListLogSummaryParser(\n    options.splitter,\n    options.fields,\n    logFormatFromCommand(commands)\n  );\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = Number.isNaN(a);\n  const bIsNum = Number.isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    \"use strict\";\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    \"use strict\";\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    \"use strict\";\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { adhocExecTask: adhocExecTask2, configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._plugins = plugins;\n      this._executor = new GitExecutor2(\n        options.baseDir,\n        new Scheduler2(options.maxConcurrentProcesses),\n        plugins\n      );\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._plugins.reconfigure(\"binary\", command);\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(\n        stashListTask2(\n          trailingOptionsArgument2(arguments) || {},\n          filterArray2(options) && options || []\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(\n        createCloneTask(\"clone\", cloneTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(\n        createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(\n        pullTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(\n        fetchTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.silent = function(silence) {\n      return this._runTask(\n        adhocExecTask2(\n          () => console.warn(\n            \"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this method will be removed.\"\n          )\n        )\n      );\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(\n        tagListTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(\n        straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(\n        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(\n        straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]),\n        next\n      );\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(\n        addAnnotatedTagTask2(tagName, tagMessage),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(\n        deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(\n        deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(\n        branchTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(\n          configurationErrorTask2(\"Raw: must supply one or more command to execute\"),\n          next\n        );\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(\n        updateSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(\n        initSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(\n        subModuleTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(\n        listRemotesTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(\n        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(\n        remoteTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(\n        straightThroughStringTask2([\"update-server-info\"]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2(\n        { remote: filterType2(remote, filterString2) },\n        getTrailingOptions2(arguments)\n      );\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(\n          configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"),\n          handler\n        );\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\n        \"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\"\n      ) : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(\n        diffSummaryTask2(getTrailingOptions2(arguments, 1)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(\n        `git.applyPatch requires one or more string patches as the first argument`\n      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(\n        straightThroughStringTask2(commands, true),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(\n        cleanWithOptionsTask2(cleanMode, customArgs),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this._runTask(\n        adhocExecTask2(\n          () => console.warn(\n            \"simple-git deprecation notice: clearQueue() is deprecated and will be removed, switch to using the abortPlugin instead.\"\n          )\n        )\n      );\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(\n        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(\n        checkIsRepoTask2(filterType2(checkType, filterString2)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_diff_name_status();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction isCloneSwitch(char, arg) {\n  if (typeof arg !== \"string\" || !arg.includes(char)) {\n    return false;\n  }\n  const token = arg.replace(/\\0g/, \"\").replace(/^(--no)?-{1,2}/, \"\");\n  return /^[\\dlsqvnobucj]+\\b/.test(token);\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(\n    void 0,\n    \"unsafe\",\n    \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\"\n  );\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"clone\" && isCloneSwitch(\"u\", arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n    );\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\nimport { deferred } from \"@kwsites/promise-deferred\";\nvar never = deferred().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: deferred(),\n      closeTimeout: deferred(),\n      exit: deferred(),\n      exitTimeout: deferred()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    async action(_data, { spawned, close }) {\n      const events = createEvents();\n      let deferClose = true;\n      let quickClose = () => void (deferClose = false);\n      spawned.stdout?.on(\"data\", quickClose);\n      spawned.stderr?.on(\"data\", quickClose);\n      spawned.on(\"error\", quickClose);\n      spawned.on(\"close\", (code) => events.close(code));\n      spawned.on(\"exit\", (code) => events.exit(code));\n      try {\n        await events.result;\n        if (deferClose) {\n          await delay(50);\n        }\n        close(events.exitCode);\n      } catch (err) {\n        close(events.exitCode, err);\n      }\n    }\n  };\n}\n\n// src/lib/plugins/custom-binary.plugin.ts\ninit_utils();\nvar WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;\nvar WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;\nfunction isBadArgument(arg) {\n  return !arg || !/^([a-z]:)?([a-z0-9/.\\\\_~-]+)$/i.test(arg);\n}\nfunction toBinaryConfig(input, allowUnsafe) {\n  if (input.length < 1 || input.length > 2) {\n    throw new GitPluginError(void 0, \"binary\", WRONG_NUMBER_ERR);\n  }\n  const isBad = input.some(isBadArgument);\n  if (isBad) {\n    if (allowUnsafe) {\n      console.warn(WRONG_CHARS_ERR);\n    } else {\n      throw new GitPluginError(void 0, \"binary\", WRONG_CHARS_ERR);\n    }\n  }\n  const [binary, prefix] = input;\n  return {\n    binary,\n    prefix\n  };\n}\nfunction customBinaryPlugin(plugins, input = [\"git\"], allowUnsafe = false) {\n  let config = toBinaryConfig(asArray(input), allowUnsafe);\n  plugins.on(\"binary\", (input2) => {\n    config = toBinaryConfig(asArray(input2), allowUnsafe);\n  });\n  plugins.append(\"spawn.binary\", () => {\n    return config.binary;\n  });\n  plugins.append(\"spawn.args\", (data) => {\n    return config.prefix ? [config.prefix, ...data] : data;\n  });\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\nimport { EventEmitter } from \"node:events\";\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */ new Set();\n    this.events = new EventEmitter();\n  }\n  on(type, listener) {\n    this.events.on(type, listener);\n  }\n  reconfigure(type, data) {\n    this.events.emit(type, data);\n  }\n  append(type, action) {\n    const plugin = append(this.plugins, { type, action });\n    return () => this.plugins.delete(plugin);\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      context.spawned.stderr?.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return { ...options, ...data };\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          context.spawned.stdout?.off(\"data\", wait);\n          context.spawned.stderr?.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && context.spawned.stdout?.on(\"data\", wait);\n        stdErr && context.spawned.stderr?.on(\"data\", wait);\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(\n            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)\n          );\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(\n    baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {},\n    options\n  );\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(\n      config,\n      `Cannot use simple-git on a directory that does not exist`\n    );\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  customBinaryPlugin(plugins, config.binary, config.unsafe?.allowUnsafeCustomBinary);\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\n  \"add\",\n  \"addAnnotatedTag\",\n  \"addConfig\",\n  \"addRemote\",\n  \"addTag\",\n  \"applyPatch\",\n  \"binaryCatFile\",\n  \"branch\",\n  \"branchLocal\",\n  \"catFile\",\n  \"checkIgnore\",\n  \"checkIsRepo\",\n  \"checkout\",\n  \"checkoutBranch\",\n  \"checkoutLatestTag\",\n  \"checkoutLocalBranch\",\n  \"clean\",\n  \"clone\",\n  \"commit\",\n  \"cwd\",\n  \"deleteLocalBranch\",\n  \"deleteLocalBranches\",\n  \"diff\",\n  \"diffSummary\",\n  \"exec\",\n  \"fetch\",\n  \"getRemotes\",\n  \"init\",\n  \"listConfig\",\n  \"listRemote\",\n  \"log\",\n  \"merge\",\n  \"mergeFromTo\",\n  \"mirror\",\n  \"mv\",\n  \"pull\",\n  \"push\",\n  \"pushTags\",\n  \"raw\",\n  \"rebase\",\n  \"remote\",\n  \"removeRemote\",\n  \"reset\",\n  \"revert\",\n  \"revparse\",\n  \"rm\",\n  \"rmKeepLocal\",\n  \"show\",\n  \"stash\",\n  \"stashList\",\n  \"status\",\n  \"subModule\",\n  \"submoduleAdd\",\n  \"submoduleInit\",\n  \"submoduleUpdate\",\n  \"tag\",\n  \"tags\",\n  \"updateServerInfo\"\n];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n    (api, name) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n      Object.defineProperty(api, name, {\n        enumerable: false,\n        configurable: false,\n        value: git ? valid : alternative\n      });\n      return api;\n    },\n    {}\n  );\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\n          \"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn\n        );\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\nexport {\n  CheckRepoActions,\n  CleanOptions,\n  DiffNameStatus,\n  GitConfigScope,\n  GitConstructError,\n  GitError,\n  GitPluginError,\n  GitResponseError,\n  ResetMode,\n  TaskConfigurationError,\n  esm_default as default,\n  gitP,\n  grepQueryBuilder,\n  pathspec,\n  simpleGit\n};\n//# sourceMappingURL=index.js.map\n","\n;(function (name, root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory()\n    module.exports['default'] = factory()\n  }\n  /* istanbul ignore next */\n  else if (typeof define === 'function' && define.amd) {\n    define(factory)\n  }\n  else {\n    root[name] = factory()\n  }\n}('slugify', this, function () {\n  var charMap = JSON.parse('{\"$\":\"dollar\",\"%\":\"percent\",\"&\":\"and\",\"<\":\"less\",\">\":\"greater\",\"|\":\"or\",\"\":\"cent\",\"\":\"pound\",\"\":\"currency\",\"\":\"yen\",\"\":\"(c)\",\"\":\"a\",\"\":\"(r)\",\"\":\"o\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"AE\",\"\":\"C\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"D\",\"\":\"N\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"Y\",\"\":\"TH\",\"\":\"ss\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"ae\",\"\":\"c\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"d\",\"\":\"n\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"y\",\"\":\"th\",\"\":\"y\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"C\",\"\":\"c\",\"\":\"C\",\"\":\"c\",\"\":\"D\",\"\":\"d\",\"\":\"DJ\",\"\":\"dj\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"G\",\"\":\"g\",\"\":\"G\",\"\":\"g\",\"\":\"I\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"k\",\"\":\"k\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"OE\",\"\":\"oe\",\"\":\"R\",\"\":\"r\",\"\":\"R\",\"\":\"r\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"T\",\"\":\"t\",\"\":\"U\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"W\",\"\":\"w\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"E\",\"\":\"f\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"LJ\",\"\":\"lj\",\"\":\"NJ\",\"\":\"nj\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"e\",\"\":\"o\",\"\":\"A\",\"\":\"E\",\"\":\"H\",\"\":\"I\",\"\":\"O\",\"\":\"Y\",\"\":\"W\",\"\":\"i\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"H\",\"\":\"8\",\"\":\"I\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"3\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"Y\",\"\":\"F\",\"\":\"X\",\"\":\"PS\",\"\":\"W\",\"\":\"I\",\"\":\"Y\",\"\":\"a\",\"\":\"e\",\"\":\"h\",\"\":\"i\",\"\":\"y\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"z\",\"\":\"h\",\"\":\"8\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"3\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"s\",\"\":\"t\",\"\":\"y\",\"\":\"f\",\"\":\"x\",\"\":\"ps\",\"\":\"w\",\"\":\"i\",\"\":\"y\",\"\":\"o\",\"\":\"y\",\"\":\"w\",\"\":\"Yo\",\"\":\"DJ\",\"\":\"Ye\",\"\":\"I\",\"\":\"Yi\",\"\":\"J\",\"\":\"LJ\",\"\":\"NJ\",\"\":\"C\",\"\":\"DZ\",\"\":\"A\",\"\":\"B\",\"\":\"V\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Zh\",\"\":\"Z\",\"\":\"I\",\"\":\"J\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"U\",\"\":\"F\",\"\":\"H\",\"\":\"C\",\"\":\"Ch\",\"\":\"Sh\",\"\":\"Sh\",\"\":\"U\",\"\":\"Y\",\"\":\"\",\"\":\"E\",\"\":\"Yu\",\"\":\"Ya\",\"\":\"a\",\"\":\"b\",\"\":\"v\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"zh\",\"\":\"z\",\"\":\"i\",\"\":\"j\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"h\",\"\":\"c\",\"\":\"ch\",\"\":\"sh\",\"\":\"sh\",\"\":\"u\",\"\":\"y\",\"\":\"\",\"\":\"e\",\"\":\"yu\",\"\":\"ya\",\"\":\"yo\",\"\":\"dj\",\"\":\"ye\",\"\":\"i\",\"\":\"yi\",\"\":\"j\",\"\":\"lj\",\"\":\"nj\",\"\":\"c\",\"\":\"u\",\"\":\"dz\",\"\":\"G\",\"\":\"g\",\"\":\"GH\",\"\":\"gh\",\"\":\"KH\",\"\":\"kh\",\"\":\"NG\",\"\":\"ng\",\"\":\"UE\",\"\":\"ue\",\"\":\"U\",\"\":\"u\",\"\":\"H\",\"\":\"h\",\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"E\\'\",\"\":\"Y\\'\",\"\":\"T\\'\",\"\":\"JH\",\"\":\"I\",\"\":\"L\",\"\":\"X\",\"\":\"C\\'\",\"\":\"K\",\"\":\"H\",\"\":\"D\\'\",\"\":\"GH\",\"\":\"TW\",\"\":\"M\",\"\":\"Y\",\"\":\"N\",\"\":\"SH\",\"\":\"CH\",\"\":\"P\",\"\":\"J\",\"\":\"R\\'\",\"\":\"S\",\"\":\"V\",\"\":\"T\",\"\":\"R\",\"\":\"C\",\"\":\"P\\'\",\"\":\"Q\\'\",\"\":\"O\\'\\'\",\"\":\"F\",\"\":\"EV\",\"\":\"a\",\"\":\"aa\",\"\":\"a\",\"\":\"u\",\"\":\"i\",\"\":\"e\",\"\":\"a\",\"\":\"b\",\"\":\"h\",\"\":\"t\",\"\":\"th\",\"\":\"j\",\"\":\"h\",\"\":\"kh\",\"\":\"d\",\"\":\"th\",\"\":\"r\",\"\":\"z\",\"\":\"s\",\"\":\"sh\",\"\":\"s\",\"\":\"dh\",\"\":\"t\",\"\":\"z\",\"\":\"a\",\"\":\"gh\",\"\":\"f\",\"\":\"q\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"h\",\"\":\"w\",\"\":\"a\",\"\":\"y\",\"\":\"an\",\"\":\"on\",\"\":\"en\",\"\":\"a\",\"\":\"u\",\"\":\"e\",\"\":\"\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"p\",\"\":\"ch\",\"\":\"zh\",\"\":\"k\",\"\":\"g\",\"\":\"y\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"baht\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"v\",\"\":\"z\",\"\":\"t\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"zh\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"k\",\"\":\"gh\",\"\":\"q\",\"\":\"sh\",\"\":\"ch\",\"\":\"ts\",\"\":\"dz\",\"\":\"ts\",\"\":\"ch\",\"\":\"kh\",\"\":\"j\",\"\":\"h\",\"\":\"S\",\"\":\"s\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"SS\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"-\",\"\":\"\\'\",\"\":\"\\'\",\"\":\"\\\\\\\"\",\"\":\"\\\\\\\"\",\"\":\"\\\\\\\"\",\"\":\"+\",\"\":\"*\",\"\":\"...\",\"\":\"ecu\",\"\":\"cruzeiro\",\"\":\"french franc\",\"\":\"lira\",\"\":\"mill\",\"\":\"naira\",\"\":\"peseta\",\"\":\"rupee\",\"\":\"won\",\"\":\"new shequel\",\"\":\"dong\",\"\":\"euro\",\"\":\"kip\",\"\":\"tugrik\",\"\":\"drachma\",\"\":\"penny\",\"\":\"peso\",\"\":\"guarani\",\"\":\"austral\",\"\":\"hryvnia\",\"\":\"cedi\",\"\":\"kazakhstani tenge\",\"\":\"indian rupee\",\"\":\"turkish lira\",\"\":\"russian ruble\",\"\":\"bitcoin\",\"\":\"sm\",\"\":\"tm\",\"\":\"d\",\"\":\"delta\",\"\":\"sum\",\"\":\"infinity\",\"\":\"love\",\"\":\"yuan\",\"\":\"yen\",\"\":\"rial\",\"\":\"laa\",\"\":\"laa\",\"\":\"lai\",\"\":\"la\"}')\n  var locales = JSON.parse('{\"bg\":{\"\":\"Y\",\"\":\"Ts\",\"\":\"Sht\",\"\":\"A\",\"\":\"Y\",\"\":\"y\",\"\":\"ts\",\"\":\"sht\",\"\":\"a\",\"\":\"y\"},\"de\":{\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"UE\",\"\":\"ue\",\"\":\"ss\",\"%\":\"prozent\",\"&\":\"und\",\"|\":\"oder\",\"\":\"summe\",\"\":\"unendlich\",\"\":\"liebe\"},\"es\":{\"%\":\"por ciento\",\"&\":\"y\",\"<\":\"menor que\",\">\":\"mayor que\",\"|\":\"o\",\"\":\"centavos\",\"\":\"libras\",\"\":\"moneda\",\"\":\"francos\",\"\":\"suma\",\"\":\"infinito\",\"\":\"amor\"},\"fr\":{\"%\":\"pourcent\",\"&\":\"et\",\"<\":\"plus petit\",\">\":\"plus grand\",\"|\":\"ou\",\"\":\"centime\",\"\":\"livre\",\"\":\"devise\",\"\":\"franc\",\"\":\"somme\",\"\":\"infini\",\"\":\"amour\"},\"pt\":{\"%\":\"porcento\",\"&\":\"e\",\"<\":\"menor\",\">\":\"maior\",\"|\":\"ou\",\"\":\"centavo\",\"\":\"soma\",\"\":\"libra\",\"\":\"infinito\",\"\":\"amor\"},\"uk\":{\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Ts\",\"\":\"ts\",\"\":\"Kh\",\"\":\"kh\",\"\":\"Shch\",\"\":\"shch\",\"\":\"H\",\"\":\"h\"},\"vi\":{\"\":\"D\",\"\":\"d\"},\"da\":{\"\":\"OE\",\"\":\"oe\",\"\":\"AA\",\"\":\"aa\",\"%\":\"procent\",\"&\":\"og\",\"|\":\"eller\",\"$\":\"dollar\",\"<\":\"mindre end\",\">\":\"strre end\"},\"nb\":{\"&\":\"og\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"},\"it\":{\"&\":\"e\"},\"nl\":{\"&\":\"en\"},\"sv\":{\"&\":\"och\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"}}')\n\n  function replace (string, options) {\n    if (typeof string !== 'string') {\n      throw new Error('slugify: string argument expected')\n    }\n\n    options = (typeof options === 'string')\n      ? {replacement: options}\n      : options || {}\n\n    var locale = locales[options.locale] || {}\n\n    var replacement = options.replacement === undefined ? '-' : options.replacement\n\n    var trim = options.trim === undefined ? true : options.trim\n\n    var slug = string.normalize().split('')\n      // replace characters based on charMap\n      .reduce(function (result, ch) {\n        var appendChar = locale[ch];\n        if (appendChar === undefined) appendChar = charMap[ch];\n        if (appendChar === undefined) appendChar = ch;\n        if (appendChar === replacement) appendChar = ' ';\n        return result + appendChar\n          // remove not allowed characters\n          .replace(options.remove || /[^\\w\\s$*_+~.()'\"!\\-:@]+/g, '')\n      }, '');\n\n    if (options.strict) {\n      slug = slug.replace(/[^A-Za-z0-9\\s]/g, '');\n    }\n\n    if (trim) {\n      slug = slug.trim()\n    }\n\n    // Replace spaces with replacement character, treating multiple consecutive\n    // spaces as a single space.\n    slug = slug.replace(/\\s+/g, replacement);\n\n    if (options.lower) {\n      slug = slug.toLowerCase()\n    }\n\n    return slug\n  }\n\n  replace.extend = function (customMap) {\n    Object.assign(charMap, customMap)\n  }\n\n  return replace\n}))\n","/**\r\n * Core  Shared utilities, constants, and internal helpers\r\n *\r\n * Ported from maxsim/bin/lib/core.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport os from 'node:os';\r\nimport { simpleGit } from 'simple-git';\r\nimport slugify from 'slugify';\r\n\r\nimport type {\r\n  BranchingStrategy,\r\n  ModelProfiles,\r\n  ModelProfileName,\r\n  ModelResolution,\r\n  AgentType,\r\n  PhaseSearchResult,\r\n  RoadmapPhaseInfo,\r\n  ArchivedPhaseDir,\r\n  GitResult,\r\n  MilestoneInfo,\r\n  AppConfig,\r\n} from './types.js';\r\n\r\n//  Model Profile Table \r\n\r\nexport const MODEL_PROFILES: ModelProfiles = {\r\n  'maxsim-planner':              { quality: 'opus', balanced: 'opus',   budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-roadmapper':           { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-executor':             { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-phase-researcher':     { quality: 'opus', balanced: 'sonnet', budget: 'haiku',  tokenburner: 'opus' },\r\n  'maxsim-project-researcher':   { quality: 'opus', balanced: 'sonnet', budget: 'haiku',  tokenburner: 'opus' },\r\n  'maxsim-research-synthesizer': { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-debugger':             { quality: 'opus', balanced: 'sonnet', budget: 'sonnet', tokenburner: 'opus' },\r\n  'maxsim-codebase-mapper':      { quality: 'sonnet', balanced: 'haiku', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-verifier':             { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-plan-checker':         { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n  'maxsim-integration-checker':  { quality: 'sonnet', balanced: 'sonnet', budget: 'haiku', tokenburner: 'opus' },\r\n};\r\n\r\n//  Output helpers \r\n// These throw CliOutput / CliError instead of calling process.exit() directly.\r\n// The CLI entry point (cli.ts) catches these and calls process.exit() there.\r\n\r\n/** Thrown by output() to signal successful command completion. */\r\nexport class CliOutput {\r\n  readonly result: unknown;\r\n  readonly raw: boolean;\r\n  readonly rawValue: unknown;\r\n  constructor(result: unknown, raw?: boolean, rawValue?: unknown) {\r\n    this.result = result;\r\n    this.raw = raw ?? false;\r\n    this.rawValue = rawValue;\r\n  }\r\n}\r\n\r\n/** Thrown by error() to signal a command error. */\r\nexport class CliError {\r\n  readonly message: string;\r\n  constructor(message: string) {\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nexport function output(result: unknown, raw?: boolean, rawValue?: unknown): never {\r\n  throw new CliOutput(result, raw, rawValue);\r\n}\r\n\r\nexport function error(message: string): never {\r\n  throw new CliError(message);\r\n}\r\n\r\n/** Re-throw CliOutput/CliError signals so catch blocks don't intercept them */\r\nexport function rethrowCliSignals(e: unknown): void {\r\n  if (e instanceof CliOutput || e instanceof CliError) throw e;\r\n}\r\n\r\n/**\r\n * Handle a CliOutput by writing to stdout. Extracted so cli.ts can use it.\r\n */\r\nexport function writeOutput(out: CliOutput): void {\r\n  if (out.raw && out.rawValue !== undefined) {\r\n    process.stdout.write(String(out.rawValue));\r\n  } else {\r\n    const json = JSON.stringify(out.result, null, 2);\r\n    if (json.length > 50000) {\r\n      const tmpPath = path.join(os.tmpdir(), `maxsim-${Date.now()}.json`);\r\n      fs.writeFileSync(tmpPath, json, 'utf-8');\r\n      process.stdout.write('@file:' + tmpPath);\r\n    } else {\r\n      process.stdout.write(json);\r\n    }\r\n  }\r\n}\r\n\r\n//  Shared micro-utilities \r\n\r\n/** Today's date as YYYY-MM-DD. */\r\nexport function todayISO(): string {\r\n  return new Date().toISOString().split('T')[0];\r\n}\r\n\r\n/** Canonical .planning/ sub-paths. */\r\nexport function planningPath(cwd: string, ...segments: string[]): string {\r\n  return path.join(cwd, '.planning', ...segments);\r\n}\r\nexport function statePath(cwd: string): string { return planningPath(cwd, 'STATE.md'); }\r\nexport function roadmapPath(cwd: string): string { return planningPath(cwd, 'ROADMAP.md'); }\r\nexport function configPath(cwd: string): string { return planningPath(cwd, 'config.json'); }\r\nexport function phasesPath(cwd: string): string { return planningPath(cwd, 'phases'); }\r\n\r\n/** Phase-file predicates. */\r\nexport const isPlanFile = (f: string): boolean => f.endsWith('-PLAN.md') || f === 'PLAN.md';\r\nexport const isSummaryFile = (f: string): boolean => f.endsWith('-SUMMARY.md') || f === 'SUMMARY.md';\r\n\r\n/** Strip suffix to get plan/summary ID. */\r\nexport const planId = (f: string): string => f.replace('-PLAN.md', '').replace('PLAN.md', '');\r\nexport const summaryId = (f: string): string => f.replace('-SUMMARY.md', '').replace('SUMMARY.md', '');\r\n\r\n/** List subdirectory names, optionally sorted by phase number. */\r\nexport function listSubDirs(dir: string, sortByPhase = false): string[] {\r\n  const dirs = fs.readdirSync(dir, { withFileTypes: true })\r\n    .filter(e => e.isDirectory())\r\n    .map(e => e.name);\r\n  return sortByPhase ? dirs.sort((a, b) => comparePhaseNum(a, b)) : dirs;\r\n}\r\n\r\n/** Log only when MAXSIM_DEBUG is set. */\r\nexport function debugLog(e: unknown): void {\r\n  if (process.env.MAXSIM_DEBUG) console.error(e);\r\n}\r\n\r\n/** Escape a phase number for use in regex. */\r\nexport function escapePhaseNum(phase: string | number): string {\r\n  return String(phase).replace(/\\./g, '\\\\.');\r\n}\r\n\r\n//  File & Config utilities \r\n\r\nexport function safeReadFile(filePath: string): string | null {\r\n  try {\r\n    return fs.readFileSync(filePath, 'utf-8');\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nlet _configCache: { cwd: string; config: AppConfig } | null = null;\r\n\r\nexport function loadConfig(cwd: string): AppConfig {\r\n  if (_configCache && _configCache.cwd === cwd) return _configCache.config;\r\n  const cfgPath = configPath(cwd);\r\n  const defaults: AppConfig = {\r\n    model_profile: 'balanced',\r\n    commit_docs: true,\r\n    search_gitignored: false,\r\n    branching_strategy: 'none',\r\n    phase_branch_template: 'maxsim/phase-{phase}-{slug}',\r\n    milestone_branch_template: 'maxsim/{milestone}-{slug}',\r\n    research: true,\r\n    plan_checker: true,\r\n    verifier: true,\r\n    parallelization: true,\r\n    brave_search: false,\r\n  };\r\n\r\n  try {\r\n    const raw = fs.readFileSync(cfgPath, 'utf-8');\r\n    const parsed: Record<string, unknown> = JSON.parse(raw) as Record<string, unknown>;\r\n\r\n    const get = (key: string, nested?: { section: string; field: string }): unknown => {\r\n      if (parsed[key] !== undefined) return parsed[key];\r\n      if (nested) {\r\n        const section = parsed[nested.section];\r\n        if (section && typeof section === 'object' && section !== null && nested.field in section) {\r\n          return (section as Record<string, unknown>)[nested.field];\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n\r\n    const parallelization = ((): boolean => {\r\n      const val = get('parallelization');\r\n      if (typeof val === 'boolean') return val;\r\n      if (typeof val === 'object' && val !== null && 'enabled' in val) {\r\n        return (val as { enabled: boolean }).enabled;\r\n      }\r\n      return defaults.parallelization;\r\n    })();\r\n\r\n    const result: AppConfig = {\r\n      model_profile: (get('model_profile') as ModelProfileName | undefined) ?? defaults.model_profile,\r\n      commit_docs: (get('commit_docs', { section: 'planning', field: 'commit_docs' }) as boolean | undefined) ?? defaults.commit_docs,\r\n      search_gitignored: (get('search_gitignored', { section: 'planning', field: 'search_gitignored' }) as boolean | undefined) ?? defaults.search_gitignored,\r\n      branching_strategy: (get('branching_strategy', { section: 'git', field: 'branching_strategy' }) as BranchingStrategy | undefined) ?? defaults.branching_strategy,\r\n      phase_branch_template: (get('phase_branch_template', { section: 'git', field: 'phase_branch_template' }) as string | undefined) ?? defaults.phase_branch_template,\r\n      milestone_branch_template: (get('milestone_branch_template', { section: 'git', field: 'milestone_branch_template' }) as string | undefined) ?? defaults.milestone_branch_template,\r\n      research: (get('research', { section: 'workflow', field: 'research' }) as boolean | undefined) ?? defaults.research,\r\n      plan_checker: ((get('plan_checker', { section: 'workflow', field: 'plan_checker' }) ?? get('plan_checker', { section: 'workflow', field: 'plan_check' })) as boolean | undefined) ?? defaults.plan_checker,\r\n      verifier: (get('verifier', { section: 'workflow', field: 'verifier' }) as boolean | undefined) ?? defaults.verifier,\r\n      parallelization,\r\n      brave_search: (get('brave_search') as boolean | undefined) ?? defaults.brave_search,\r\n      model_overrides: parsed['model_overrides'] as AppConfig['model_overrides'],\r\n    };\r\n    _configCache = { cwd, config: result };\r\n    return result;\r\n  } catch {\r\n    _configCache = { cwd, config: defaults };\r\n    return defaults;\r\n  }\r\n}\r\n\r\n//  Git utilities \r\n\r\nexport async function isGitIgnored(cwd: string, targetPath: string): Promise<boolean> {\r\n  try {\r\n    const git = simpleGit(cwd);\r\n    const result = await git.checkIgnore(targetPath);\r\n    return result.length > 0;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function execGit(cwd: string, args: string[]): Promise<GitResult> {\r\n  try {\r\n    const git = simpleGit(cwd);\r\n    const stdout = await git.raw(args);\r\n    return { exitCode: 0, stdout: (stdout ?? '').trim(), stderr: '' };\r\n  } catch (thrown: unknown) {\r\n    const err = thrown as { message?: string };\r\n    // simple-git throws on non-zero exit  extract what we can\r\n    const message = err.message ?? '';\r\n    return {\r\n      exitCode: 1,\r\n      stdout: '',\r\n      stderr: message,\r\n    };\r\n  }\r\n}\r\n\r\n//  Phase utilities \r\n\r\nexport function normalizePhaseName(phase: string): string {\r\n  const match = phase.match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  if (!match) return phase;\r\n  const padded = match[1].padStart(2, '0');\r\n  const letter = match[2] ? match[2].toUpperCase() : '';\r\n  const decimal = match[3] || '';\r\n  return padded + letter + decimal;\r\n}\r\n\r\nexport function comparePhaseNum(a: string | number, b: string | number): number {\r\n  const pa = String(a).match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  const pb = String(b).match(/^(\\d+)([A-Z])?(\\.\\d+)?/i);\r\n  if (!pa || !pb) return String(a).localeCompare(String(b));\r\n  const intDiff = parseInt(pa[1], 10) - parseInt(pb[1], 10);\r\n  if (intDiff !== 0) return intDiff;\r\n  const la = (pa[2] || '').toUpperCase();\r\n  const lb = (pb[2] || '').toUpperCase();\r\n  if (la !== lb) {\r\n    if (!la) return -1;\r\n    if (!lb) return 1;\r\n    return la < lb ? -1 : 1;\r\n  }\r\n  const da = pa[3] ? parseFloat(pa[3]) : -1;\r\n  const db = pb[3] ? parseFloat(pb[3]) : -1;\r\n  return da - db;\r\n}\r\n\r\n//  Phase regex helper \r\n\r\n/**\r\n * Returns the canonical regex for matching Phase heading lines in ROADMAP.md.\r\n *\r\n * General form (no escapedPhaseNum):\r\n *   Matches: ## Phase 03: Name Here\r\n *   Group 1: phase number string (e.g. \"03\", \"3A\", \"2.1\")\r\n *   Group 2: phase name string (e.g. \"Name Here\")\r\n *\r\n * Specific form (with escapedPhaseNum):\r\n *   Matches: ## Phase 03: Name Here\r\n *   Group 1: phase name string only\r\n *\r\n * @param escapedPhaseNum - regex-escaped phase number string to match a specific phase\r\n * @param flags - regex flags (default: 'gi')\r\n */\r\nexport function getPhasePattern(escapedPhaseNum?: string, flags = 'gim'): RegExp {\r\n  if (escapedPhaseNum) {\r\n    return new RegExp(\r\n      `^#{2,4}\\\\s*Phase\\\\s+${escapedPhaseNum}:\\\\s*([^\\\\n]+)`,\r\n      flags,\r\n    );\r\n  }\r\n  return new RegExp(\r\n    `^#{2,4}\\\\s*Phase\\\\s+(\\\\d+[A-Z]?(?:\\\\.\\\\d+)?)\\\\s*:\\\\s*([^\\\\n]+)`,\r\n    flags,\r\n  );\r\n}\r\n\r\nfunction searchPhaseInDir(baseDir: string, relBase: string, normalized: string): PhaseSearchResult | null {\r\n  try {\r\n    const dirs = listSubDirs(baseDir, true);\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (!match) return null;\r\n\r\n    const dirMatch = match.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n    const phaseNumber = dirMatch ? dirMatch[1] : normalized;\r\n    const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;\r\n    const phaseDir = path.join(baseDir, match);\r\n    const phaseFiles = fs.readdirSync(phaseDir);\r\n\r\n    const plans = phaseFiles.filter(isPlanFile).sort();\r\n    const summaries = phaseFiles.filter(isSummaryFile).sort();\r\n    const hasResearch = phaseFiles.some(f => f.endsWith('-RESEARCH.md') || f === 'RESEARCH.md');\r\n    const hasContext = phaseFiles.some(f => f.endsWith('-CONTEXT.md') || f === 'CONTEXT.md');\r\n    const hasVerification = phaseFiles.some(f => f.endsWith('-VERIFICATION.md') || f === 'VERIFICATION.md');\r\n\r\n    const completedPlanIds = new Set(summaries.map(summaryId));\r\n    const incompletePlans = plans.filter(p => !completedPlanIds.has(planId(p)));\r\n\r\n    return {\r\n      found: true,\r\n      directory: path.join(relBase, match),\r\n      phase_number: phaseNumber,\r\n      phase_name: phaseName,\r\n      phase_slug: phaseName ? phaseName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : null,\r\n      plans,\r\n      summaries,\r\n      incomplete_plans: incompletePlans,\r\n      has_research: hasResearch,\r\n      has_context: hasContext,\r\n      has_verification: hasVerification,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function findPhaseInternal(cwd: string, phase: string): PhaseSearchResult | null {\r\n  if (!phase) return null;\r\n\r\n  const pd = phasesPath(cwd);\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  const current = searchPhaseInDir(pd, path.join('.planning', 'phases'), normalized);\r\n  if (current) return current;\r\n\r\n  const milestonesDir = planningPath(cwd, 'milestones');\r\n\r\n  try {\r\n    fs.statSync(milestonesDir);\r\n  } catch {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });\r\n    const archiveDirs = milestoneEntries\r\n      .filter(e => e.isDirectory() && /^v[\\d.]+-phases$/.test(e.name))\r\n      .map(e => e.name)\r\n      .sort()\r\n      .reverse();\r\n\r\n    for (const archiveName of archiveDirs) {\r\n      const versionMatch = archiveName.match(/^(v[\\d.]+)-phases$/);\r\n      if (!versionMatch) continue;\r\n      const version = versionMatch[1];\r\n      const archivePath = path.join(milestonesDir, archiveName);\r\n      const relBase = path.join('.planning', 'milestones', archiveName);\r\n      const result = searchPhaseInDir(archivePath, relBase, normalized);\r\n      if (result) {\r\n        result.archived = version;\r\n        return result;\r\n      }\r\n    }\r\n  } catch (e) {\r\n    debugLog(e);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getArchivedPhaseDirs(cwd: string): ArchivedPhaseDir[] {\r\n  const milestonesDir = planningPath(cwd, 'milestones');\r\n  const results: ArchivedPhaseDir[] = [];\r\n\r\n  try {\r\n    const milestoneEntries = fs.readdirSync(milestonesDir, { withFileTypes: true });\r\n    const phaseDirs = milestoneEntries\r\n      .filter(e => e.isDirectory() && /^v[\\d.]+-phases$/.test(e.name))\r\n      .map(e => e.name)\r\n      .sort()\r\n      .reverse();\r\n\r\n    for (const archiveName of phaseDirs) {\r\n      const versionMatch = archiveName.match(/^(v[\\d.]+)-phases$/);\r\n      if (!versionMatch) continue;\r\n      const version = versionMatch[1];\r\n      const archivePath = path.join(milestonesDir, archiveName);\r\n      const dirs = listSubDirs(archivePath, true);\r\n\r\n      for (const dir of dirs) {\r\n        results.push({\r\n          name: dir,\r\n          milestone: version,\r\n          basePath: path.join('.planning', 'milestones', archiveName),\r\n          fullPath: path.join(archivePath, dir),\r\n        });\r\n      }\r\n    }\r\n  } catch (e) {\r\n    debugLog(e);\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n//  Roadmap & model utilities \r\n\r\nexport function getRoadmapPhaseInternal(cwd: string, phaseNum: string | number): RoadmapPhaseInfo | null {\r\n  if (!phaseNum) return null;\r\n  const rp = roadmapPath(cwd);\r\n\r\n  try {\r\n    const content = fs.readFileSync(rp, 'utf-8');\r\n    const escapedPhase = escapePhaseNum(phaseNum);\r\n    const phasePattern = getPhasePattern(escapedPhase, 'i');\r\n    const headerMatch = content.match(phasePattern);\r\n    if (!headerMatch) return null;\r\n\r\n    const phaseName = headerMatch[1].trim();\r\n    const headerIndex = headerMatch.index!;\r\n    const restOfContent = content.slice(headerIndex);\r\n    const nextHeaderMatch = restOfContent.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\r\n    const sectionEnd = nextHeaderMatch ? headerIndex + nextHeaderMatch.index! : content.length;\r\n    const section = content.slice(headerIndex, sectionEnd).trim();\r\n\r\n    const goalMatch = section.match(/\\*\\*Goal(?::\\*\\*|\\*\\*:)\\s*([^\\n]+)/i);\r\n    const goal = goalMatch ? goalMatch[1].trim() : null;\r\n\r\n    return {\r\n      found: true,\r\n      phase_number: phaseNum.toString(),\r\n      phase_name: phaseName,\r\n      goal,\r\n      section,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function resolveModelInternal(cwd: string, agentType: AgentType, config?: AppConfig): ModelResolution {\r\n  config = config ?? loadConfig(cwd);\r\n\r\n  const override = config.model_overrides?.[agentType];\r\n  if (override) {\r\n    return override === 'opus' ? 'inherit' : override;\r\n  }\r\n\r\n  const profile: ModelProfileName = config.model_profile || 'balanced';\r\n  const agentModels = MODEL_PROFILES[agentType];\r\n  if (!agentModels) return 'sonnet';\r\n  const resolved = agentModels[profile] || agentModels['balanced'] || 'sonnet';\r\n  return resolved === 'opus' ? 'inherit' : resolved;\r\n}\r\n\r\n//  Misc utilities \r\n\r\nexport function pathExistsInternal(cwd: string, targetPath: string): boolean {\r\n  const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);\r\n  try {\r\n    fs.statSync(fullPath);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function generateSlugInternal(text: string | null | undefined): string | null {\r\n  if (!text) return null;\r\n  return slugify(text, { lower: true, strict: true });\r\n}\r\n\r\nexport function getMilestoneInfo(cwd: string): MilestoneInfo {\r\n  try {\r\n    const roadmap = fs.readFileSync(roadmapPath(cwd), 'utf-8');\r\n    const versionMatch = roadmap.match(/v(\\d+\\.\\d+)/);\r\n    const nameMatch = roadmap.match(/## .*v\\d+\\.\\d+[:\\s]+([^\\n(]+)/);\r\n    return {\r\n      version: versionMatch ? versionMatch[0] : 'v1.0',\r\n      name: nameMatch ? nameMatch[1].trim() : 'milestone',\r\n    };\r\n  } catch {\r\n    return { version: 'v1.0', name: 'milestone' };\r\n  }\r\n}\r\n","'use strict';\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexports.ALIAS = ALIAS;\nexports.DOC = DOC;\nexports.MAP = MAP;\nexports.NODE_TYPE = NODE_TYPE;\nexports.PAIR = PAIR;\nexports.SCALAR = SCALAR;\nexports.SEQ = SEQ;\nexports.hasAnchor = hasAnchor;\nexports.isAlias = isAlias;\nexports.isCollection = isCollection;\nexports.isDocument = isDocument;\nexports.isMap = isMap;\nexports.isNode = isNode;\nexports.isPair = isPair;\nexports.isScalar = isScalar;\nexports.isSeq = isSeq;\n","'use strict';\n\nvar identity = require('./nodes/identity.js');\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (identity.isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (identity.isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (identity.isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (identity.isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (identity.isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (identity.isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (identity.isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (identity.isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexports.visit = visit;\nexports.visitAsync = visitAsync;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (identity.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit.visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            prevAnchors ?? (prevAnchors = anchorNames(doc));\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexports.anchorIsValid = anchorIsValid;\nexports.anchorNames = anchorNames;\nexports.createNodeAnchors = createNodeAnchors;\nexports.findNewAnchor = findNewAnchor;\n","'use strict';\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n","'use strict';\n\nvar identity = require('./identity.js');\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !identity.hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexports.toJS = toJS;\n","'use strict';\n\nvar applyReviver = require('../doc/applyReviver.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!identity.isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexports.NodeBase = NodeBase;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar visit = require('../visit.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nclass Alias extends Node.NodeBase {\n    constructor(source) {\n        super(identity.ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc, ctx) {\n        let nodes;\n        if (ctx?.aliasResolveCache) {\n            nodes = ctx.aliasResolveCache;\n        }\n        else {\n            nodes = [];\n            visit.visit(doc, {\n                Node: (_key, node) => {\n                    if (identity.isAlias(node) || identity.hasAnchor(node))\n                        nodes.push(node);\n                }\n            });\n            if (ctx)\n                ctx.aliasResolveCache = nodes;\n        }\n        let found = undefined;\n        for (const node of nodes) {\n            if (node === this)\n                break;\n            if (node.anchor === this.source)\n                found = node;\n        }\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc, ctx);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS.toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (data?.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchors.anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (identity.isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (identity.isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (identity.isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexports.Alias = Alias;\n","'use strict';\n\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends Node.NodeBase {\n    constructor(value) {\n        super(identity.SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexports.Scalar = Scalar;\nexports.isScalarValue = isScalarValue;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (identity.isDocument(value))\n        value = value.contents;\n    if (identity.isNode(value))\n        return value;\n    if (identity.isPair(value)) {\n        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            ref.anchor ?? (ref.anchor = onAnchor(value));\n            return new Alias.Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar.Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[identity.MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[identity.SEQ]\n                    : schema[identity.MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar.Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexports.createNode = createNode;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode.createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends Node.NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (identity.isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && identity.isScalar(node) ? node.value : node;\n        else\n            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!identity.isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    identity.isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return identity.isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexports.Collection = Collection;\nexports.collectionFromPath = collectionFromPath;\nexports.isEmptyPath = isEmptyPath;\n","'use strict';\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexports.indentComment = indentComment;\nexports.lineComment = lineComment;\nexports.stringifyComment = stringifyComment;\n","'use strict';\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar foldFlowLines = require('./foldFlowLines.js');\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    // Leading | or > is added later\n    let header = (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (!literal) {\n        const foldedValue = value\n            .replace(/\\n+/g, '\\n$&')\n            .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n            .replace(/\\n+/g, `$&${indent}`);\n        let literalFallback = false;\n        const foldOptions = getFoldOptions(ctx, true);\n        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {\n            foldOptions.onOverflow = () => {\n                literalFallback = true;\n            };\n        }\n        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);\n        if (!literalFallback)\n            return `>${header}\\n${indent}${body}`;\n    }\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `|${header}\\n${indent}${start}${value}${end}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (/^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.Scalar.BLOCK_FOLDED:\n            case Scalar.Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexports.stringifyString = stringifyString;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar identity = require('../nodes/identity.js');\nvar stringifyComment = require('./stringifyComment.js');\nvar stringifyString = require('./stringifyString.js');\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment.stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (identity.isScalar(item)) {\n        obj = item.value;\n        let match = tags.filter(t => t.identify?.(obj));\n        if (match.length > 1) {\n            const testMatch = match.filter(t => t.test);\n            if (testMatch.length > 0)\n                match = testMatch;\n        }\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;\n    if (anchor && anchors.anchorIsValid(anchor)) {\n        anchors$1.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (identity.isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (identity.isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = identity.isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : identity.isScalar(node)\n            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return identity.isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexports.createStringifyContext = createStringifyContext;\nexports.stringify = stringify;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (identity.isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            identity.isCollection(key) ||\n            (identity.isScalar(key)\n                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (identity.isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && identity.isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        identity.isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${stringifyComment.indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n' && valueComment)\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && identity.isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexports.stringifyPair = stringifyPair;\n","'use strict';\n\nvar node_process = require('process');\n\nfunction debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof node_process.emitWarning === 'function')\n            node_process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexports.debug = debug;\nexports.warn = warn;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Scalar = require('../../nodes/Scalar.js');\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (identity.isScalar(key) &&\n        (!key.type || key.type === Scalar.Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (identity.isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!identity.isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nexports.addMergeToJSMap = addMergeToJSMap;\nexports.isMergeKey = isMergeKey;\nexports.merge = merge;\n","'use strict';\n\nvar log = require('../log.js');\nvar merge = require('../schema/yaml-1.1/merge.js');\nvar stringify = require('../stringify/stringify.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (identity.isNode(key) && key.addToJSMap)\n        key.addToJSMap(ctx, map, value);\n    // TODO: Should drop this special case for bare << handling\n    else if (merge.isMergeKey(ctx, key))\n        merge.addMergeToJSMap(ctx, map, value);\n    else {\n        const jsKey = toJS.toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS.toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS.toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (identity.isNode(key) && ctx?.doc) {\n        const strCtx = stringify.createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexports.addPairToJSMap = addPairToJSMap;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyPair = require('../stringify/stringifyPair.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar identity = require('./identity.js');\n\nfunction createPair(key, value, ctx) {\n    const k = createNode.createNode(key, undefined, ctx);\n    const v = createNode.createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (identity.isNode(key))\n            key = key.clone(schema);\n        if (identity.isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap.addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexports.Pair = Pair;\nexports.createPair = createPair;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + stringifyComment.indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = identity.isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = stringifyComment.indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexports.stringifyCollection = stringifyCollection;\n","'use strict';\n\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Pair = require('./Pair.js');\nvar Scalar = require('./Scalar.js');\n\nfunction findPair(items, key) {\n    const k = identity.isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (identity.isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (identity.isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(identity.MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(Pair.createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (identity.isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair.Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair.Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair.Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap.addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!identity.isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexports.YAMLMap = YAMLMap;\nexports.findPair = findPair;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap.YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!identity.isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)\n};\n\nexports.map = map;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Scalar = require('./Scalar.js');\nvar toJS = require('./toJS.js');\n\nclass YAMLSeq extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(identity.SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && identity.isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (identity.isScalar(prev) && Scalar.isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS.toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode.createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = identity.isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexports.YAMLSeq = YAMLSeq;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq.YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!identity.isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)\n};\n\nexports.seq = seq;\n","'use strict';\n\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.string = string;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar.Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar.Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexports.nullTag = nullTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexports.boolTag = boolTag;\n","'use strict';\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = Object.is(value, -0) ? '-0' : JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexports.stringifyNumber = stringifyNumber;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.boolTag,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar map = require('../common/map.js');\nvar seq = require('../common/seq.js');\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar.Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map.map, seq.seq].concat(jsonScalars, jsonError);\n\nexports.schema = schema;\n","'use strict';\n\nvar node_buffer = require('buffer');\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof node_buffer.Buffer === 'function') {\n            return node_buffer.Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof node_buffer.Buffer === 'function') {\n            str =\n                buf instanceof node_buffer.Buffer\n                    ? buf.toString('base64')\n                    : node_buffer.Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);\n        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.binary = binary;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar Scalar = require('../../nodes/Scalar.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nfunction resolvePairs(seq, onError) {\n    if (identity.isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (identity.isPair(item))\n                continue;\n            else if (identity.isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq.YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(Pair.createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexports.createPairs = createPairs;\nexports.pairs = pairs;\nexports.resolvePairs = resolvePairs;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar toJS = require('../../nodes/toJS.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\nvar pairs = require('./pairs.js');\n\nclass YAMLOMap extends YAMLSeq.YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (identity.isPair(pair)) {\n                key = toJS.toJS(pair.key, '', ctx);\n                value = toJS.toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS.toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs$1 = pairs.createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs$1.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs$1 = pairs.resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs$1.items) {\n            if (identity.isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs$1);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexports.YAMLOMap = YAMLOMap;\nexports.omap = omap;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar.Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar.Scalar(false),\n    stringify: boolStringify\n};\n\nexports.falseTag = falseTag;\nexports.trueTag = trueTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intBin = intBin;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nclass YAMLSet extends YAMLMap.YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (identity.isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair.Pair(key.key, null);\n        else\n            pair = new Pair.Pair(key, null);\n        const prev = YAMLMap.findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = YAMLMap.findPair(this.items, key);\n        return !keepPair && identity.isPair(pair)\n            ? identity.isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = YAMLMap.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(Pair.createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (identity.isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexports.YAMLSet = YAMLSet;\nexports.set = set;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber.stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.timestamp = timestamp;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar binary = require('./binary.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\nvar merge = require('./merge.js');\nvar omap = require('./omap.js');\nvar pairs = require('./pairs.js');\nvar set = require('./set.js');\nvar timestamp = require('./timestamp.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.trueTag,\n    bool.falseTag,\n    int.intBin,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float,\n    binary.binary,\n    merge.merge,\n    omap.omap,\n    pairs.pairs,\n    set.set,\n    timestamp.intTime,\n    timestamp.floatTime,\n    timestamp.timestamp\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar map = require('./common/map.js');\nvar _null = require('./common/null.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar bool = require('./core/bool.js');\nvar float = require('./core/float.js');\nvar int = require('./core/int.js');\nvar schema = require('./core/schema.js');\nvar schema$1 = require('./json/schema.js');\nvar binary = require('./yaml-1.1/binary.js');\nvar merge = require('./yaml-1.1/merge.js');\nvar omap = require('./yaml-1.1/omap.js');\nvar pairs = require('./yaml-1.1/pairs.js');\nvar schema$2 = require('./yaml-1.1/schema.js');\nvar set = require('./yaml-1.1/set.js');\nvar timestamp = require('./yaml-1.1/timestamp.js');\n\nconst schemas = new Map([\n    ['core', schema.schema],\n    ['failsafe', [map.map, seq.seq, string.string]],\n    ['json', schema$1.schema],\n    ['yaml11', schema$2.schema],\n    ['yaml-1.1', schema$2.schema]\n]);\nconst tagsByName = {\n    binary: binary.binary,\n    bool: bool.boolTag,\n    float: float.float,\n    floatExp: float.floatExp,\n    floatNaN: float.floatNaN,\n    floatTime: timestamp.floatTime,\n    int: int.int,\n    intHex: int.intHex,\n    intOct: int.intOct,\n    intTime: timestamp.intTime,\n    map: map.map,\n    merge: merge.merge,\n    null: _null.nullTag,\n    omap: omap.omap,\n    pairs: pairs.pairs,\n    seq: seq.seq,\n    set: set.set,\n    timestamp: timestamp.timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary.binary,\n    'tag:yaml.org,2002:merge': merge.merge,\n    'tag:yaml.org,2002:omap': omap.omap,\n    'tag:yaml.org,2002:pairs': pairs.pairs,\n    'tag:yaml.org,2002:set': set.set,\n    'tag:yaml.org,2002:timestamp': timestamp.timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge.merge)\n            ? schemaTags.concat(merge.merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge.merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexports.coreKnownTags = coreKnownTags;\nexports.getTags = getTags;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar map = require('./common/map.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar tags = require('./tags.js');\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? tags.getTags(compat, 'compat')\n            : compat\n                ? tags.getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};\n        this.tags = tags.getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, identity.MAP, { value: map.map });\n        Object.defineProperty(this, identity.SCALAR, { value: string.string });\n        Object.defineProperty(this, identity.SEQ, { value: seq.seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexports.Schema = Schema;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = stringify.createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(stringifyComment.indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (identity.isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += stringifyComment.lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify.stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(stringifyComment.indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexports.stringifyDocument = stringifyDocument;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar Collection = require('../nodes/Collection.js');\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar toJS = require('../nodes/toJS.js');\nvar Schema = require('../schema/Schema.js');\nvar stringifyDocument = require('../stringify/stringifyDocument.js');\nvar anchors = require('./anchors.js');\nvar applyReviver = require('./applyReviver.js');\nvar createNode = require('./createNode.js');\nvar directives = require('./directives.js');\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new directives.Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [identity.NODE_TYPE]: { value: identity.DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = identity.isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchors.anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias.Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode.createNode(value, tag, ctx);\n        if (flow && identity.isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair.Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (Collection.isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return identity.isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (Collection.isEmptyPath(path))\n            return !keepScalar && identity.isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return identity.isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return identity.isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (Collection.isEmptyPath(path))\n            return this.contents !== undefined;\n        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (Collection.isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new directives.Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new directives.Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema.Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument.stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (identity.isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexports.Document = Document;\n","'use strict';\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end?.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexports.YAMLError = YAMLError;\nexports.YAMLParseError = YAMLParseError;\nexports.YAMLWarning = YAMLWarning;\nexports.prettifyError = prettifyError;\n","'use strict';\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexports.resolveProps = resolveProps;\n","'use strict';\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexports.containsNewline = containsNewline;\n","'use strict';\n\nvar utilContainsNewline = require('./util-contains-newline.js');\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            utilContainsNewline.containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexports.flowIndentCheck = flowIndentCheck;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexports.mapIncludes = mapIncludes;\n","'use strict';\n\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n","'use strict';\n\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps.resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value?.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexports.resolveBlockSeq = resolveBlockSeq;\n","'use strict';\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexports.resolveEnd = resolveEnd;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps.resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (identity.isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            //  key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps.resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source?.[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap.YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce?.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexports.resolveFlowCollection = resolveFlowCollection;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveBlockMap = require('./resolve-block-map.js');\nvar resolveBlockSeq = require('./resolve-block-seq.js');\nvar resolveFlowCollection = require('./resolve-flow-collection.js');\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt?.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = identity.isNode(res)\n        ? res\n        : new Scalar.Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexports.composeCollection = composeCollection;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexports.resolveFlowScalar = resolveFlowScalar;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveBlockScalar = require('./resolve-block-scalar.js');\nvar resolveFlowScalar = require('./resolve-flow-scalar.js');\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[identity.SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[identity.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[identity.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[identity.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[identity.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n","'use strict';\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        pos ?? (pos = before.length);\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexports.emptyScalarPosition = emptyScalarPosition;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar composeCollection = require('./compose-collection.js');\nvar composeScalar = require('./compose-scalar.js');\nvar resolveEnd = require('./resolve-end.js');\nvar utilEmptyScalarPosition = require('./util-empty-scalar-position.js');\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar.composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection.composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!identity.isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar.composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias.Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexports.composeEmptyNode = composeEmptyNode;\nexports.composeNode = composeNode;\n","'use strict';\n\nvar Document = require('../doc/Document.js');\nvar composeNode = require('./compose-node.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document.Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps.resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode.composeNode(ctx, value, props, onError)\n        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexports.composeDoc = composeDoc;\n","'use strict';\n\nvar node_process = require('process');\nvar directives = require('../doc/directives.js');\nvar Document = require('../doc/Document.js');\nvar errors = require('../errors.js');\nvar identity = require('../nodes/identity.js');\nvar composeDoc = require('./compose-doc.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (identity.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (node_process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n","'use strict';\n\nvar resolveBlockScalar = require('../compose/resolve-block-scalar.js');\nvar resolveFlowScalar = require('../compose/resolve-flow-scalar.js');\nvar errors = require('../errors.js');\nvar stringifyString = require('../stringify/stringifyString.js');\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new errors.YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexports.createScalarToken = createScalarToken;\nexports.resolveAsScalar = resolveAsScalar;\nexports.setScalarValue = setScalarValue;\n","'use strict';\n\n/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexports.stringify = stringify;\n","'use strict';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]`  Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null`  Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]`  Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token`  The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n","'use strict';\n\nvar cstScalar = require('./cst-scalar.js');\nvar cstStringify = require('./cst-stringify.js');\nvar cstVisit = require('./cst-visit.js');\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexports.createScalarToken = cstScalar.createScalarToken;\nexports.resolveAsScalar = cstScalar.resolveAsScalar;\nexports.setScalarValue = cstScalar.setScalarValue;\nexports.stringify = cstStringify.stringify;\nexports.visit = cstVisit.visit;\nexports.BOM = BOM;\nexports.DOCUMENT = DOCUMENT;\nexports.FLOW_END = FLOW_END;\nexports.SCALAR = SCALAR;\nexports.isCollection = isCollection;\nexports.isScalar = isScalar;\nexports.prettyToken = prettyToken;\nexports.tokenType = tokenType;\n","'use strict';\n\nvar cst = require('./cst.js');\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n","'use strict';\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexports.LineCounter = LineCounter;\n","'use strict';\n\nvar node_process = require('process');\nvar cst = require('./cst.js');\nvar lexer = require('./lexer.js');\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (node_process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && top?.type !== 'doc-end') {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top?.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar errors = require('./errors.js');\nvar log = require('./log.js');\nvar identity = require('./nodes/identity.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;\n    return { lineCounter: lineCounter$1, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    const docs = Array.from(composer$1.compose(parser$1.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(errors.prettifyError(source, lineCounter));\n            doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer$1.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(errors.prettifyError(source, lineCounter));\n        doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (identity.isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document.Document(value, _replacer, options).toString(options);\n}\n\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar Schema = require('./schema/Schema.js');\nvar errors = require('./errors.js');\nvar Alias = require('./nodes/Alias.js');\nvar identity = require('./nodes/identity.js');\nvar Pair = require('./nodes/Pair.js');\nvar Scalar = require('./nodes/Scalar.js');\nvar YAMLMap = require('./nodes/YAMLMap.js');\nvar YAMLSeq = require('./nodes/YAMLSeq.js');\nvar cst = require('./parse/cst.js');\nvar lexer = require('./parse/lexer.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\nvar publicApi = require('./public-api.js');\nvar visit = require('./visit.js');\n\n\n\nexports.Composer = composer.Composer;\nexports.Document = Document.Document;\nexports.Schema = Schema.Schema;\nexports.YAMLError = errors.YAMLError;\nexports.YAMLParseError = errors.YAMLParseError;\nexports.YAMLWarning = errors.YAMLWarning;\nexports.Alias = Alias.Alias;\nexports.isAlias = identity.isAlias;\nexports.isCollection = identity.isCollection;\nexports.isDocument = identity.isDocument;\nexports.isMap = identity.isMap;\nexports.isNode = identity.isNode;\nexports.isPair = identity.isPair;\nexports.isScalar = identity.isScalar;\nexports.isSeq = identity.isSeq;\nexports.Pair = Pair.Pair;\nexports.Scalar = Scalar.Scalar;\nexports.YAMLMap = YAMLMap.YAMLMap;\nexports.YAMLSeq = YAMLSeq.YAMLSeq;\nexports.CST = cst;\nexports.Lexer = lexer.Lexer;\nexports.LineCounter = lineCounter.LineCounter;\nexports.Parser = parser.Parser;\nexports.parse = publicApi.parse;\nexports.parseAllDocuments = publicApi.parseAllDocuments;\nexports.parseDocument = publicApi.parseDocument;\nexports.stringify = publicApi.stringify;\nexports.visit = visit.visit;\nexports.visitAsync = visit.visitAsync;\n","/**\r\n * Frontmatter  YAML frontmatter parsing, serialization, and CRUD commands\r\n *\r\n * Uses the `yaml` npm package instead of a hand-rolled parser.\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport YAML from 'yaml';\r\n\r\nimport { safeReadFile, output, error } from './core.js';\r\nimport type {\r\n  FrontmatterData,\r\n  FrontmatterValue,\r\n  FrontmatterValidationResult,\r\n  FrontmatterSchema,\r\n} from './types.js';\r\n\r\n//  Parsing engine \r\n\r\n/**\r\n * Extract YAML frontmatter from markdown content into a typed object.\r\n */\r\nexport function extractFrontmatter(content: string): FrontmatterData {\r\n  const match = content.match(/^---\\n([\\s\\S]+?)\\n---/);\r\n  if (!match) return {};\r\n  try {\r\n    const parsed = YAML.parse(match[1]);\r\n    return (parsed && typeof parsed === 'object' && !Array.isArray(parsed))\r\n      ? parsed as FrontmatterData\r\n      : {};\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Reconstruct YAML frontmatter string from an object.\r\n */\r\nexport function reconstructFrontmatter(obj: FrontmatterData): string {\r\n  // Filter out null/undefined values\r\n  const cleaned: FrontmatterData = {};\r\n  for (const [key, value] of Object.entries(obj)) {\r\n    if (value !== null && value !== undefined) {\r\n      cleaned[key] = value;\r\n    }\r\n  }\r\n\r\n  return YAML.stringify(cleaned, {\r\n    lineWidth: 0,        // Don't wrap long lines\r\n    defaultKeyType: 'PLAIN',\r\n    defaultStringType: 'PLAIN',\r\n  }).trimEnd();\r\n}\r\n\r\n/**\r\n * Replace or insert frontmatter in markdown content.\r\n */\r\nexport function spliceFrontmatter(content: string, newObj: FrontmatterData): string {\r\n  const yamlStr = reconstructFrontmatter(newObj);\r\n  const match = content.match(/^---\\n[\\s\\S]+?\\n---/);\r\n  if (match) {\r\n    return `---\\n${yamlStr}\\n---` + content.slice(match[0].length);\r\n  }\r\n  return `---\\n${yamlStr}\\n---\\n\\n` + content;\r\n}\r\n\r\ninterface MustHaveItem {\r\n  [key: string]: string | number | string[];\r\n}\r\n\r\n/**\r\n * Parse a specific block from must_haves in frontmatter.\r\n * With the yaml package, this is just object traversal.\r\n */\r\nexport function parseMustHavesBlock(content: string, blockName: string): (string | MustHaveItem)[] {\r\n  const fm = extractFrontmatter(content);\r\n  const mustHaves = fm.must_haves as FrontmatterData | undefined;\r\n  if (!mustHaves || typeof mustHaves !== 'object') return [];\r\n  const block = mustHaves[blockName];\r\n  if (!Array.isArray(block)) return [];\r\n  return block as (string | MustHaveItem)[];\r\n}\r\n\r\n//  Frontmatter schema validation \r\n\r\nexport const FRONTMATTER_SCHEMAS: Record<string, FrontmatterSchema> = {\r\n  plan: {\r\n    required: ['phase', 'plan', 'type', 'wave', 'depends_on', 'files_modified', 'autonomous', 'must_haves'],\r\n  },\r\n  summary: {\r\n    required: ['phase', 'plan', 'subsystem', 'tags', 'duration', 'completed'],\r\n  },\r\n  verification: {\r\n    required: ['phase', 'verified', 'status', 'score'],\r\n  },\r\n};\r\n\r\n//  Frontmatter CRUD commands \r\n\r\nexport function cmdFrontmatterGet(\r\n  cwd: string,\r\n  filePath: string | null,\r\n  field: string | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!filePath) {\r\n    error('file path required');\r\n  }\r\n  const fullPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n  const fm = extractFrontmatter(content);\r\n  if (field) {\r\n    const value = fm[field];\r\n    if (value === undefined) {\r\n      output({ error: 'Field not found', field }, raw);\r\n      return;\r\n    }\r\n    output({ [field]: value }, raw, JSON.stringify(value));\r\n  } else {\r\n    output(fm, raw);\r\n  }\r\n}\r\n\r\nexport function cmdFrontmatterSet(\r\n  cwd: string,\r\n  filePath: string | null,\r\n  field: string | null,\r\n  value: string | undefined,\r\n  raw: boolean,\r\n): void {\r\n  if (!filePath || !field || value === undefined) {\r\n    error('file, field, and value required');\r\n  }\r\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\r\n  if (!fs.existsSync(fullPath)) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n  const content = fs.readFileSync(fullPath, 'utf-8');\r\n  const fm = extractFrontmatter(content);\r\n  let parsedValue: FrontmatterValue;\r\n  try {\r\n    parsedValue = JSON.parse(value!) as FrontmatterValue;\r\n  } catch {\r\n    parsedValue = value!;\r\n  }\r\n  fm[field!] = parsedValue;\r\n  const newContent = spliceFrontmatter(content, fm);\r\n  fs.writeFileSync(fullPath, newContent, 'utf-8');\r\n  output({ updated: true, field, value: parsedValue }, raw, 'true');\r\n}\r\n\r\nexport function cmdFrontmatterMerge(\r\n  cwd: string,\r\n  filePath: string | null,\r\n  data: string | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!filePath || !data) {\r\n    error('file and data required');\r\n  }\r\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\r\n  if (!fs.existsSync(fullPath)) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n  const content = fs.readFileSync(fullPath, 'utf-8');\r\n  const fm = extractFrontmatter(content);\r\n  let mergeData: FrontmatterData;\r\n  try {\r\n    mergeData = JSON.parse(data!) as FrontmatterData;\r\n  } catch {\r\n    error('Invalid JSON for --data');\r\n    return;\r\n  }\r\n  Object.assign(fm, mergeData);\r\n  const newContent = spliceFrontmatter(content, fm);\r\n  fs.writeFileSync(fullPath, newContent, 'utf-8');\r\n  output({ merged: true, fields: Object.keys(mergeData) }, raw, 'true');\r\n}\r\n\r\nexport function cmdFrontmatterValidate(\r\n  cwd: string,\r\n  filePath: string | null,\r\n  schemaName: string | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!filePath || !schemaName) {\r\n    error('file and schema required');\r\n  }\r\n  const schema = FRONTMATTER_SCHEMAS[schemaName!];\r\n  if (!schema) {\r\n    error(\r\n      `Unknown schema: ${schemaName}. Available: ${Object.keys(FRONTMATTER_SCHEMAS).join(', ')}`,\r\n    );\r\n  }\r\n  const fullPath = path.isAbsolute(filePath!) ? filePath! : path.join(cwd, filePath!);\r\n  const content = safeReadFile(fullPath);\r\n  if (!content) {\r\n    output({ error: 'File not found', path: filePath }, raw);\r\n    return;\r\n  }\r\n  const fm = extractFrontmatter(content);\r\n  const missing = schema.required.filter(f => fm[f] === undefined);\r\n  const present = schema.required.filter(f => fm[f] !== undefined);\r\n  const result: FrontmatterValidationResult = {\r\n    valid: missing.length === 0,\r\n    missing,\r\n    present,\r\n    schema: schemaName!,\r\n  };\r\n  output(result, raw, missing.length === 0 ? 'valid' : 'invalid');\r\n}\r\n","/**\r\n * Phase  Phase CRUD, query, and lifecycle operations\r\n *\r\n * Ported from maxsim/bin/lib/phase.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport {\r\n  normalizePhaseName,\r\n  comparePhaseNum,\r\n  getPhasePattern,\r\n  findPhaseInternal,\r\n  getArchivedPhaseDirs,\r\n  generateSlugInternal,\r\n  output,\r\n  error,\r\n  rethrowCliSignals,\r\n  phasesPath,\r\n  roadmapPath,\r\n  statePath,\r\n  planningPath,\r\n  isPlanFile,\r\n  isSummaryFile,\r\n  planId,\r\n  summaryId,\r\n  listSubDirs,\r\n  debugLog,\r\n  todayISO,\r\n  escapePhaseNum,\r\n} from './core.js';\r\nimport { extractFrontmatter } from './frontmatter.js';\r\nimport type {\r\n  PhaseNumber,\r\n  PhasesListOptions,\r\n  FrontmatterData,\r\n} from './types.js';\r\n\r\n//  Core result types \r\n\r\nexport interface PhaseCreateOptions {\r\n  includeStubs?: boolean;\r\n}\r\n\r\nexport interface PhaseAddResult {\r\n  phase_number: number;\r\n  padded: string;\r\n  slug: string;\r\n  directory: string;\r\n  description: string;\r\n}\r\n\r\nexport interface PhaseInsertResult {\r\n  phase_number: string;\r\n  after_phase: string;\r\n  slug: string;\r\n  directory: string;\r\n  description: string;\r\n}\r\n\r\nexport interface PhaseCompleteResult {\r\n  completed_phase: string;\r\n  phase_name: string | null;\r\n  plans_executed: string;\r\n  next_phase: string | null;\r\n  next_phase_name: string | null;\r\n  is_last_phase: boolean;\r\n  date: string;\r\n  roadmap_updated: boolean;\r\n  state_updated: boolean;\r\n  requirements_updated: boolean;\r\n}\r\n\r\n//  Stub scaffolding \r\n\r\nexport function scaffoldPhaseStubs(dirPath: string, phaseId: string, name: string): void {\r\n  const today = todayISO();\r\n  fs.writeFileSync(\r\n    path.join(dirPath, `${phaseId}-CONTEXT.md`),\r\n    `# Phase ${phaseId} Context: ${name}\\n\\n**Created:** ${today}\\n**Phase goal:** [To be defined during /maxsim:discuss-phase]\\n\\n---\\n\\n_Context will be populated by /maxsim:discuss-phase_\\n`,\r\n  );\r\n  fs.writeFileSync(\r\n    path.join(dirPath, `${phaseId}-RESEARCH.md`),\r\n    `# Phase ${phaseId}: ${name} - Research\\n\\n**Researched:** Not yet\\n**Domain:** TBD\\n**Confidence:** TBD\\n\\n---\\n\\n_Research will be populated by /maxsim:research-phase_\\n`,\r\n  );\r\n}\r\n\r\n//  Core functions \r\n\r\nexport function phaseAddCore(cwd: string, description: string, options?: PhaseCreateOptions): PhaseAddResult {\r\n  const rmPath = roadmapPath(cwd);\r\n  if (!fs.existsSync(rmPath)) {\r\n    throw new Error('ROADMAP.md not found');\r\n  }\r\n\r\n  const content = fs.readFileSync(rmPath, 'utf-8');\r\n  const slug = generateSlugInternal(description);\r\n\r\n  const phasePattern = getPhasePattern();\r\n  let maxPhase = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = phasePattern.exec(content)) !== null) {\r\n    const num = parseInt(m[1], 10);\r\n    if (num > maxPhase) maxPhase = num;\r\n  }\r\n\r\n  const newPhaseNum = maxPhase + 1;\r\n  const paddedNum = String(newPhaseNum).padStart(2, '0');\r\n  const dirName = `${paddedNum}-${slug}`;\r\n  const dirPath = planningPath(cwd, 'phases', dirName);\r\n\r\n  fs.mkdirSync(dirPath, { recursive: true });\r\n  fs.writeFileSync(path.join(dirPath, '.gitkeep'), '');\r\n\r\n  if (options?.includeStubs) {\r\n    scaffoldPhaseStubs(dirPath, paddedNum, description);\r\n  }\r\n\r\n  const phaseEntry = `\\n### Phase ${newPhaseNum}: ${description}\\n\\n**Goal:** [To be planned]\\n**Requirements**: TBD\\n**Depends on:** Phase ${maxPhase}\\n**Plans:** 0 plans\\n\\nPlans:\\n- [ ] TBD (run /maxsim:plan-phase ${newPhaseNum} to break down)\\n`;\r\n\r\n  let updatedContent: string;\r\n  const lastSeparator = content.lastIndexOf('\\n---');\r\n  if (lastSeparator > 0) {\r\n    updatedContent = content.slice(0, lastSeparator) + phaseEntry + content.slice(lastSeparator);\r\n  } else {\r\n    updatedContent = content + phaseEntry;\r\n  }\r\n\r\n  fs.writeFileSync(rmPath, updatedContent, 'utf-8');\r\n\r\n  return {\r\n    phase_number: newPhaseNum,\r\n    padded: paddedNum,\r\n    slug,\r\n    directory: `.planning/phases/${dirName}`,\r\n    description,\r\n  };\r\n}\r\n\r\nexport function phaseInsertCore(cwd: string, afterPhase: string, description: string, options?: PhaseCreateOptions): PhaseInsertResult {\r\n  const rmPath = roadmapPath(cwd);\r\n  if (!fs.existsSync(rmPath)) {\r\n    throw new Error('ROADMAP.md not found');\r\n  }\r\n\r\n  const content = fs.readFileSync(rmPath, 'utf-8');\r\n  const slug = generateSlugInternal(description);\r\n\r\n  const normalizedAfter = normalizePhaseName(afterPhase);\r\n  const unpadded = normalizedAfter.replace(/^0+/, '');\r\n  const afterPhaseEscaped = '0*' + unpadded.replace(/\\./g, '\\\\.');\r\n  const targetPattern = getPhasePattern(afterPhaseEscaped, 'i');\r\n  if (!targetPattern.test(content)) {\r\n    throw new Error(`Phase ${afterPhase} not found in ROADMAP.md`);\r\n  }\r\n\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const normalizedBase = normalizePhaseName(afterPhase);\r\n  const existingDecimals: number[] = [];\r\n\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath);\r\n    const decimalPattern = new RegExp(`^${normalizedBase}\\\\.(\\\\d+)`);\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(decimalPattern);\r\n      if (dm) existingDecimals.push(parseInt(dm[1], 10));\r\n    }\r\n  } catch (e) {\r\n    debugLog(e);\r\n  }\r\n\r\n  const nextDecimal = existingDecimals.length === 0 ? 1 : Math.max(...existingDecimals) + 1;\r\n  const decimalPhase = `${normalizedBase}.${nextDecimal}`;\r\n  const dirName = `${decimalPhase}-${slug}`;\r\n  const dirPath = planningPath(cwd, 'phases', dirName);\r\n\r\n  fs.mkdirSync(dirPath, { recursive: true });\r\n  fs.writeFileSync(path.join(dirPath, '.gitkeep'), '');\r\n\r\n  if (options?.includeStubs) {\r\n    scaffoldPhaseStubs(dirPath, decimalPhase, description);\r\n  }\r\n\r\n  const phaseEntry = `\\n### Phase ${decimalPhase}: ${description} (INSERTED)\\n\\n**Goal:** [Urgent work - to be planned]\\n**Requirements**: TBD\\n**Depends on:** Phase ${afterPhase}\\n**Plans:** 0 plans\\n\\nPlans:\\n- [ ] TBD (run /maxsim:plan-phase ${decimalPhase} to break down)\\n`;\r\n\r\n  const headerPattern = new RegExp(`(#{2,4}\\\\s*Phase\\\\s+0*${afterPhaseEscaped}:[^\\\\n]*\\\\n)`, 'i');\r\n  const headerMatch = content.match(headerPattern);\r\n  if (!headerMatch) {\r\n    throw new Error(`Could not find Phase ${afterPhase} header`);\r\n  }\r\n\r\n  const headerIdx = content.indexOf(headerMatch[0]);\r\n  const afterHeader = content.slice(headerIdx + headerMatch[0].length);\r\n  const nextPhaseMatch = afterHeader.match(/\\n#{2,4}\\s+Phase\\s+\\d/i);\r\n\r\n  let insertIdx: number;\r\n  if (nextPhaseMatch) {\r\n    insertIdx = headerIdx + headerMatch[0].length + nextPhaseMatch.index!;\r\n  } else {\r\n    insertIdx = content.length;\r\n  }\r\n\r\n  const updatedContent = content.slice(0, insertIdx) + phaseEntry + content.slice(insertIdx);\r\n  fs.writeFileSync(rmPath, updatedContent, 'utf-8');\r\n\r\n  return {\r\n    phase_number: decimalPhase,\r\n    after_phase: afterPhase,\r\n    slug,\r\n    directory: `.planning/phases/${dirName}`,\r\n    description,\r\n  };\r\n}\r\n\r\nexport function phaseCompleteCore(cwd: string, phaseNum: string): PhaseCompleteResult {\r\n  const rmPath = roadmapPath(cwd);\r\n  const stPath = statePath(cwd);\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const today = todayISO();\r\n\r\n  const phaseInfo = findPhaseInternal(cwd, phaseNum);\r\n  if (!phaseInfo) {\r\n    throw new Error(`Phase ${phaseNum} not found`);\r\n  }\r\n\r\n  const planCount = phaseInfo.plans.length;\r\n  const summaryCount = phaseInfo.summaries.length;\r\n  let requirementsUpdated = false;\r\n\r\n  if (fs.existsSync(rmPath)) {\r\n    let roadmapContent = fs.readFileSync(rmPath, 'utf-8');\r\n\r\n    const checkboxPattern = new RegExp(\r\n      `(-\\\\s*\\\\[)[ ](\\\\]\\\\s*.*Phase\\\\s+${escapePhaseNum(phaseNum)}[:\\\\s][^\\\\n]*)`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(checkboxPattern, `$1x$2 (completed ${today})`);\r\n\r\n    const phaseEscaped = escapePhaseNum(phaseNum);\r\n    const tablePattern = new RegExp(\r\n      `(\\\\|\\\\s*${phaseEscaped}\\\\.?\\\\s[^|]*\\\\|[^|]*\\\\|)\\\\s*[^|]*(\\\\|)\\\\s*[^|]*(\\\\|)`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(\r\n      tablePattern,\r\n      `$1 Complete    $2 ${today} $3`,\r\n    );\r\n\r\n    const planCountPattern = new RegExp(\r\n      `(#{2,4}\\\\s*Phase\\\\s+${phaseEscaped}[\\\\s\\\\S]*?\\\\*\\\\*Plans:\\\\*\\\\*\\\\s*)[^\\\\n]+`,\r\n      'i',\r\n    );\r\n    roadmapContent = roadmapContent.replace(\r\n      planCountPattern,\r\n      `$1${summaryCount}/${planCount} plans complete`,\r\n    );\r\n\r\n    fs.writeFileSync(rmPath, roadmapContent, 'utf-8');\r\n\r\n    // Update REQUIREMENTS.md\r\n    const reqPath = planningPath(cwd, 'REQUIREMENTS.md');\r\n    if (fs.existsSync(reqPath)) {\r\n      const reqMatch = roadmapContent.match(\r\n        new RegExp(`Phase\\\\s+${escapePhaseNum(phaseNum)}[\\\\s\\\\S]*?\\\\*\\\\*Requirements:\\\\*\\\\*\\\\s*([^\\\\n]+)`, 'i'),\r\n      );\r\n\r\n      if (reqMatch) {\r\n        const reqIds = reqMatch[1].replace(/[\\[\\]]/g, '').split(/[,\\s]+/).map(r => r.trim()).filter(Boolean);\r\n        let reqContent = fs.readFileSync(reqPath, 'utf-8');\r\n\r\n        for (const reqId of reqIds) {\r\n          reqContent = reqContent.replace(\r\n            new RegExp(`(-\\\\s*\\\\[)[ ](\\\\]\\\\s*\\\\*\\\\*${reqId}\\\\*\\\\*)`, 'gi'),\r\n            '$1x$2',\r\n          );\r\n          reqContent = reqContent.replace(\r\n            new RegExp(`(\\\\|\\\\s*${reqId}\\\\s*\\\\|[^|]+\\\\|)\\\\s*Pending\\\\s*(\\\\|)`, 'gi'),\r\n            '$1 Complete $2',\r\n          );\r\n        }\r\n\r\n        fs.writeFileSync(reqPath, reqContent, 'utf-8');\r\n        requirementsUpdated = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find next phase\r\n  let nextPhaseNum: string | null = null;\r\n  let nextPhaseName: string | null = null;\r\n  let isLastPhase = true;\r\n\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath, true);\r\n\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n      if (dm) {\r\n        if (comparePhaseNum(dm[1], phaseNum) > 0) {\r\n          nextPhaseNum = dm[1];\r\n          nextPhaseName = dm[2] || null;\r\n          isLastPhase = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    debugLog(e);\r\n  }\r\n\r\n  // Update STATE.md\r\n  if (fs.existsSync(stPath)) {\r\n    let stateContent = fs.readFileSync(stPath, 'utf-8');\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Current Phase:\\*\\*\\s*).*/,\r\n      `$1${nextPhaseNum || phaseNum}`,\r\n    );\r\n\r\n    if (nextPhaseName) {\r\n      stateContent = stateContent.replace(\r\n        /(\\*\\*Current Phase Name:\\*\\*\\s*).*/,\r\n        `$1${nextPhaseName.replace(/-/g, ' ')}`,\r\n      );\r\n    }\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Status:\\*\\*\\s*).*/,\r\n      `$1${isLastPhase ? 'Milestone complete' : 'Ready to plan'}`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Current Plan:\\*\\*\\s*).*/,\r\n      `$1Not started`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity:\\*\\*\\s*).*/,\r\n      `$1${today}`,\r\n    );\r\n\r\n    stateContent = stateContent.replace(\r\n      /(\\*\\*Last Activity Description:\\*\\*\\s*).*/,\r\n      `$1Phase ${phaseNum} complete${nextPhaseNum ? `, transitioned to Phase ${nextPhaseNum}` : ''}`,\r\n    );\r\n\r\n    fs.writeFileSync(stPath, stateContent, 'utf-8');\r\n  }\r\n\r\n  return {\r\n    completed_phase: phaseNum,\r\n    phase_name: phaseInfo.phase_name,\r\n    plans_executed: `${summaryCount}/${planCount}`,\r\n    next_phase: nextPhaseNum,\r\n    next_phase_name: nextPhaseName,\r\n    is_last_phase: isLastPhase,\r\n    date: today,\r\n    roadmap_updated: fs.existsSync(rmPath),\r\n    state_updated: fs.existsSync(stPath),\r\n    requirements_updated: requirementsUpdated,\r\n  };\r\n}\r\n\r\n//  Phase list \r\n\r\nexport function cmdPhasesList(cwd: string, options: PhasesListOptions, raw: boolean): void {\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const { type, phase, includeArchived } = options;\r\n\r\n  if (!fs.existsSync(phasesDirPath)) {\r\n    if (type) {\r\n      output({ files: [], count: 0 }, raw, '');\r\n    } else {\r\n      output({ directories: [], count: 0 }, raw, '');\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    let dirs = listSubDirs(phasesDirPath);\r\n\r\n    if (includeArchived) {\r\n      const archived = getArchivedPhaseDirs(cwd);\r\n      for (const a of archived) {\r\n        dirs.push(`${a.name} [${a.milestone}]`);\r\n      }\r\n    }\r\n\r\n    dirs.sort((a, b) => comparePhaseNum(a, b));\r\n\r\n    if (phase) {\r\n      const normalized = normalizePhaseName(phase);\r\n      const match = dirs.find(d => d.startsWith(normalized));\r\n      if (!match) {\r\n        output({ files: [], count: 0, phase_dir: null, error: 'Phase not found' }, raw, '');\r\n        return;\r\n      }\r\n      dirs = [match];\r\n    }\r\n\r\n    if (type) {\r\n      const files: string[] = [];\r\n      for (const dir of dirs) {\r\n        const dirPath = path.join(phasesDirPath, dir);\r\n        const dirFiles = fs.readdirSync(dirPath);\r\n\r\n        let filtered: string[];\r\n        if (type === 'plans') {\r\n          filtered = dirFiles.filter(isPlanFile);\r\n        } else if (type === 'summaries') {\r\n          filtered = dirFiles.filter(isSummaryFile);\r\n        } else {\r\n          filtered = dirFiles;\r\n        }\r\n\r\n        files.push(...filtered.sort());\r\n      }\r\n\r\n      const result = {\r\n        files,\r\n        count: files.length,\r\n        phase_dir: phase ? dirs[0].replace(/^\\d+(?:\\.\\d+)?-?/, '') : null,\r\n      };\r\n      output(result, raw, files.join('\\n'));\r\n      return;\r\n    }\r\n\r\n    output({ directories: dirs, count: dirs.length }, raw, dirs.join('\\n'));\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    error('Failed to list phases: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n//  Next decimal \r\n\r\nexport function cmdPhaseNextDecimal(cwd: string, basePhase: string, raw: boolean): void {\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const normalized = normalizePhaseName(basePhase);\r\n\r\n  if (!fs.existsSync(phasesDirPath)) {\r\n    output(\r\n      { found: false, base_phase: normalized, next: `${normalized}.1`, existing: [] },\r\n      raw,\r\n      `${normalized}.1`,\r\n    );\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath);\r\n\r\n    const baseExists = dirs.some(d => d.startsWith(normalized + '-') || d === normalized);\r\n\r\n    const decimalPattern = new RegExp(`^${normalized}\\\\.(\\\\d+)`);\r\n    const existingDecimals: string[] = [];\r\n\r\n    for (const dir of dirs) {\r\n      const match = dir.match(decimalPattern);\r\n      if (match) {\r\n        existingDecimals.push(`${normalized}.${match[1]}`);\r\n      }\r\n    }\r\n\r\n    existingDecimals.sort((a, b) => {\r\n      const aNum = parseFloat(a);\r\n      const bNum = parseFloat(b);\r\n      return aNum - bNum;\r\n    });\r\n\r\n    let nextDecimal: string;\r\n    if (existingDecimals.length === 0) {\r\n      nextDecimal = `${normalized}.1`;\r\n    } else {\r\n      const lastDecimal = existingDecimals[existingDecimals.length - 1];\r\n      const lastNum = parseInt(lastDecimal.split('.')[1], 10);\r\n      nextDecimal = `${normalized}.${lastNum + 1}`;\r\n    }\r\n\r\n    output(\r\n      { found: baseExists, base_phase: normalized, next: nextDecimal, existing: existingDecimals },\r\n      raw,\r\n      nextDecimal,\r\n    );\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    error('Failed to calculate next decimal phase: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n//  Find phase \r\n\r\nexport function cmdFindPhase(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase identifier required');\r\n  }\r\n\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  const notFound = { found: false, directory: null, phase_number: null, phase_name: null, plans: [] as string[], summaries: [] as string[] };\r\n\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath, true);\r\n\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (!match) {\r\n      output(notFound, raw, '');\r\n      return;\r\n    }\r\n\r\n    const dirMatch = match.match(/^(\\d+[A-Z]?(?:\\.\\d+)?)-?(.*)/i);\r\n    const phaseNumber = dirMatch ? dirMatch[1] : normalized;\r\n    const phaseName = dirMatch && dirMatch[2] ? dirMatch[2] : null;\r\n\r\n    const phaseDir = path.join(phasesDirPath, match);\r\n    const phaseFiles = fs.readdirSync(phaseDir);\r\n    const plans = phaseFiles.filter(isPlanFile).sort();\r\n    const summaries = phaseFiles.filter(isSummaryFile).sort();\r\n\r\n    const result = {\r\n      found: true,\r\n      directory: path.join('.planning', 'phases', match),\r\n      phase_number: phaseNumber,\r\n      phase_name: phaseName,\r\n      plans,\r\n      summaries,\r\n    };\r\n\r\n    output(result, raw, result.directory);\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    output(notFound, raw, '');\r\n  }\r\n}\r\n\r\n//  Phase plan index \r\n\r\nexport function cmdPhasePlanIndex(cwd: string, phase: string | undefined, raw: boolean): void {\r\n  if (!phase) {\r\n    error('phase required for phase-plan-index');\r\n  }\r\n\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const normalized = normalizePhaseName(phase);\r\n\r\n  let phaseDir: string | null = null;\r\n  let phaseDirName: string | null = null;\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath, true);\r\n    const match = dirs.find(d => d.startsWith(normalized));\r\n    if (match) {\r\n      phaseDir = path.join(phasesDirPath, match);\r\n      phaseDirName = match;\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    debugLog(e);\r\n  }\r\n\r\n  if (!phaseDir) {\r\n    output({ phase: normalized, error: 'Phase not found', plans: [], waves: {}, incomplete: [], has_checkpoints: false }, raw);\r\n    return;\r\n  }\r\n\r\n  const phaseFiles = fs.readdirSync(phaseDir);\r\n  const planFiles = phaseFiles.filter(isPlanFile).sort();\r\n  const summaryFiles = phaseFiles.filter(isSummaryFile);\r\n\r\n  const completedPlanIds = new Set(\r\n    summaryFiles.map(summaryId),\r\n  );\r\n\r\n  const plans: Array<{\r\n    id: string;\r\n    wave: number;\r\n    autonomous: boolean;\r\n    objective: string | null;\r\n    files_modified: string[];\r\n    task_count: number;\r\n    has_summary: boolean;\r\n  }> = [];\r\n  const waves: Record<string, string[]> = {};\r\n  const incomplete: string[] = [];\r\n  let hasCheckpoints = false;\r\n\r\n  for (const planFile of planFiles) {\r\n    const id = planId(planFile);\r\n    const planPath = path.join(phaseDir, planFile);\r\n    const content = fs.readFileSync(planPath, 'utf-8');\r\n    const fm = extractFrontmatter(content);\r\n\r\n    const taskMatches = content.match(/##\\s*Task\\s*\\d+/gi) || [];\r\n    const taskCount = taskMatches.length;\r\n\r\n    const wave = parseInt(fm.wave as string, 10) || 1;\r\n\r\n    let autonomous = true;\r\n    if (fm.autonomous !== undefined) {\r\n      autonomous = fm.autonomous === 'true' || fm.autonomous === true;\r\n    }\r\n\r\n    if (!autonomous) {\r\n      hasCheckpoints = true;\r\n    }\r\n\r\n    let filesModified: string[] = [];\r\n    if (fm['files-modified']) {\r\n      filesModified = Array.isArray(fm['files-modified']) ? fm['files-modified'] as string[] : [fm['files-modified'] as string];\r\n    }\r\n\r\n    const hasSummary = completedPlanIds.has(id);\r\n    if (!hasSummary) {\r\n      incomplete.push(id);\r\n    }\r\n\r\n    const plan = {\r\n      id,\r\n      wave,\r\n      autonomous,\r\n      objective: (fm.objective as string) || null,\r\n      files_modified: filesModified,\r\n      task_count: taskCount,\r\n      has_summary: hasSummary,\r\n    };\r\n\r\n    plans.push(plan);\r\n\r\n    const waveKey = String(wave);\r\n    if (!waves[waveKey]) {\r\n      waves[waveKey] = [];\r\n    }\r\n    waves[waveKey].push(id);\r\n  }\r\n\r\n  output({ phase: normalized, plans, waves, incomplete, has_checkpoints: hasCheckpoints }, raw);\r\n}\r\n\r\n//  Phase add \r\n\r\nexport function cmdPhaseAdd(cwd: string, description: string | undefined, raw: boolean): void {\r\n  if (!description) {\r\n    error('description required for phase add');\r\n  }\r\n\r\n  try {\r\n    const result = phaseAddCore(cwd, description, { includeStubs: false });\r\n    output(\r\n      { phase_number: result.phase_number, padded: result.padded, name: result.description, slug: result.slug, directory: result.directory },\r\n      raw,\r\n      result.padded,\r\n    );\r\n  } catch (e) {\r\n    rethrowCliSignals(e);\r\n    error((e as Error).message);\r\n  }\r\n}\r\n\r\n//  Phase insert \r\n\r\nexport function cmdPhaseInsert(cwd: string, afterPhase: string | undefined, description: string | undefined, raw: boolean): void {\r\n  if (!afterPhase || !description) {\r\n    error('after-phase and description required for phase insert');\r\n  }\r\n\r\n  try {\r\n    const result = phaseInsertCore(cwd, afterPhase, description, { includeStubs: false });\r\n    output(\r\n      { phase_number: result.phase_number, after_phase: result.after_phase, name: result.description, slug: result.slug, directory: result.directory },\r\n      raw,\r\n      result.phase_number,\r\n    );\r\n  } catch (e) {\r\n    rethrowCliSignals(e);\r\n    error((e as Error).message);\r\n  }\r\n}\r\n\r\n//  Phase remove \r\n\r\nexport function cmdPhaseRemove(\r\n  cwd: string,\r\n  targetPhase: string | undefined,\r\n  options: { force: boolean },\r\n  raw: boolean,\r\n): void {\r\n  if (!targetPhase) {\r\n    error('phase number required for phase remove');\r\n  }\r\n\r\n  const rmPath = roadmapPath(cwd);\r\n  const phasesDirPath = phasesPath(cwd);\r\n  const force = options.force || false;\r\n\r\n  if (!fs.existsSync(rmPath)) {\r\n    error('ROADMAP.md not found');\r\n  }\r\n\r\n  const normalized = normalizePhaseName(targetPhase);\r\n  const isDecimal = targetPhase.includes('.');\r\n\r\n  let targetDir: string | null = null;\r\n  try {\r\n    const dirs = listSubDirs(phasesDirPath, true);\r\n    targetDir = dirs.find(d => d.startsWith(normalized + '-') || d === normalized) || null;\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    debugLog(e);\r\n  }\r\n\r\n  if (targetDir && !force) {\r\n    const targetPath = path.join(phasesDirPath, targetDir);\r\n    const files = fs.readdirSync(targetPath);\r\n    const summaries = files.filter(isSummaryFile);\r\n    if (summaries.length > 0) {\r\n      error(`Phase ${targetPhase} has ${summaries.length} executed plan(s). Use --force to remove anyway.`);\r\n    }\r\n  }\r\n\r\n  if (targetDir) {\r\n    fs.rmSync(path.join(phasesDirPath, targetDir), { recursive: true, force: true });\r\n  }\r\n\r\n  const renamedDirs: Array<{ from: string; to: string }> = [];\r\n  const renamedFiles: Array<{ from: string; to: string }> = [];\r\n\r\n  if (isDecimal) {\r\n    const baseParts = normalized.split('.');\r\n    const baseInt = baseParts[0];\r\n    const removedDecimal = parseInt(baseParts[1], 10);\r\n\r\n    try {\r\n      const dirs = listSubDirs(phasesDirPath, true);\r\n\r\n      const decPattern = new RegExp(`^${baseInt}\\\\.(\\\\d+)-(.+)$`);\r\n      const toRename: Array<{ dir: string; oldDecimal: number; slug: string }> = [];\r\n      for (const dir of dirs) {\r\n        const dm = dir.match(decPattern);\r\n        if (dm && parseInt(dm[1], 10) > removedDecimal) {\r\n          toRename.push({ dir, oldDecimal: parseInt(dm[1], 10), slug: dm[2] });\r\n        }\r\n      }\r\n\r\n      toRename.sort((a, b) => b.oldDecimal - a.oldDecimal);\r\n\r\n      for (const item of toRename) {\r\n        const newDecimal = item.oldDecimal - 1;\r\n        const oldPhaseId = `${baseInt}.${item.oldDecimal}`;\r\n        const newPhaseId = `${baseInt}.${newDecimal}`;\r\n        const newDirName = `${baseInt}.${newDecimal}-${item.slug}`;\r\n\r\n        fs.renameSync(path.join(phasesDirPath, item.dir), path.join(phasesDirPath, newDirName));\r\n        renamedDirs.push({ from: item.dir, to: newDirName });\r\n\r\n        const dirFiles = fs.readdirSync(path.join(phasesDirPath, newDirName));\r\n        for (const f of dirFiles) {\r\n          if (f.includes(oldPhaseId)) {\r\n            const newFileName = f.replace(oldPhaseId, newPhaseId);\r\n            fs.renameSync(\r\n              path.join(phasesDirPath, newDirName, f),\r\n              path.join(phasesDirPath, newDirName, newFileName),\r\n            );\r\n            renamedFiles.push({ from: f, to: newFileName });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      debugLog(e);\r\n    }\r\n  } else {\r\n    const removedInt = parseInt(normalized, 10);\r\n\r\n    try {\r\n      const dirs = listSubDirs(phasesDirPath, true);\r\n\r\n      const toRename: Array<{ dir: string; oldInt: number; letter: string; decimal: number | null; slug: string }> = [];\r\n      for (const dir of dirs) {\r\n        const dm = dir.match(/^(\\d+)([A-Z])?(?:\\.(\\d+))?-(.+)$/i);\r\n        if (!dm) continue;\r\n        const dirInt = parseInt(dm[1], 10);\r\n        if (dirInt > removedInt) {\r\n          toRename.push({\r\n            dir,\r\n            oldInt: dirInt,\r\n            letter: dm[2] ? dm[2].toUpperCase() : '',\r\n            decimal: dm[3] ? parseInt(dm[3], 10) : null,\r\n            slug: dm[4],\r\n          });\r\n        }\r\n      }\r\n\r\n      toRename.sort((a, b) => {\r\n        if (a.oldInt !== b.oldInt) return b.oldInt - a.oldInt;\r\n        return (b.decimal || 0) - (a.decimal || 0);\r\n      });\r\n\r\n      for (const item of toRename) {\r\n        const newInt = item.oldInt - 1;\r\n        const newPadded = String(newInt).padStart(2, '0');\r\n        const oldPadded = String(item.oldInt).padStart(2, '0');\r\n        const letterSuffix = item.letter || '';\r\n        const decimalSuffix = item.decimal !== null ? `.${item.decimal}` : '';\r\n        const oldPrefix = `${oldPadded}${letterSuffix}${decimalSuffix}`;\r\n        const newPrefix = `${newPadded}${letterSuffix}${decimalSuffix}`;\r\n        const newDirName = `${newPrefix}-${item.slug}`;\r\n\r\n        fs.renameSync(path.join(phasesDirPath, item.dir), path.join(phasesDirPath, newDirName));\r\n        renamedDirs.push({ from: item.dir, to: newDirName });\r\n\r\n        const dirFiles = fs.readdirSync(path.join(phasesDirPath, newDirName));\r\n        for (const f of dirFiles) {\r\n          if (f.startsWith(oldPrefix)) {\r\n            const newFileName = newPrefix + f.slice(oldPrefix.length);\r\n            fs.renameSync(\r\n              path.join(phasesDirPath, newDirName, f),\r\n              path.join(phasesDirPath, newDirName, newFileName),\r\n            );\r\n            renamedFiles.push({ from: f, to: newFileName });\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      debugLog(e);\r\n    }\r\n  }\r\n\r\n  // Update ROADMAP.md\r\n  let roadmapContent = fs.readFileSync(rmPath, 'utf-8');\r\n\r\n  const targetEscaped = escapePhaseNum(targetPhase);\r\n  const sectionPattern = new RegExp(\r\n    `\\\\n?#{2,4}\\\\s*Phase\\\\s+${targetEscaped}\\\\s*:[\\\\s\\\\S]*?(?=\\\\n#{2,4}\\\\s+Phase\\\\s+\\\\d|$)`,\r\n    'i',\r\n  );\r\n  roadmapContent = roadmapContent.replace(sectionPattern, '');\r\n\r\n  const checkboxPattern = new RegExp(`\\\\n?-\\\\s*\\\\[[ x]\\\\]\\\\s*.*Phase\\\\s+${targetEscaped}[:\\\\s][^\\\\n]*`, 'gi');\r\n  roadmapContent = roadmapContent.replace(checkboxPattern, '');\r\n\r\n  const tableRowPattern = new RegExp(`\\\\n?\\\\|\\\\s*${targetEscaped}\\\\.?\\\\s[^|]*\\\\|[^\\\\n]*`, 'gi');\r\n  roadmapContent = roadmapContent.replace(tableRowPattern, '');\r\n\r\n  if (!isDecimal) {\r\n    const removedInt = parseInt(normalized, 10);\r\n    const maxPhase = 99;\r\n    for (let oldNum = maxPhase; oldNum > removedInt; oldNum--) {\r\n      const newNum = oldNum - 1;\r\n      const oldStr = String(oldNum);\r\n      const newStr = String(newNum);\r\n      const oldPad = oldStr.padStart(2, '0');\r\n      const newPad = newStr.padStart(2, '0');\r\n\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(#{2,4}\\\\s*Phase\\\\s+)${oldStr}(\\\\s*:)`, 'gi'),\r\n        `$1${newStr}$2`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(Phase\\\\s+)${oldStr}([:\\\\s])`, 'g'),\r\n        `$1${newStr}$2`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`${oldPad}-(\\\\d{2})`, 'g'),\r\n        `${newPad}-$1`,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(\\\\|\\\\s*)${oldStr}\\\\.\\\\s`, 'g'),\r\n        `$1${newStr}. `,\r\n      );\r\n      roadmapContent = roadmapContent.replace(\r\n        new RegExp(`(Depends on:\\\\*\\\\*\\\\s*Phase\\\\s+)${oldStr}\\\\b`, 'gi'),\r\n        `$1${newStr}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  fs.writeFileSync(rmPath, roadmapContent, 'utf-8');\r\n\r\n  // Update STATE.md phase count\r\n  const stPath = statePath(cwd);\r\n  if (fs.existsSync(stPath)) {\r\n    let stateContent = fs.readFileSync(stPath, 'utf-8');\r\n    const totalPattern = /(\\*\\*Total Phases:\\*\\*\\s*)(\\d+)/;\r\n    const totalMatch = stateContent.match(totalPattern);\r\n    if (totalMatch) {\r\n      const oldTotal = parseInt(totalMatch[2], 10);\r\n      stateContent = stateContent.replace(totalPattern, `$1${oldTotal - 1}`);\r\n    }\r\n    const ofPattern = /(\\bof\\s+)(\\d+)(\\s*(?:\\(|phases?))/i;\r\n    const ofMatch = stateContent.match(ofPattern);\r\n    if (ofMatch) {\r\n      const oldTotal = parseInt(ofMatch[2], 10);\r\n      stateContent = stateContent.replace(ofPattern, `$1${oldTotal - 1}$3`);\r\n    }\r\n    fs.writeFileSync(stPath, stateContent, 'utf-8');\r\n  }\r\n\r\n  output({\r\n    removed: targetPhase,\r\n    directory_deleted: targetDir || null,\r\n    renamed_directories: renamedDirs,\r\n    renamed_files: renamedFiles,\r\n    roadmap_updated: true,\r\n    state_updated: fs.existsSync(stPath),\r\n  }, raw);\r\n}\r\n\r\n//  Phase complete \r\n\r\nexport function cmdPhaseComplete(cwd: string, phaseNum: string | undefined, raw: boolean): void {\r\n  if (!phaseNum) {\r\n    error('phase number required for phase complete');\r\n  }\r\n\r\n  try {\r\n    const result = phaseCompleteCore(cwd, phaseNum);\r\n    output({\r\n      completed_phase: result.completed_phase,\r\n      phase_name: result.phase_name,\r\n      plans_executed: result.plans_executed,\r\n      next_phase: result.next_phase,\r\n      next_phase_name: result.next_phase_name,\r\n      is_last_phase: result.is_last_phase,\r\n      date: result.date,\r\n      roadmap_updated: result.roadmap_updated,\r\n      state_updated: result.state_updated,\r\n    }, raw);\r\n  } catch (e) {\r\n    rethrowCliSignals(e);\r\n    error((e as Error).message);\r\n  }\r\n}\r\n","/**\r\n * MCP Utilities  Shared helpers for MCP tools\r\n *\r\n * CRITICAL: Never import output() or error() from core  they call process.exit().\r\n * CRITICAL: Never write to stdout  it is reserved for MCP JSON-RPC protocol.\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\n/**\r\n * Walk up from startDir to find a directory containing `.planning/`.\r\n * Returns the directory containing `.planning/` or null if not found.\r\n */\r\nlet _cachedRoot: string | null | undefined;\r\n\r\nexport function detectProjectRoot(startDir?: string): string | null {\r\n  // Only cache when using default startDir (cwd)\r\n  if (startDir === undefined && _cachedRoot !== undefined) {\r\n    return _cachedRoot;\r\n  }\r\n\r\n  let dir = startDir || process.cwd();\r\n\r\n  // Safety limit to prevent infinite loops\r\n  for (let i = 0; i < 100; i++) {\r\n    const planningDir = path.join(dir, '.planning');\r\n    try {\r\n      const stat = fs.statSync(planningDir);\r\n      if (stat.isDirectory()) {\r\n        if (startDir === undefined) _cachedRoot = dir;\r\n        return dir;\r\n      }\r\n    } catch {\r\n      // Not found here, walk up\r\n    }\r\n\r\n    const parent = path.dirname(dir);\r\n    if (parent === dir) {\r\n      // Reached filesystem root\r\n      if (startDir === undefined) _cachedRoot = null;\r\n      return null;\r\n    }\r\n    dir = parent;\r\n  }\r\n\r\n  if (startDir === undefined) _cachedRoot = null;\r\n  return null;\r\n}\r\n\r\n/**\r\n * Return a structured MCP success response.\r\n */\r\nexport function mcpSuccess(data: Record<string, unknown>, summary: string) {\r\n  return {\r\n    content: [\r\n      {\r\n        type: 'text' as const,\r\n        text: JSON.stringify({ success: true, data, summary }, null, 2),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\n/**\r\n * Return a structured MCP error response.\r\n */\r\nexport function mcpError(error: string, summary: string) {\r\n  return {\r\n    content: [\r\n      {\r\n        type: 'text' as const,\r\n        text: JSON.stringify({ success: false, error, summary }, null, 2),\r\n      },\r\n    ],\r\n    isError: true as const,\r\n  };\r\n}\r\n","/**\r\n * Phase CRUD MCP Tools  Phase operations exposed as MCP tools\r\n *\r\n * CRITICAL: Never import output() or error() from core  they call process.exit().\r\n * CRITICAL: Never write to stdout  it is reserved for MCP JSON-RPC protocol.\r\n * CRITICAL: Never call process.exit()  the server must stay alive after every tool call.\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport { z } from 'zod';\r\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\n\r\nimport {\r\n  findPhaseInternal,\r\n  comparePhaseNum,\r\n  getArchivedPhaseDirs,\r\n  phasesPath,\r\n  listSubDirs,\r\n} from '../core/core.js';\r\n\r\nimport {\r\n  phaseAddCore,\r\n  phaseInsertCore,\r\n  phaseCompleteCore,\r\n} from '../core/phase.js';\r\n\r\nimport { detectProjectRoot, mcpSuccess, mcpError } from './utils.js';\r\n\r\n/**\r\n * Register all phase CRUD tools on the MCP server.\r\n */\r\nexport function registerPhaseTools(server: McpServer): void {\r\n  //  mcp_find_phase \r\n\r\n  server.tool(\r\n    'mcp_find_phase',\r\n    'Find a phase directory by number or name. Returns phase details including plans, summaries, and status.',\r\n    {\r\n      phase: z.string().describe('Phase number or name (e.g. \"01\", \"1\", \"01A\", \"1.1\")'),\r\n    },\r\n    async ({ phase }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const result = findPhaseInternal(cwd, phase);\r\n        if (!result) {\r\n          return mcpError(`Phase ${phase} not found`, 'Phase not found');\r\n        }\r\n\r\n        return mcpSuccess(\r\n          {\r\n            found: result.found,\r\n            directory: result.directory,\r\n            phase_number: result.phase_number,\r\n            phase_name: result.phase_name,\r\n            phase_slug: result.phase_slug,\r\n            plans: result.plans,\r\n            summaries: result.summaries,\r\n            incomplete_plans: result.incomplete_plans,\r\n            has_research: result.has_research,\r\n            has_context: result.has_context,\r\n            has_verification: result.has_verification,\r\n            archived: result.archived ?? null,\r\n          },\r\n          `Found phase ${result.phase_number}: ${result.phase_name ?? 'unnamed'}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_list_phases \r\n\r\n  server.tool(\r\n    'mcp_list_phases',\r\n    'List all phase directories, sorted correctly. Optionally include archived phases from milestones.',\r\n    {\r\n      include_archived: z\r\n        .boolean()\r\n        .optional()\r\n        .default(false)\r\n        .describe('Include archived phases from completed milestones'),\r\n    },\r\n    async ({ include_archived }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const phasesDir = phasesPath(cwd);\r\n        if (!fs.existsSync(phasesDir)) {\r\n          return mcpSuccess(\r\n            { directories: [], count: 0 },\r\n            'No phases directory found',\r\n          );\r\n        }\r\n\r\n        let dirs = listSubDirs(phasesDir);\r\n\r\n        if (include_archived) {\r\n          const archived = getArchivedPhaseDirs(cwd);\r\n          for (const a of archived) {\r\n            dirs.push(`${a.name} [${a.milestone}]`);\r\n          }\r\n        }\r\n\r\n        dirs.sort((a, b) => comparePhaseNum(a, b));\r\n\r\n        return mcpSuccess(\r\n          { directories: dirs, count: dirs.length },\r\n          `Found ${dirs.length} phase(s)`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_create_phase \r\n\r\n  server.tool(\r\n    'mcp_create_phase',\r\n    'Create a new phase. Adds the next sequential phase directory and appends to ROADMAP.md.',\r\n    {\r\n      name: z.string().describe('Phase description/name (e.g. \"Authentication System\")'),\r\n    },\r\n    async ({ name }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        if (!name || !name.trim()) {\r\n          return mcpError('Phase name must not be empty', 'Validation failed');\r\n        }\r\n\r\n        const result = phaseAddCore(cwd, name, { includeStubs: true });\r\n\r\n        return mcpSuccess(\r\n          {\r\n            phase_number: result.phase_number,\r\n            padded: result.padded,\r\n            name: result.description,\r\n            slug: result.slug,\r\n            directory: result.directory,\r\n          },\r\n          `Created Phase ${result.phase_number}: ${result.description}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_insert_phase \r\n\r\n  server.tool(\r\n    'mcp_insert_phase',\r\n    'Insert a decimal phase after a specified phase (e.g. 01.1 after 01). Creates directory and updates ROADMAP.md.',\r\n    {\r\n      name: z.string().describe('Phase description/name'),\r\n      after: z.string().describe('Phase number to insert after (e.g. \"01\", \"1\")'),\r\n    },\r\n    async ({ name, after }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        if (!name || !name.trim()) {\r\n          return mcpError('Phase name must not be empty', 'Validation failed');\r\n        }\r\n\r\n        const result = phaseInsertCore(cwd, after, name, { includeStubs: true });\r\n\r\n        return mcpSuccess(\r\n          {\r\n            phase_number: result.phase_number,\r\n            after_phase: result.after_phase,\r\n            name: result.description,\r\n            slug: result.slug,\r\n            directory: result.directory,\r\n          },\r\n          `Inserted Phase ${result.phase_number}: ${result.description} after Phase ${result.after_phase}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_complete_phase \r\n\r\n  server.tool(\r\n    'mcp_complete_phase',\r\n    'Mark a phase as complete. Updates ROADMAP.md checkbox, progress table, plan count, STATE.md, and REQUIREMENTS.md.',\r\n    {\r\n      phase: z.string().describe('Phase number to complete (e.g. \"01\", \"1\", \"1.1\")'),\r\n    },\r\n    async ({ phase }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const result = phaseCompleteCore(cwd, phase);\r\n\r\n        return mcpSuccess(\r\n          {\r\n            completed_phase: result.completed_phase,\r\n            phase_name: result.phase_name,\r\n            plans_executed: result.plans_executed,\r\n            next_phase: result.next_phase,\r\n            next_phase_name: result.next_phase_name,\r\n            is_last_phase: result.is_last_phase,\r\n            date: result.date,\r\n            roadmap_updated: result.roadmap_updated,\r\n            state_updated: result.state_updated,\r\n          },\r\n          `Phase ${phase} marked as complete${result.next_phase ? `, next: Phase ${result.next_phase}` : ''}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n}\r\n","/**\r\n * Commands  Standalone utility commands\r\n *\r\n * Ported from maxsim/bin/lib/commands.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport chalk from 'chalk';\r\nimport slugify from 'slugify';\r\nimport {\r\n  safeReadFile,\r\n  loadConfig,\r\n  isGitIgnored,\r\n  execGit,\r\n  normalizePhaseName,\r\n  getArchivedPhaseDirs,\r\n  generateSlugInternal,\r\n  getMilestoneInfo,\r\n  resolveModelInternal,\r\n  MODEL_PROFILES,\r\n  output,\r\n  error,\r\n  rethrowCliSignals,\r\n  findPhaseInternal,\r\n  todayISO,\r\n  planningPath,\r\n  phasesPath,\r\n  listSubDirs,\r\n  isPlanFile,\r\n  isSummaryFile,\r\n  debugLog,\r\n} from './core.js';\r\nimport { extractFrontmatter } from './frontmatter.js';\r\nimport type {\r\n  TodoItem,\r\n  HistoryDigest,\r\n  HistoryPhaseDigest,\r\n  WebSearchOptions,\r\n  WebSearchResult,\r\n  ScaffoldOptions,\r\n  TimestampFormat,\r\n  ModelProfileName,\r\n  AgentType,\r\n  FrontmatterData,\r\n} from './types.js';\r\n\r\n//  Todo frontmatter parsing \r\n\r\nexport interface TodoFrontmatter {\r\n  created: string;\r\n  title: string;\r\n  area: string;\r\n  completed?: string;\r\n}\r\n\r\nexport function parseTodoFrontmatter(content: string): TodoFrontmatter {\r\n  const createdMatch = content.match(/^created:\\s*(.+)$/m);\r\n  const titleMatch = content.match(/^title:\\s*(.+)$/m);\r\n  const areaMatch = content.match(/^area:\\s*(.+)$/m);\r\n  const completedMatch = content.match(/^completed:\\s*(.+)$/m);\r\n\r\n  return {\r\n    created: createdMatch ? createdMatch[1].trim() : 'unknown',\r\n    title: titleMatch ? titleMatch[1].trim() : 'Untitled',\r\n    area: areaMatch ? areaMatch[1].trim() : 'general',\r\n    ...(completedMatch && { completed: completedMatch[1].trim() }),\r\n  };\r\n}\r\n\r\n//  Slug generation \r\n\r\nexport function cmdGenerateSlug(text: string | undefined, raw: boolean): void {\r\n  if (!text) {\r\n    error('text required for slug generation');\r\n  }\r\n\r\n  const slug = slugify(text, { lower: true, strict: true });\r\n\r\n  const result = { slug };\r\n  output(result, raw, slug);\r\n}\r\n\r\n//  Timestamp \r\n\r\nexport function cmdCurrentTimestamp(format: TimestampFormat, raw: boolean): void {\r\n  const now = new Date();\r\n  let result: string;\r\n\r\n  switch (format) {\r\n    case 'date':\r\n      result = todayISO();\r\n      break;\r\n    case 'filename':\r\n      result = now.toISOString().replace(/:/g, '-').replace(/\\..+/, '');\r\n      break;\r\n    case 'full':\r\n    default:\r\n      result = now.toISOString();\r\n      break;\r\n  }\r\n\r\n  output({ timestamp: result }, raw, result);\r\n}\r\n\r\n//  Todos \r\n\r\nexport function cmdListTodos(cwd: string, area: string | undefined, raw: boolean): void {\r\n  const pendingDir = planningPath(cwd, 'todos', 'pending');\r\n\r\n  let count = 0;\r\n  const todos: TodoItem[] = [];\r\n\r\n  try {\r\n    const files = fs.readdirSync(pendingDir).filter(f => f.endsWith('.md'));\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const content = fs.readFileSync(path.join(pendingDir, file), 'utf-8');\r\n        const fm = parseTodoFrontmatter(content);\r\n\r\n        // Apply area filter if specified\r\n        if (area && fm.area !== area) continue;\r\n\r\n        count++;\r\n        todos.push({\r\n          file,\r\n          created: fm.created,\r\n          title: fm.title,\r\n          area: fm.area,\r\n          path: path.join('.planning', 'todos', 'pending', file),\r\n        });\r\n      } catch (e) {\r\n        /* optional op, ignore */\r\n        debugLog(e);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    debugLog(e);\r\n  }\r\n\r\n  const result = { count, todos };\r\n  output(result, raw, count.toString());\r\n}\r\n\r\n//  Path verification \r\n\r\nexport function cmdVerifyPathExists(cwd: string, targetPath: string | undefined, raw: boolean): void {\r\n  if (!targetPath) {\r\n    error('path required for verification');\r\n  }\r\n\r\n  const fullPath = path.isAbsolute(targetPath) ? targetPath : path.join(cwd, targetPath);\r\n\r\n  try {\r\n    const stats = fs.statSync(fullPath);\r\n    const type = stats.isDirectory() ? 'directory' : stats.isFile() ? 'file' : 'other';\r\n    const result = { exists: true, type };\r\n    output(result, raw, 'true');\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    const result = { exists: false, type: null };\r\n    output(result, raw, 'false');\r\n  }\r\n}\r\n\r\n//  History digest \r\n\r\nexport function cmdHistoryDigest(cwd: string, raw: boolean): void {\r\n  const phasesDir = phasesPath(cwd);\r\n  const digest: {\r\n    phases: Record<string, { name: string; provides: Set<string>; affects: Set<string>; patterns: Set<string> }>;\r\n    decisions: Array<{ phase: string; decision: string }>;\r\n    tech_stack: Set<string> | string[];\r\n  } = { phases: {}, decisions: [], tech_stack: new Set<string>() };\r\n\r\n  // Collect all phase directories: archived + current\r\n  const allPhaseDirs: Array<{ name: string; fullPath: string; milestone: string | null }> = [];\r\n\r\n  // Add archived phases first (oldest milestones first)\r\n  const archived = getArchivedPhaseDirs(cwd);\r\n  for (const a of archived) {\r\n    allPhaseDirs.push({ name: a.name, fullPath: a.fullPath, milestone: a.milestone });\r\n  }\r\n\r\n  // Add current phases\r\n  if (fs.existsSync(phasesDir)) {\r\n    try {\r\n      const currentDirs = listSubDirs(phasesDir, true);\r\n      for (const dir of currentDirs) {\r\n        allPhaseDirs.push({ name: dir, fullPath: path.join(phasesDir, dir), milestone: null });\r\n      }\r\n    } catch (e) {\r\n      /* optional op, ignore */\r\n      debugLog(e);\r\n    }\r\n  }\r\n\r\n  if (allPhaseDirs.length === 0) {\r\n    const emptyDigest: HistoryDigest = { phases: {}, decisions: [], tech_stack: [] };\r\n    output(emptyDigest, raw);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    for (const { name: dir, fullPath: dirPath } of allPhaseDirs) {\r\n      const summaries = fs.readdirSync(dirPath).filter(f => isSummaryFile(f));\r\n\r\n      for (const summary of summaries) {\r\n        try {\r\n          const content = fs.readFileSync(path.join(dirPath, summary), 'utf-8');\r\n          const fm = extractFrontmatter(content);\r\n\r\n          const phaseNum = (fm.phase as string) || dir.split('-')[0];\r\n\r\n          if (!digest.phases[phaseNum]) {\r\n            digest.phases[phaseNum] = {\r\n              name: (fm.name as string) || dir.split('-').slice(1).join(' ') || 'Unknown',\r\n              provides: new Set<string>(),\r\n              affects: new Set<string>(),\r\n              patterns: new Set<string>(),\r\n            };\r\n          }\r\n\r\n          // Merge provides\r\n          const depGraph = fm['dependency-graph'] as FrontmatterData | undefined;\r\n          if (depGraph && depGraph.provides) {\r\n            (depGraph.provides as string[]).forEach(p => digest.phases[phaseNum].provides.add(p));\r\n          } else if (fm.provides) {\r\n            (fm.provides as string[]).forEach(p => digest.phases[phaseNum].provides.add(p));\r\n          }\r\n\r\n          // Merge affects\r\n          if (depGraph && depGraph.affects) {\r\n            (depGraph.affects as string[]).forEach(a => digest.phases[phaseNum].affects.add(a));\r\n          }\r\n\r\n          // Merge patterns\r\n          if (fm['patterns-established']) {\r\n            (fm['patterns-established'] as string[]).forEach(p => digest.phases[phaseNum].patterns.add(p));\r\n          }\r\n\r\n          // Merge decisions\r\n          if (fm['key-decisions']) {\r\n            (fm['key-decisions'] as string[]).forEach(d => {\r\n              digest.decisions.push({ phase: phaseNum, decision: d });\r\n            });\r\n          }\r\n\r\n          // Merge tech stack\r\n          const techStack = fm['tech-stack'] as FrontmatterData | undefined;\r\n          if (techStack && techStack.added) {\r\n            (techStack.added as Array<string | FrontmatterData>).forEach(t =>\r\n              (digest.tech_stack as Set<string>).add(typeof t === 'string' ? t : (t as FrontmatterData).name as string)\r\n            );\r\n          }\r\n        } catch (e) {\r\n          /* optional op, ignore */\r\n          debugLog(e);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Convert Sets to Arrays for JSON output\r\n    const outputDigest: HistoryDigest = {\r\n      phases: {},\r\n      decisions: digest.decisions,\r\n      tech_stack: [...(digest.tech_stack as Set<string>)],\r\n    };\r\n    for (const [p, data] of Object.entries(digest.phases)) {\r\n      outputDigest.phases[p] = {\r\n        name: data.name,\r\n        provides: [...data.provides],\r\n        affects: [...data.affects],\r\n        patterns: [...data.patterns],\r\n      };\r\n    }\r\n\r\n    output(outputDigest, raw);\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    error('Failed to generate history digest: ' + (e as Error).message);\r\n  }\r\n}\r\n\r\n//  Model resolution \r\n\r\nexport function cmdResolveModel(cwd: string, agentType: string | undefined, raw: boolean): void {\r\n  if (!agentType) {\r\n    error('agent-type required');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n  const profile: ModelProfileName = config.model_profile || 'balanced';\r\n\r\n  const agentModels = MODEL_PROFILES[agentType as AgentType];\r\n  if (!agentModels) {\r\n    const result = { model: 'sonnet', profile, unknown_agent: true };\r\n    output(result, raw, 'sonnet');\r\n    return;\r\n  }\r\n\r\n  const resolved = agentModels[profile] || agentModels['balanced'] || 'sonnet';\r\n  const model = resolved === 'opus' ? 'inherit' : resolved;\r\n  const result = { model, profile };\r\n  output(result, raw, model);\r\n}\r\n\r\n//  Commit \r\n\r\nexport async function cmdCommit(\r\n  cwd: string,\r\n  message: string | undefined,\r\n  files: string[],\r\n  raw: boolean,\r\n  amend: boolean,\r\n): Promise<void> {\r\n  if (!message && !amend) {\r\n    error('commit message required');\r\n  }\r\n\r\n  const config = loadConfig(cwd);\r\n\r\n  // Check commit_docs config\r\n  if (!config.commit_docs) {\r\n    const result = { committed: false, hash: null, reason: 'skipped_commit_docs_false' };\r\n    output(result, raw, 'skipped');\r\n    return;\r\n  }\r\n\r\n  // Check if .planning is gitignored\r\n  if (await isGitIgnored(cwd, '.planning')) {\r\n    const result = { committed: false, hash: null, reason: 'skipped_gitignored' };\r\n    output(result, raw, 'skipped');\r\n    return;\r\n  }\r\n\r\n  // Stage files\r\n  const filesToStage = files && files.length > 0 ? files : ['.planning/'];\r\n  for (const file of filesToStage) {\r\n    await execGit(cwd, ['add', file]);\r\n  }\r\n\r\n  // Commit\r\n  const commitArgs = amend ? ['commit', '--amend', '--no-edit'] : ['commit', '-m', message!];\r\n  const commitResult = await execGit(cwd, commitArgs);\r\n  if (commitResult.exitCode !== 0) {\r\n    if (commitResult.stdout.includes('nothing to commit') || commitResult.stderr.includes('nothing to commit')) {\r\n      const result = { committed: false, hash: null, reason: 'nothing_to_commit' };\r\n      output(result, raw, 'nothing');\r\n      return;\r\n    }\r\n    const result = { committed: false, hash: null, reason: 'nothing_to_commit', error: commitResult.stderr };\r\n    output(result, raw, 'nothing');\r\n    return;\r\n  }\r\n\r\n  // Get short hash\r\n  const hashResult = await execGit(cwd, ['rev-parse', '--short', 'HEAD']);\r\n  const hash = hashResult.exitCode === 0 ? hashResult.stdout : null;\r\n  const result = { committed: true, hash, reason: 'committed' };\r\n  output(result, raw, hash || 'committed');\r\n}\r\n\r\n//  Summary extract \r\n\r\nexport function cmdSummaryExtract(\r\n  cwd: string,\r\n  summaryPath: string | undefined,\r\n  fields: string[] | null,\r\n  raw: boolean,\r\n): void {\r\n  if (!summaryPath) {\r\n    error('summary-path required for summary-extract');\r\n  }\r\n\r\n  const fullPath = path.join(cwd, summaryPath);\r\n\r\n  if (!fs.existsSync(fullPath)) {\r\n    output({ error: 'File not found', path: summaryPath }, raw);\r\n    return;\r\n  }\r\n\r\n  const content = fs.readFileSync(fullPath, 'utf-8');\r\n  const fm = extractFrontmatter(content);\r\n\r\n  // Parse key-decisions into structured format\r\n  const parseDecisions = (decisionsList: unknown): Array<{ summary: string; rationale: string | null }> => {\r\n    if (!decisionsList || !Array.isArray(decisionsList)) return [];\r\n    return decisionsList.map((d: string) => {\r\n      const colonIdx = d.indexOf(':');\r\n      if (colonIdx > 0) {\r\n        return {\r\n          summary: d.substring(0, colonIdx).trim(),\r\n          rationale: d.substring(colonIdx + 1).trim(),\r\n        };\r\n      }\r\n      return { summary: d, rationale: null };\r\n    });\r\n  };\r\n\r\n  const techStack = fm['tech-stack'] as FrontmatterData | undefined;\r\n\r\n  // Build full result\r\n  const fullResult: Record<string, unknown> = {\r\n    path: summaryPath,\r\n    one_liner: fm['one-liner'] || null,\r\n    key_files: fm['key-files'] || [],\r\n    tech_added: (techStack && techStack.added) || [],\r\n    patterns: fm['patterns-established'] || [],\r\n    decisions: parseDecisions(fm['key-decisions']),\r\n    requirements_completed: fm['requirements-completed'] || [],\r\n  };\r\n\r\n  // If fields specified, filter to only those fields\r\n  if (fields && fields.length > 0) {\r\n    const filtered: Record<string, unknown> = { path: summaryPath };\r\n    for (const field of fields) {\r\n      if (fullResult[field] !== undefined) {\r\n        filtered[field] = fullResult[field];\r\n      }\r\n    }\r\n    output(filtered, raw);\r\n    return;\r\n  }\r\n\r\n  output(fullResult, raw);\r\n}\r\n\r\n//  Web search \r\n\r\nexport async function cmdWebsearch(\r\n  query: string | undefined,\r\n  options: WebSearchOptions,\r\n  raw: boolean,\r\n): Promise<void> {\r\n  const apiKey = process.env.BRAVE_API_KEY;\r\n\r\n  if (!apiKey) {\r\n    output({ available: false, reason: 'BRAVE_API_KEY not set' }, raw, '');\r\n    return;\r\n  }\r\n\r\n  if (!query) {\r\n    output({ available: false, error: 'Query required' }, raw, '');\r\n    return;\r\n  }\r\n\r\n  const params = new URLSearchParams({\r\n    q: query,\r\n    count: String(options.limit || 10),\r\n    country: 'us',\r\n    search_lang: 'en',\r\n    text_decorations: 'false',\r\n  });\r\n\r\n  if (options.freshness) {\r\n    params.set('freshness', options.freshness);\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `https://api.search.brave.com/res/v1/web/search?${params}`,\r\n      {\r\n        headers: {\r\n          Accept: 'application/json',\r\n          'X-Subscription-Token': apiKey,\r\n        },\r\n      },\r\n    );\r\n\r\n    if (!response.ok) {\r\n      output({ available: false, error: `API error: ${response.status}` }, raw, '');\r\n      return;\r\n    }\r\n\r\n    const data = (await response.json()) as { web?: { results?: Array<{ title: string; url: string; description: string; age?: string }> } };\r\n\r\n    const results: WebSearchResult[] = (data.web?.results || []).map(r => ({\r\n      title: r.title,\r\n      url: r.url,\r\n      description: r.description,\r\n      age: r.age || null,\r\n    }));\r\n\r\n    output(\r\n      {\r\n        available: true,\r\n        query,\r\n        count: results.length,\r\n        results,\r\n      },\r\n      raw,\r\n      results.map(r => `${r.title}\\n${r.url}\\n${r.description}`).join('\\n\\n'),\r\n    );\r\n  } catch (err: unknown) {\r\n    rethrowCliSignals(err);\r\n    output({ available: false, error: (err as Error).message }, raw, '');\r\n  }\r\n}\r\n\r\n//  Progress render \r\n\r\nexport function cmdProgressRender(cwd: string, format: string, raw: boolean): void {\r\n  const phasesDir = phasesPath(cwd);\r\n  const milestone = getMilestoneInfo(cwd);\r\n\r\n  const phases: Array<{ number: string; name: string; plans: number; summaries: number; status: string }> = [];\r\n  let totalPlans = 0;\r\n  let totalSummaries = 0;\r\n\r\n  try {\r\n    const entries = fs.readdirSync(phasesDir, { withFileTypes: true });\r\n    const dirs = entries\r\n      .filter(e => e.isDirectory())\r\n      .map(e => e.name)\r\n      .sort((a, b) => {\r\n        const aNum = parseFloat(a.match(/^(\\d+(?:\\.\\d+)?)/)?.[1] || '0');\r\n        const bNum = parseFloat(b.match(/^(\\d+(?:\\.\\d+)?)/)?.[1] || '0');\r\n        return aNum - bNum;\r\n      });\r\n\r\n    for (const dir of dirs) {\r\n      const dm = dir.match(/^(\\d+(?:\\.\\d+)?)-?(.*)/);\r\n      const phaseNum = dm ? dm[1] : dir;\r\n      const phaseName = dm && dm[2] ? dm[2].replace(/-/g, ' ') : '';\r\n      const phaseFiles = fs.readdirSync(path.join(phasesDir, dir));\r\n      const planCount = phaseFiles.filter(f => isPlanFile(f)).length;\r\n      const summaryCount = phaseFiles.filter(f => isSummaryFile(f)).length;\r\n\r\n      totalPlans += planCount;\r\n      totalSummaries += summaryCount;\r\n\r\n      let status: string;\r\n      if (planCount === 0) status = 'Pending';\r\n      else if (summaryCount >= planCount) status = 'Complete';\r\n      else if (summaryCount > 0) status = 'In Progress';\r\n      else status = 'Planned';\r\n\r\n      phases.push({ number: phaseNum, name: phaseName, plans: planCount, summaries: summaryCount, status });\r\n    }\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    debugLog(e);\r\n  }\r\n\r\n  const percent = totalPlans > 0 ? Math.min(100, Math.round((totalSummaries / totalPlans) * 100)) : 0;\r\n\r\n  if (format === 'table') {\r\n    const barWidth = 10;\r\n    const filled = Math.round((percent / 100) * barWidth);\r\n    const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n    let out = `# ${milestone.version} ${milestone.name}\\n\\n`;\r\n    out += `**Progress:** [${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)\\n\\n`;\r\n    out += `| Phase | Name | Plans | Status |\\n`;\r\n    out += `|-------|------|-------|--------|\\n`;\r\n    for (const p of phases) {\r\n      out += `| ${p.number} | ${p.name} | ${p.summaries}/${p.plans} | ${p.status} |\\n`;\r\n    }\r\n    output({ rendered: out }, raw, out);\r\n  } else if (format === 'bar') {\r\n    const barWidth = 20;\r\n    const filled = Math.round((percent / 100) * barWidth);\r\n    const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n    const text = `[${bar}] ${totalSummaries}/${totalPlans} plans (${percent}%)`;\r\n    output({ bar: text, percent, completed: totalSummaries, total: totalPlans }, raw, text);\r\n  } else if (format === 'phase-bars') {\r\n    const doneCount = phases.filter(p => p.status === 'Complete').length;\r\n    const inProgressCount = phases.filter(p => p.status === 'In Progress').length;\r\n    const totalCount = phases.length;\r\n    const header = chalk.bold(\r\n      `Milestone: ${milestone.name}  ${doneCount}/${totalCount} phases complete (${percent}%)`\r\n    );\r\n    const lines: string[] = [header, ''];\r\n\r\n    for (const p of phases) {\r\n      const pPercent =\r\n        p.plans > 0 ? Math.min(100, Math.round((p.summaries / p.plans) * 100)) : 0;\r\n      const barWidth = 10;\r\n      const filled = Math.round((pPercent / 100) * barWidth);\r\n      const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n      const phaseLabel = `Phase ${p.number.padStart(2, '0')}`;\r\n      const statusLabel =\r\n        p.status === 'Complete'\r\n          ? 'DONE'\r\n          : p.status === 'In Progress'\r\n          ? 'IN PROGRESS'\r\n          : 'PLANNED';\r\n\r\n      let line = `${phaseLabel} [${bar}] ${String(pPercent).padStart(3, ' ')}%  ${statusLabel}`;\r\n      if (p.status === 'Complete') line = chalk.green(line);\r\n      else if (p.status === 'In Progress') line = chalk.yellow(line);\r\n      else line = chalk.dim(line);\r\n\r\n      lines.push(line);\r\n    }\r\n\r\n    const rendered = lines.join('\\n');\r\n    output({ rendered, done: doneCount, in_progress: inProgressCount, total: totalCount, percent }, raw, rendered);\r\n  } else {\r\n    output({\r\n      milestone_version: milestone.version,\r\n      milestone_name: milestone.name,\r\n      phases,\r\n      total_plans: totalPlans,\r\n      total_summaries: totalSummaries,\r\n      percent,\r\n    }, raw);\r\n  }\r\n}\r\n\r\n//  Todo complete \r\n\r\nexport function cmdTodoComplete(cwd: string, filename: string | undefined, raw: boolean): void {\r\n  if (!filename) {\r\n    error('filename required for todo complete');\r\n  }\r\n\r\n  const pendingDir = planningPath(cwd, 'todos', 'pending');\r\n  const completedDir = planningPath(cwd, 'todos', 'completed');\r\n  const sourcePath = path.join(pendingDir, filename);\r\n\r\n  if (!fs.existsSync(sourcePath)) {\r\n    error(`Todo not found: ${filename}`);\r\n  }\r\n\r\n  // Ensure completed directory exists\r\n  fs.mkdirSync(completedDir, { recursive: true });\r\n\r\n  // Read, add completion timestamp, move\r\n  let content = fs.readFileSync(sourcePath, 'utf-8');\r\n  const today = todayISO();\r\n  content = `completed: ${today}\\n` + content;\r\n\r\n  fs.writeFileSync(path.join(completedDir, filename), content, 'utf-8');\r\n  fs.unlinkSync(sourcePath);\r\n\r\n  output({ completed: true, file: filename, date: today }, raw, 'completed');\r\n}\r\n\r\n//  Scaffold \r\n\r\nexport function cmdScaffold(\r\n  cwd: string,\r\n  type: string | undefined,\r\n  options: ScaffoldOptions,\r\n  raw: boolean,\r\n): void {\r\n  const { phase, name } = options;\r\n  const padded = phase ? normalizePhaseName(phase) : '00';\r\n  const today = todayISO();\r\n\r\n  // Find phase directory\r\n  const phaseInfo = phase ? findPhaseInternal(cwd, phase) : null;\r\n  const phaseDir = phaseInfo ? path.join(cwd, phaseInfo.directory) : null;\r\n\r\n  if (phase && !phaseDir && type !== 'phase-dir') {\r\n    error(`Phase ${phase} directory not found`);\r\n  }\r\n\r\n  let filePath: string;\r\n  let content: string;\r\n\r\n  switch (type) {\r\n    case 'context': {\r\n      filePath = path.join(phaseDir!, `${padded}-CONTEXT.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'}  Context\\n\\n## Decisions\\n\\n_Decisions will be captured during /maxsim:discuss-phase ${phase}_\\n\\n## Discretion Areas\\n\\n_Areas where the executor can use judgment_\\n\\n## Deferred Ideas\\n\\n_Ideas to consider later_\\n`;\r\n      break;\r\n    }\r\n    case 'uat': {\r\n      filePath = path.join(phaseDir!, `${padded}-UAT.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\nstatus: pending\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'}  User Acceptance Testing\\n\\n## Test Results\\n\\n| # | Test | Status | Notes |\\n|---|------|--------|-------|\\n\\n## Summary\\n\\n_Pending UAT_\\n`;\r\n      break;\r\n    }\r\n    case 'verification': {\r\n      filePath = path.join(phaseDir!, `${padded}-VERIFICATION.md`);\r\n      content = `---\\nphase: \"${padded}\"\\nname: \"${name || phaseInfo?.phase_name || 'Unnamed'}\"\\ncreated: ${today}\\nstatus: pending\\n---\\n\\n# Phase ${phase}: ${name || phaseInfo?.phase_name || 'Unnamed'}  Verification\\n\\n## Goal-Backward Verification\\n\\n**Phase Goal:** [From ROADMAP.md]\\n\\n## Checks\\n\\n| # | Requirement | Status | Evidence |\\n|---|------------|--------|----------|\\n\\n## Result\\n\\n_Pending verification_\\n`;\r\n      break;\r\n    }\r\n    case 'phase-dir': {\r\n      if (!phase || !name) {\r\n        error('phase and name required for phase-dir scaffold');\r\n      }\r\n      const slug = generateSlugInternal(name);\r\n      const dirName = `${padded}-${slug}`;\r\n      const phasesParent = phasesPath(cwd);\r\n      fs.mkdirSync(phasesParent, { recursive: true });\r\n      const dirPath = path.join(phasesParent, dirName);\r\n      fs.mkdirSync(dirPath, { recursive: true });\r\n      output({ created: true, directory: `.planning/phases/${dirName}`, path: dirPath }, raw, dirPath);\r\n      return;\r\n    }\r\n    default:\r\n      error(`Unknown scaffold type: ${type}. Available: context, uat, verification, phase-dir`);\r\n      return; // unreachable but satisfies TS\r\n  }\r\n\r\n  if (fs.existsSync(filePath)) {\r\n    output({ created: false, reason: 'already_exists', path: filePath }, raw, 'exists');\r\n    return;\r\n  }\r\n\r\n  fs.writeFileSync(filePath, content, 'utf-8');\r\n  const relPath = path.relative(cwd, filePath);\r\n  output({ created: true, path: relPath }, raw, relPath);\r\n}\r\n","/**\r\n * Todo CRUD MCP Tools  Todo operations exposed as MCP tools\r\n *\r\n * CRITICAL: Never import output() or error() from core  they call process.exit().\r\n * CRITICAL: Never write to stdout  it is reserved for MCP JSON-RPC protocol.\r\n * CRITICAL: Never call process.exit()  the server must stay alive after every tool call.\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\nimport { z } from 'zod';\r\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\n\r\nimport { generateSlugInternal, todayISO, planningPath } from '../core/core.js';\r\nimport { parseTodoFrontmatter } from '../core/commands.js';\r\nimport { detectProjectRoot, mcpSuccess, mcpError } from './utils.js';\r\n\r\n/**\r\n * Register all todo CRUD tools on the MCP server.\r\n */\r\nexport function registerTodoTools(server: McpServer): void {\r\n  //  mcp_add_todo \r\n\r\n  server.tool(\r\n    'mcp_add_todo',\r\n    'Create a new todo item in .planning/todos/pending/ with frontmatter metadata.',\r\n    {\r\n      title: z.string().describe('Title of the todo item'),\r\n      description: z.string().optional().describe('Optional description body'),\r\n      area: z.string().optional().default('general').describe('Area/category (default: general)'),\r\n      phase: z.string().optional().describe('Associated phase number'),\r\n    },\r\n    async ({ title, description, area, phase }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const pendingDir = planningPath(cwd, 'todos', 'pending');\r\n        fs.mkdirSync(pendingDir, { recursive: true });\r\n\r\n        const today = todayISO();\r\n        const slug = generateSlugInternal(title) || 'untitled';\r\n        const timestamp = Date.now();\r\n        const filename = `${timestamp}-${slug}.md`;\r\n        const filePath = path.join(pendingDir, filename);\r\n\r\n        const content = `---\\ncreated: ${today}\\ntitle: ${title}\\narea: ${area || 'general'}\\nphase: ${phase || 'unassigned'}\\n---\\n${description || ''}\\n`;\r\n\r\n        fs.writeFileSync(filePath, content, 'utf-8');\r\n\r\n        return mcpSuccess(\r\n          {\r\n            file: filename,\r\n            path: `.planning/todos/pending/${filename}`,\r\n            title,\r\n            area: area || 'general',\r\n          },\r\n          `Todo created: ${title}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_complete_todo \r\n\r\n  server.tool(\r\n    'mcp_complete_todo',\r\n    'Mark a pending todo as completed by moving it from pending/ to completed/ with a completion timestamp.',\r\n    {\r\n      todo_id: z.string().describe('Filename of the todo (e.g., 1234567890-my-task.md)'),\r\n    },\r\n    async ({ todo_id }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const pendingDir = planningPath(cwd, 'todos', 'pending');\r\n        const completedDir = planningPath(cwd, 'todos', 'completed');\r\n        const sourcePath = path.join(pendingDir, todo_id);\r\n\r\n        if (!fs.existsSync(sourcePath)) {\r\n          return mcpError(`Todo not found in pending: ${todo_id}`, 'Todo not found');\r\n        }\r\n\r\n        fs.mkdirSync(completedDir, { recursive: true });\r\n\r\n        let content = fs.readFileSync(sourcePath, 'utf-8');\r\n        const today = todayISO();\r\n        content = `completed: ${today}\\n` + content;\r\n\r\n        fs.writeFileSync(path.join(completedDir, todo_id), content, 'utf-8');\r\n        fs.unlinkSync(sourcePath);\r\n\r\n        return mcpSuccess(\r\n          { completed: true, file: todo_id, date: today },\r\n          `Todo completed: ${todo_id}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_list_todos \r\n\r\n  server.tool(\r\n    'mcp_list_todos',\r\n    'List todo items, optionally filtered by area and status (pending, completed, or all).',\r\n    {\r\n      area: z.string().optional().describe('Filter by area/category'),\r\n      status: z\r\n        .enum(['pending', 'completed', 'all'])\r\n        .optional()\r\n        .default('pending')\r\n        .describe('Which todos to list (default: pending)'),\r\n    },\r\n    async ({ area, status }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const todosBase = planningPath(cwd, 'todos');\r\n        const dirs: string[] = [];\r\n\r\n        if (status === 'pending' || status === 'all') {\r\n          dirs.push(path.join(todosBase, 'pending'));\r\n        }\r\n        if (status === 'completed' || status === 'all') {\r\n          dirs.push(path.join(todosBase, 'completed'));\r\n        }\r\n\r\n        const todos: Array<{\r\n          file: string;\r\n          created: string;\r\n          title: string;\r\n          area: string;\r\n          status: string;\r\n          path: string;\r\n        }> = [];\r\n\r\n        for (const dir of dirs) {\r\n          const dirStatus = dir.endsWith('pending') ? 'pending' : 'completed';\r\n\r\n          let files: string[] = [];\r\n          try {\r\n            files = fs.readdirSync(dir).filter((f) => f.endsWith('.md'));\r\n          } catch {\r\n            // Directory may not exist\r\n            continue;\r\n          }\r\n\r\n          for (const file of files) {\r\n            try {\r\n              const content = fs.readFileSync(path.join(dir, file), 'utf-8');\r\n              const fm = parseTodoFrontmatter(content);\r\n\r\n              if (area && fm.area !== area) continue;\r\n\r\n              todos.push({\r\n                file,\r\n                created: fm.created,\r\n                title: fm.title,\r\n                area: fm.area,\r\n                status: dirStatus,\r\n                path: `.planning/todos/${dirStatus}/${file}`,\r\n              });\r\n            } catch {\r\n              // Skip unreadable files\r\n            }\r\n          }\r\n        }\r\n\r\n        return mcpSuccess(\r\n          { count: todos.length, todos },\r\n          `${todos.length} todos found`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n}\r\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\r\n * State  STATE.md operations and progression engine\r\n *\r\n * Ported from maxsim/bin/lib/state.cjs\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nimport escapeStringRegexp from 'escape-string-regexp';\r\n\r\nimport { loadConfig, output, error, rethrowCliSignals, safeReadFile, planningPath, statePath as statePathUtil, configPath, roadmapPath, phasesPath, debugLog, todayISO, isPlanFile, isSummaryFile } from './core.js';\r\nimport type {\r\n  AppConfig,\r\n  StatePatchResult,\r\n  StateMetricOptions,\r\n  StateDecisionOptions,\r\n  StateBlockerOptions,\r\n  StateSessionOptions,\r\n  StateSnapshot,\r\n  Decision,\r\n} from './types.js';\r\n\r\n//  Internal helpers \r\n\r\nexport function stateExtractField(content: string, fieldName: string): string | null {\r\n  const pattern = new RegExp(`\\\\*\\\\*${fieldName}:\\\\*\\\\*\\\\s*(.+)`, 'i');\r\n  const match = content.match(pattern);\r\n  return match ? match[1].trim() : null;\r\n}\r\n\r\nexport function stateReplaceField(content: string, fieldName: string, newValue: string): string | null {\r\n  const escaped = escapeStringRegexp(fieldName);\r\n  const pattern = new RegExp(`(\\\\*\\\\*${escaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\r\n  if (pattern.test(content)) {\r\n    return content.replace(pattern, (_match, prefix: string) => `${prefix}${newValue}`);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction readTextArgOrFile(cwd: string, value: string | undefined, filePath: string | undefined, label: string): string | undefined {\r\n  if (!filePath) return value;\r\n  const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);\r\n  try {\r\n    return fs.readFileSync(resolvedPath, 'utf-8').trimEnd();\r\n  } catch {\r\n    throw new Error(`${label} file not found: ${filePath}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Append an entry to a section in STATE.md content, removing placeholder text.\r\n * Returns updated content or null if section not found.\r\n */\r\nexport function appendToStateSection(\r\n  content: string,\r\n  sectionPattern: RegExp,\r\n  entry: string,\r\n  placeholderPatterns?: RegExp[],\r\n): string | null {\r\n  const match = content.match(sectionPattern);\r\n  if (!match) return null;\r\n\r\n  let sectionBody = match[2];\r\n  const defaults = [/None yet\\.?\\s*\\n?/gi, /No decisions yet\\.?\\s*\\n?/gi, /None\\.?\\s*\\n?/gi];\r\n  for (const pat of placeholderPatterns || defaults) {\r\n    sectionBody = sectionBody.replace(pat, '');\r\n  }\r\n  sectionBody = sectionBody.trimEnd() + '\\n' + entry + '\\n';\r\n\r\n  return content.replace(sectionPattern, (_m, header: string) => `${header}${sectionBody}`);\r\n}\r\n\r\n//  State commands \r\n\r\nexport function cmdStateLoad(cwd: string, raw: boolean): void {\r\n  const config: AppConfig = loadConfig(cwd);\r\n  let stateRaw = '';\r\n  try {\r\n    stateRaw = fs.readFileSync(statePathUtil(cwd), 'utf-8');\r\n  } catch (e) {\r\n    /* optional op, ignore */\r\n    debugLog(e);\r\n  }\r\n\r\n  const configExists = fs.existsSync(configPath(cwd));\r\n  const roadmapExists = fs.existsSync(roadmapPath(cwd));\r\n  const stateExists = stateRaw.length > 0;\r\n\r\n  const result = {\r\n    config,\r\n    state_raw: stateRaw,\r\n    state_exists: stateExists,\r\n    roadmap_exists: roadmapExists,\r\n    config_exists: configExists,\r\n  };\r\n\r\n  if (raw) {\r\n    const c = config;\r\n    const lines = [\r\n      `model_profile=${c.model_profile}`,\r\n      `commit_docs=${c.commit_docs}`,\r\n      `branching_strategy=${c.branching_strategy}`,\r\n      `phase_branch_template=${c.phase_branch_template}`,\r\n      `milestone_branch_template=${c.milestone_branch_template}`,\r\n      `parallelization=${c.parallelization}`,\r\n      `research=${c.research}`,\r\n      `plan_checker=${c.plan_checker}`,\r\n      `verifier=${c.verifier}`,\r\n      `config_exists=${configExists}`,\r\n      `roadmap_exists=${roadmapExists}`,\r\n      `state_exists=${stateExists}`,\r\n    ];\r\n    output(result, true, lines.join('\\n'));\r\n  }\r\n\r\n  output(result);\r\n}\r\n\r\nexport function cmdStateGet(cwd: string, section: string | null, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  try {\r\n    const content = fs.readFileSync(statePath, 'utf-8');\r\n\r\n    if (!section) {\r\n      output({ content }, raw, content);\r\n      return;\r\n    }\r\n\r\n    const fieldEscaped = escapeStringRegexp(section);\r\n\r\n    // Check for **field:** value\r\n    const fieldPattern = new RegExp(`\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*(.*)`, 'i');\r\n    const fieldMatch = content.match(fieldPattern);\r\n    if (fieldMatch) {\r\n      output({ [section]: fieldMatch[1].trim() }, raw, fieldMatch[1].trim());\r\n      return;\r\n    }\r\n\r\n    // Check for ## Section\r\n    const sectionPattern = new RegExp(`##\\\\s*${fieldEscaped}\\\\s*\\n([\\\\s\\\\S]*?)(?=\\\\n##|$)`, 'i');\r\n    const sectionMatch = content.match(sectionPattern);\r\n    if (sectionMatch) {\r\n      output({ [section]: sectionMatch[1].trim() }, raw, sectionMatch[1].trim());\r\n      return;\r\n    }\r\n\r\n    output({ error: `Section or field \"${section}\" not found` }, raw, '');\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    error('STATE.md not found');\r\n  }\r\n}\r\n\r\nexport function cmdStatePatch(cwd: string, patches: Record<string, string>, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  try {\r\n    let content = fs.readFileSync(statePath, 'utf-8');\r\n    const results: StatePatchResult = { updated: [], failed: [] };\r\n\r\n    for (const [field, value] of Object.entries(patches)) {\r\n      const fieldEscaped = escapeStringRegexp(field);\r\n      const pattern = new RegExp(`(\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\r\n\r\n      if (pattern.test(content)) {\r\n        content = content.replace(pattern, (_match, prefix: string) => `${prefix}${value}`);\r\n        results.updated.push(field);\r\n      } else {\r\n        results.failed.push(field);\r\n      }\r\n    }\r\n\r\n    if (results.updated.length > 0) {\r\n      fs.writeFileSync(statePath, content, 'utf-8');\r\n    }\r\n\r\n    output(results, raw, results.updated.length > 0 ? 'true' : 'false');\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    error('STATE.md not found');\r\n  }\r\n}\r\n\r\nexport function cmdStateUpdate(cwd: string, field: string | undefined, value: string | undefined): void {\r\n  if (!field || value === undefined) {\r\n    error('field and value required for state update');\r\n  }\r\n\r\n  const statePath = statePathUtil(cwd);\r\n  try {\r\n    let content = fs.readFileSync(statePath, 'utf-8');\r\n    const fieldEscaped = escapeStringRegexp(field);\r\n    const pattern = new RegExp(`(\\\\*\\\\*${fieldEscaped}:\\\\*\\\\*\\\\s*)(.*)`, 'i');\r\n    if (pattern.test(content)) {\r\n      content = content.replace(pattern, (_match, prefix: string) => `${prefix}${value}`);\r\n      fs.writeFileSync(statePath, content, 'utf-8');\r\n      output({ updated: true });\r\n    } else {\r\n      output({ updated: false, reason: `Field \"${field}\" not found in STATE.md` });\r\n    }\r\n  } catch (e: unknown) {\r\n    rethrowCliSignals(e);\r\n    output({ updated: false, reason: 'STATE.md not found' });\r\n  }\r\n}\r\n\r\n//  State Progression Engine \r\n\r\nexport function cmdStateAdvancePlan(cwd: string, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n\r\n  let content = fs.readFileSync(statePath, 'utf-8');\r\n  const currentPlan = parseInt(stateExtractField(content, 'Current Plan') ?? '', 10);\r\n  const totalPlans = parseInt(stateExtractField(content, 'Total Plans in Phase') ?? '', 10);\r\n  const today = todayISO();\r\n\r\n  if (isNaN(currentPlan) || isNaN(totalPlans)) {\r\n    output({ error: 'Cannot parse Current Plan or Total Plans in Phase from STATE.md' }, raw);\r\n    return;\r\n  }\r\n\r\n  if (currentPlan >= totalPlans) {\r\n    content = stateReplaceField(content, 'Status', 'Phase complete  ready for verification') || content;\r\n    content = stateReplaceField(content, 'Last Activity', today) || content;\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ advanced: false, reason: 'last_plan', current_plan: currentPlan, total_plans: totalPlans, status: 'ready_for_verification' }, raw, 'false');\r\n  } else {\r\n    const newPlan = currentPlan + 1;\r\n    content = stateReplaceField(content, 'Current Plan', String(newPlan)) || content;\r\n    content = stateReplaceField(content, 'Status', 'Ready to execute') || content;\r\n    content = stateReplaceField(content, 'Last Activity', today) || content;\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ advanced: true, previous_plan: currentPlan, current_plan: newPlan, total_plans: totalPlans }, raw, 'true');\r\n  }\r\n}\r\n\r\nexport function cmdStateRecordMetric(cwd: string, options: StateMetricOptions, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n\r\n  let content = fs.readFileSync(statePath, 'utf-8');\r\n  const { phase, plan, duration, tasks, files } = options;\r\n\r\n  if (!phase || !plan || !duration) {\r\n    output({ error: 'phase, plan, and duration required' }, raw);\r\n    return;\r\n  }\r\n\r\n  const metricsPattern = /(##\\s*Performance Metrics[\\s\\S]*?\\n\\|[^\\n]+\\n\\|[-|\\s]+\\n)([\\s\\S]*?)(?=\\n##|\\n$|$)/i;\r\n  const metricsMatch = content.match(metricsPattern);\r\n\r\n  if (metricsMatch) {\r\n    let tableBody = metricsMatch[2].trimEnd();\r\n    const newRow = `| Phase ${phase} P${plan} | ${duration} | ${tasks || '-'} tasks | ${files || '-'} files |`;\r\n\r\n    if (tableBody.trim() === '' || tableBody.includes('None yet')) {\r\n      tableBody = newRow;\r\n    } else {\r\n      tableBody = tableBody + '\\n' + newRow;\r\n    }\r\n\r\n    content = content.replace(metricsPattern, (_match, header: string) => `${header}${tableBody}\\n`);\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ recorded: true, phase, plan, duration }, raw, 'true');\r\n  } else {\r\n    output({ recorded: false, reason: 'Performance Metrics section not found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateUpdateProgress(cwd: string, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n\r\n  let content = fs.readFileSync(statePath, 'utf-8');\r\n\r\n  const phasesDir = phasesPath(cwd);\r\n  let totalPlans = 0;\r\n  let totalSummaries = 0;\r\n\r\n  if (fs.existsSync(phasesDir)) {\r\n    const phaseDirs = fs.readdirSync(phasesDir, { withFileTypes: true })\r\n      .filter(e => e.isDirectory()).map(e => e.name);\r\n    for (const dir of phaseDirs) {\r\n      const files = fs.readdirSync(path.join(phasesDir, dir));\r\n      totalPlans += files.filter(f => isPlanFile(f)).length;\r\n      totalSummaries += files.filter(f => isSummaryFile(f)).length;\r\n    }\r\n  }\r\n\r\n  const percent = totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0;\r\n  const barWidth = 10;\r\n  const filled = Math.round(percent / 100 * barWidth);\r\n  const bar = '\\u2588'.repeat(filled) + '\\u2591'.repeat(barWidth - filled);\r\n  const progressStr = `[${bar}] ${percent}%`;\r\n\r\n  const progressPattern = /(\\*\\*Progress:\\*\\*\\s*).*/i;\r\n  if (progressPattern.test(content)) {\r\n    content = content.replace(progressPattern, (_match, prefix: string) => `${prefix}${progressStr}`);\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ updated: true, percent, completed: totalSummaries, total: totalPlans, bar: progressStr }, raw, progressStr);\r\n  } else {\r\n    output({ updated: false, reason: 'Progress field not found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateAddDecision(cwd: string, options: StateDecisionOptions, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n\r\n  const { phase, summary, summary_file, rationale, rationale_file } = options;\r\n  let summaryText: string | undefined;\r\n  let rationaleText = '';\r\n\r\n  try {\r\n    summaryText = readTextArgOrFile(cwd, summary, summary_file, 'summary');\r\n    rationaleText = readTextArgOrFile(cwd, rationale || '', rationale_file, 'rationale') || '';\r\n  } catch (thrown: unknown) {\r\n    const e = thrown as Error;\r\n    output({ added: false, reason: e.message }, raw, 'false');\r\n    return;\r\n  }\r\n\r\n  if (!summaryText) { output({ error: 'summary required' }, raw); return; }\r\n\r\n  const content = fs.readFileSync(statePath, 'utf-8');\r\n  const entry = `- [Phase ${phase || '?'}]: ${summaryText}${rationaleText ? `  ${rationaleText}` : ''}`;\r\n\r\n  const sectionPattern = /(###?\\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n  const updated = appendToStateSection(content, sectionPattern, entry, [/None yet\\.?\\s*\\n?/gi, /No decisions yet\\.?\\s*\\n?/gi]);\r\n\r\n  if (updated) {\r\n    fs.writeFileSync(statePath, updated, 'utf-8');\r\n    output({ added: true, decision: entry }, raw, 'true');\r\n  } else {\r\n    output({ added: false, reason: 'Decisions section not found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateAddBlocker(cwd: string, text: string | StateBlockerOptions, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n  const blockerOptions: StateBlockerOptions = typeof text === 'object' && text !== null ? text : { text: text as string };\r\n  let blockerText: string | undefined;\r\n\r\n  try {\r\n    blockerText = readTextArgOrFile(cwd, blockerOptions.text, blockerOptions.text_file, 'blocker');\r\n  } catch (thrown: unknown) {\r\n    const e = thrown as Error;\r\n    output({ added: false, reason: e.message }, raw, 'false');\r\n    return;\r\n  }\r\n\r\n  if (!blockerText) { output({ error: 'text required' }, raw); return; }\r\n\r\n  const content = fs.readFileSync(statePath, 'utf-8');\r\n  const entry = `- ${blockerText}`;\r\n\r\n  const sectionPattern = /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n  const updated = appendToStateSection(content, sectionPattern, entry, [/None\\.?\\s*\\n?/gi, /None yet\\.?\\s*\\n?/gi]);\r\n\r\n  if (updated) {\r\n    fs.writeFileSync(statePath, updated, 'utf-8');\r\n    output({ added: true, blocker: blockerText }, raw, 'true');\r\n  } else {\r\n    output({ added: false, reason: 'Blockers section not found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateResolveBlocker(cwd: string, text: string | null, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n  if (!text) { output({ error: 'text required' }, raw); return; }\r\n\r\n  let content = fs.readFileSync(statePath, 'utf-8');\r\n\r\n  const sectionPattern = /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n  const match = content.match(sectionPattern);\r\n\r\n  if (match) {\r\n    const sectionBody = match[2];\r\n    const lines = sectionBody.split('\\n');\r\n    const filtered = lines.filter(line => {\r\n      if (!line.startsWith('- ')) return true;\r\n      return !line.toLowerCase().includes(text.toLowerCase());\r\n    });\r\n\r\n    let newBody = filtered.join('\\n');\r\n    if (!newBody.trim() || !newBody.includes('- ')) {\r\n      newBody = 'None\\n';\r\n    }\r\n\r\n    content = content.replace(sectionPattern, (_match, header: string) => `${header}${newBody}`);\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ resolved: true, blocker: text }, raw, 'true');\r\n  } else {\r\n    output({ resolved: false, reason: 'Blockers section not found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateRecordSession(cwd: string, options: StateSessionOptions, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n  if (!fs.existsSync(statePath)) { output({ error: 'STATE.md not found' }, raw); return; }\r\n\r\n  let content = fs.readFileSync(statePath, 'utf-8');\r\n  const now = new Date().toISOString();\r\n  const updated: string[] = [];\r\n\r\n  let result = stateReplaceField(content, 'Last session', now);\r\n  if (result) { content = result; updated.push('Last session'); }\r\n  result = stateReplaceField(content, 'Last Date', now);\r\n  if (result) { content = result; updated.push('Last Date'); }\r\n\r\n  if (options.stopped_at) {\r\n    result = stateReplaceField(content, 'Stopped At', options.stopped_at);\r\n    if (!result) result = stateReplaceField(content, 'Stopped at', options.stopped_at);\r\n    if (result) { content = result; updated.push('Stopped At'); }\r\n  }\r\n\r\n  const resumeFile = options.resume_file || 'None';\r\n  result = stateReplaceField(content, 'Resume File', resumeFile);\r\n  if (!result) result = stateReplaceField(content, 'Resume file', resumeFile);\r\n  if (result) { content = result; updated.push('Resume File'); }\r\n\r\n  if (updated.length > 0) {\r\n    fs.writeFileSync(statePath, content, 'utf-8');\r\n    output({ recorded: true, updated }, raw, 'true');\r\n  } else {\r\n    output({ recorded: false, reason: 'No session fields found in STATE.md' }, raw, 'false');\r\n  }\r\n}\r\n\r\nexport function cmdStateSnapshot(cwd: string, raw: boolean): void {\r\n  const statePath = statePathUtil(cwd);\r\n\r\n  if (!fs.existsSync(statePath)) {\r\n    output({ error: 'STATE.md not found' }, raw);\r\n    return;\r\n  }\r\n\r\n  const content = fs.readFileSync(statePath, 'utf-8');\r\n\r\n  const extractField = (fieldName: string): string | null => {\r\n    const pattern = new RegExp(`\\\\*\\\\*${fieldName}:\\\\*\\\\*\\\\s*(.+)`, 'i');\r\n    const match = content.match(pattern);\r\n    return match ? match[1].trim() : null;\r\n  };\r\n\r\n  const currentPhase = extractField('Current Phase');\r\n  const currentPhaseName = extractField('Current Phase Name');\r\n  const totalPhasesRaw = extractField('Total Phases');\r\n  const currentPlan = extractField('Current Plan');\r\n  const totalPlansRaw = extractField('Total Plans in Phase');\r\n  const status = extractField('Status');\r\n  const progressRaw = extractField('Progress');\r\n  const lastActivity = extractField('Last Activity');\r\n  const lastActivityDesc = extractField('Last Activity Description');\r\n  const pausedAt = extractField('Paused At');\r\n\r\n  const totalPhases = totalPhasesRaw ? parseInt(totalPhasesRaw, 10) : null;\r\n  const totalPlansInPhase = totalPlansRaw ? parseInt(totalPlansRaw, 10) : null;\r\n  const progressPercent = progressRaw ? parseInt(progressRaw.replace('%', ''), 10) : null;\r\n\r\n  const decisions: Decision[] = [];\r\n  const decisionsMatch = content.match(/##\\s*Decisions Made[\\s\\S]*?\\n\\|[^\\n]+\\n\\|[-|\\s]+\\n([\\s\\S]*?)(?=\\n##|\\n$|$)/i);\r\n  if (decisionsMatch) {\r\n    const tableBody = decisionsMatch[1];\r\n    const rows = tableBody.trim().split('\\n').filter(r => r.includes('|'));\r\n    for (const row of rows) {\r\n      const cells = row.split('|').map(c => c.trim()).filter(Boolean);\r\n      if (cells.length >= 3) {\r\n        decisions.push({\r\n          phase: cells[0],\r\n          summary: cells[1],\r\n          rationale: cells[2],\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  const blockers: string[] = [];\r\n  const blockersMatch = content.match(/##\\s*Blockers\\s*\\n([\\s\\S]*?)(?=\\n##|$)/i);\r\n  if (blockersMatch) {\r\n    const blockersSection = blockersMatch[1];\r\n    const items = blockersSection.match(/^-\\s+(.+)$/gm) || [];\r\n    for (const item of items) {\r\n      blockers.push(item.replace(/^-\\s+/, '').trim());\r\n    }\r\n  }\r\n\r\n  const session: StateSnapshot['session'] = {\r\n    last_date: null,\r\n    stopped_at: null,\r\n    resume_file: null,\r\n  };\r\n\r\n  const sessionMatch = content.match(/##\\s*Session\\s*\\n([\\s\\S]*?)(?=\\n##|$)/i);\r\n  if (sessionMatch) {\r\n    const sessionSection = sessionMatch[1];\r\n    const lastDateMatch = sessionSection.match(/\\*\\*Last Date:\\*\\*\\s*(.+)/i);\r\n    const stoppedAtMatch = sessionSection.match(/\\*\\*Stopped At:\\*\\*\\s*(.+)/i);\r\n    const resumeFileMatch = sessionSection.match(/\\*\\*Resume File:\\*\\*\\s*(.+)/i);\r\n\r\n    if (lastDateMatch) session.last_date = lastDateMatch[1].trim();\r\n    if (stoppedAtMatch) session.stopped_at = stoppedAtMatch[1].trim();\r\n    if (resumeFileMatch) session.resume_file = resumeFileMatch[1].trim();\r\n  }\r\n\r\n  const snapshot: StateSnapshot = {\r\n    current_phase: currentPhase,\r\n    current_phase_name: currentPhaseName,\r\n    total_phases: totalPhases,\r\n    current_plan: currentPlan,\r\n    total_plans_in_phase: totalPlansInPhase,\r\n    status,\r\n    progress_percent: progressPercent,\r\n    last_activity: lastActivity,\r\n    last_activity_desc: lastActivityDesc,\r\n    decisions,\r\n    blockers,\r\n    paused_at: pausedAt,\r\n    session,\r\n  };\r\n\r\n  output(snapshot, raw);\r\n}\r\n","/**\r\n * State Management MCP Tools  STATE.md operations exposed as MCP tools\r\n *\r\n * CRITICAL: Never import output() or error() from core  they call process.exit().\r\n * CRITICAL: Never write to stdout  it is reserved for MCP JSON-RPC protocol.\r\n * CRITICAL: Never call process.exit()  the server must stay alive after every tool call.\r\n */\r\n\r\nimport fs from 'node:fs';\r\nimport { z } from 'zod';\r\nimport escapeStringRegexp from 'escape-string-regexp';\r\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\n\r\nimport { statePath } from '../core/core.js';\r\nimport { stateExtractField, stateReplaceField, appendToStateSection } from '../core/state.js';\r\nimport { detectProjectRoot, mcpSuccess, mcpError } from './utils.js';\r\n\r\n/**\r\n * Register all state management tools on the MCP server.\r\n */\r\nexport function registerStateTools(server: McpServer): void {\r\n  //  mcp_get_state \r\n\r\n  server.tool(\r\n    'mcp_get_state',\r\n    'Read STATE.md content  full file, a specific **field:** value, or a ## section.',\r\n    {\r\n      field: z\r\n        .string()\r\n        .optional()\r\n        .describe('Specific field or section name, or omit for full STATE.md'),\r\n    },\r\n    async ({ field }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const stPath = statePath(cwd);\r\n        if (!fs.existsSync(stPath)) {\r\n          return mcpError('STATE.md not found', 'STATE.md missing');\r\n        }\r\n\r\n        const content = fs.readFileSync(stPath, 'utf-8');\r\n\r\n        if (!field) {\r\n          return mcpSuccess({ content }, 'Full STATE.md retrieved');\r\n        }\r\n\r\n        // Try **field:** value pattern first\r\n        const fieldValue = stateExtractField(content, field);\r\n        if (fieldValue) {\r\n          return mcpSuccess(\r\n            { content: fieldValue, field },\r\n            `State field retrieved: ${field}`,\r\n          );\r\n        }\r\n\r\n        // Try ## Section pattern\r\n        const fieldEscaped = escapeStringRegexp(field);\r\n        const sectionPattern = new RegExp(\r\n          `##\\\\s*${fieldEscaped}\\\\s*\\n([\\\\s\\\\S]*?)(?=\\\\n##|$)`,\r\n          'i',\r\n        );\r\n        const sectionMatch = content.match(sectionPattern);\r\n        if (sectionMatch) {\r\n          return mcpSuccess(\r\n            { content: sectionMatch[1].trim(), field },\r\n            `State section retrieved: ${field}`,\r\n          );\r\n        }\r\n\r\n        return mcpError(\r\n          `Section or field \"${field}\" not found in STATE.md`,\r\n          'Field not found',\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_update_state \r\n\r\n  server.tool(\r\n    'mcp_update_state',\r\n    'Update a **field:** value in STATE.md (e.g., \"Status\", \"Current focus\").',\r\n    {\r\n      field: z.string().describe('Field name (e.g., \"Status\", \"Current focus\")'),\r\n      value: z.string().describe('New value for the field'),\r\n    },\r\n    async ({ field, value }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const stPath = statePath(cwd);\r\n        if (!fs.existsSync(stPath)) {\r\n          return mcpError('STATE.md not found', 'STATE.md missing');\r\n        }\r\n\r\n        const content = fs.readFileSync(stPath, 'utf-8');\r\n        const updated = stateReplaceField(content, field, value);\r\n\r\n        if (!updated) {\r\n          return mcpError(\r\n            `Field \"${field}\" not found in STATE.md`,\r\n            'Field not found',\r\n          );\r\n        }\r\n\r\n        fs.writeFileSync(stPath, updated, 'utf-8');\r\n\r\n        return mcpSuccess(\r\n          { updated: true, field, value },\r\n          `State updated: ${field}`,\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_add_decision \r\n\r\n  server.tool(\r\n    'mcp_add_decision',\r\n    'Record a decision in the Decisions section of STATE.md.',\r\n    {\r\n      summary: z.string().describe('Decision summary'),\r\n      rationale: z.string().optional().describe('Optional rationale'),\r\n      phase: z.string().optional().describe('Associated phase number'),\r\n    },\r\n    async ({ summary, rationale, phase }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const stPath = statePath(cwd);\r\n        if (!fs.existsSync(stPath)) {\r\n          return mcpError('STATE.md not found', 'STATE.md missing');\r\n        }\r\n\r\n        const content = fs.readFileSync(stPath, 'utf-8');\r\n        const entry = `- [Phase ${phase || '?'}]: ${summary}${rationale ? ` -- ${rationale}` : ''}`;\r\n\r\n        const sectionPattern =\r\n          /(###?\\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n        const updated = appendToStateSection(content, sectionPattern, entry, [/None yet\\.?\\s*\\n?/gi, /No decisions yet\\.?\\s*\\n?/gi]);\r\n\r\n        if (!updated) {\r\n          return mcpError(\r\n            'Decisions section not found in STATE.md',\r\n            'Section not found',\r\n          );\r\n        }\r\n\r\n        fs.writeFileSync(stPath, updated, 'utf-8');\r\n\r\n        return mcpSuccess(\r\n          { added: true, decision: entry },\r\n          'Decision recorded',\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_add_blocker \r\n\r\n  server.tool(\r\n    'mcp_add_blocker',\r\n    'Add a blocker entry to the Blockers section of STATE.md.',\r\n    {\r\n      text: z.string().describe('Blocker description'),\r\n    },\r\n    async ({ text }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const stPath = statePath(cwd);\r\n        if (!fs.existsSync(stPath)) {\r\n          return mcpError('STATE.md not found', 'STATE.md missing');\r\n        }\r\n\r\n        const content = fs.readFileSync(stPath, 'utf-8');\r\n        const entry = `- ${text}`;\r\n\r\n        const sectionPattern =\r\n          /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n        const updated = appendToStateSection(content, sectionPattern, entry, [/None\\.?\\s*\\n?/gi, /None yet\\.?\\s*\\n?/gi]);\r\n\r\n        if (!updated) {\r\n          return mcpError(\r\n            'Blockers section not found in STATE.md',\r\n            'Section not found',\r\n          );\r\n        }\r\n\r\n        fs.writeFileSync(stPath, updated, 'utf-8');\r\n\r\n        return mcpSuccess(\r\n          { added: true, blocker: text },\r\n          'Blocker added',\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n\r\n  //  mcp_resolve_blocker \r\n\r\n  server.tool(\r\n    'mcp_resolve_blocker',\r\n    'Remove a blocker from STATE.md by matching text (case-insensitive partial match).',\r\n    {\r\n      text: z\r\n        .string()\r\n        .describe('Text to match against blocker entries (case-insensitive partial match)'),\r\n    },\r\n    async ({ text }) => {\r\n      try {\r\n        const cwd = detectProjectRoot();\r\n        if (!cwd) {\r\n          return mcpError('No .planning/ directory found', 'Project not detected');\r\n        }\r\n\r\n        const stPath = statePath(cwd);\r\n        if (!fs.existsSync(stPath)) {\r\n          return mcpError('STATE.md not found', 'STATE.md missing');\r\n        }\r\n\r\n        let content = fs.readFileSync(stPath, 'utf-8');\r\n\r\n        const sectionPattern =\r\n          /(###?\\s*(?:Blockers|Blockers\\/Concerns|Concerns)\\s*\\n)([\\s\\S]*?)(?=\\n###?|\\n##[^#]|$)/i;\r\n        const match = content.match(sectionPattern);\r\n\r\n        if (!match) {\r\n          return mcpError(\r\n            'Blockers section not found in STATE.md',\r\n            'Section not found',\r\n          );\r\n        }\r\n\r\n        const sectionBody = match[2];\r\n        const lines = sectionBody.split('\\n');\r\n        const filtered = lines.filter((line) => {\r\n          if (!line.startsWith('- ')) return true;\r\n          return !line.toLowerCase().includes(text.toLowerCase());\r\n        });\r\n\r\n        let newBody = filtered.join('\\n');\r\n        if (!newBody.trim() || !newBody.includes('- ')) {\r\n          newBody = 'None\\n';\r\n        }\r\n\r\n        content = content.replace(\r\n          sectionPattern,\r\n          (_match, header: string) => `${header}${newBody}`,\r\n        );\r\n\r\n        fs.writeFileSync(stPath, content, 'utf-8');\r\n\r\n        return mcpSuccess(\r\n          { resolved: true, blocker: text },\r\n          'Blocker resolved',\r\n        );\r\n      } catch (e) {\r\n        return mcpError((e as Error).message, 'Operation failed');\r\n      }\r\n    },\r\n  );\r\n}\r\n","/**\r\n * MCP Tool Registration  Orchestrates all tool registrations\r\n *\r\n * This is the single entry point for registering MCP tools on the server.\r\n * Later plans will add registerTodoTools, registerStateTools, etc.\r\n */\r\n\r\nimport type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\nimport { registerPhaseTools } from './phase-tools.js';\r\nimport { registerTodoTools } from './todo-tools.js';\r\nimport { registerStateTools } from './state-tools.js';\r\n\r\n/**\r\n * Register all MCP tools on the given server instance.\r\n */\r\nexport function registerAllTools(server: McpServer): void {\r\n  registerPhaseTools(server);\r\n  registerTodoTools(server);\r\n  registerStateTools(server);\r\n}\r\n","/**\r\n * MAXSIM MCP Server  Entry point\r\n *\r\n * Provides MCP tools for phase operations, state management, and more.\r\n * Communicates over stdio using the MCP JSON-RPC protocol.\r\n *\r\n * CRITICAL: Never write to stdout directly  stdout is reserved for MCP protocol.\r\n * All logging must go to stderr.\r\n * CRITICAL: Never import output() or error() from core  they call process.exit().\r\n */\r\n\r\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\r\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\r\nimport { registerAllTools } from './mcp/index.js';\r\n\r\nasync function main() {\r\n  const server = new McpServer({\r\n    name: 'maxsim',\r\n    version: '1.0.0',\r\n  });\r\n\r\n  registerAllTools(server);\r\n\r\n  const transport = new StdioServerTransport();\r\n  await server.connect(transport);\r\n\r\n  // Log to stderr ONLY  stdout is reserved for MCP JSON-RPC protocol\r\n  process.stderr.write('MAXSIM MCP server started\\n');\r\n}\r\n\r\nmain().catch((err) => {\r\n  process.stderr.write(`MAXSIM MCP server error: ${err}\\n`);\r\n  process.exitCode = 1;\r\n});\r\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,91],"mappings":"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"}