//#region \0rolldown/runtime.js
var __create = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames$1(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp$1.call(to, key) && key !== except) {
				__defProp$1(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let node_path = require("node:path");
node_path = __toESM(node_path);
let node_fs = require("node:fs");
node_fs = __toESM(node_fs);
let node_os = require("node:os");
node_os = __toESM(node_os);
let node_http = require("node:http");
let path = require("path");
path = __toESM(path);
let fs = require("fs");
let events = require("events");
let node_querystring = require("node:querystring");
node_querystring = __toESM(node_querystring);
let _modelcontextprotocol_sdk_server_streamableHttp_js = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
let _modelcontextprotocol_sdk_server_mcp_js = require("@modelcontextprotocol/sdk/server/mcp.js");
let node_crypto = require("node:crypto");
let node_net = require("node:net");
let node_util = require("node:util");
let node_fs_promises = require("node:fs/promises");
node_fs_promises = __toESM(node_fs_promises);
let node_child_process = require("node:child_process");
node_child_process = __toESM(node_child_process);
let node_process = require("node:process");
node_process = __toESM(node_process);
let node_buffer = require("node:buffer");
let node_url = require("node:url");
let os = require("os");
let child_process = require("child_process");
let fs_promises = require("fs/promises");
let node_stream = require("node:stream");

//#region ../../node_modules/depd/index.js
var require_depd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* depd
	* Copyright(c) 2014-2018 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module dependencies.
	*/
	var relative = require("path").relative;
	/**
	* Module exports.
	*/
	module.exports = depd;
	/**
	* Get the path to base files on.
	*/
	var basePath = process.cwd();
	/**
	* Determine if namespace is contained in the string.
	*/
	function containsNamespace(str, namespace) {
		var vals = str.split(/[ ,]+/);
		var ns = String(namespace).toLowerCase();
		for (var i = 0; i < vals.length; i++) {
			var val = vals[i];
			if (val && (val === "*" || val.toLowerCase() === ns)) return true;
		}
		return false;
	}
	/**
	* Convert a data descriptor to accessor descriptor.
	*/
	function convertDataDescriptorToAccessor(obj, prop, message) {
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		var value = descriptor.value;
		descriptor.get = function getter() {
			return value;
		};
		if (descriptor.writable) descriptor.set = function setter(val) {
			return value = val;
		};
		delete descriptor.value;
		delete descriptor.writable;
		Object.defineProperty(obj, prop, descriptor);
		return descriptor;
	}
	/**
	* Create arguments string to keep arity.
	*/
	function createArgumentsString(arity) {
		var str = "";
		for (var i = 0; i < arity; i++) str += ", arg" + i;
		return str.substr(2);
	}
	/**
	* Create stack string from stack.
	*/
	function createStackString(stack) {
		var str = this.name + ": " + this.namespace;
		if (this.message) str += " deprecated " + this.message;
		for (var i = 0; i < stack.length; i++) str += "\n    at " + stack[i].toString();
		return str;
	}
	/**
	* Create deprecate for namespace in caller.
	*/
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		var file = callSiteLocation(getStack()[1])[0];
		function deprecate(message) {
			log.call(deprecate, message);
		}
		deprecate._file = file;
		deprecate._ignored = isignored(namespace);
		deprecate._namespace = namespace;
		deprecate._traced = istraced(namespace);
		deprecate._warned = Object.create(null);
		deprecate.function = wrapfunction;
		deprecate.property = wrapproperty;
		return deprecate;
	}
	/**
	* Determine if event emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function eehaslisteners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if namespace is ignored.
	*/
	function isignored(namespace) {
		if (process.noDeprecation) return true;
		return containsNamespace(process.env.NO_DEPRECATION || "", namespace);
	}
	/**
	* Determine if namespace is traced.
	*/
	function istraced(namespace) {
		if (process.traceDeprecation) return true;
		return containsNamespace(process.env.TRACE_DEPRECATION || "", namespace);
	}
	/**
	* Display deprecation message.
	*/
	function log(message, site) {
		var haslisteners = eehaslisteners(process, "deprecation");
		if (!haslisteners && this._ignored) return;
		var caller;
		var callFile;
		var callSite;
		var depSite;
		var i = 0;
		var seen = false;
		var stack = getStack();
		var file = this._file;
		if (site) {
			depSite = site;
			callSite = callSiteLocation(stack[1]);
			callSite.name = depSite.name;
			file = callSite[0];
		} else {
			i = 2;
			depSite = callSiteLocation(stack[i]);
			callSite = depSite;
		}
		for (; i < stack.length; i++) {
			caller = callSiteLocation(stack[i]);
			callFile = caller[0];
			if (callFile === file) seen = true;
			else if (callFile === this._file) file = this._file;
			else if (seen) break;
		}
		var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
		if (key !== void 0 && key in this._warned) return;
		this._warned[key] = true;
		var msg = message;
		if (!msg) msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
		if (haslisteners) {
			var err = DeprecationError(this._namespace, msg, stack.slice(i));
			process.emit("deprecation", err);
			return;
		}
		var output = (process.stderr.isTTY ? formatColor : formatPlain).call(this, msg, caller, stack.slice(i));
		process.stderr.write(output + "\n", "utf8");
	}
	/**
	* Get call site location as array.
	*/
	function callSiteLocation(callSite) {
		var file = callSite.getFileName() || "<anonymous>";
		var line = callSite.getLineNumber();
		var colm = callSite.getColumnNumber();
		if (callSite.isEval()) file = callSite.getEvalOrigin() + ", " + file;
		var site = [
			file,
			line,
			colm
		];
		site.callSite = callSite;
		site.name = callSite.getFunctionName();
		return site;
	}
	/**
	* Generate a default message from the site.
	*/
	function defaultMessage(site) {
		var callSite = site.callSite;
		var funcName = site.name;
		if (!funcName) funcName = "<anonymous@" + formatLocation(site) + ">";
		var context = callSite.getThis();
		var typeName = context && callSite.getTypeName();
		if (typeName === "Object") typeName = void 0;
		if (typeName === "Function") typeName = context.name || typeName;
		return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
	}
	/**
	* Format deprecation message without color.
	*/
	function formatPlain(msg, caller, stack) {
		var formatted = (/* @__PURE__ */ new Date()).toUTCString() + " " + this._namespace + " deprecated " + msg;
		if (this._traced) {
			for (var i = 0; i < stack.length; i++) formatted += "\n    at " + stack[i].toString();
			return formatted;
		}
		if (caller) formatted += " at " + formatLocation(caller);
		return formatted;
	}
	/**
	* Format deprecation message with color.
	*/
	function formatColor(msg, caller, stack) {
		var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
		if (this._traced) {
			for (var i = 0; i < stack.length; i++) formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
			return formatted;
		}
		if (caller) formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
		return formatted;
	}
	/**
	* Format call site location.
	*/
	function formatLocation(callSite) {
		return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
	}
	/**
	* Get the stack as array of call sites.
	*/
	function getStack() {
		var limit = Error.stackTraceLimit;
		var obj = {};
		var prep = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareObjectStackTrace;
		Error.stackTraceLimit = Math.max(10, limit);
		Error.captureStackTrace(obj);
		var stack = obj.stack.slice(1);
		Error.prepareStackTrace = prep;
		Error.stackTraceLimit = limit;
		return stack;
	}
	/**
	* Capture call site stack from v8.
	*/
	function prepareObjectStackTrace(obj, stack) {
		return stack;
	}
	/**
	* Return a wrapped function in a deprecation message.
	*/
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		var args = createArgumentsString(fn.length);
		var site = callSiteLocation(getStack()[1]);
		site.name = fn.name;
		return new Function("fn", "log", "deprecate", "message", "site", "\"use strict\"\nreturn function (" + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
	}
	/**
	* Wrap property in a deprecation message.
	*/
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
		var deprecate = this;
		var site = callSiteLocation(getStack()[1]);
		site.name = prop;
		if ("value" in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
		var get = descriptor.get;
		var set = descriptor.set;
		if (typeof get === "function") descriptor.get = function getter() {
			log.call(deprecate, message, site);
			return get.apply(this, arguments);
		};
		if (typeof set === "function") descriptor.set = function setter() {
			log.call(deprecate, message, site);
			return set.apply(this, arguments);
		};
		Object.defineProperty(obj, prop, descriptor);
	}
	/**
	* Create DeprecationError for deprecation
	*/
	function DeprecationError(namespace, message, stack) {
		var error = /* @__PURE__ */ new Error();
		var stackString;
		Object.defineProperty(error, "constructor", { value: DeprecationError });
		Object.defineProperty(error, "message", {
			configurable: true,
			enumerable: false,
			value: message,
			writable: true
		});
		Object.defineProperty(error, "name", {
			enumerable: false,
			configurable: true,
			value: "DeprecationError",
			writable: true
		});
		Object.defineProperty(error, "namespace", {
			configurable: true,
			enumerable: false,
			value: namespace,
			writable: true
		});
		Object.defineProperty(error, "stack", {
			configurable: true,
			enumerable: false,
			get: function() {
				if (stackString !== void 0) return stackString;
				return stackString = createStackString.call(this, stack);
			},
			set: function setter(val) {
				stackString = val;
			}
		});
		return error;
	}
}));

//#endregion
//#region ../../node_modules/bytes/index.js
/*!
* bytes
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015 Jed Watson
* MIT Licensed
*/
var require_bytes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = bytes;
	module.exports.format = format;
	module.exports.parse = parse;
	/**
	* Module variables.
	* @private
	*/
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	/**
	* Convert the given value in bytes into a string or parse to string to an integer in bytes.
	*
	* @param {string|number} value
	* @param {{
	*  case: [string],
	*  decimalPlaces: [number]
	*  fixedDecimals: [boolean]
	*  thousandsSeparator: [string]
	*  unitSeparator: [string]
	*  }} [options] bytes options.
	*
	* @returns {string|number|null}
	*/
	function bytes(value, options) {
		if (typeof value === "string") return parse(value);
		if (typeof value === "number") return format(value, options);
		return null;
	}
	/**
	* Format the given value in bytes into a string.
	*
	* If the value is negative, it is kept as such. If it is a float,
	* it is rounded.
	*
	* @param {number} value
	* @param {object} [options]
	* @param {number} [options.decimalPlaces=2]
	* @param {number} [options.fixedDecimals=false]
	* @param {string} [options.thousandsSeparator=]
	* @param {string} [options.unit=]
	* @param {string} [options.unitSeparator=]
	*
	* @returns {string|null}
	* @public
	*/
	function format(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str = str.split(".").map(function(s, i) {
			return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
		}).join(".");
		return str + unitSeparator + unit;
	}
	/**
	* Parse the string value into an integer in bytes.
	*
	* If no unit is given, it is assumed the value is in bytes.
	*
	* @param {number|string} val
	*
	* @returns {number|null}
	* @public
	*/
	function parse(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
}));

//#endregion
//#region ../../node_modules/content-type/index.js
/*!
* content-type
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_content_type = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	*/
	var QUOTE_REGEXP = /([\\"])/g;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* Module exports.
	* @public
	*/
	exports.format = format;
	exports.parse = parse;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @public
	*/
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || !TYPE_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = type;
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				if (!TOKEN_REGEXP.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @public
	*/
	function parse(string) {
		if (!string) throw new TypeError("argument string is required");
		var header = typeof string === "object" ? getcontenttype(string) : string;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index = header.indexOf(";");
		var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (!TYPE_REGEXP.test(type)) throw new TypeError("invalid media type");
		var obj = new ContentType(type.toLowerCase());
		if (index !== -1) {
			var key;
			var match;
			var value;
			PARAM_REGEXP.lastIndex = index;
			while (match = PARAM_REGEXP.exec(header)) {
				if (match.index !== index) throw new TypeError("invalid parameter format");
				index += match[0].length;
				key = match[1].toLowerCase();
				value = match[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP, "$1");
				}
				obj.parameters[key] = value;
			}
			if (index !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @private
	*/
	function getcontenttype(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring(val) {
		var str = String(val);
		if (TOKEN_REGEXP.test(str)) return str;
		if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	/**
	* Class to represent a content type.
	* @private
	*/
	function ContentType(type) {
		this.parameters = Object.create(null);
		this.type = type;
	}
}));

//#endregion
//#region ../../node_modules/setprototypeof/index.js
var require_setprototypeof = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}
	function mixinProperties(obj, proto) {
		for (var prop in proto) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
		return obj;
	}
}));

//#endregion
//#region ../../node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}));

//#endregion
//#region ../../node_modules/statuses/index.js
/*!
* statuses
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_statuses = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Create a map of message to status code.
	* @private
	*/
	function createMessageToStatusCodeMap(codes) {
		var map = {};
		Object.keys(codes).forEach(function forEachCode(code) {
			var message = codes[code];
			var status = Number(code);
			map[message.toLowerCase()] = status;
		});
		return map;
	}
	/**
	* Create a list of all status codes.
	* @private
	*/
	function createStatusCodeList(codes) {
		return Object.keys(codes).map(function mapCode(code) {
			return Number(code);
		});
	}
	/**
	* Get the status code for given message.
	* @private
	*/
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	/**
	* Get the status message for given code.
	* @private
	*/
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error("invalid status code: " + code);
		return status.message[code];
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
}));

//#endregion
//#region ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));

//#endregion
//#region ../../node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	try {
		var util$6 = require("util");
		/* istanbul ignore next */
		if (typeof util$6.inherits !== "function") throw "";
		module.exports = util$6.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}));

//#endregion
//#region ../../node_modules/toidentifier/index.js
/*!
* toidentifier
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_toidentifier = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = toIdentifier;
	/**
	* Trasform the given string into a JavaScript identifier
	*
	* @param {string} str
	* @returns {string}
	* @public
	*/
	function toIdentifier(str) {
		return str.split(" ").map(function(token) {
			return token.slice(0, 1).toUpperCase() + token.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
}));

//#endregion
//#region ../../node_modules/http-errors/index.js
/*!
* http-errors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_http_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("http-errors");
	var setPrototypeOf = require_setprototypeof();
	var statuses = require_statuses();
	var inherits = require_inherits();
	var toIdentifier = require_toidentifier();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createError;
	module.exports.HttpError = createHttpErrorConstructor();
	module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
	/**
	* Get the code class of a status code.
	* @private
	*/
	function codeClass(status) {
		return Number(String(status).charAt(0) + "00");
	}
	/**
	* Create a new HTTP Error.
	*
	* @returns {Error}
	* @public
	*/
	function createError() {
		var err;
		var msg;
		var status = 500;
		var props = {};
		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			var type = typeof arg;
			if (type === "object" && arg instanceof Error) {
				err = arg;
				status = err.status || err.statusCode || status;
			} else if (type === "number" && i === 0) status = arg;
			else if (type === "string") msg = arg;
			else if (type === "object") props = arg;
			else throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
		}
		if (typeof status === "number" && (status < 400 || status >= 600)) deprecate("non-error status code; use only 4xx or 5xx status codes");
		if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) status = 500;
		var HttpError = createError[status] || createError[codeClass(status)];
		if (!err) {
			err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
			Error.captureStackTrace(err, createError);
		}
		if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
			err.expose = status < 500;
			err.status = err.statusCode = status;
		}
		for (var key in props) if (key !== "status" && key !== "statusCode") err[key] = props[key];
		return err;
	}
	/**
	* Create HTTP error abstract base class.
	* @private
	*/
	function createHttpErrorConstructor() {
		function HttpError() {
			throw new TypeError("cannot construct abstract class");
		}
		inherits(HttpError, Error);
		return HttpError;
	}
	/**
	* Create a constructor for a client error.
	* @private
	*/
	function createClientErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ClientError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ClientError);
			setPrototypeOf(err, ClientError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ClientError, HttpError);
		nameFunc(ClientError, className);
		ClientError.prototype.status = code;
		ClientError.prototype.statusCode = code;
		ClientError.prototype.expose = true;
		return ClientError;
	}
	/**
	* Create function to test is a value is a HttpError.
	* @private
	*/
	function createIsHttpErrorFunction(HttpError) {
		return function isHttpError(val) {
			if (!val || typeof val !== "object") return false;
			if (val instanceof HttpError) return true;
			return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
		};
	}
	/**
	* Create a constructor for a server error.
	* @private
	*/
	function createServerErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ServerError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ServerError);
			setPrototypeOf(err, ServerError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ServerError, HttpError);
		nameFunc(ServerError, className);
		ServerError.prototype.status = code;
		ServerError.prototype.statusCode = code;
		ServerError.prototype.expose = false;
		return ServerError;
	}
	/**
	* Set the name of a function, if possible.
	* @private
	*/
	function nameFunc(func, name) {
		var desc = Object.getOwnPropertyDescriptor(func, "name");
		if (desc && desc.configurable) {
			desc.value = name;
			Object.defineProperty(func, "name", desc);
		}
	}
	/**
	* Populate the exports object with constructors for every error class.
	* @private
	*/
	function populateConstructorExports(exports$1, codes, HttpError) {
		codes.forEach(function forEachCode(code) {
			var CodeError;
			var name = toIdentifier(statuses.message[code]);
			switch (codeClass(code)) {
				case 400:
					CodeError = createClientErrorConstructor(HttpError, name, code);
					break;
				case 500:
					CodeError = createServerErrorConstructor(HttpError, name, code);
					break;
			}
			if (CodeError) {
				exports$1[code] = CodeError;
				exports$1[name] = CodeError;
			}
		});
	}
	/**
	* Get a class name from a name identifier.
	*
	* @param {string} name
	* @returns {string}
	* @private
	*/
	function toClassName(name) {
		return name.slice(-5) === "Error" ? name : name + "Error";
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/ms/index.js
var require_ms$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n, name) {
		if (ms < n) return;
		if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
		return Math.ceil(ms / n) + " " + name + "s";
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms$4();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i;
		for (i in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug() {
			if (!debug.enabled) return;
			var self = debug;
			var curr = +/* @__PURE__ */ new Date();
			self.diff = curr - (prevTime || curr);
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self, args);
			(debug.log || exports.log || console.log.bind(console)).apply(self, args);
		}
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug);
		return debug;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i = 0; i < len; i++) {
			if (!split[i]) continue;
			namespaces = split[i].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
		for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$3();
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var useColors = this.useColors;
		args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ("%%" === match) return;
			index++;
			if ("%c" === match) lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/debug/src/node.js
var require_node$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty$5 = require("tty");
	var util$5 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$3();
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$5.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream$3(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$5.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log() {
		return stream.write(util$5.format.apply(util$5, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream$3(fd) {
		var stream;
		switch (process.binding("tty_wrap").guessHandleType(fd)) {
			case "TTY":
				stream = new tty$5.WriteStream(fd);
				stream._type = "tty";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			case "FILE":
				stream = new (require("fs")).SyncWriteStream(fd, { autoClose: false });
				stream._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream = new (require("net")).Socket({
					fd,
					readable: false,
					writable: true
				});
				stream.readable = false;
				stream.read = null;
				stream._type = "pipe";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream.fd = fd;
		stream._isStdio = true;
		return stream;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/debug/src/index.js
var require_src$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser$4();
	else module.exports = require_node$4();
}));

//#endregion
//#region ../../node_modules/destroy/index.js
/*!
* destroy
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_destroy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var EventEmitter$5 = require("events").EventEmitter;
	var ReadStream = require("fs").ReadStream;
	var Stream$1 = require("stream");
	var Zlib = require("zlib");
	/**
	* Module exports.
	* @public
	*/
	module.exports = destroy;
	/**
	* Destroy the given stream, and optionally suppress any future `error` events.
	*
	* @param {object} stream
	* @param {boolean} suppress
	* @public
	*/
	function destroy(stream, suppress) {
		if (isFsReadStream(stream)) destroyReadStream(stream);
		else if (isZlibStream(stream)) destroyZlibStream(stream);
		else if (hasDestroy(stream)) stream.destroy();
		if (isEventEmitter(stream) && suppress) {
			stream.removeAllListeners("error");
			stream.addListener("error", noop);
		}
		return stream;
	}
	/**
	* Destroy a ReadStream.
	*
	* @param {object} stream
	* @private
	*/
	function destroyReadStream(stream) {
		stream.destroy();
		if (typeof stream.close === "function") stream.on("open", onOpenClose);
	}
	/**
	* Close a Zlib stream.
	*
	* Zlib streams below Node.js 4.5.5 have a buggy implementation
	* of .close() when zlib encountered an error.
	*
	* @param {object} stream
	* @private
	*/
	function closeZlibStream(stream) {
		if (stream._hadError === true) {
			var prop = stream._binding === null ? "_binding" : "_handle";
			stream[prop] = { close: function() {
				this[prop] = null;
			} };
		}
		stream.close();
	}
	/**
	* Destroy a Zlib stream.
	*
	* Zlib streams don't have a destroy function in Node.js 6. On top of that
	* simply calling destroy on a zlib stream in Node.js 8+ will result in a
	* memory leak. So until that is fixed, we need to call both close AND destroy.
	*
	* PR to fix memory leak: https://github.com/nodejs/node/pull/23734
	*
	* In Node.js 6+8, it's important that destroy is called before close as the
	* stream would otherwise emit the error 'zlib binding closed'.
	*
	* @param {object} stream
	* @private
	*/
	function destroyZlibStream(stream) {
		if (typeof stream.destroy === "function")
 // istanbul ignore if: node.js 0.8
		if (stream._binding) {
			stream.destroy();
			if (stream._processing) {
				stream._needDrain = true;
				stream.once("drain", onDrainClearBinding);
			} else stream._binding.clear();
		} else if (stream._destroy && stream._destroy !== Stream$1.Transform.prototype._destroy) stream.destroy();
		else if (stream._destroy && typeof stream.close === "function") {
			stream.destroyed = true;
			stream.close();
		} else
 // istanbul ignore next
		stream.destroy();
		else if (typeof stream.close === "function") closeZlibStream(stream);
	}
	/**
	* Determine if stream has destroy.
	* @private
	*/
	function hasDestroy(stream) {
		return stream instanceof Stream$1 && typeof stream.destroy === "function";
	}
	/**
	* Determine if val is EventEmitter.
	* @private
	*/
	function isEventEmitter(val) {
		return val instanceof EventEmitter$5;
	}
	/**
	* Determine if stream is fs.ReadStream stream.
	* @private
	*/
	function isFsReadStream(stream) {
		return stream instanceof ReadStream;
	}
	/**
	* Determine if stream is Zlib stream.
	* @private
	*/
	function isZlibStream(stream) {
		return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
	}
	/**
	* No-op function.
	* @private
	*/
	function noop() {}
	/**
	* On drain handler to clear binding.
	* @private
	*/
	// istanbul ignore next: node.js 0.8
	function onDrainClearBinding() {
		this._binding.clear();
	}
	/**
	* On open handler to close stream.
	* @private
	*/
	function onOpenClose() {
		if (typeof this.fd === "number") this.close();
	}
}));

//#endregion
//#region ../../node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer$2 = require("buffer");
	var Buffer = buffer$2.Buffer;
	var safer = {};
	var key;
	for (key in buffer$2) {
		if (!buffer$2.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer$2[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer) {
		if (!Buffer.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer[key];
	}
	safer.Buffer.prototype = Buffer.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/internal.js
var require_internal$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder$1 = require("string_decoder").StringDecoder;
	if (!StringDecoder$1.prototype.end) StringDecoder$1.prototype.end = function() {};
	function InternalDecoder(options, codec) {
		StringDecoder$1.call(this, codec.enc);
	}
	InternalDecoder.prototype = StringDecoder$1.prototype;
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var charCode = str.charCodeAt(i);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
		for (var i = 0; i < buf.length; i++) {
			var curByte = buf[i];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/utf16.js
var require_utf16$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer.from(str, "ucs2");
		for (var i = 0; i < buf.length; i += 2) {
			var tmp = buf[i];
			buf[i] = buf[i + 1];
			buf[i + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer.alloc(buf.length + 1), i = 0, j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i = 1;
			j = 2;
		}
		for (; i < buf.length - 1; i += 2, j += 2) {
			buf2[j] = buf[i + 1];
			buf2[j + 1] = buf[i];
		}
		this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBytes = [];
		this.initialBytesLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBytes.push(buf);
			this.initialBytesLen += buf.length;
			if (this.initialBytesLen < 16) return "";
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			this.initialBytes.length = this.initialBytesLen = 0;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var res = this.decoder.write(buf), trail = this.decoder.end();
			return trail ? res + trail : res;
		}
		return this.decoder.end();
	};
	function detectEncoding(buf, defaultEncoding) {
		var enc = defaultEncoding || "utf-16le";
		if (buf.length >= 2) if (buf[0] == 254 && buf[1] == 255) enc = "utf-16be";
		else if (buf[0] == 255 && buf[1] == 254) enc = "utf-16le";
		else {
			var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
			for (var i = 0; i < _len; i += 2) {
				if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
				if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
			}
			if (asciiCharsBE > asciiCharsLE) enc = "utf-16be";
			else if (asciiCharsBE < asciiCharsLE) enc = "utf-16le";
		}
		return enc;
	}
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/utf7.js
var require_utf7$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "+";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString();
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString();
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer.alloc(str.length * 5 + 10), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var uChar = str.charCodeAt(i);
			if (32 <= uChar && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer.alloc(10), bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "&";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, "/");
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
		for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length);
		for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer.alloc(buf.length * 2);
		var idx1 = 0, idx2 = 0;
		for (var i = 0; i < buf.length; i++) {
			idx1 = buf[i] * 2;
			idx2 = i * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"10029": "maccenteuro",
		"maccenteuro": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"808": "cp808",
		"ibm808": "cp808",
		"cp808": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"mik": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii8bit": "ascii",
		"usascii": "ascii",
		"ansix34": "ascii",
		"ansix341968": "ascii",
		"ansix341986": "ascii",
		"csascii": "ascii",
		"cp367": "ascii",
		"ibm367": "ascii",
		"isoir6": "ascii",
		"iso646us": "ascii",
		"iso646irv": "ascii",
		"us": "ascii",
		"latin1": "iso88591",
		"latin2": "iso88592",
		"latin3": "iso88593",
		"latin4": "iso88594",
		"latin5": "iso88599",
		"latin6": "iso885910",
		"latin7": "iso885913",
		"latin8": "iso885914",
		"latin9": "iso885915",
		"latin10": "iso885916",
		"csisolatin1": "iso88591",
		"csisolatin2": "iso88592",
		"csisolatin3": "iso88593",
		"csisolatin4": "iso88594",
		"csisolatincyrillic": "iso88595",
		"csisolatinarabic": "iso88596",
		"csisolatingreek": "iso88597",
		"csisolatinhebrew": "iso88598",
		"csisolatin5": "iso88599",
		"csisolatin6": "iso885910",
		"l1": "iso88591",
		"l2": "iso88592",
		"l3": "iso88593",
		"l4": "iso88594",
		"l5": "iso88599",
		"l6": "iso885910",
		"l7": "iso885913",
		"l8": "iso885914",
		"l9": "iso885915",
		"l10": "iso885916",
		"isoir14": "iso646jp",
		"isoir57": "iso646cn",
		"isoir100": "iso88591",
		"isoir101": "iso88592",
		"isoir109": "iso88593",
		"isoir110": "iso88594",
		"isoir144": "iso88595",
		"isoir127": "iso88596",
		"isoir126": "iso88597",
		"isoir138": "iso88598",
		"isoir148": "iso88599",
		"isoir157": "iso885910",
		"isoir166": "tis620",
		"isoir179": "iso885913",
		"isoir199": "iso885914",
		"isoir203": "iso885915",
		"isoir226": "iso885916",
		"cp819": "iso88591",
		"ibm819": "iso88591",
		"cyrillic": "iso88595",
		"arabic": "iso88596",
		"arabic8": "iso88596",
		"ecma114": "iso88596",
		"asmo708": "iso88596",
		"greek": "iso88597",
		"greek8": "iso88597",
		"ecma118": "iso88597",
		"elot928": "iso88597",
		"hebrew": "iso88598",
		"hebrew8": "iso88598",
		"turkish": "iso88599",
		"turkish8": "iso88599",
		"thai": "iso885911",
		"thai8": "iso885911",
		"celtic": "iso885914",
		"celtic8": "iso885914",
		"isoceltic": "iso885914",
		"tis6200": "tis620",
		"tis62025291": "tis620",
		"tis62025330": "tis620",
		"10000": "macroman",
		"10006": "macgreek",
		"10007": "maccyrillic",
		"10079": "maciceland",
		"10081": "macturkish",
		"cspc8codepage437": "cp437",
		"cspc775baltic": "cp775",
		"cspc850multilingual": "cp850",
		"cspcp852": "cp852",
		"cspc862latinhebrew": "cp862",
		"cpgr": "cp869",
		"msee": "cp1250",
		"mscyrl": "cp1251",
		"msansi": "cp1252",
		"msgreek": "cp1253",
		"msturk": "cp1254",
		"mshebr": "cp1255",
		"msarab": "cp1256",
		"winbaltrim": "cp1257",
		"cp20866": "koi8r",
		"20866": "koi8r",
		"ibm878": "koi8r",
		"cskoi8r": "koi8r",
		"cp21866": "koi8u",
		"21866": "koi8u",
		"ibm1168": "koi8u",
		"strk10482002": "rk1048",
		"tcvn5712": "tcvn",
		"tcvn57121": "tcvn",
		"gb198880": "iso646cn",
		"cn": "iso646cn",
		"csiso14jisc6220ro": "iso646jp",
		"jisc62201969ro": "iso646jp",
		"jp": "iso646jp",
		"cshproman8": "hproman8",
		"r8": "hproman8",
		"roman8": "hproman8",
		"xroman8": "hproman8",
		"ibm1051": "hproman8",
		"mac": "macintosh",
		"csmacintosh": "macintosh"
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
	for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
		this.defaultCharUnicode = iconv.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
			var val = codecOptions.encodeSkipVals[i];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var thirdByteNodeIdx = this.decodeTables.length;
			var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			var fourthByteNodeIdx = this.decodeTables.length;
			var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			for (var i = 129; i <= 254; i++) {
				var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
				var secondByteNode = this.decodeTables[secondByteNodeIdx];
				for (var j = 48; j <= 57; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
			}
			for (var i = 129; i <= 254; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
			for (var i = 48; i <= 57; i++) fourthByteNode[i] = GB18030_CODE;
		}
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes = [];
		for (; addr > 0; addr >>= 8) bytes.push(addr & 255);
		if (bytes.length == 0) bytes.push(0);
		var node = this.decodeTables[0];
		for (var i = bytes.length - 1; i > 0; i--) {
			var val = node[bytes[i]];
			if (val == UNASSIGNED) {
				node[bytes[i]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (55296 <= code && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (4080 < code && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		for (var i = 0; i < 256; i++) {
			var uCode = node[i];
			var mbCode = prefix + i;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
			else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
			else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
		}
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i == str.length) break;
				var uCode = str.charCodeAt(i++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (55296 <= uCode && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode == "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer.alloc(10), j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBuf = Buffer.alloc(0);
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
		if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
		for (var i = 0, j = 0; i < buf.length; i++) {
			var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				i = seqStart;
				uCode = this.defaultCharUnicode.charCodeAt(0);
			} else if (uCode === GB18030_CODE) {
				var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
				var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode > 65535) {
				uCode -= 65536;
				var uCodeLead = 55296 + Math.floor(uCode / 1024);
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 + uCode % 1024;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBuf.length > 0) {
			ret += this.defaultCharUnicode;
			var buf = this.prevBuf.slice(1);
			this.prevBuf = Buffer.alloc(0);
			this.nodeIdx = 0;
			if (buf.length > 0) ret += this.write(buf);
		}
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0, r = table.length;
		while (l < r - 1) {
			var mid = l + Math.floor((r - l + 1) / 2);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"shiftjis": {
			type: "_dbcs",
			table: function() {
				return require_shiftjis$1();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		"csshiftjis": "shiftjis",
		"mskanji": "shiftjis",
		"sjis": "shiftjis",
		"windows31j": "shiftjis",
		"ms31j": "shiftjis",
		"xsjis": "shiftjis",
		"windows932": "shiftjis",
		"ms932": "shiftjis",
		"932": "shiftjis",
		"cp932": "shiftjis",
		"eucjp": {
			type: "_dbcs",
			table: function() {
				return require_eucjp$1();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		"gb2312": "cp936",
		"gb231280": "cp936",
		"gb23121980": "cp936",
		"csgb2312": "cp936",
		"csiso58gb231280": "cp936",
		"euccn": "cp936",
		"windows936": "cp936",
		"ms936": "cp936",
		"936": "cp936",
		"cp936": {
			type: "_dbcs",
			table: function() {
				return require_cp936$1();
			}
		},
		"gbk": {
			type: "_dbcs",
			table: function() {
				return require_cp936$1().concat(require_gbk_added$1());
			}
		},
		"xgbk": "gbk",
		"isoir58": "gbk",
		"gb18030": {
			type: "_dbcs",
			table: function() {
				return require_cp936$1().concat(require_gbk_added$1());
			},
			gb18030: function() {
				return require_gb18030_ranges$1();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		"chinese": "gb18030",
		"windows949": "cp949",
		"ms949": "cp949",
		"949": "cp949",
		"cp949": {
			type: "_dbcs",
			table: function() {
				return require_cp949$1();
			}
		},
		"cseuckr": "cp949",
		"csksc56011987": "cp949",
		"euckr": "cp949",
		"isoir149": "cp949",
		"korean": "cp949",
		"ksc56011987": "cp949",
		"ksc56011989": "cp949",
		"ksc5601": "cp949",
		"windows950": "cp950",
		"ms950": "cp950",
		"950": "cp950",
		"cp950": {
			type: "_dbcs",
			table: function() {
				return require_cp950$1();
			}
		},
		"big5": "big5hkscs",
		"big5hkscs": {
			type: "_dbcs",
			table: function() {
				return require_cp950$1().concat(require_big5_added$1());
			},
			encodeSkipVals: [41676]
		},
		"cnbig5": "big5hkscs",
		"csbig5": "big5hkscs",
		"xxbig5": "big5hkscs"
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/encodings/index.js
var require_encodings$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var modules = [
		require_internal$1(),
		require_utf16$1(),
		require_utf7$1(),
		require_sbcs_codec$1(),
		require_sbcs_data$1(),
		require_sbcs_data_generated$1(),
		require_dbcs_codec$1(),
		require_dbcs_data$1()
	];
	for (var i = 0; i < modules.length; i++) {
		var module = modules[i];
		for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
	}
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/lib/streams.js
var require_streams$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$5 = require("buffer").Buffer, Transform$1 = require("stream").Transform;
	module.exports = function(iconv) {
		iconv.encodeStream = function encodeStream(encoding, options) {
			return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
		};
		iconv.decodeStream = function decodeStream(encoding, options) {
			return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
		};
		iconv.supportsStreams = true;
		iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
		iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
		iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};
	function IconvLiteEncoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.decodeStrings = false;
		Transform$1.call(this, options);
	}
	IconvLiteEncoderStream.prototype = Object.create(Transform$1.prototype, { constructor: { value: IconvLiteEncoderStream } });
	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
		if (typeof chunk != "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype.collect = function(cb) {
		var chunks = [];
		this.on("error", cb);
		this.on("data", function(chunk) {
			chunks.push(chunk);
		});
		this.on("end", function() {
			cb(null, Buffer$5.concat(chunks));
		});
		return this;
	};
	function IconvLiteDecoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.encoding = this.encoding = "utf8";
		Transform$1.call(this, options);
	}
	IconvLiteDecoderStream.prototype = Object.create(Transform$1.prototype, { constructor: { value: IconvLiteDecoderStream } });
	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
		if (!Buffer$5.isBuffer(chunk)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype.collect = function(cb) {
		var res = "";
		this.on("error", cb);
		this.on("data", function(chunk) {
			res += chunk;
		});
		this.on("end", function() {
			cb(null, res);
		});
		return this;
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$4 = require("buffer").Buffer;
	module.exports = function(iconv) {
		var original = void 0;
		iconv.supportsNodeEncodingsExtension = !(Buffer$4.from || new Buffer$4(0) instanceof Uint8Array);
		iconv.extendNodeEncodings = function extendNodeEncodings() {
			if (original) return;
			original = {};
			if (!iconv.supportsNodeEncodingsExtension) {
				console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
				console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
				return;
			}
			var nodeNativeEncodings = {
				"hex": true,
				"utf8": true,
				"utf-8": true,
				"ascii": true,
				"binary": true,
				"base64": true,
				"ucs2": true,
				"ucs-2": true,
				"utf16le": true,
				"utf-16le": true
			};
			Buffer$4.isNativeEncoding = function(enc) {
				return enc && nodeNativeEncodings[enc.toLowerCase()];
			};
			var SlowBuffer = require("buffer").SlowBuffer;
			original.SlowBufferToString = SlowBuffer.prototype.toString;
			SlowBuffer.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$4.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.SlowBufferWrite = SlowBuffer.prototype.write;
			SlowBuffer.prototype.write = function(string, offset, length, encoding) {
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$4.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			original.BufferIsEncoding = Buffer$4.isEncoding;
			Buffer$4.isEncoding = function(encoding) {
				return Buffer$4.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
			};
			original.BufferByteLength = Buffer$4.byteLength;
			Buffer$4.byteLength = SlowBuffer.byteLength = function(str, encoding) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$4.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
				return iconv.encode(str, encoding).length;
			};
			original.BufferToString = Buffer$4.prototype.toString;
			Buffer$4.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$4.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.BufferWrite = Buffer$4.prototype.write;
			Buffer$4.prototype.write = function(string, offset, length, encoding) {
				var _offset = offset, _length = length, _encoding = encoding;
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$4.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				original.ReadableSetEncoding = Readable.prototype.setEncoding;
				Readable.prototype.setEncoding = function setEncoding(enc, options) {
					this._readableState.decoder = iconv.getDecoder(enc, options);
					this._readableState.encoding = enc;
				};
				Readable.prototype.collect = iconv._collect;
			}
		};
		iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
			if (!iconv.supportsNodeEncodingsExtension) return;
			if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
			delete Buffer$4.isNativeEncoding;
			var SlowBuffer = require("buffer").SlowBuffer;
			SlowBuffer.prototype.toString = original.SlowBufferToString;
			SlowBuffer.prototype.write = original.SlowBufferWrite;
			Buffer$4.isEncoding = original.BufferIsEncoding;
			Buffer$4.byteLength = original.BufferByteLength;
			Buffer$4.prototype.toString = original.BufferToString;
			Buffer$4.prototype.write = original.BufferWrite;
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				Readable.prototype.setEncoding = original.ReadableSetEncoding;
				delete Readable.prototype.collect;
			}
			original = void 0;
		};
	};
}));

//#endregion
//#region ../../node_modules/raw-body/node_modules/iconv-lite/lib/index.js
var require_lib$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	var bomHandling = require_bom_handling$1(), iconv = module.exports;
	iconv.encodings = null;
	iconv.defaultCharUnicode = "";
	iconv.defaultCharSingleByte = "?";
	iconv.encode = function encode(str, encoding, options) {
		str = "" + (str || "");
		var encoder = iconv.getEncoder(encoding, options);
		var res = encoder.write(str);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
	};
	iconv.decode = function decode(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv.skipDecodeWarning = true;
			}
			buf = Buffer.from("" + (buf || ""), "binary");
		}
		var decoder = iconv.getDecoder(encoding, options);
		var res = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res + trail : res;
	};
	iconv.encodingExists = function encodingExists(enc) {
		try {
			iconv.getCodec(enc);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;
	iconv._codecDataCache = {};
	iconv.getCodec = function getCodec(encoding) {
		if (!iconv.encodings) iconv.encodings = require_encodings$1();
		var enc = iconv._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv._codecDataCache[enc];
			if (codec) return codec;
			var codecDef = iconv.encodings[enc];
			switch (typeof codecDef) {
				case "string":
					enc = codecDef;
					break;
				case "object":
					for (var key in codecDef) codecOptions[key] = codecDef[key];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					enc = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					codec = new codecDef(codecOptions, iconv);
					iconv._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
			}
		}
	};
	iconv._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv.getDecoder = function getDecoder(encoding, options) {
		var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
	if (nodeVer) {
		var nodeVerArr = nodeVer.split(".").map(Number);
		if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) require_streams$1()(iconv);
		require_extend_node$1()(iconv);
	}
}));

//#endregion
//#region ../../node_modules/unpipe/index.js
/*!
* unpipe
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_unpipe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream) {
		var listeners = stream.listeners("data");
		for (var i = 0; i < listeners.length; i++) if (listeners[i].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe(stream) {
		if (!stream) throw new TypeError("argument stream is required");
		if (typeof stream.unpipe === "function") {
			stream.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream)) return;
		var listener;
		var listeners = stream.listeners("close");
		for (var i = 0; i < listeners.length; i++) {
			listener = listeners[i];
			if (listener.name !== "cleanup" && listener.name !== "onclose") continue;
			listener.call(stream);
		}
	}
}));

//#endregion
//#region ../../node_modules/raw-body/index.js
/*!
* raw-body
* Copyright(c) 2013-2014 Jonathan Ong
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_raw_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks$1();
	var bytes = require_bytes();
	var createError = require_http_errors();
	var iconv = require_lib$2();
	var unpipe = require_unpipe();
	/**
	* Module exports.
	* @public
	*/
	module.exports = getRawBody;
	/**
	* Module variables.
	* @private
	*/
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	/**
	* Get the decoder for a given encoding.
	*
	* @param {string} encoding
	* @private
	*/
	function getDecoder(encoding) {
		if (!encoding) return null;
		try {
			return iconv.getDecoder(encoding);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError(415, "specified encoding unsupported", {
				encoding,
				type: "encoding.unsupported"
			});
		}
	}
	/**
	* Get the raw body of a stream (typically HTTP).
	*
	* @param {object} stream
	* @param {object|string|function} [options]
	* @param {function} [callback]
	* @public
	*/
	function getRawBody(stream, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !global.Promise) throw new TypeError("argument callback is required");
		var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit = bytes.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream(stream, encoding, length, limit, wrap(done));
		return new Promise(function executor(resolve, reject) {
			readStream(stream, encoding, length, limit, function onRead(err, buf) {
				if (err) return reject(err);
				resolve(buf);
			});
		});
	}
	/**
	* Halt a stream.
	*
	* @param {Object} stream
	* @private
	*/
	function halt(stream) {
		unpipe(stream);
		if (typeof stream.pause === "function") stream.pause();
	}
	/**
	* Read the data from the stream.
	*
	* @param {object} stream
	* @param {string} encoding
	* @param {number} length
	* @param {number} limit
	* @param {function} callback
	* @public
	*/
	function readStream(stream, encoding, length, limit, callback) {
		var complete = false;
		var sync = true;
		if (limit !== null && length !== null && length > limit) return done(createError(413, "request entity too large", {
			expected: length,
			length,
			limit,
			type: "entity.too.large"
		}));
		var state = stream._readableState;
		if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream.readable !== "undefined" && !stream.readable) return done(createError(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding);
		} catch (err) {
			return done(err);
		}
		var buffer = decoder ? "" : [];
		stream.on("aborted", onAborted);
		stream.on("close", cleanup);
		stream.on("data", onData);
		stream.on("end", onEnd);
		stream.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit !== null && received > limit) done(createError(413, "request entity too large", {
				limit,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer += decoder.write(chunk);
			else buffer.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else done(null, decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer));
		}
		function cleanup() {
			buffer = null;
			stream.removeListener("aborted", onAborted);
			stream.removeListener("data", onData);
			stream.removeListener("end", onEnd);
			stream.removeListener("error", onEnd);
			stream.removeListener("close", cleanup);
		}
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks$1() {
		try {
			return require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = /* @__PURE__ */ __commonJSMin(((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/internal.js
var require_internal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = require("string_decoder").StringDecoder;
	if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
	function InternalDecoder(options, codec) {
		StringDecoder.call(this, codec.enc);
	}
	InternalDecoder.prototype = StringDecoder.prototype;
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var charCode = str.charCodeAt(i);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
		for (var i = 0; i < buf.length; i++) {
			var curByte = buf[i];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer.from(str, "ucs2");
		for (var i = 0; i < buf.length; i += 2) {
			var tmp = buf[i];
			buf[i] = buf[i + 1];
			buf[i + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer.alloc(buf.length + 1), i = 0, j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i = 1;
			j = 2;
		}
		for (; i < buf.length - 1; i += 2, j += 2) {
			buf2[j] = buf[i + 1];
			buf2[j + 1] = buf[i];
		}
		this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBytes = [];
		this.initialBytesLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBytes.push(buf);
			this.initialBytesLen += buf.length;
			if (this.initialBytesLen < 16) return "";
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			this.initialBytes.length = this.initialBytesLen = 0;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var buf = Buffer.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var res = this.decoder.write(buf), trail = this.decoder.end();
			return trail ? res + trail : res;
		}
		return this.decoder.end();
	};
	function detectEncoding(buf, defaultEncoding) {
		var enc = defaultEncoding || "utf-16le";
		if (buf.length >= 2) if (buf[0] == 254 && buf[1] == 255) enc = "utf-16be";
		else if (buf[0] == 255 && buf[1] == 254) enc = "utf-16le";
		else {
			var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
			for (var i = 0; i < _len; i += 2) {
				if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
				if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
			}
			if (asciiCharsBE > asciiCharsLE) enc = "utf-16be";
			else if (asciiCharsBE < asciiCharsLE) enc = "utf-16le";
		}
		return enc;
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
	var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "+";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString();
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString();
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
		this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer.alloc(str.length * 5 + 10), bufIdx = 0;
		for (var i = 0; i < str.length; i++) {
			var uChar = str.charCodeAt(i);
			if (32 <= uChar && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer.alloc(10), bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i = 0; i < buf.length; i++) if (!inBase64) {
			if (buf[i] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i), "ascii");
				lastI = i + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i]]) {
			if (i == lastI && buf[i] == minusChar) res += "&";
			else {
				var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, "/");
				res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i] != minusChar) i--;
			lastI = i + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
		for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer.alloc(str.length);
		for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer.alloc(buf.length * 2);
		var idx1 = 0, idx2 = 0;
		for (var i = 0; i < buf.length; i++) {
			idx1 = buf[i] * 2;
			idx2 = i * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"10029": "maccenteuro",
		"maccenteuro": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"808": "cp808",
		"ibm808": "cp808",
		"cp808": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"mik": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii8bit": "ascii",
		"usascii": "ascii",
		"ansix34": "ascii",
		"ansix341968": "ascii",
		"ansix341986": "ascii",
		"csascii": "ascii",
		"cp367": "ascii",
		"ibm367": "ascii",
		"isoir6": "ascii",
		"iso646us": "ascii",
		"iso646irv": "ascii",
		"us": "ascii",
		"latin1": "iso88591",
		"latin2": "iso88592",
		"latin3": "iso88593",
		"latin4": "iso88594",
		"latin5": "iso88599",
		"latin6": "iso885910",
		"latin7": "iso885913",
		"latin8": "iso885914",
		"latin9": "iso885915",
		"latin10": "iso885916",
		"csisolatin1": "iso88591",
		"csisolatin2": "iso88592",
		"csisolatin3": "iso88593",
		"csisolatin4": "iso88594",
		"csisolatincyrillic": "iso88595",
		"csisolatinarabic": "iso88596",
		"csisolatingreek": "iso88597",
		"csisolatinhebrew": "iso88598",
		"csisolatin5": "iso88599",
		"csisolatin6": "iso885910",
		"l1": "iso88591",
		"l2": "iso88592",
		"l3": "iso88593",
		"l4": "iso88594",
		"l5": "iso88599",
		"l6": "iso885910",
		"l7": "iso885913",
		"l8": "iso885914",
		"l9": "iso885915",
		"l10": "iso885916",
		"isoir14": "iso646jp",
		"isoir57": "iso646cn",
		"isoir100": "iso88591",
		"isoir101": "iso88592",
		"isoir109": "iso88593",
		"isoir110": "iso88594",
		"isoir144": "iso88595",
		"isoir127": "iso88596",
		"isoir126": "iso88597",
		"isoir138": "iso88598",
		"isoir148": "iso88599",
		"isoir157": "iso885910",
		"isoir166": "tis620",
		"isoir179": "iso885913",
		"isoir199": "iso885914",
		"isoir203": "iso885915",
		"isoir226": "iso885916",
		"cp819": "iso88591",
		"ibm819": "iso88591",
		"cyrillic": "iso88595",
		"arabic": "iso88596",
		"arabic8": "iso88596",
		"ecma114": "iso88596",
		"asmo708": "iso88596",
		"greek": "iso88597",
		"greek8": "iso88597",
		"ecma118": "iso88597",
		"elot928": "iso88597",
		"hebrew": "iso88598",
		"hebrew8": "iso88598",
		"turkish": "iso88599",
		"turkish8": "iso88599",
		"thai": "iso885911",
		"thai8": "iso885911",
		"celtic": "iso885914",
		"celtic8": "iso885914",
		"isoceltic": "iso885914",
		"tis6200": "tis620",
		"tis62025291": "tis620",
		"tis62025330": "tis620",
		"10000": "macroman",
		"10006": "macgreek",
		"10007": "maccyrillic",
		"10079": "maciceland",
		"10081": "macturkish",
		"cspc8codepage437": "cp437",
		"cspc775baltic": "cp775",
		"cspc850multilingual": "cp850",
		"cspcp852": "cp852",
		"cspc862latinhebrew": "cp862",
		"cpgr": "cp869",
		"msee": "cp1250",
		"mscyrl": "cp1251",
		"msansi": "cp1252",
		"msgreek": "cp1253",
		"msturk": "cp1254",
		"mshebr": "cp1255",
		"msarab": "cp1256",
		"winbaltrim": "cp1257",
		"cp20866": "koi8r",
		"20866": "koi8r",
		"ibm878": "koi8r",
		"cskoi8r": "koi8r",
		"cp21866": "koi8u",
		"21866": "koi8u",
		"ibm1168": "koi8u",
		"strk10482002": "rk1048",
		"tcvn5712": "tcvn",
		"tcvn57121": "tcvn",
		"gb198880": "iso646cn",
		"cn": "iso646cn",
		"csiso14jisc6220ro": "iso646jp",
		"jisc62201969ro": "iso646jp",
		"jp": "iso646jp",
		"cshproman8": "hproman8",
		"r8": "hproman8",
		"roman8": "hproman8",
		"xroman8": "hproman8",
		"ibm1051": "hproman8",
		"mac": "macintosh",
		"csmacintosh": "macintosh"
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
	for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
		this.defaultCharUnicode = iconv.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
			var val = codecOptions.encodeSkipVals[i];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var thirdByteNodeIdx = this.decodeTables.length;
			var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			var fourthByteNodeIdx = this.decodeTables.length;
			var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			for (var i = 129; i <= 254; i++) {
				var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
				var secondByteNode = this.decodeTables[secondByteNodeIdx];
				for (var j = 48; j <= 57; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
			}
			for (var i = 129; i <= 254; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
			for (var i = 48; i <= 57; i++) fourthByteNode[i] = GB18030_CODE;
		}
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes = [];
		for (; addr > 0; addr >>= 8) bytes.push(addr & 255);
		if (bytes.length == 0) bytes.push(0);
		var node = this.decodeTables[0];
		for (var i = bytes.length - 1; i > 0; i--) {
			var val = node[bytes[i]];
			if (val == UNASSIGNED) {
				node[bytes[i]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (55296 <= code && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (4080 < code && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		for (var i = 0; i < 256; i++) {
			var uCode = node[i];
			var mbCode = prefix + i;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
			else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
			else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
		}
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i == str.length) break;
				var uCode = str.charCodeAt(i++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (55296 <= uCode && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode == "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer.alloc(10), j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBuf = Buffer.alloc(0);
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
		if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
		for (var i = 0, j = 0; i < buf.length; i++) {
			var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				i = seqStart;
				uCode = this.defaultCharUnicode.charCodeAt(0);
			} else if (uCode === GB18030_CODE) {
				var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
				var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode > 65535) {
				uCode -= 65536;
				var uCodeLead = 55296 + Math.floor(uCode / 1024);
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 + uCode % 1024;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBuf.length > 0) {
			ret += this.defaultCharUnicode;
			var buf = this.prevBuf.slice(1);
			this.prevBuf = Buffer.alloc(0);
			this.nodeIdx = 0;
			if (buf.length > 0) ret += this.write(buf);
		}
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0, r = table.length;
		while (l < r - 1) {
			var mid = l + Math.floor((r - l + 1) / 2);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"shiftjis": {
			type: "_dbcs",
			table: function() {
				return require_shiftjis();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		"csshiftjis": "shiftjis",
		"mskanji": "shiftjis",
		"sjis": "shiftjis",
		"windows31j": "shiftjis",
		"ms31j": "shiftjis",
		"xsjis": "shiftjis",
		"windows932": "shiftjis",
		"ms932": "shiftjis",
		"932": "shiftjis",
		"cp932": "shiftjis",
		"eucjp": {
			type: "_dbcs",
			table: function() {
				return require_eucjp();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		"gb2312": "cp936",
		"gb231280": "cp936",
		"gb23121980": "cp936",
		"csgb2312": "cp936",
		"csiso58gb231280": "cp936",
		"euccn": "cp936",
		"windows936": "cp936",
		"ms936": "cp936",
		"936": "cp936",
		"cp936": {
			type: "_dbcs",
			table: function() {
				return require_cp936();
			}
		},
		"gbk": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			}
		},
		"xgbk": "gbk",
		"isoir58": "gbk",
		"gb18030": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			},
			gb18030: function() {
				return require_gb18030_ranges();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		"chinese": "gb18030",
		"windows949": "cp949",
		"ms949": "cp949",
		"949": "cp949",
		"cp949": {
			type: "_dbcs",
			table: function() {
				return require_cp949();
			}
		},
		"cseuckr": "cp949",
		"csksc56011987": "cp949",
		"euckr": "cp949",
		"isoir149": "cp949",
		"korean": "cp949",
		"ksc56011987": "cp949",
		"ksc56011989": "cp949",
		"ksc5601": "cp949",
		"windows950": "cp950",
		"ms950": "cp950",
		"950": "cp950",
		"cp950": {
			type: "_dbcs",
			table: function() {
				return require_cp950();
			}
		},
		"big5": "big5hkscs",
		"big5hkscs": {
			type: "_dbcs",
			table: function() {
				return require_cp950().concat(require_big5_added());
			},
			encodeSkipVals: [41676]
		},
		"cnbig5": "big5hkscs",
		"csbig5": "big5hkscs",
		"xxbig5": "big5hkscs"
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/encodings/index.js
var require_encodings = /* @__PURE__ */ __commonJSMin(((exports) => {
	var modules = [
		require_internal(),
		require_utf16(),
		require_utf7(),
		require_sbcs_codec(),
		require_sbcs_data(),
		require_sbcs_data_generated(),
		require_dbcs_codec(),
		require_dbcs_data()
	];
	for (var i = 0; i < modules.length; i++) {
		var module = modules[i];
		for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
	}
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/lib/streams.js
var require_streams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$3 = require("buffer").Buffer, Transform = require("stream").Transform;
	module.exports = function(iconv) {
		iconv.encodeStream = function encodeStream(encoding, options) {
			return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
		};
		iconv.decodeStream = function decodeStream(encoding, options) {
			return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
		};
		iconv.supportsStreams = true;
		iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
		iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
		iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};
	function IconvLiteEncoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.decodeStrings = false;
		Transform.call(this, options);
	}
	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
		if (typeof chunk != "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype.collect = function(cb) {
		var chunks = [];
		this.on("error", cb);
		this.on("data", function(chunk) {
			chunks.push(chunk);
		});
		this.on("end", function() {
			cb(null, Buffer$3.concat(chunks));
		});
		return this;
	};
	function IconvLiteDecoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.encoding = this.encoding = "utf8";
		Transform.call(this, options);
	}
	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
		if (!Buffer$3.isBuffer(chunk)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
		try {
			var res = this.conv.write(chunk);
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype._flush = function(done) {
		try {
			var res = this.conv.end();
			if (res && res.length) this.push(res, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype.collect = function(cb) {
		var res = "";
		this.on("error", cb);
		this.on("data", function(chunk) {
			res += chunk;
		});
		this.on("end", function() {
			cb(null, res);
		});
		return this;
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer$2 = require("buffer").Buffer;
	module.exports = function(iconv) {
		var original = void 0;
		iconv.supportsNodeEncodingsExtension = !(Buffer$2.from || new Buffer$2(0) instanceof Uint8Array);
		iconv.extendNodeEncodings = function extendNodeEncodings() {
			if (original) return;
			original = {};
			if (!iconv.supportsNodeEncodingsExtension) {
				console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
				console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
				return;
			}
			var nodeNativeEncodings = {
				"hex": true,
				"utf8": true,
				"utf-8": true,
				"ascii": true,
				"binary": true,
				"base64": true,
				"ucs2": true,
				"ucs-2": true,
				"utf16le": true,
				"utf-16le": true
			};
			Buffer$2.isNativeEncoding = function(enc) {
				return enc && nodeNativeEncodings[enc.toLowerCase()];
			};
			var SlowBuffer = require("buffer").SlowBuffer;
			original.SlowBufferToString = SlowBuffer.prototype.toString;
			SlowBuffer.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.SlowBufferWrite = SlowBuffer.prototype.write;
			SlowBuffer.prototype.write = function(string, offset, length, encoding) {
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			original.BufferIsEncoding = Buffer$2.isEncoding;
			Buffer$2.isEncoding = function(encoding) {
				return Buffer$2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
			};
			original.BufferByteLength = Buffer$2.byteLength;
			Buffer$2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
				return iconv.encode(str, encoding).length;
			};
			original.BufferToString = Buffer$2.prototype.toString;
			Buffer$2.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv.decode(this.slice(start, end), encoding);
			};
			original.BufferWrite = Buffer$2.prototype.write;
			Buffer$2.prototype.write = function(string, offset, length, encoding) {
				var _offset = offset, _length = length, _encoding = encoding;
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$2.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				original.ReadableSetEncoding = Readable.prototype.setEncoding;
				Readable.prototype.setEncoding = function setEncoding(enc, options) {
					this._readableState.decoder = iconv.getDecoder(enc, options);
					this._readableState.encoding = enc;
				};
				Readable.prototype.collect = iconv._collect;
			}
		};
		iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
			if (!iconv.supportsNodeEncodingsExtension) return;
			if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
			delete Buffer$2.isNativeEncoding;
			var SlowBuffer = require("buffer").SlowBuffer;
			SlowBuffer.prototype.toString = original.SlowBufferToString;
			SlowBuffer.prototype.write = original.SlowBufferWrite;
			Buffer$2.isEncoding = original.BufferIsEncoding;
			Buffer$2.byteLength = original.BufferByteLength;
			Buffer$2.prototype.toString = original.BufferToString;
			Buffer$2.prototype.write = original.BufferWrite;
			if (iconv.supportsStreams) {
				var Readable = require("stream").Readable;
				Readable.prototype.setEncoding = original.ReadableSetEncoding;
				delete Readable.prototype.collect;
			}
			original = void 0;
		};
	};
}));

//#endregion
//#region ../../node_modules/body-parser/node_modules/iconv-lite/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Buffer = require_safer().Buffer;
	var bomHandling = require_bom_handling(), iconv = module.exports;
	iconv.encodings = null;
	iconv.defaultCharUnicode = "";
	iconv.defaultCharSingleByte = "?";
	iconv.encode = function encode(str, encoding, options) {
		str = "" + (str || "");
		var encoder = iconv.getEncoder(encoding, options);
		var res = encoder.write(str);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
	};
	iconv.decode = function decode(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv.skipDecodeWarning = true;
			}
			buf = Buffer.from("" + (buf || ""), "binary");
		}
		var decoder = iconv.getDecoder(encoding, options);
		var res = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res + trail : res;
	};
	iconv.encodingExists = function encodingExists(enc) {
		try {
			iconv.getCodec(enc);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv.toEncoding = iconv.encode;
	iconv.fromEncoding = iconv.decode;
	iconv._codecDataCache = {};
	iconv.getCodec = function getCodec(encoding) {
		if (!iconv.encodings) iconv.encodings = require_encodings();
		var enc = iconv._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv._codecDataCache[enc];
			if (codec) return codec;
			var codecDef = iconv.encodings[enc];
			switch (typeof codecDef) {
				case "string":
					enc = codecDef;
					break;
				case "object":
					for (var key in codecDef) codecOptions[key] = codecDef[key];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					enc = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					codec = new codecDef(codecOptions, iconv);
					iconv._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
			}
		}
	};
	iconv._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv.getDecoder = function getDecoder(encoding, options) {
		var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
	if (nodeVer) {
		var nodeVerArr = nodeVer.split(".").map(Number);
		if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) require_streams()(iconv);
		require_extend_node()(iconv);
	}
}));

//#endregion
//#region ../../node_modules/ee-first/index.js
/*!
* ee-first
* Copyright(c) 2014 Jonathan Ong
* MIT Licensed
*/
var require_ee_first = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = first;
	/**
	* Get the first event in a set of event emitters and event pairs.
	*
	* @param {array} stuff
	* @param {function} done
	* @public
	*/
	function first(stuff, done) {
		if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");
		var cleanups = [];
		for (var i = 0; i < stuff.length; i++) {
			var arr = stuff[i];
			if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");
			var ee = arr[0];
			for (var j = 1; j < arr.length; j++) {
				var event = arr[j];
				var fn = listener(event, callback);
				ee.on(event, fn);
				cleanups.push({
					ee,
					event,
					fn
				});
			}
		}
		function callback() {
			cleanup();
			done.apply(null, arguments);
		}
		function cleanup() {
			var x;
			for (var i = 0; i < cleanups.length; i++) {
				x = cleanups[i];
				x.ee.removeListener(x.event, x.fn);
			}
		}
		function thunk(fn) {
			done = fn;
		}
		thunk.cancel = cleanup;
		return thunk;
	}
	/**
	* Create the event listener.
	* @private
	*/
	function listener(event, done) {
		return function onevent(arg1) {
			var args = new Array(arguments.length);
			var ee = this;
			var err = event === "error" ? arg1 : null;
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			done(err, ee, event, args);
		};
	}
}));

//#endregion
//#region ../../node_modules/on-finished/index.js
/*!
* on-finished
* Copyright(c) 2013 Jonathan Ong
* Copyright(c) 2014 Douglas Christopher Wilson
* MIT Licensed
*/
var require_on_finished = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onFinished;
	module.exports.isFinished = isFinished;
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks();
	var first = require_ee_first();
	/**
	* Variables.
	* @private
	*/
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Invoke callback when the response has finished, useful for
	* cleaning up resources afterwards.
	*
	* @param {object} msg
	* @param {function} listener
	* @return {object}
	* @public
	*/
	function onFinished(msg, listener) {
		if (isFinished(msg) !== false) {
			defer(listener, null, msg);
			return msg;
		}
		attachListener(msg, wrap(listener));
		return msg;
	}
	/**
	* Determine if message is already finished.
	*
	* @param {object} msg
	* @return {boolean}
	* @public
	*/
	function isFinished(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	/**
	* Attach a finished listener to the message.
	*
	* @param {object} msg
	* @param {function} callback
	* @private
	*/
	function attachFinishedListener(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error);
		}
		eeMsg = eeSocket = first([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0)
 // istanbul ignore next: node.js 0.8 patch
		patchAssignSocket(msg, onSocket);
	}
	/**
	* Attach the listener to the message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function attachListener(msg, listener) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener(msg);
			attachFinishedListener(msg, attached);
		}
		attached.queue.push(listener);
	}
	/**
	* Create listener on message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function createListener(msg) {
		function listener(err) {
			if (msg.__onFinished === listener) msg.__onFinished = null;
			if (!listener.queue) return;
			var queue = listener.queue;
			listener.queue = null;
			for (var i = 0; i < queue.length; i++) queue[i](err, msg);
		}
		listener.queue = [];
		return listener;
	}
	/**
	* Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	*
	* @param {ServerResponse} res
	* @param {function} callback
	* @private
	*/
	// istanbul ignore next: node.js 0.8 patch
	function patchAssignSocket(res, callback) {
		var assignSocket = res.assignSocket;
		if (typeof assignSocket !== "function") return;
		res.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks() {
		try {
			return require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}));

//#endregion
//#region ../../node_modules/body-parser/lib/read.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_read = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError = require_http_errors();
	var destroy = require_destroy();
	var getBody = require_raw_body();
	var iconv = require_lib$1();
	var onFinished = require_on_finished();
	var unpipe = require_unpipe();
	var zlib$1 = require("zlib");
	/**
	* Module exports.
	*/
	module.exports = read;
	/**
	* Read a request into a buffer and parse.
	*
	* @param {object} req
	* @param {object} res
	* @param {function} next
	* @param {function} parse
	* @param {function} debug
	* @param {object} options
	* @private
	*/
	function read(req, res, next, parse, debug, options) {
		var length;
		var opts = options;
		var stream;
		req._body = true;
		var encoding = opts.encoding !== null ? opts.encoding : null;
		var verify = opts.verify;
		try {
			stream = contentstream(req, debug, opts.inflate);
			length = stream.length;
			stream.length = void 0;
		} catch (err) {
			return next(err);
		}
		opts.length = length;
		opts.encoding = verify ? null : encoding;
		if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) return next(createError(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
			charset: encoding.toLowerCase(),
			type: "charset.unsupported"
		}));
		debug("read body");
		getBody(stream, opts, function(error, body) {
			if (error) {
				var _error;
				if (error.type === "encoding.unsupported") _error = createError(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
					charset: encoding.toLowerCase(),
					type: "charset.unsupported"
				});
				else _error = createError(400, error);
				if (stream !== req) {
					unpipe(req);
					destroy(stream, true);
				}
				dump(req, function onfinished() {
					next(createError(400, _error));
				});
				return;
			}
			if (verify) try {
				debug("verify body");
				verify(req, res, body, encoding);
			} catch (err) {
				next(createError(403, err, {
					body,
					type: err.type || "entity.verify.failed"
				}));
				return;
			}
			var str = body;
			try {
				debug("parse body");
				str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
				req.body = parse(str);
			} catch (err) {
				next(createError(400, err, {
					body: str,
					type: err.type || "entity.parse.failed"
				}));
				return;
			}
			next();
		});
	}
	/**
	* Get the content stream of the request.
	*
	* @param {object} req
	* @param {function} debug
	* @param {boolean} [inflate=true]
	* @return {object}
	* @api private
	*/
	function contentstream(req, debug, inflate) {
		var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
		var length = req.headers["content-length"];
		var stream;
		debug("content-encoding \"%s\"", encoding);
		if (inflate === false && encoding !== "identity") throw createError(415, "content encoding unsupported", {
			encoding,
			type: "encoding.unsupported"
		});
		switch (encoding) {
			case "deflate":
				stream = zlib$1.createInflate();
				debug("inflate body");
				req.pipe(stream);
				break;
			case "gzip":
				stream = zlib$1.createGunzip();
				debug("gunzip body");
				req.pipe(stream);
				break;
			case "identity":
				stream = req;
				stream.length = length;
				break;
			default: throw createError(415, "unsupported content encoding \"" + encoding + "\"", {
				encoding,
				type: "encoding.unsupported"
			});
		}
		return stream;
	}
	/**
	* Dump the contents of a request.
	*
	* @param {object} req
	* @param {function} callback
	* @api private
	*/
	function dump(req, callback) {
		if (onFinished.isFinished(req)) callback(null);
		else {
			onFinished(req, callback);
			req.resume();
		}
	}
}));

//#endregion
//#region ../../node_modules/media-typer/index.js
var require_media_typer = /* @__PURE__ */ __commonJSMin(((exports) => {
	/*!
	* media-typer
	* Copyright(c) 2014 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* SHT           = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	*/
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	*/
	var qescRegExp = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	*/
	var quoteRegExp = /([\\"])/g;
	/**
	* RegExp to match type in RFC 6838
	*
	* type-name = restricted-name
	* subtype-name = restricted-name
	* restricted-name = restricted-name-first *126restricted-name-chars
	* restricted-name-first  = ALPHA / DIGIT
	* restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	*                          "$" / "&" / "-" / "^" / "_"
	* restricted-name-chars =/ "." ; Characters before first dot always
	*                              ; specify a facet name
	* restricted-name-chars =/ "+" ; Characters after last plus always
	*                              ; specify a structured syntax suffix
	* ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	* DIGIT =  %x30-39             ; 0-9
	*/
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	/**
	* Module exports.
	*/
	exports.format = format;
	exports.parse = parse;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @api public
	*/
	function format(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var subtype = obj.subtype;
		var suffix = obj.suffix;
		var type = obj.type;
		if (!type || !typeNameRegExp.test(type)) throw new TypeError("invalid type");
		if (!subtype || !subtypeNameRegExp.test(subtype)) throw new TypeError("invalid subtype");
		var string = type + "/" + subtype;
		if (suffix) {
			if (!typeNameRegExp.test(suffix)) throw new TypeError("invalid suffix");
			string += "+" + suffix;
		}
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				if (!tokenRegExp.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @api public
	*/
	function parse(string) {
		if (!string) throw new TypeError("argument string is required");
		if (typeof string === "object") string = getcontenttype(string);
		if (typeof string !== "string") throw new TypeError("argument string is required to be a string");
		var index = string.indexOf(";");
		var type = index !== -1 ? string.substr(0, index) : string;
		var key;
		var match;
		var obj = splitType(type);
		var params = {};
		var value;
		paramRegExp.lastIndex = index;
		while (match = paramRegExp.exec(string)) {
			if (match.index !== index) throw new TypeError("invalid parameter format");
			index += match[0].length;
			key = match[1].toLowerCase();
			value = match[2];
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
			params[key] = value;
		}
		if (index !== -1 && index !== string.length) throw new TypeError("invalid parameter format");
		obj.parameters = params;
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @api private
	*/
	function getcontenttype(obj) {
		if (typeof obj.getHeader === "function") return obj.getHeader("content-type");
		if (typeof obj.headers === "object") return obj.headers && obj.headers["content-type"];
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @api private
	*/
	function qstring(val) {
		var str = String(val);
		if (tokenRegExp.test(str)) return str;
		if (str.length > 0 && !textRegExp.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(quoteRegExp, "\\$1") + "\"";
	}
	/**
	* Simply "type/subtype+siffx" into parts.
	*
	* @param {string} string
	* @return {Object}
	* @api private
	*/
	function splitType(string) {
		var match = typeRegExp.exec(string.toLowerCase());
		if (!match) throw new TypeError("invalid media type");
		var type = match[1];
		var subtype = match[2];
		var suffix;
		var index = subtype.lastIndexOf("+");
		if (index !== -1) {
			suffix = subtype.substr(index + 1);
			subtype = subtype.substr(0, index);
		}
		return {
			type,
			subtype,
			suffix
		};
	}
}));

//#endregion
//#region ../../node_modules/mime-db/db.json
var require_db = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"application/1d-interleaved-parityfec": { "source": "iana" },
		"application/3gpdash-qoe-report+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/3gpp-ims+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphalforms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/a2l": { "source": "iana" },
		"application/ace+cbor": { "source": "iana" },
		"application/activemessage": { "source": "iana" },
		"application/activity+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamcontrol+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": { "source": "iana" },
		"application/andrew-inset": {
			"source": "iana",
			"extensions": ["ez"]
		},
		"application/applefile": { "source": "iana" },
		"application/applixware": {
			"source": "apache",
			"extensions": ["aw"]
		},
		"application/at+jwt": { "source": "iana" },
		"application/atf": { "source": "iana" },
		"application/atfx": { "source": "iana" },
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atom"]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomcat"]
		},
		"application/atomdeleted+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomdeleted"]
		},
		"application/atomicmail": { "source": "iana" },
		"application/atomsvc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomsvc"]
		},
		"application/atsc-dwd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dwd"]
		},
		"application/atsc-dynamic-event-message": { "source": "iana" },
		"application/atsc-held+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["held"]
		},
		"application/atsc-rdt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/atsc-rsat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsat"]
		},
		"application/atxml": { "source": "iana" },
		"application/auth-policy+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/bacnet-xdd+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/batch-smtp": { "source": "iana" },
		"application/bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/beep+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xcs"]
		},
		"application/call-completion": { "source": "iana" },
		"application/cals-1840": { "source": "iana" },
		"application/captive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cbor": { "source": "iana" },
		"application/cbor-seq": { "source": "iana" },
		"application/cccex": { "source": "iana" },
		"application/ccmp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ccxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ccxml"]
		},
		"application/cdfx+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdfx"]
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": ["cdmia"]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": ["cdmic"]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": ["cdmid"]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": ["cdmio"]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": ["cdmiq"]
		},
		"application/cdni": { "source": "iana" },
		"application/cea": { "source": "iana" },
		"application/cea-2018+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cellml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cfw": { "source": "iana" },
		"application/city+json": {
			"source": "iana",
			"compressible": true
		},
		"application/clr": { "source": "iana" },
		"application/clue+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/clue_info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cms": { "source": "iana" },
		"application/cnrp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-payload": { "source": "iana" },
		"application/commonground": { "source": "iana" },
		"application/conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cose": { "source": "iana" },
		"application/cose-key": { "source": "iana" },
		"application/cose-key-set": { "source": "iana" },
		"application/cpl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cpl"]
		},
		"application/csrattrs": { "source": "iana" },
		"application/csta+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cstadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": ["cu"]
		},
		"application/cwt": { "source": "iana" },
		"application/cybercash": { "source": "iana" },
		"application/dart": { "compressible": true },
		"application/dash+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpd"]
		},
		"application/dash-patch+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpp"]
		},
		"application/dashdelta": { "source": "iana" },
		"application/davmount+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["davmount"]
		},
		"application/dca-rft": { "source": "iana" },
		"application/dcd": { "source": "iana" },
		"application/dec-dx": { "source": "iana" },
		"application/dialog-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom": { "source": "iana" },
		"application/dicom+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dii": { "source": "iana" },
		"application/dit": { "source": "iana" },
		"application/dns": { "source": "iana" },
		"application/dns+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dns-message": { "source": "iana" },
		"application/docbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dbk"]
		},
		"application/dots+cbor": { "source": "iana" },
		"application/dskpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": ["dssc"]
		},
		"application/dssc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdssc"]
		},
		"application/dvcs": { "source": "iana" },
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es", "ecma"]
		},
		"application/edi-consent": { "source": "iana" },
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": { "source": "iana" },
		"application/elm+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/elm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.cap+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.ecall.msd": { "source": "iana" },
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.veds+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emma+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emma"]
		},
		"application/emotionml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emotionml"]
		},
		"application/encaprtp": { "source": "iana" },
		"application/epp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/epub+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["epub"]
		},
		"application/eshop": { "source": "iana" },
		"application/exi": {
			"source": "iana",
			"extensions": ["exi"]
		},
		"application/expect-ct-report+json": {
			"source": "iana",
			"compressible": true
		},
		"application/express": {
			"source": "iana",
			"extensions": ["exp"]
		},
		"application/fastinfoset": { "source": "iana" },
		"application/fastsoap": { "source": "iana" },
		"application/fdt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fdt"]
		},
		"application/fhir+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fhir+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fido.trusted-apps+json": { "compressible": true },
		"application/fits": { "source": "iana" },
		"application/flexfec": { "source": "iana" },
		"application/font-sfnt": { "source": "iana" },
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": ["pfr"]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false
		},
		"application/framework-attributes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["geojson"]
		},
		"application/geo+json-seq": { "source": "iana" },
		"application/geopackage+sqlite3": { "source": "iana" },
		"application/geoxacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/gltf-buffer": { "source": "iana" },
		"application/gml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gml"]
		},
		"application/gpx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["gpx"]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": ["gxf"]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gz"]
		},
		"application/h224": { "source": "iana" },
		"application/held+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/hjson": { "extensions": ["hjson"] },
		"application/http": { "source": "iana" },
		"application/hyperstudio": {
			"source": "iana",
			"extensions": ["stk"]
		},
		"application/ibe-key-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pp-data": { "source": "iana" },
		"application/iges": { "source": "iana" },
		"application/im-iscomposing+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/index": { "source": "iana" },
		"application/index.cmd": { "source": "iana" },
		"application/index.obj": { "source": "iana" },
		"application/index.response": { "source": "iana" },
		"application/index.vnd": { "source": "iana" },
		"application/inkml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ink", "inkml"]
		},
		"application/iotp": { "source": "iana" },
		"application/ipfix": {
			"source": "iana",
			"extensions": ["ipfix"]
		},
		"application/ipp": { "source": "iana" },
		"application/isup": { "source": "iana" },
		"application/its+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["its"]
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": ["ser"]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["class"]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["js", "mjs"]
		},
		"application/jf2feed+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jose": { "source": "iana" },
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jscalendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["json", "map"]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": { "source": "iana" },
		"application/json5": { "extensions": ["json5"] },
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": ["jsonml"]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": { "source": "iana" },
		"application/kpml-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/kpml-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["jsonld"]
		},
		"application/lgr+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lgr"]
		},
		"application/link-format": { "source": "iana" },
		"application/load-control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lost+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lostxml"]
		},
		"application/lostsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lpf+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/lxf": { "source": "iana" },
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": ["hqx"]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": ["cpt"]
		},
		"application/macwriteii": { "source": "iana" },
		"application/mads+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mads"]
		},
		"application/manifest+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["webmanifest"]
		},
		"application/marc": {
			"source": "iana",
			"extensions": ["mrc"]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mrcx"]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mathml"]
		},
		"application/mathml-content+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mathml-presentation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-deregister+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-envelope+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-protection-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-reception-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-schedule+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbox": {
			"source": "iana",
			"extensions": ["mbox"]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpf"]
		},
		"application/media_control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mscml"]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["metalink"]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["meta4"]
		},
		"application/mets+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mets"]
		},
		"application/mf4": { "source": "iana" },
		"application/mikey": { "source": "iana" },
		"application/mipc": { "source": "iana" },
		"application/missing-blocks+cbor-seq": { "source": "iana" },
		"application/mmt-aei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["maei"]
		},
		"application/mmt-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musd"]
		},
		"application/mods+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mods"]
		},
		"application/moss-keys": { "source": "iana" },
		"application/moss-signature": { "source": "iana" },
		"application/mosskey-data": { "source": "iana" },
		"application/mosskey-request": { "source": "iana" },
		"application/mp21": {
			"source": "iana",
			"extensions": ["m21", "mp21"]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": ["mp4s", "m4p"]
		},
		"application/mpeg4-generic": { "source": "iana" },
		"application/mpeg4-iod": { "source": "iana" },
		"application/mpeg4-iod-xmt": { "source": "iana" },
		"application/mrb-consumer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mrb-publish+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/msc-ivr+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msc-mixer+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": ["doc", "dot"]
		},
		"application/mud+json": {
			"source": "iana",
			"compressible": true
		},
		"application/multipart-core": { "source": "iana" },
		"application/mxf": {
			"source": "iana",
			"extensions": ["mxf"]
		},
		"application/n-quads": {
			"source": "iana",
			"extensions": ["nq"]
		},
		"application/n-triples": {
			"source": "iana",
			"extensions": ["nt"]
		},
		"application/nasdata": { "source": "iana" },
		"application/news-checkgroups": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-groupinfo": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-transmission": { "source": "iana" },
		"application/nlsml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/node": {
			"source": "iana",
			"extensions": ["cjs"]
		},
		"application/nss": { "source": "iana" },
		"application/oauth-authz-req+jwt": { "source": "iana" },
		"application/oblivious-dns-message": { "source": "iana" },
		"application/ocsp-request": { "source": "iana" },
		"application/ocsp-response": { "source": "iana" },
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": ["oda"]
		},
		"application/odm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/odx": { "source": "iana" },
		"application/oebps-package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["opf"]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogx"]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["omdoc"]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/opc-nodeset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/oscore": { "source": "iana" },
		"application/oxps": {
			"source": "iana",
			"extensions": ["oxps"]
		},
		"application/p21": { "source": "iana" },
		"application/p21+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/p2p-overlay+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["relo"]
		},
		"application/parityfec": { "source": "iana" },
		"application/passport": { "source": "iana" },
		"application/patch-ops-error+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xer"]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pdf"]
		},
		"application/pdx": { "source": "iana" },
		"application/pem-certificate-chain": { "source": "iana" },
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pgp"]
		},
		"application/pgp-keys": {
			"source": "iana",
			"extensions": ["asc"]
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": ["asc", "sig"]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": ["prf"]
		},
		"application/pidf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pidf-diff+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": ["p10"]
		},
		"application/pkcs12": { "source": "iana" },
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": ["p7m", "p7c"]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": ["p7s"]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": ["p8"]
		},
		"application/pkcs8-encrypted": { "source": "iana" },
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": ["ac"]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": ["cer"]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": ["crl"]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": ["pkipath"]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": ["pki"]
		},
		"application/pls+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pls"]
		},
		"application/poc-settings+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/provenance+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["provx"]
		},
		"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
		"application/prs.cww": {
			"source": "iana",
			"extensions": ["cww"]
		},
		"application/prs.cyn": {
			"source": "iana",
			"charset": "7-BIT"
		},
		"application/prs.hpub+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/prs.nprend": { "source": "iana" },
		"application/prs.plucker": { "source": "iana" },
		"application/prs.rdf-xml-crypt": { "source": "iana" },
		"application/prs.xsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/pskc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pskcxml"]
		},
		"application/pvd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/qsig": { "source": "iana" },
		"application/raml+yaml": {
			"compressible": true,
			"extensions": ["raml"]
		},
		"application/raptorfec": { "source": "iana" },
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rdf", "owl"]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rif"]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": ["rnc"]
		},
		"application/remote-printing": { "source": "iana" },
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rl"]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rld"]
		},
		"application/rfc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/riscos": { "source": "iana" },
		"application/rlmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/rls-services+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rs"]
		},
		"application/route-apd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rapd"]
		},
		"application/route-s-tsid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sls"]
		},
		"application/route-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rusd"]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": ["gbr"]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": ["mft"]
		},
		"application/rpki-publication": { "source": "iana" },
		"application/rpki-roa": {
			"source": "iana",
			"extensions": ["roa"]
		},
		"application/rpki-updown": { "source": "iana" },
		"application/rsd+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rsd"]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rss"]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"application/rtploopback": { "source": "iana" },
		"application/rtx": { "source": "iana" },
		"application/samlassertion+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/samlmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif-external-properties+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sbe": { "source": "iana" },
		"application/sbml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sbml"]
		},
		"application/scaip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": ["scq"]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": ["scs"]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": ["spq"]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": ["spp"]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": ["sdp"]
		},
		"application/secevent+jwt": { "source": "iana" },
		"application/senml+cbor": { "source": "iana" },
		"application/senml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["senmlx"]
		},
		"application/senml-etch+cbor": { "source": "iana" },
		"application/senml-etch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml-exi": { "source": "iana" },
		"application/sensml+cbor": { "source": "iana" },
		"application/sensml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sensml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sensmlx"]
		},
		"application/sensml-exi": { "source": "iana" },
		"application/sep+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sep-exi": { "source": "iana" },
		"application/session-info": { "source": "iana" },
		"application/set-payment": { "source": "iana" },
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": ["setpay"]
		},
		"application/set-registration": { "source": "iana" },
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": ["setreg"]
		},
		"application/sgml": { "source": "iana" },
		"application/sgml-open-catalog": { "source": "iana" },
		"application/shf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["shf"]
		},
		"application/sieve": {
			"source": "iana",
			"extensions": ["siv", "sieve"]
		},
		"application/simple-filter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/simple-message-summary": { "source": "iana" },
		"application/simplesymbolcontainer": { "source": "iana" },
		"application/sipc": { "source": "iana" },
		"application/slate": { "source": "iana" },
		"application/smil": { "source": "iana" },
		"application/smil+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["smi", "smil"]
		},
		"application/smpte336m": { "source": "iana" },
		"application/soap+fastinfoset": { "source": "iana" },
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": ["rq"]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["srx"]
		},
		"application/spdx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/spirits-event+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sql": { "source": "iana" },
		"application/srgs": {
			"source": "iana",
			"extensions": ["gram"]
		},
		"application/srgs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["grxml"]
		},
		"application/sru+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sru"]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ssdl"]
		},
		"application/ssml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ssml"]
		},
		"application/stix+json": {
			"source": "iana",
			"compressible": true
		},
		"application/swid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["swidtag"]
		},
		"application/tamp-apex-update": { "source": "iana" },
		"application/tamp-apex-update-confirm": { "source": "iana" },
		"application/tamp-community-update": { "source": "iana" },
		"application/tamp-community-update-confirm": { "source": "iana" },
		"application/tamp-error": { "source": "iana" },
		"application/tamp-sequence-adjust": { "source": "iana" },
		"application/tamp-sequence-adjust-confirm": { "source": "iana" },
		"application/tamp-status-query": { "source": "iana" },
		"application/tamp-status-response": { "source": "iana" },
		"application/tamp-update": { "source": "iana" },
		"application/tamp-update-confirm": { "source": "iana" },
		"application/tar": { "compressible": true },
		"application/taxii+json": {
			"source": "iana",
			"compressible": true
		},
		"application/td+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tei", "teicorpus"]
		},
		"application/tetra_isi": { "source": "iana" },
		"application/thraud+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tfi"]
		},
		"application/timestamp-query": { "source": "iana" },
		"application/timestamp-reply": { "source": "iana" },
		"application/timestamped-data": {
			"source": "iana",
			"extensions": ["tsd"]
		},
		"application/tlsrpt+gzip": { "source": "iana" },
		"application/tlsrpt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tnauthlist": { "source": "iana" },
		"application/token-introspection+jwt": { "source": "iana" },
		"application/toml": {
			"compressible": true,
			"extensions": ["toml"]
		},
		"application/trickle-ice-sdpfrag": { "source": "iana" },
		"application/trig": {
			"source": "iana",
			"extensions": ["trig"]
		},
		"application/ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttml"]
		},
		"application/tve-trigger": { "source": "iana" },
		"application/tzif": { "source": "iana" },
		"application/tzif-leap": { "source": "iana" },
		"application/ubjson": {
			"compressible": false,
			"extensions": ["ubj"]
		},
		"application/ulpfec": { "source": "iana" },
		"application/urc-grpsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/urc-ressheet+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsheet"]
		},
		"application/urc-targetdesc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["td"]
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vemmi": { "source": "iana" },
		"application/vividence.scriptfile": { "source": "apache" },
		"application/vnd.1000minds.decision-model+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["1km"]
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
		"application/vnd.3gpp.5gnas": { "source": "iana" },
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gmop+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gtpc": { "source": "iana" },
		"application/vnd.3gpp.interworking-data": { "source": "iana" },
		"application/vnd.3gpp.lpp": { "source": "iana" },
		"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
		"application/vnd.3gpp.mcdata-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ngap": { "source": "iana" },
		"application/vnd.3gpp.pfcp": { "source": "iana" },
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": ["plb"]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": ["psb"]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": ["pvb"]
		},
		"application/vnd.3gpp.s1ap": { "source": "iana" },
		"application/vnd.3gpp.sms": { "source": "iana" },
		"application/vnd.3gpp.sms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.sms": { "source": "iana" },
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": ["tcap"]
		},
		"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": ["pwn"]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": ["aso"]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": ["imp"]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": ["acu"]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": ["atc", "acutc"]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["air"]
		},
		"application/vnd.adobe.flash.movie": { "source": "iana" },
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": ["fcdt"]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": ["fxp", "fxpl"]
		},
		"application/vnd.adobe.partial-upload": { "source": "iana" },
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdp"]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": ["xfdf"]
		},
		"application/vnd.aether.imp": { "source": "iana" },
		"application/vnd.afpc.afplinedata": { "source": "iana" },
		"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
		"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
		"application/vnd.afpc.foca-charset": { "source": "iana" },
		"application/vnd.afpc.foca-codedfont": { "source": "iana" },
		"application/vnd.afpc.foca-codepage": { "source": "iana" },
		"application/vnd.afpc.modca": { "source": "iana" },
		"application/vnd.afpc.modca-cmtable": { "source": "iana" },
		"application/vnd.afpc.modca-formdef": { "source": "iana" },
		"application/vnd.afpc.modca-mediummap": { "source": "iana" },
		"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
		"application/vnd.afpc.modca-overlay": { "source": "iana" },
		"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
		"application/vnd.age": {
			"source": "iana",
			"extensions": ["age"]
		},
		"application/vnd.ah-barcode": { "source": "iana" },
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": ["ahead"]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": ["azf"]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": ["azs"]
		},
		"application/vnd.amadeus+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": ["azw"]
		},
		"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": ["acc"]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": ["ami"]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.android.ota": { "source": "iana" },
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": ["apk"]
		},
		"application/vnd.anki": { "source": "iana" },
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": ["cii"]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": ["fti"]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": ["atx"]
		},
		"application/vnd.apache.arrow.file": { "source": "iana" },
		"application/vnd.apache.arrow.stream": { "source": "iana" },
		"application/vnd.apache.thrift.binary": { "source": "iana" },
		"application/vnd.apache.thrift.compact": { "source": "iana" },
		"application/vnd.apache.thrift.json": { "source": "iana" },
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.aplextor.warrp+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apothekende.reservation+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpkg"]
		},
		"application/vnd.apple.keynote": {
			"source": "iana",
			"extensions": ["key"]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": ["m3u8"]
		},
		"application/vnd.apple.numbers": {
			"source": "iana",
			"extensions": ["numbers"]
		},
		"application/vnd.apple.pages": {
			"source": "iana",
			"extensions": ["pages"]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": ["pkpass"]
		},
		"application/vnd.arastra.swi": { "source": "iana" },
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": ["swi"]
		},
		"application/vnd.artisan+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.artsquare": { "source": "iana" },
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": ["iota"]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": ["aep"]
		},
		"application/vnd.autopackage": { "source": "iana" },
		"application/vnd.avalon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.avistar+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmml"]
		},
		"application/vnd.balsamiq.bmpr": { "source": "iana" },
		"application/vnd.banana-accounting": { "source": "iana" },
		"application/vnd.bbf.usp.error": { "source": "iana" },
		"application/vnd.bbf.usp.msg": { "source": "iana" },
		"application/vnd.bbf.usp.msg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bint.med-content": { "source": "iana" },
		"application/vnd.biopax.rdf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": ["mpm"]
		},
		"application/vnd.bluetooth.ep.oob": { "source": "iana" },
		"application/vnd.bluetooth.le.oob": { "source": "iana" },
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": ["bmi"]
		},
		"application/vnd.bpf": { "source": "iana" },
		"application/vnd.bpf3": { "source": "iana" },
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": ["rep"]
		},
		"application/vnd.byu.uapi+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cab-jscript": { "source": "iana" },
		"application/vnd.canon-cpdl": { "source": "iana" },
		"application/vnd.canon-lips": { "source": "iana" },
		"application/vnd.capasystems-pg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
		"application/vnd.century-systems.tcp_stream": { "source": "iana" },
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdxml"]
		},
		"application/vnd.chess-pgn": { "source": "iana" },
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": ["mmd"]
		},
		"application/vnd.ciedi": { "source": "iana" },
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": ["cdy"]
		},
		"application/vnd.cirpack.isdn-ext": { "source": "iana" },
		"application/vnd.citationstyles.style+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csl"]
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": ["cla"]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": ["rp9"]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": ["c11amc"]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": ["c11amz"]
		},
		"application/vnd.coffeescript": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.comicbook-rar": { "source": "iana" },
		"application/vnd.commerce-battelle": { "source": "iana" },
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": ["csp"]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": ["cdbcmsg"]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": ["cmc"]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": ["clkx"]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": ["clkk"]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": ["clkp"]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": ["clkt"]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": ["clkw"]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wbs"]
		},
		"application/vnd.cryptii.pipe+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.crypto-shade-file": { "source": "iana" },
		"application/vnd.cryptomator.encrypted": { "source": "iana" },
		"application/vnd.cryptomator.vault": { "source": "iana" },
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": ["pml"]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cups-pdf": { "source": "iana" },
		"application/vnd.cups-postscript": { "source": "iana" },
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": ["ppd"]
		},
		"application/vnd.cups-raster": { "source": "iana" },
		"application/vnd.cups-raw": { "source": "iana" },
		"application/vnd.curl": { "source": "iana" },
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": ["car"]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": ["pcurl"]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cybank": { "source": "iana" },
		"application/vnd.cyclonedx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cyclonedx+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.d3m-dataset": { "source": "iana" },
		"application/vnd.d3m-problem": { "source": "iana" },
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dart"]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": ["rdz"]
		},
		"application/vnd.datapackage+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dataresource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dbf": {
			"source": "iana",
			"extensions": ["dbf"]
		},
		"application/vnd.debian.binary-package": { "source": "iana" },
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uvt", "uvvt"]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": ["uvx", "uvvx"]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": ["uvz", "uvvz"]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": ["fe_launch"]
		},
		"application/vnd.desmume.movie": { "source": "iana" },
		"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
		"application/vnd.dm.delegation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": ["dna"]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": ["mlp"]
		},
		"application/vnd.dolby.mobile.1": { "source": "iana" },
		"application/vnd.dolby.mobile.2": { "source": "iana" },
		"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": ["dpg"]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": ["dfac"]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": ["kpxx"]
		},
		"application/vnd.dtg.local": { "source": "iana" },
		"application/vnd.dtg.local.flash": { "source": "iana" },
		"application/vnd.dtg.local.html": { "source": "iana" },
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": ["ait"]
		},
		"application/vnd.dvb.dvbisl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.dvbj": { "source": "iana" },
		"application/vnd.dvb.esgcontainer": { "source": "iana" },
		"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
		"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
		"application/vnd.dvb.ipdcroaming": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.pfr": { "source": "iana" },
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": ["svc"]
		},
		"application/vnd.dxr": { "source": "iana" },
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": ["geo"]
		},
		"application/vnd.dzr": { "source": "iana" },
		"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
		"application/vnd.ecdis-update": { "source": "iana" },
		"application/vnd.ecip.rlp": { "source": "iana" },
		"application/vnd.eclipse.ditto+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": ["mag"]
		},
		"application/vnd.ecowin.filerequest": { "source": "iana" },
		"application/vnd.ecowin.fileupdate": { "source": "iana" },
		"application/vnd.ecowin.series": { "source": "iana" },
		"application/vnd.ecowin.seriesrequest": { "source": "iana" },
		"application/vnd.ecowin.seriesupdate": { "source": "iana" },
		"application/vnd.efi.img": { "source": "iana" },
		"application/vnd.efi.iso": { "source": "iana" },
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": ["nml"]
		},
		"application/vnd.enphase.envoy": { "source": "iana" },
		"application/vnd.eprints.data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": ["esf"]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": ["msf"]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": ["qam"]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": ["slt"]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": ["ssf"]
		},
		"application/vnd.ericsson.quickcall": { "source": "iana" },
		"application/vnd.espass-espass+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es3", "et3"]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mheg5": { "source": "iana" },
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.timestamp-token": { "source": "iana" },
		"application/vnd.etsi.tsl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.tsl.der": { "source": "iana" },
		"application/vnd.eu.kasparian.car+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.eudora.data": { "source": "iana" },
		"application/vnd.evolv.ecig.profile": { "source": "iana" },
		"application/vnd.evolv.ecig.settings": { "source": "iana" },
		"application/vnd.evolv.ecig.theme": { "source": "iana" },
		"application/vnd.exstream-empower+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.exstream-package": { "source": "iana" },
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": ["ez2"]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": ["ez3"]
		},
		"application/vnd.f-secure.mobile": { "source": "iana" },
		"application/vnd.familysearch.gedcom+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.fastcopy-disk-image": { "source": "iana" },
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": ["fdf"]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": ["mseed"]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": ["seed", "dataless"]
		},
		"application/vnd.ffsns": { "source": "iana" },
		"application/vnd.ficlab.flb+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.filmit.zfc": { "source": "iana" },
		"application/vnd.fints": { "source": "iana" },
		"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": ["gph"]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": ["ftc"]
		},
		"application/vnd.font-fontforge-sfd": { "source": "iana" },
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": ["fnc"]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": ["ltf"]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": ["fsc"]
		},
		"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
		"application/vnd.fujifilm.fb.jfi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": ["oas"]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": ["oa2"]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": ["oa3"]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": ["fg5"]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": ["bh2"]
		},
		"application/vnd.fujixerox.art-ex": { "source": "iana" },
		"application/vnd.fujixerox.art4": { "source": "iana" },
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": ["ddd"]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": ["xdw"]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": ["xbd"]
		},
		"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
		"application/vnd.fujixerox.hbpl": { "source": "iana" },
		"application/vnd.fut-misnet": { "source": "iana" },
		"application/vnd.futoin+cbor": { "source": "iana" },
		"application/vnd.futoin+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": ["fzs"]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": ["txd"]
		},
		"application/vnd.gentics.grd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": ["ggb"]
		},
		"application/vnd.geogebra.slides": { "source": "iana" },
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": ["ggt"]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": ["gex", "gre"]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": ["gxt"]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": ["g2w"]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": ["g3w"]
		},
		"application/vnd.gerber": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": ["gmx"]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": ["gdoc"]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": ["gslides"]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": ["gsheet"]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["kml"]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": ["kmz"]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": ["gqf", "gqs"]
		},
		"application/vnd.gridmp": { "source": "iana" },
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": ["gac"]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": ["ghf"]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": ["gim"]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": ["grv"]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": ["gtm"]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": ["tpl"]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": ["vcg"]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["hal"]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zmm"]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": ["hbci"]
		},
		"application/vnd.hc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hcl-bireports": { "source": "iana" },
		"application/vnd.hdt": { "source": "iana" },
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": ["les"]
		},
		"application/vnd.hl7cda+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hl7v2+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": ["hpgl"]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": ["hpid"]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": ["hps"]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": ["jlt"]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": ["pcl"]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": ["pclxl"]
		},
		"application/vnd.httphone": { "source": "iana" },
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": ["sfd-hdstx"]
		},
		"application/vnd.hyper+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyper-item+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": { "source": "iana" },
		"application/vnd.ibm.afplinedata": { "source": "iana" },
		"application/vnd.ibm.electronic-media": { "source": "iana" },
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": ["mpy"]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": ["irm"]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": ["sc"]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": ["icc", "icm"]
		},
		"application/vnd.ieee.1905": { "source": "iana" },
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": ["igl"]
		},
		"application/vnd.imagemeter.folder+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.imagemeter.image+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": ["ivp"]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": ["ivu"]
		},
		"application/vnd.ims.imsccv1p1": { "source": "iana" },
		"application/vnd.ims.imsccv1p2": { "source": "iana" },
		"application/vnd.ims.imsccv1p3": { "source": "iana" },
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informix-visionary": { "source": "iana" },
		"application/vnd.infotech.project": { "source": "iana" },
		"application/vnd.infotech.project+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.innopath.wamp.notification": { "source": "iana" },
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": ["igm"]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": ["xpw", "xpx"]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": ["i2g"]
		},
		"application/vnd.intertrust.digibox": { "source": "iana" },
		"application/vnd.intertrust.nncp": { "source": "iana" },
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": ["qbo"]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": ["qfx"]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": ["rcprofile"]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["irp"]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": ["xpr"]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": ["fcs"]
		},
		"application/vnd.iso11783-10+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": ["jam"]
		},
		"application/vnd.japannet-directory-service": { "source": "iana" },
		"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-payment-wakeup": { "source": "iana" },
		"application/vnd.japannet-registration": { "source": "iana" },
		"application/vnd.japannet-registration-wakeup": { "source": "iana" },
		"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-verification": { "source": "iana" },
		"application/vnd.japannet-verification-wakeup": { "source": "iana" },
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": ["rms"]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": ["jisp"]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": ["joda"]
		},
		"application/vnd.jsk.isdn-ngn": { "source": "iana" },
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": ["ktz", "ktr"]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": ["karbon"]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": ["chrt"]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": ["kfo"]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": ["flw"]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": ["kon"]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": ["kpr", "kpt"]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": ["ksp"]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": ["kwd", "kwt"]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": ["htke"]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": ["kia"]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": ["kne", "knp"]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": ["sse"]
		},
		"application/vnd.las": { "source": "iana" },
		"application/vnd.las.las+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lasxml"]
		},
		"application/vnd.laszip": { "source": "iana" },
		"application/vnd.leap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": ["lbd"]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lbe"]
		},
		"application/vnd.logipipe.circuit+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.loom": { "source": "iana" },
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": ["123"]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": ["apr"]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": ["pre"]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": ["nsf"]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": ["org"]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": ["scm"]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": ["lwp"]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": ["portpkg"]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana",
			"extensions": ["mvt"]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.mdcf": { "source": "iana" },
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxar.archive.3tz+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.maxmind.maxmind-db": { "source": "iana" },
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": ["mcd"]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": ["mc1"]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": ["cdkey"]
		},
		"application/vnd.meridian-slingshot": { "source": "iana" },
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": ["mwf"]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": ["mfm"]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": ["flo"]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": ["igx"]
		},
		"application/vnd.microsoft.portable-executable": { "source": "iana" },
		"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": ["mif"]
		},
		"application/vnd.minisoft-hp3000-save": { "source": "iana" },
		"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": ["daf"]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": ["dis"]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": ["mbk"]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": ["mqy"]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": ["msl"]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": ["plc"]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": ["txf"]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": ["mpn"]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": ["mpc"]
		},
		"application/vnd.motorola.flexsuite": { "source": "iana" },
		"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
		"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
		"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
		"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
		"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
		"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
		"application/vnd.motorola.iprm": { "source": "iana" },
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xul"]
		},
		"application/vnd.ms-3mfdocument": { "source": "iana" },
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": ["cil"]
		},
		"application/vnd.ms-asf": { "source": "iana" },
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": ["cab"]
		},
		"application/vnd.ms-color.iccprofile": { "source": "apache" },
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlam"]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsb"]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsm"]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["xltm"]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eot"]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": ["chm"]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": ["ims"]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": ["lrm"]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": ["thmx"]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-outlook": {
			"compressible": false,
			"extensions": ["msg"]
		},
		"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": ["cat"]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": ["stl"]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppam"]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": ["pptm"]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": ["sldm"]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppsm"]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["potm"]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": ["mpp", "mpt"]
		},
		"application/vnd.ms-tnef": { "source": "iana" },
		"application/vnd.ms-windows.devicepairing": { "source": "iana" },
		"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
		"application/vnd.ms-windows.printerpairing": { "source": "iana" },
		"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": ["docm"]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["dotm"]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": ["wpl"]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xps"]
		},
		"application/vnd.msa-disk-image": { "source": "iana" },
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": ["mseq"]
		},
		"application/vnd.msign": { "source": "iana" },
		"application/vnd.multiad.creator": { "source": "iana" },
		"application/vnd.multiad.creator.cif": { "source": "iana" },
		"application/vnd.music-niff": { "source": "iana" },
		"application/vnd.musician": {
			"source": "iana",
			"extensions": ["mus"]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": ["msty"]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": ["taglet"]
		},
		"application/vnd.nacamar.ybrid+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ncd.control": { "source": "iana" },
		"application/vnd.ncd.reference": { "source": "iana" },
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nebumind.line": { "source": "iana" },
		"application/vnd.nervana": { "source": "iana" },
		"application/vnd.netfpx": { "source": "iana" },
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": ["nlu"]
		},
		"application/vnd.nimn": { "source": "iana" },
		"application/vnd.nintendo.nitro.rom": { "source": "iana" },
		"application/vnd.nintendo.snes.rom": { "source": "iana" },
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": ["ntf", "nitf"]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": ["nnd"]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": ["nns"]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": ["nnw"]
		},
		"application/vnd.nokia.catalogs": { "source": "iana" },
		"application/vnd.nokia.conml+wbxml": { "source": "iana" },
		"application/vnd.nokia.conml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
		"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
		"application/vnd.nokia.landmark+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ac"]
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": ["ngdat"]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": ["n-gage"]
		},
		"application/vnd.nokia.ncd": { "source": "iana" },
		"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
		"application/vnd.nokia.pcd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": ["rpst"]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": ["rpss"]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": ["edm"]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": ["edx"]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": ["ext"]
		},
		"application/vnd.ntt-local.content-share": { "source": "iana" },
		"application/vnd.ntt-local.file-transfer": { "source": "iana" },
		"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": ["odc"]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": ["otc"]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": ["odb"]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": ["odf"]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": ["odft"]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odg"]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": ["otg"]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": ["odi"]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": ["oti"]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odp"]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": ["otp"]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ods"]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": ["ots"]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odt"]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": ["odm"]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": ["ott"]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": ["oth"]
		},
		"application/vnd.obn": { "source": "iana" },
		"application/vnd.ocf+cbor": { "source": "iana" },
		"application/vnd.oci.image.manifest.v1+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.pae.gem": { "source": "iana" },
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": ["xo"]
		},
		"application/vnd.oma-scws-config": { "source": "iana" },
		"application/vnd.oma-scws-http-request": { "source": "iana" },
		"application/vnd.oma-scws-http-response": { "source": "iana" },
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.ltkm": { "source": "iana" },
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
		"application/vnd.oma.bcast.sgboot": { "source": "iana" },
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sgdu": { "source": "iana" },
		"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.stkm": { "source": "iana" },
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.dcd": { "source": "iana" },
		"application/vnd.oma.dcdc": { "source": "iana" },
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dd2"]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
		"application/vnd.oma.pal+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.push": { "source": "iana" },
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.omads-email+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-file+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omaloc-supl-init": { "source": "iana" },
		"application/vnd.onepager": { "source": "iana" },
		"application/vnd.onepagertamp": { "source": "iana" },
		"application/vnd.onepagertamx": { "source": "iana" },
		"application/vnd.onepagertat": { "source": "iana" },
		"application/vnd.onepagertatp": { "source": "iana" },
		"application/vnd.onepagertatx": { "source": "iana" },
		"application/vnd.openblox.game+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["obgx"]
		},
		"application/vnd.openblox.game-binary": { "source": "iana" },
		"application/vnd.openeye.oeb": { "source": "iana" },
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": ["oxt"]
		},
		"application/vnd.openstreetmap.data+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osm"]
		},
		"application/vnd.opentimestamps.ots": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pptx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": ["sldx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": ["ppsx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "iana",
			"extensions": ["potx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xlsx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "iana",
			"extensions": ["xltx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": ["docx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "iana",
			"extensions": ["dotx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": { "source": "iana" },
		"application/vnd.osa.netdeploy": { "source": "iana" },
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": ["mgp"]
		},
		"application/vnd.osgi.bundle": { "source": "iana" },
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": ["dp"]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": ["esa"]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oxli.countgraph": { "source": "iana" },
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": { "source": "iana" },
		"application/vnd.paos.xml": { "source": "iana" },
		"application/vnd.patentdive": { "source": "iana" },
		"application/vnd.patientecommsdoc": { "source": "iana" },
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": ["paw"]
		},
		"application/vnd.pcos": { "source": "iana" },
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": ["str"]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": ["ei6"]
		},
		"application/vnd.piaccess.application-licence": { "source": "iana" },
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": ["efif"]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": ["wg"]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": ["plf"]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": ["pbd"]
		},
		"application/vnd.powerbuilder6-s": { "source": "iana" },
		"application/vnd.powerbuilder7": { "source": "iana" },
		"application/vnd.powerbuilder7-s": { "source": "iana" },
		"application/vnd.powerbuilder75": { "source": "iana" },
		"application/vnd.powerbuilder75-s": { "source": "iana" },
		"application/vnd.preminet": { "source": "iana" },
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": ["box"]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": ["mgz"]
		},
		"application/vnd.psfs": { "source": "iana" },
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": ["qps"]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": ["ptid"]
		},
		"application/vnd.pwg-multiplexed": { "source": "iana" },
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
		"application/vnd.quarantainenet": { "source": "iana" },
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": { "source": "iana" },
		"application/vnd.radisys.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rainstor.data": { "source": "iana" },
		"application/vnd.rapid": { "source": "iana" },
		"application/vnd.rar": {
			"source": "iana",
			"extensions": ["rar"]
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": ["bed"]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": ["mxl"]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musicxml"]
		},
		"application/vnd.renlearn.rlprint": { "source": "iana" },
		"application/vnd.resilient.logic": { "source": "iana" },
		"application/vnd.restful+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": ["cryptonote"]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": ["cod"]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": ["rm"]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": ["rmvb"]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["link66"]
		},
		"application/vnd.rs-274x": { "source": "iana" },
		"application/vnd.ruckus.download": { "source": "iana" },
		"application/vnd.s3sms": { "source": "iana" },
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": ["st"]
		},
		"application/vnd.sar": { "source": "iana" },
		"application/vnd.sbm.cid": { "source": "iana" },
		"application/vnd.sbm.mid2": { "source": "iana" },
		"application/vnd.scribus": { "source": "iana" },
		"application/vnd.sealed.3df": { "source": "iana" },
		"application/vnd.sealed.csf": { "source": "iana" },
		"application/vnd.sealed.doc": { "source": "iana" },
		"application/vnd.sealed.eml": { "source": "iana" },
		"application/vnd.sealed.mht": { "source": "iana" },
		"application/vnd.sealed.net": { "source": "iana" },
		"application/vnd.sealed.ppt": { "source": "iana" },
		"application/vnd.sealed.tiff": { "source": "iana" },
		"application/vnd.sealed.xls": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": ["see"]
		},
		"application/vnd.seis+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": ["sema"]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": ["semd"]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": ["semf"]
		},
		"application/vnd.shade-save-file": { "source": "iana" },
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": ["ifm"]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": ["itp"]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": ["iif"]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": ["ipk"]
		},
		"application/vnd.shootproof+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shopkick+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shp": { "source": "iana" },
		"application/vnd.shx": { "source": "iana" },
		"application/vnd.sigrok.session": { "source": "iana" },
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": ["twd", "twds"]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": ["mmf"]
		},
		"application/vnd.smart.notebook": { "source": "iana" },
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": ["teacher"]
		},
		"application/vnd.snesdev-page-table": { "source": "iana" },
		"application/vnd.software602.filler.form+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fo"]
		},
		"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sdkm", "sdkd"]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": ["dxp"]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": ["sfs"]
		},
		"application/vnd.sqlite3": { "source": "iana" },
		"application/vnd.sss-cod": { "source": "iana" },
		"application/vnd.sss-dtf": { "source": "iana" },
		"application/vnd.sss-ntf": { "source": "iana" },
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": ["sdc"]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": ["sda"]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": ["sdd"]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": ["smf"]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": ["sdw", "vor"]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": ["sgl"]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": ["smzip"]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": ["sm"]
		},
		"application/vnd.street-stream": { "source": "iana" },
		"application/vnd.sun.wadl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wadl"]
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": ["sxc"]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": ["stc"]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": ["sxd"]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": ["std"]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": ["sxi"]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": ["sti"]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": ["sxm"]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": ["sxw"]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": ["sxg"]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": ["stw"]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": ["sus", "susp"]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": ["svd"]
		},
		"application/vnd.swiftview-ics": { "source": "iana" },
		"application/vnd.sycle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.syft+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": ["sis", "sisx"]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xsm"]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["bdm"]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xdm"]
		},
		"application/vnd.syncml.dm.notification": { "source": "iana" },
		"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["ddf"]
		},
		"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.syncml.ds.notification": { "source": "iana" },
		"application/vnd.tableschema+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": ["tao"]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.think-cell.ppttc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tml": { "source": "iana" },
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": ["tmo"]
		},
		"application/vnd.tri.onesource": { "source": "iana" },
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": ["tpt"]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": ["mxs"]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": ["tra"]
		},
		"application/vnd.truedoc": { "source": "iana" },
		"application/vnd.ubisoft.webplayer": { "source": "iana" },
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": ["ufd", "ufdl"]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": ["utz"]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": ["umj"]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": ["unityweb"]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uoml"]
		},
		"application/vnd.uplanet.alert": { "source": "iana" },
		"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
		"application/vnd.uplanet.cacheop": { "source": "iana" },
		"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
		"application/vnd.uplanet.channel": { "source": "iana" },
		"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
		"application/vnd.uplanet.list": { "source": "iana" },
		"application/vnd.uplanet.list-wbxml": { "source": "iana" },
		"application/vnd.uplanet.listcmd": { "source": "iana" },
		"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
		"application/vnd.uplanet.signal": { "source": "iana" },
		"application/vnd.uri-map": { "source": "iana" },
		"application/vnd.valve.source.material": { "source": "iana" },
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": ["vcx"]
		},
		"application/vnd.vd-study": { "source": "iana" },
		"application/vnd.vectorworks": { "source": "iana" },
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": { "source": "iana" },
		"application/vnd.veritone.aion+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.veryant.thin": { "source": "iana" },
		"application/vnd.ves.encrypted": { "source": "iana" },
		"application/vnd.vidsoft.vidconference": { "source": "iana" },
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": ["vis"]
		},
		"application/vnd.vividence.scriptfile": { "source": "iana" },
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": ["vsf"]
		},
		"application/vnd.wap.sic": { "source": "iana" },
		"application/vnd.wap.slc": { "source": "iana" },
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["wbxml"]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": ["wmlc"]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": ["wmlsc"]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": ["wtb"]
		},
		"application/vnd.wfa.dpp": { "source": "iana" },
		"application/vnd.wfa.p2p": { "source": "iana" },
		"application/vnd.wfa.wsc": { "source": "iana" },
		"application/vnd.windows.devicepairing": { "source": "iana" },
		"application/vnd.wmc": { "source": "iana" },
		"application/vnd.wmf.bootstrap": { "source": "iana" },
		"application/vnd.wolfram.mathematica": { "source": "iana" },
		"application/vnd.wolfram.mathematica.package": { "source": "iana" },
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": ["nbp"]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": ["wpd"]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": ["wqd"]
		},
		"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": ["stf"]
		},
		"application/vnd.wv.csp+wbxml": { "source": "iana" },
		"application/vnd.wv.csp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": ["xar"]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": ["xfdl"]
		},
		"application/vnd.xfdl.webform": { "source": "iana" },
		"application/vnd.xmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xmpie.cpkg": { "source": "iana" },
		"application/vnd.xmpie.dpkg": { "source": "iana" },
		"application/vnd.xmpie.plan": { "source": "iana" },
		"application/vnd.xmpie.ppkg": { "source": "iana" },
		"application/vnd.xmpie.xlim": { "source": "iana" },
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": ["hvd"]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": ["hvs"]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": ["hvp"]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": ["osf"]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osfpvg"]
		},
		"application/vnd.yamaha.remote-setup": { "source": "iana" },
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": ["saf"]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": ["spf"]
		},
		"application/vnd.yamaha.through-ngn": { "source": "iana" },
		"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
		"application/vnd.yaoweme": { "source": "iana" },
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": ["cmp"]
		},
		"application/vnd.youtube.yt": { "source": "iana" },
		"application/vnd.zul": {
			"source": "iana",
			"extensions": ["zir", "zirz"]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zaz"]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vxml"]
		},
		"application/voucher-cms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vq-rtcpxr": { "source": "iana" },
		"application/wasm": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wasm"]
		},
		"application/watcherinfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wif"]
		},
		"application/webpush-options+json": {
			"source": "iana",
			"compressible": true
		},
		"application/whoispp-query": { "source": "iana" },
		"application/whoispp-response": { "source": "iana" },
		"application/widget": {
			"source": "iana",
			"extensions": ["wgt"]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": ["hlp"]
		},
		"application/wita": { "source": "iana" },
		"application/wordperfect5.1": { "source": "iana" },
		"application/wsdl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wsdl"]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wspolicy"]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["7z"]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": ["abw"]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": ["ace"]
		},
		"application/x-amf": { "source": "apache" },
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": ["dmg"]
		},
		"application/x-arj": {
			"compressible": false,
			"extensions": ["arj"]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": ["aam"]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": ["aas"]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": ["bcpio"]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": ["torrent"]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": ["blb", "blorb"]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz"]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz2", "boz"]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": ["vcd"]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": ["cfs"]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": ["chat"]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": ["pgn"]
		},
		"application/x-chrome-extension": { "extensions": ["crx"] },
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": ["cco"]
		},
		"application/x-compress": { "source": "apache" },
		"application/x-conference": {
			"source": "apache",
			"extensions": ["nsc"]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": ["cpio"]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": ["csh"]
		},
		"application/x-deb": { "compressible": false },
		"application/x-debian-package": {
			"source": "apache",
			"extensions": ["deb", "udeb"]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": ["dgc"]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": ["wad"]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ncx"]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dtb"]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["res"]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": ["dvi"]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": ["evy"]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": ["eva"]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": ["bdf"]
		},
		"application/x-font-dos": { "source": "apache" },
		"application/x-font-framemaker": { "source": "apache" },
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": ["gsf"]
		},
		"application/x-font-libgrx": { "source": "apache" },
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": ["psf"]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": ["pcf"]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": ["snf"]
		},
		"application/x-font-speedo": { "source": "apache" },
		"application/x-font-sunos-news": { "source": "apache" },
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": { "source": "apache" },
		"application/x-freearc": {
			"source": "apache",
			"extensions": ["arc"]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": ["spl"]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": ["gca"]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": ["ulx"]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": ["gnumeric"]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": ["gramps"]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": ["gtar"]
		},
		"application/x-gzip": { "source": "apache" },
		"application/x-hdf": {
			"source": "apache",
			"extensions": ["hdf"]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": ["php"]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": ["install"]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": ["iso"]
		},
		"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
		"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
		"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": ["jardiff"]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": ["jnlp"]
		},
		"application/x-javascript": { "compressible": true },
		"application/x-keepass2": { "extensions": ["kdbx"] },
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": ["latex"]
		},
		"application/x-lua-bytecode": { "extensions": ["luac"] },
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": ["lzh", "lha"]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": ["run"]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": ["mie"]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": ["prc", "mobi"]
		},
		"application/x-mpegurl": { "compressible": false },
		"application/x-ms-application": {
			"source": "apache",
			"extensions": ["application"]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": ["lnk"]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": ["wmd"]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": ["wmz"]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": ["xbap"]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": ["mdb"]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": ["obd"]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": ["crd"]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": ["clp"]
		},
		"application/x-msdos-program": { "extensions": ["exe"] },
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": ["mny"]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": ["pub"]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": ["scd"]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": ["trm"]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": ["wri"]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": ["nc", "cdf"]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": ["pac"]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": ["nzb"]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": ["pl", "pm"]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": ["prc", "pdb"]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": ["p12", "pfx"]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": ["p7b", "spc"]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": ["p7r"]
		},
		"application/x-pki-message": { "source": "iana" },
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["rar"]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": ["rpm"]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": ["ris"]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": ["sea"]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": ["sh"]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": ["shar"]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": ["swf"]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": ["xap"]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": ["sql"]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": ["sit"]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": ["sitx"]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": ["srt"]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": ["sv4cpio"]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": ["sv4crc"]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": ["t3"]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": ["gam"]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": ["tar"]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": ["tcl", "tk"]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": ["tex"]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": ["tfm"]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": ["texinfo", "texi"]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": ["obj"]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": ["ustar"]
		},
		"application/x-virtualbox-hdd": {
			"compressible": true,
			"extensions": ["hdd"]
		},
		"application/x-virtualbox-ova": {
			"compressible": true,
			"extensions": ["ova"]
		},
		"application/x-virtualbox-ovf": {
			"compressible": true,
			"extensions": ["ovf"]
		},
		"application/x-virtualbox-vbox": {
			"compressible": true,
			"extensions": ["vbox"]
		},
		"application/x-virtualbox-vbox-extpack": {
			"compressible": false,
			"extensions": ["vbox-extpack"]
		},
		"application/x-virtualbox-vdi": {
			"compressible": true,
			"extensions": ["vdi"]
		},
		"application/x-virtualbox-vhd": {
			"compressible": true,
			"extensions": ["vhd"]
		},
		"application/x-virtualbox-vmdk": {
			"compressible": true,
			"extensions": ["vmdk"]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": ["src"]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": ["webapp"]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "iana",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-x509-ca-ra-cert": { "source": "iana" },
		"application/x-x509-next-ca-cert": { "source": "iana" },
		"application/x-xfig": {
			"source": "apache",
			"extensions": ["fig"]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": ["xpi"]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": ["xz"]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": { "source": "iana" },
		"application/xacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xaml+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xaml"]
		},
		"application/xcap-att+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xav"]
		},
		"application/xcap-caps+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xca"]
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdf"]
		},
		"application/xcap-el+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xel"]
		},
		"application/xcap-error+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcap-ns+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xns"]
		},
		"application/xcon-conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xenc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xenc"]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xhtml", "xht"]
		},
		"application/xhtml-voice+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/xliff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dtd"]
		},
		"application/xml-external-parsed-entity": { "source": "iana" },
		"application/xml-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xmpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xop"]
		},
		"application/xproc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xpl"]
		},
		"application/xslt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xsl", "xslt"]
		},
		"application/xspf+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xspf"]
		},
		"application/xv+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": ["yang"]
		},
		"application/yang-data+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yin+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["yin"]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["zip"]
		},
		"application/zlib": { "source": "iana" },
		"application/zstd": { "source": "iana" },
		"audio/1d-interleaved-parityfec": { "source": "iana" },
		"audio/32kadpcm": { "source": "iana" },
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": ["3gpp"]
		},
		"audio/3gpp2": { "source": "iana" },
		"audio/aac": { "source": "iana" },
		"audio/ac3": { "source": "iana" },
		"audio/adpcm": {
			"source": "apache",
			"extensions": ["adp"]
		},
		"audio/amr": {
			"source": "iana",
			"extensions": ["amr"]
		},
		"audio/amr-wb": { "source": "iana" },
		"audio/amr-wb+": { "source": "iana" },
		"audio/aptx": { "source": "iana" },
		"audio/asc": { "source": "iana" },
		"audio/atrac-advanced-lossless": { "source": "iana" },
		"audio/atrac-x": { "source": "iana" },
		"audio/atrac3": { "source": "iana" },
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": ["au", "snd"]
		},
		"audio/bv16": { "source": "iana" },
		"audio/bv32": { "source": "iana" },
		"audio/clearmode": { "source": "iana" },
		"audio/cn": { "source": "iana" },
		"audio/dat12": { "source": "iana" },
		"audio/dls": { "source": "iana" },
		"audio/dsr-es201108": { "source": "iana" },
		"audio/dsr-es202050": { "source": "iana" },
		"audio/dsr-es202211": { "source": "iana" },
		"audio/dsr-es202212": { "source": "iana" },
		"audio/dv": { "source": "iana" },
		"audio/dvi4": { "source": "iana" },
		"audio/eac3": { "source": "iana" },
		"audio/encaprtp": { "source": "iana" },
		"audio/evrc": { "source": "iana" },
		"audio/evrc-qcp": { "source": "iana" },
		"audio/evrc0": { "source": "iana" },
		"audio/evrc1": { "source": "iana" },
		"audio/evrcb": { "source": "iana" },
		"audio/evrcb0": { "source": "iana" },
		"audio/evrcb1": { "source": "iana" },
		"audio/evrcnw": { "source": "iana" },
		"audio/evrcnw0": { "source": "iana" },
		"audio/evrcnw1": { "source": "iana" },
		"audio/evrcwb": { "source": "iana" },
		"audio/evrcwb0": { "source": "iana" },
		"audio/evrcwb1": { "source": "iana" },
		"audio/evs": { "source": "iana" },
		"audio/flexfec": { "source": "iana" },
		"audio/fwdred": { "source": "iana" },
		"audio/g711-0": { "source": "iana" },
		"audio/g719": { "source": "iana" },
		"audio/g722": { "source": "iana" },
		"audio/g7221": { "source": "iana" },
		"audio/g723": { "source": "iana" },
		"audio/g726-16": { "source": "iana" },
		"audio/g726-24": { "source": "iana" },
		"audio/g726-32": { "source": "iana" },
		"audio/g726-40": { "source": "iana" },
		"audio/g728": { "source": "iana" },
		"audio/g729": { "source": "iana" },
		"audio/g7291": { "source": "iana" },
		"audio/g729d": { "source": "iana" },
		"audio/g729e": { "source": "iana" },
		"audio/gsm": { "source": "iana" },
		"audio/gsm-efr": { "source": "iana" },
		"audio/gsm-hr-08": { "source": "iana" },
		"audio/ilbc": { "source": "iana" },
		"audio/ip-mr_v2.5": { "source": "iana" },
		"audio/isac": { "source": "apache" },
		"audio/l16": { "source": "iana" },
		"audio/l20": { "source": "iana" },
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": { "source": "iana" },
		"audio/lpc": { "source": "iana" },
		"audio/melp": { "source": "iana" },
		"audio/melp1200": { "source": "iana" },
		"audio/melp2400": { "source": "iana" },
		"audio/melp600": { "source": "iana" },
		"audio/mhas": { "source": "iana" },
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana",
			"extensions": ["mxmf"]
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": ["mp3"]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": ["m4a", "mp4a"]
		},
		"audio/mp4a-latm": { "source": "iana" },
		"audio/mpa": { "source": "iana" },
		"audio/mpa-robust": { "source": "iana" },
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": { "source": "iana" },
		"audio/musepack": { "source": "apache" },
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx",
				"opus"
			]
		},
		"audio/opus": { "source": "iana" },
		"audio/parityfec": { "source": "iana" },
		"audio/pcma": { "source": "iana" },
		"audio/pcma-wb": { "source": "iana" },
		"audio/pcmu": { "source": "iana" },
		"audio/pcmu-wb": { "source": "iana" },
		"audio/prs.sid": { "source": "iana" },
		"audio/qcelp": { "source": "iana" },
		"audio/raptorfec": { "source": "iana" },
		"audio/red": { "source": "iana" },
		"audio/rtp-enc-aescm128": { "source": "iana" },
		"audio/rtp-midi": { "source": "iana" },
		"audio/rtploopback": { "source": "iana" },
		"audio/rtx": { "source": "iana" },
		"audio/s3m": {
			"source": "apache",
			"extensions": ["s3m"]
		},
		"audio/scip": { "source": "iana" },
		"audio/silk": {
			"source": "apache",
			"extensions": ["sil"]
		},
		"audio/smv": { "source": "iana" },
		"audio/smv-qcp": { "source": "iana" },
		"audio/smv0": { "source": "iana" },
		"audio/sofa": { "source": "iana" },
		"audio/sp-midi": { "source": "iana" },
		"audio/speex": { "source": "iana" },
		"audio/t140c": { "source": "iana" },
		"audio/t38": { "source": "iana" },
		"audio/telephone-event": { "source": "iana" },
		"audio/tetra_acelp": { "source": "iana" },
		"audio/tetra_acelp_bb": { "source": "iana" },
		"audio/tone": { "source": "iana" },
		"audio/tsvcis": { "source": "iana" },
		"audio/uemclip": { "source": "iana" },
		"audio/ulpfec": { "source": "iana" },
		"audio/usac": { "source": "iana" },
		"audio/vdvi": { "source": "iana" },
		"audio/vmr-wb": { "source": "iana" },
		"audio/vnd.3gpp.iufp": { "source": "iana" },
		"audio/vnd.4sb": { "source": "iana" },
		"audio/vnd.audiokoz": { "source": "iana" },
		"audio/vnd.celp": { "source": "iana" },
		"audio/vnd.cisco.nse": { "source": "iana" },
		"audio/vnd.cmles.radio-events": { "source": "iana" },
		"audio/vnd.cns.anp1": { "source": "iana" },
		"audio/vnd.cns.inf1": { "source": "iana" },
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": ["uva", "uvva"]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": ["eol"]
		},
		"audio/vnd.dlna.adts": { "source": "iana" },
		"audio/vnd.dolby.heaac.1": { "source": "iana" },
		"audio/vnd.dolby.heaac.2": { "source": "iana" },
		"audio/vnd.dolby.mlp": { "source": "iana" },
		"audio/vnd.dolby.mps": { "source": "iana" },
		"audio/vnd.dolby.pl2": { "source": "iana" },
		"audio/vnd.dolby.pl2x": { "source": "iana" },
		"audio/vnd.dolby.pl2z": { "source": "iana" },
		"audio/vnd.dolby.pulse.1": { "source": "iana" },
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": ["dra"]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": ["dts"]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": ["dtshd"]
		},
		"audio/vnd.dts.uhd": { "source": "iana" },
		"audio/vnd.dvb.file": { "source": "iana" },
		"audio/vnd.everad.plj": { "source": "iana" },
		"audio/vnd.hns.audio": { "source": "iana" },
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": ["lvp"]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": ["pya"]
		},
		"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
		"audio/vnd.nortel.vbk": { "source": "iana" },
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": ["ecelp4800"]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": ["ecelp7470"]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": ["ecelp9600"]
		},
		"audio/vnd.octel.sbc": { "source": "iana" },
		"audio/vnd.presonus.multitrack": { "source": "iana" },
		"audio/vnd.qcelp": { "source": "iana" },
		"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": ["rip"]
		},
		"audio/vnd.rn-realaudio": { "compressible": false },
		"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
		"audio/vnd.vmx.cvsd": { "source": "iana" },
		"audio/vnd.wave": { "compressible": false },
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": { "source": "iana" },
		"audio/wav": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["weba"]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": ["aac"]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": ["caf"]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": ["flac"]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": ["m4a"]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": ["mka"]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": ["m3u"]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": ["wax"]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": ["wma"]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": ["ram", "ra"]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": ["rmp"]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": ["ra"]
		},
		"audio/x-tta": { "source": "apache" },
		"audio/x-wav": {
			"source": "apache",
			"extensions": ["wav"]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": ["xm"]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": ["cdx"]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": ["cif"]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": ["cmdf"]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": ["cml"]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": ["csml"]
		},
		"chemical/x-pdb": { "source": "apache" },
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": ["xyz"]
		},
		"font/collection": {
			"source": "iana",
			"extensions": ["ttc"]
		},
		"font/otf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["otf"]
		},
		"font/sfnt": { "source": "iana" },
		"font/ttf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttf"]
		},
		"font/woff": {
			"source": "iana",
			"extensions": ["woff"]
		},
		"font/woff2": {
			"source": "iana",
			"extensions": ["woff2"]
		},
		"image/aces": {
			"source": "iana",
			"extensions": ["exr"]
		},
		"image/apng": {
			"compressible": false,
			"extensions": ["apng"]
		},
		"image/avci": {
			"source": "iana",
			"extensions": ["avci"]
		},
		"image/avcs": {
			"source": "iana",
			"extensions": ["avcs"]
		},
		"image/avif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["avif"]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": ["cgm"]
		},
		"image/dicom-rle": {
			"source": "iana",
			"extensions": ["drle"]
		},
		"image/emf": {
			"source": "iana",
			"extensions": ["emf"]
		},
		"image/fits": {
			"source": "iana",
			"extensions": ["fits"]
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": ["g3"]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gif"]
		},
		"image/heic": {
			"source": "iana",
			"extensions": ["heic"]
		},
		"image/heic-sequence": {
			"source": "iana",
			"extensions": ["heics"]
		},
		"image/heif": {
			"source": "iana",
			"extensions": ["heif"]
		},
		"image/heif-sequence": {
			"source": "iana",
			"extensions": ["heifs"]
		},
		"image/hej2k": {
			"source": "iana",
			"extensions": ["hej2"]
		},
		"image/hsj2": {
			"source": "iana",
			"extensions": ["hsj2"]
		},
		"image/ief": {
			"source": "iana",
			"extensions": ["ief"]
		},
		"image/jls": {
			"source": "iana",
			"extensions": ["jls"]
		},
		"image/jp2": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jp2", "jpg2"]
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jph": {
			"source": "iana",
			"extensions": ["jph"]
		},
		"image/jphc": {
			"source": "iana",
			"extensions": ["jhc"]
		},
		"image/jpm": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpm"]
		},
		"image/jpx": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpx", "jpf"]
		},
		"image/jxr": {
			"source": "iana",
			"extensions": ["jxr"]
		},
		"image/jxra": {
			"source": "iana",
			"extensions": ["jxra"]
		},
		"image/jxrs": {
			"source": "iana",
			"extensions": ["jxrs"]
		},
		"image/jxs": {
			"source": "iana",
			"extensions": ["jxs"]
		},
		"image/jxsc": {
			"source": "iana",
			"extensions": ["jxsc"]
		},
		"image/jxsi": {
			"source": "iana",
			"extensions": ["jxsi"]
		},
		"image/jxss": {
			"source": "iana",
			"extensions": ["jxss"]
		},
		"image/ktx": {
			"source": "iana",
			"extensions": ["ktx"]
		},
		"image/ktx2": {
			"source": "iana",
			"extensions": ["ktx2"]
		},
		"image/naplps": { "source": "iana" },
		"image/pjpeg": { "compressible": false },
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": ["png"]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": ["btif"]
		},
		"image/prs.pti": {
			"source": "iana",
			"extensions": ["pti"]
		},
		"image/pwg-raster": { "source": "iana" },
		"image/sgi": {
			"source": "apache",
			"extensions": ["sgi"]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["svg", "svgz"]
		},
		"image/t38": {
			"source": "iana",
			"extensions": ["t38"]
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": ["tif", "tiff"]
		},
		"image/tiff-fx": {
			"source": "iana",
			"extensions": ["tfx"]
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": ["psd"]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana",
			"extensions": ["azv"]
		},
		"image/vnd.cns.inf2": { "source": "iana" },
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": ["djvu", "djv"]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": ["dwg"]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": ["dxf"]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": ["fbs"]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": ["fpx"]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": ["fst"]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": ["mmr"]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": ["rlc"]
		},
		"image/vnd.globalgraphics.pgb": { "source": "iana" },
		"image/vnd.microsoft.icon": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/vnd.mix": { "source": "iana" },
		"image/vnd.mozilla.apng": { "source": "iana" },
		"image/vnd.ms-dds": {
			"compressible": true,
			"extensions": ["dds"]
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": ["mdi"]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": ["wdp"]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": ["npx"]
		},
		"image/vnd.pco.b16": {
			"source": "iana",
			"extensions": ["b16"]
		},
		"image/vnd.radiance": { "source": "iana" },
		"image/vnd.sealed.png": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
		"image/vnd.svf": { "source": "iana" },
		"image/vnd.tencent.tap": {
			"source": "iana",
			"extensions": ["tap"]
		},
		"image/vnd.valve.source.texture": {
			"source": "iana",
			"extensions": ["vtf"]
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": ["wbmp"]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": ["xif"]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana",
			"extensions": ["pcx"]
		},
		"image/webp": {
			"source": "apache",
			"extensions": ["webp"]
		},
		"image/wmf": {
			"source": "iana",
			"extensions": ["wmf"]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": ["3ds"]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": ["ras"]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": ["cmx"]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": ["jng"]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": ["sid"]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": ["pcx"]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": ["pic", "pct"]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": ["pnm"]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": ["pbm"]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": ["pgm"]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": ["ppm"]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": ["rgb"]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": ["tga"]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": ["xbm"]
		},
		"image/x-xcf": { "compressible": false },
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": ["xpm"]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": ["xwd"]
		},
		"message/cpim": { "source": "iana" },
		"message/delivery-status": { "source": "iana" },
		"message/disposition-notification": {
			"source": "iana",
			"extensions": ["disposition-notification"]
		},
		"message/external-body": { "source": "iana" },
		"message/feedback-report": { "source": "iana" },
		"message/global": {
			"source": "iana",
			"extensions": ["u8msg"]
		},
		"message/global-delivery-status": {
			"source": "iana",
			"extensions": ["u8dsn"]
		},
		"message/global-disposition-notification": {
			"source": "iana",
			"extensions": ["u8mdn"]
		},
		"message/global-headers": {
			"source": "iana",
			"extensions": ["u8hdr"]
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": { "source": "iana" },
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eml", "mime"]
		},
		"message/s-http": { "source": "iana" },
		"message/sip": { "source": "iana" },
		"message/sipfrag": { "source": "iana" },
		"message/tracking-status": { "source": "iana" },
		"message/vnd.si.simp": { "source": "iana" },
		"message/vnd.wfa.wsc": {
			"source": "iana",
			"extensions": ["wsc"]
		},
		"model/3mf": {
			"source": "iana",
			"extensions": ["3mf"]
		},
		"model/e57": { "source": "iana" },
		"model/gltf+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gltf"]
		},
		"model/gltf-binary": {
			"source": "iana",
			"compressible": true,
			"extensions": ["glb"]
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": ["igs", "iges"]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/mtl": {
			"source": "iana",
			"extensions": ["mtl"]
		},
		"model/obj": {
			"source": "iana",
			"extensions": ["obj"]
		},
		"model/step": { "source": "iana" },
		"model/step+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["stpx"]
		},
		"model/step+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpz"]
		},
		"model/step-xml+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpxz"]
		},
		"model/stl": {
			"source": "iana",
			"extensions": ["stl"]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dae"]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": ["dwf"]
		},
		"model/vnd.flatland.3dml": { "source": "iana" },
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": ["gdl"]
		},
		"model/vnd.gs-gdl": { "source": "apache" },
		"model/vnd.gs.gdl": { "source": "iana" },
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": ["gtw"]
		},
		"model/vnd.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": ["mts"]
		},
		"model/vnd.opengex": {
			"source": "iana",
			"extensions": ["ogex"]
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana",
			"extensions": ["x_b"]
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana",
			"extensions": ["x_t"]
		},
		"model/vnd.pytha.pyox": { "source": "iana" },
		"model/vnd.rosette.annotated-data-model": { "source": "iana" },
		"model/vnd.sap.vds": {
			"source": "iana",
			"extensions": ["vds"]
		},
		"model/vnd.usdz+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["usdz"]
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana",
			"extensions": ["bsp"]
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": ["vtu"]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": ["wrl", "vrml"]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3db", "x3dbz"]
		},
		"model/x3d+fastinfoset": {
			"source": "iana",
			"extensions": ["x3db"]
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3dv", "x3dvz"]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["x3d", "x3dz"]
		},
		"model/x3d-vrml": {
			"source": "iana",
			"extensions": ["x3dv"]
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": { "source": "iana" },
		"multipart/byteranges": { "source": "iana" },
		"multipart/digest": { "source": "iana" },
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": { "source": "iana" },
		"multipart/mixed": { "source": "iana" },
		"multipart/multilingual": { "source": "iana" },
		"multipart/parallel": { "source": "iana" },
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": { "source": "iana" },
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/vnd.bint.med-plus": { "source": "iana" },
		"multipart/voice-message": { "source": "iana" },
		"multipart/x-mixed-replace": { "source": "iana" },
		"text/1d-interleaved-parityfec": { "source": "iana" },
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": ["appcache", "manifest"]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": ["ics", "ifb"]
		},
		"text/calender": { "compressible": true },
		"text/cmd": { "compressible": true },
		"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
		"text/cql": { "source": "iana" },
		"text/cql-expression": { "source": "iana" },
		"text/cql-identifier": { "source": "iana" },
		"text/css": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["css"]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csv"]
		},
		"text/csv-schema": { "source": "iana" },
		"text/directory": { "source": "iana" },
		"text/dns": { "source": "iana" },
		"text/ecmascript": { "source": "iana" },
		"text/encaprtp": { "source": "iana" },
		"text/enriched": { "source": "iana" },
		"text/fhirpath": { "source": "iana" },
		"text/flexfec": { "source": "iana" },
		"text/fwdred": { "source": "iana" },
		"text/gff3": { "source": "iana" },
		"text/grammar-ref-list": { "source": "iana" },
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": { "extensions": ["jade"] },
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": { "source": "iana" },
		"text/jsx": {
			"compressible": true,
			"extensions": ["jsx"]
		},
		"text/less": {
			"compressible": true,
			"extensions": ["less"]
		},
		"text/markdown": {
			"source": "iana",
			"compressible": true,
			"extensions": ["markdown", "md"]
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": ["mml"]
		},
		"text/mdx": {
			"compressible": true,
			"extensions": ["mdx"]
		},
		"text/mizar": { "source": "iana" },
		"text/n3": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["n3"]
		},
		"text/parameters": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/parityfec": { "source": "iana" },
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/prs.fallenstein.rst": { "source": "iana" },
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": ["dsc"]
		},
		"text/prs.prop.logic": { "source": "iana" },
		"text/raptorfec": { "source": "iana" },
		"text/red": { "source": "iana" },
		"text/rfc822-headers": { "source": "iana" },
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtx"]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"text/rtp-enc-aescm128": { "source": "iana" },
		"text/rtploopback": { "source": "iana" },
		"text/rtx": { "source": "iana" },
		"text/sgml": {
			"source": "iana",
			"extensions": ["sgml", "sgm"]
		},
		"text/shaclc": { "source": "iana" },
		"text/shex": {
			"source": "iana",
			"extensions": ["shex"]
		},
		"text/slim": { "extensions": ["slim", "slm"] },
		"text/spdx": {
			"source": "iana",
			"extensions": ["spdx"]
		},
		"text/strings": { "source": "iana" },
		"text/stylus": { "extensions": ["stylus", "styl"] },
		"text/t140": { "source": "iana" },
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tsv"]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["ttl"]
		},
		"text/ulpfec": { "source": "iana" },
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vcard"]
		},
		"text/vnd.a": { "source": "iana" },
		"text/vnd.abc": { "source": "iana" },
		"text/vnd.ascii-art": { "source": "iana" },
		"text/vnd.curl": {
			"source": "iana",
			"extensions": ["curl"]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": ["dcurl"]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": ["mcurl"]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": ["scurl"]
		},
		"text/vnd.debian.copyright": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.dmclientscript": { "source": "iana" },
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.familysearch.gedcom": {
			"source": "iana",
			"extensions": ["ged"]
		},
		"text/vnd.ficlab.flt": { "source": "iana" },
		"text/vnd.fly": {
			"source": "iana",
			"extensions": ["fly"]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": ["flx"]
		},
		"text/vnd.gml": { "source": "iana" },
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": ["gv"]
		},
		"text/vnd.hans": { "source": "iana" },
		"text/vnd.hgl": { "source": "iana" },
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": ["3dml"]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": ["spot"]
		},
		"text/vnd.iptc.newsml": { "source": "iana" },
		"text/vnd.iptc.nitf": { "source": "iana" },
		"text/vnd.latex-z": { "source": "iana" },
		"text/vnd.motorola.reflex": { "source": "iana" },
		"text/vnd.ms-mediapackage": { "source": "iana" },
		"text/vnd.net2phone.commcenter.command": { "source": "iana" },
		"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
		"text/vnd.senx.warpscript": { "source": "iana" },
		"text/vnd.si.uricatalogue": { "source": "iana" },
		"text/vnd.sosi": { "source": "iana" },
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["jad"]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.wap.si": { "source": "iana" },
		"text/vnd.wap.sl": { "source": "iana" },
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": ["wml"]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": ["wmls"]
		},
		"text/vtt": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["vtt"]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": ["s", "asm"]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": ["htc"]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": { "compressible": true },
		"text/x-handlebars-template": { "extensions": ["hbs"] },
		"text/x-java-source": {
			"source": "apache",
			"extensions": ["java"]
		},
		"text/x-jquery-tmpl": { "compressible": true },
		"text/x-lua": { "extensions": ["lua"] },
		"text/x-markdown": {
			"compressible": true,
			"extensions": ["mkd"]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": ["nfo"]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": ["opml"]
		},
		"text/x-org": {
			"compressible": true,
			"extensions": ["org"]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": ["p", "pas"]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": ["pde"]
		},
		"text/x-sass": { "extensions": ["sass"] },
		"text/x-scss": { "extensions": ["scss"] },
		"text/x-setext": {
			"source": "apache",
			"extensions": ["etx"]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": ["sfv"]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": ["ymp"]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": ["uu"]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": ["vcs"]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": ["vcf"]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xml"]
		},
		"text/xml-external-parsed-entity": { "source": "iana" },
		"text/yaml": {
			"compressible": true,
			"extensions": ["yaml", "yml"]
		},
		"video/1d-interleaved-parityfec": { "source": "iana" },
		"video/3gpp": {
			"source": "iana",
			"extensions": ["3gp", "3gpp"]
		},
		"video/3gpp-tt": { "source": "iana" },
		"video/3gpp2": {
			"source": "iana",
			"extensions": ["3g2"]
		},
		"video/av1": { "source": "iana" },
		"video/bmpeg": { "source": "iana" },
		"video/bt656": { "source": "iana" },
		"video/celb": { "source": "iana" },
		"video/dv": { "source": "iana" },
		"video/encaprtp": { "source": "iana" },
		"video/ffv1": { "source": "iana" },
		"video/flexfec": { "source": "iana" },
		"video/h261": {
			"source": "iana",
			"extensions": ["h261"]
		},
		"video/h263": {
			"source": "iana",
			"extensions": ["h263"]
		},
		"video/h263-1998": { "source": "iana" },
		"video/h263-2000": { "source": "iana" },
		"video/h264": {
			"source": "iana",
			"extensions": ["h264"]
		},
		"video/h264-rcdo": { "source": "iana" },
		"video/h264-svc": { "source": "iana" },
		"video/h265": { "source": "iana" },
		"video/iso.segment": {
			"source": "iana",
			"extensions": ["m4s"]
		},
		"video/jpeg": {
			"source": "iana",
			"extensions": ["jpgv"]
		},
		"video/jpeg2000": { "source": "iana" },
		"video/jpm": {
			"source": "apache",
			"extensions": ["jpm", "jpgm"]
		},
		"video/jxsv": { "source": "iana" },
		"video/mj2": {
			"source": "iana",
			"extensions": ["mj2", "mjp2"]
		},
		"video/mp1s": { "source": "iana" },
		"video/mp2p": { "source": "iana" },
		"video/mp2t": {
			"source": "iana",
			"extensions": ["ts"]
		},
		"video/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": { "source": "iana" },
		"video/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": { "source": "iana" },
		"video/mpv": { "source": "iana" },
		"video/nv": { "source": "iana" },
		"video/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogv"]
		},
		"video/parityfec": { "source": "iana" },
		"video/pointer": { "source": "iana" },
		"video/quicktime": {
			"source": "iana",
			"compressible": false,
			"extensions": ["qt", "mov"]
		},
		"video/raptorfec": { "source": "iana" },
		"video/raw": { "source": "iana" },
		"video/rtp-enc-aescm128": { "source": "iana" },
		"video/rtploopback": { "source": "iana" },
		"video/rtx": { "source": "iana" },
		"video/scip": { "source": "iana" },
		"video/smpte291": { "source": "iana" },
		"video/smpte292m": { "source": "iana" },
		"video/ulpfec": { "source": "iana" },
		"video/vc1": { "source": "iana" },
		"video/vc2": { "source": "iana" },
		"video/vnd.cctv": { "source": "iana" },
		"video/vnd.dece.hd": {
			"source": "iana",
			"extensions": ["uvh", "uvvh"]
		},
		"video/vnd.dece.mobile": {
			"source": "iana",
			"extensions": ["uvm", "uvvm"]
		},
		"video/vnd.dece.mp4": { "source": "iana" },
		"video/vnd.dece.pd": {
			"source": "iana",
			"extensions": ["uvp", "uvvp"]
		},
		"video/vnd.dece.sd": {
			"source": "iana",
			"extensions": ["uvs", "uvvs"]
		},
		"video/vnd.dece.video": {
			"source": "iana",
			"extensions": ["uvv", "uvvv"]
		},
		"video/vnd.directv.mpeg": { "source": "iana" },
		"video/vnd.directv.mpeg-tts": { "source": "iana" },
		"video/vnd.dlna.mpeg-tts": { "source": "iana" },
		"video/vnd.dvb.file": {
			"source": "iana",
			"extensions": ["dvb"]
		},
		"video/vnd.fvt": {
			"source": "iana",
			"extensions": ["fvt"]
		},
		"video/vnd.hns.video": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.ttsavc": { "source": "iana" },
		"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
		"video/vnd.motorola.video": { "source": "iana" },
		"video/vnd.motorola.videop": { "source": "iana" },
		"video/vnd.mpegurl": {
			"source": "iana",
			"extensions": ["mxu", "m4u"]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "iana",
			"extensions": ["pyv"]
		},
		"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
		"video/vnd.nokia.mp4vr": { "source": "iana" },
		"video/vnd.nokia.videovoip": { "source": "iana" },
		"video/vnd.objectvideo": { "source": "iana" },
		"video/vnd.radgamettools.bink": { "source": "iana" },
		"video/vnd.radgamettools.smacker": { "source": "iana" },
		"video/vnd.sealed.mpeg1": { "source": "iana" },
		"video/vnd.sealed.mpeg4": { "source": "iana" },
		"video/vnd.sealed.swf": { "source": "iana" },
		"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
		"video/vnd.uvvu.mp4": {
			"source": "iana",
			"extensions": ["uvu", "uvvu"]
		},
		"video/vnd.vivo": {
			"source": "iana",
			"extensions": ["viv"]
		},
		"video/vnd.youtube.yt": { "source": "iana" },
		"video/vp8": { "source": "iana" },
		"video/vp9": { "source": "iana" },
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["webm"]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": ["f4v"]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": ["fli"]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["flv"]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": ["m4v"]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": ["mng"]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": ["asf", "asx"]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": ["vob"]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": ["wm"]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["wmv"]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": ["wmx"]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": ["wvx"]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": ["avi"]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": ["movie"]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": ["smv"]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": ["ice"]
		},
		"x-shader/x-fragment": { "compressible": true },
		"x-shader/x-vertex": { "compressible": true }
	};
}));

//#endregion
//#region ../../node_modules/mime-db/index.js
var require_mime_db = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*!
	* mime-db
	* Copyright(c) 2014 Jonathan Ong
	* Copyright(c) 2015-2022 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module exports.
	*/
	module.exports = require_db();
}));

//#endregion
//#region ../../node_modules/mime-types/index.js
/*!
* mime-types
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_mime_types = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var db = require_mime_db();
	var extname = require("path").extname;
	/**
	* Module variables.
	* @private
	*/
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	/**
	* Module exports.
	* @public
	*/
	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	/**
	* Get the default charset for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function charset(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var mime = match && db[match[1].toLowerCase()];
		if (mime && mime.charset) return mime.charset;
		if (match && TEXT_TYPE_REGEXP.test(match[1])) return "UTF-8";
		return false;
	}
	/**
	* Create a full Content-Type header given a MIME type or extension.
	*
	* @param {string} str
	* @return {boolean|string}
	*/
	function contentType(str) {
		if (!str || typeof str !== "string") return false;
		var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime) return false;
		if (mime.indexOf("charset") === -1) {
			var charset = exports.charset(mime);
			if (charset) mime += "; charset=" + charset.toLowerCase();
		}
		return mime;
	}
	/**
	* Get the default extension for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function extension(type) {
		if (!type || typeof type !== "string") return false;
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var exts = match && exports.extensions[match[1].toLowerCase()];
		if (!exts || !exts.length) return false;
		return exts[0];
	}
	/**
	* Lookup the MIME type for a file path/extension.
	*
	* @param {string} path
	* @return {boolean|string}
	*/
	function lookup(path$70) {
		if (!path$70 || typeof path$70 !== "string") return false;
		var extension = extname("x." + path$70).toLowerCase().substr(1);
		if (!extension) return false;
		return exports.types[extension] || false;
	}
	/**
	* Populate the extensions and types maps.
	* @private
	*/
	function populateMaps(extensions, types) {
		var preference = [
			"nginx",
			"apache",
			void 0,
			"iana"
		];
		Object.keys(db).forEach(function forEachMimeType(type) {
			var mime = db[type];
			var exts = mime.extensions;
			if (!exts || !exts.length) return;
			extensions[type] = exts;
			for (var i = 0; i < exts.length; i++) {
				var extension = exts[i];
				if (types[extension]) {
					var from = preference.indexOf(db[types[extension]].source);
					var to = preference.indexOf(mime.source);
					if (types[extension] !== "application/octet-stream" && (from > to || from === to && types[extension].substr(0, 12) === "application/")) continue;
				}
				types[extension] = type;
			}
		});
	}
}));

//#endregion
//#region ../../node_modules/type-is/index.js
/*!
* type-is
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_type_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var typer = require_media_typer();
	var mime = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = typeofrequest;
	module.exports.is = typeis;
	module.exports.hasBody = hasbody;
	module.exports.normalize = normalize;
	module.exports.match = mimeMatch;
	/**
	* Compare a `value` content-type with `types`.
	* Each `type` can be an extension like `html`,
	* a special shortcut like `multipart` or `urlencoded`,
	* or a mime type.
	*
	* If no types match, `false` is returned.
	* Otherwise, the first `type` that matches is returned.
	*
	* @param {String} value
	* @param {Array} types
	* @public
	*/
	function typeis(value, types_) {
		var i;
		var types = types_;
		var val = tryNormalizeType(value);
		if (!val) return false;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length - 1);
			for (i = 0; i < types.length; i++) types[i] = arguments[i + 1];
		}
		if (!types || !types.length) return val;
		var type;
		for (i = 0; i < types.length; i++) if (mimeMatch(normalize(type = types[i]), val)) return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
		return false;
	}
	/**
	* Check if a request has a request body.
	* A request with a body __must__ either have `transfer-encoding`
	* or `content-length` headers set.
	* http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	*
	* @param {Object} request
	* @return {Boolean}
	* @public
	*/
	function hasbody(req) {
		return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
	}
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains any of the give mime `type`s.
	* If there is no request body, `null` is returned.
	* If there is no content type, `false` is returned.
	* Otherwise, it returns the first `type` that matches.
	*
	* Examples:
	*
	*     // With Content-Type: text/html; charset=utf-8
	*     this.is('html'); // => 'html'
	*     this.is('text/html'); // => 'text/html'
	*     this.is('text/*', 'application/json'); // => 'text/html'
	*
	*     // When Content-Type is application/json
	*     this.is('json', 'urlencoded'); // => 'json'
	*     this.is('application/json'); // => 'application/json'
	*     this.is('html', 'application/*'); // => 'application/json'
	*
	*     this.is('html'); // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	function typeofrequest(req, types_) {
		var types = types_;
		if (!hasbody(req)) return null;
		if (arguments.length > 2) {
			types = new Array(arguments.length - 1);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i + 1];
		}
		var value = req.headers["content-type"];
		return typeis(value, types);
	}
	/**
	* Normalize a mime type.
	* If it's a shorthand, expand it to a valid mime type.
	*
	* In general, you probably want:
	*
	*   var type = is(req, ['urlencoded', 'json', 'multipart']);
	*
	* Then use the appropriate body parsers.
	* These three are the most common request body types
	* and are thus ensured to work.
	*
	* @param {String} type
	* @private
	*/
	function normalize(type) {
		if (typeof type !== "string") return false;
		switch (type) {
			case "urlencoded": return "application/x-www-form-urlencoded";
			case "multipart": return "multipart/*";
		}
		if (type[0] === "+") return "*/*" + type;
		return type.indexOf("/") === -1 ? mime.lookup(type) : type;
	}
	/**
	* Check if `expected` mime type
	* matches `actual` mime type with
	* wildcard and +suffix support.
	*
	* @param {String} expected
	* @param {String} actual
	* @return {Boolean}
	* @private
	*/
	function mimeMatch(expected, actual) {
		if (expected === false) return false;
		var actualParts = actual.split("/");
		var expectedParts = expected.split("/");
		if (actualParts.length !== 2 || expectedParts.length !== 2) return false;
		if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) return false;
		if (expectedParts[1].substr(0, 2) === "*+") return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
		if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) return false;
		return true;
	}
	/**
	* Normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function normalizeType(value) {
		var type = typer.parse(value);
		type.parameters = void 0;
		return typer.format(type);
	}
	/**
	* Try to normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function tryNormalizeType(value) {
		if (!value) return null;
		try {
			return normalizeType(value);
		} catch (err) {
			return null;
		}
	}
}));

//#endregion
//#region ../../node_modules/body-parser/lib/types/json.js
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_json = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var createError = require_http_errors();
	var debug = require_src$5()("body-parser:json");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = json;
	/**
	* RegExp to match the first non-space in a string.
	*
	* Allowed whitespace is defined in RFC 7159:
	*
	*    ws = *(
	*            %x20 /              ; Space
	*            %x09 /              ; Horizontal tab
	*            %x0A /              ; Line feed or New line
	*            %x0D )              ; Carriage return
	*/
	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
	var JSON_SYNTAX_CHAR = "#";
	var JSON_SYNTAX_REGEXP = /#+/g;
	/**
	* Create a middleware to parse JSON bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function json(options) {
		var opts = options || {};
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var inflate = opts.inflate !== false;
		var reviver = opts.reviver;
		var strict = opts.strict !== false;
		var type = opts.type || "application/json";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(body) {
			if (body.length === 0) return {};
			if (strict) {
				var first = firstchar(body);
				if (first !== "{" && first !== "[") {
					debug("strict violation");
					throw createStrictSyntaxError(body, first);
				}
			}
			try {
				debug("parse json");
				return JSON.parse(body, reviver);
			} catch (e) {
				throw normalizeJsonSyntaxError(e, {
					message: e.message,
					stack: e.stack
				});
			}
		}
		return function jsonParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			var charset = getCharset(req) || "utf-8";
			if (charset.slice(0, 4) !== "utf-") {
				debug("invalid charset");
				next(createError(415, "unsupported charset \"" + charset.toUpperCase() + "\"", {
					charset,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: charset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Create strict violation syntax error matching native error.
	*
	* @param {string} str
	* @param {string} char
	* @return {Error}
	* @private
	*/
	function createStrictSyntaxError(str, char) {
		var index = str.indexOf(char);
		var partial = "";
		if (index !== -1) {
			partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
			for (var i = index + 1; i < str.length; i++) partial += JSON_SYNTAX_CHAR;
		}
		try {
			JSON.parse(partial);
			/* istanbul ignore next */ throw new SyntaxError("strict violation");
		} catch (e) {
			return normalizeJsonSyntaxError(e, {
				message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
					return str.substring(index, index + placeholder.length);
				}),
				stack: e.stack
			});
		}
	}
	/**
	* Get the first non-whitespace character in a string.
	*
	* @param {string} str
	* @return {function}
	* @private
	*/
	function firstchar(str) {
		var match = FIRST_CHAR_REGEXP.exec(str);
		return match ? match[1] : void 0;
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Normalize a SyntaxError for JSON.parse.
	*
	* @param {SyntaxError} error
	* @param {object} obj
	* @return {SyntaxError}
	*/
	function normalizeJsonSyntaxError(error, obj) {
		var keys = Object.getOwnPropertyNames(error);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (key !== "stack" && key !== "message") delete error[key];
		}
		error.stack = obj.stack.replace(error.message, obj.message);
		error.message = obj.message;
		return error;
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/body-parser/lib/types/raw.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_raw = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes = require_bytes();
	var debug = require_src$5()("body-parser:raw");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = raw;
	/**
	* Create a middleware to parse raw bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function raw(options) {
		var opts = options || {};
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/octet-stream";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(buf) {
			return buf;
		}
		return function rawParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: null,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/body-parser/lib/types/text.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_text = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var debug = require_src$5()("body-parser:text");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = text;
	/**
	* Create a middleware to parse text bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function text(options) {
		var opts = options || {};
		var defaultCharset = opts.defaultCharset || "utf-8";
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "text/plain";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(buf) {
			return buf;
		}
		return function textParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			read(req, res, next, parse, debug, {
				encoding: getCharset(req) || defaultCharset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/es-errors/type.js
var require_type = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./type')} */
	module.exports = TypeError;
}));

//#endregion
//#region ../../node_modules/object-inspect/util.inspect.js
var require_util_inspect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require("util").inspect;
}));

//#endregion
//#region ../../node_modules/object-inspect/index.js
var require_object_inspect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hasMap = typeof Map === "function" && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === "function" && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var weakMapHas = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap.prototype.has : null;
	var weakSetHas = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet.prototype.has : null;
	var weakRefDeref = typeof WeakRef === "function" && WeakRef.prototype ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
	var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
		return O.__proto__;
	} : null);
	function addNumericSeparator(num, str) {
		if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) return str;
		var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		if (typeof num === "number") {
			var int = num < 0 ? -$floor(-num) : $floor(num);
			if (int !== num) {
				var intStr = String(int);
				var dec = $slice.call(str, intStr.length + 1);
				return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
			}
		}
		return $replace.call(str, sepRegex, "$&_");
	}
	var utilInspect = require_util_inspect();
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
	var quotes = {
		__proto__: null,
		"double": "\"",
		single: "'"
	};
	var quoteREs = {
		__proto__: null,
		"double": /(["\\])/g,
		single: /(['\\])/g
	};
	module.exports = function inspect_(obj, options, depth, seen) {
		var opts = options || {};
		if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) throw new TypeError("option \"quoteStyle\" must be \"single\" or \"double\"");
		if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError("option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`");
		var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
		if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
		if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError("option \"indent\" must be \"\\t\", an integer > 0, or `null`");
		if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError("option \"numericSeparator\", if provided, must be `true` or `false`");
		var numericSeparator = opts.numericSeparator;
		if (typeof obj === "undefined") return "undefined";
		if (obj === null) return "null";
		if (typeof obj === "boolean") return obj ? "true" : "false";
		if (typeof obj === "string") return inspectString(obj, opts);
		if (typeof obj === "number") {
			if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
			var str = String(obj);
			return numericSeparator ? addNumericSeparator(obj, str) : str;
		}
		if (typeof obj === "bigint") {
			var bigIntStr = String(obj) + "n";
			return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		}
		var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
		if (typeof depth === "undefined") depth = 0;
		if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray(obj) ? "[Array]" : "[Object]";
		var indent = getIndent(opts, depth);
		if (typeof seen === "undefined") seen = [];
		else if (indexOf(seen, obj) >= 0) return "[Circular]";
		function inspect(value, from, noIndent) {
			if (from) {
				seen = $arrSlice.call(seen);
				seen.push(from);
			}
			if (noIndent) {
				var newOpts = { depth: opts.depth };
				if (has(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
				return inspect_(value, newOpts, depth + 1, seen);
			}
			return inspect_(value, opts, depth + 1, seen);
		}
		if (typeof obj === "function" && !isRegExp(obj)) {
			var name = nameOf(obj);
			var keys = arrObjKeys(obj, inspect);
			return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
		}
		if (isSymbol(obj)) {
			var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
			return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
		}
		if (isElement(obj)) {
			var s = "<" + $toLowerCase.call(String(obj.nodeName));
			var attrs = obj.attributes || [];
			for (var i = 0; i < attrs.length; i++) s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
			s += ">";
			if (obj.childNodes && obj.childNodes.length) s += "...";
			s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
			return s;
		}
		if (isArray(obj)) {
			if (obj.length === 0) return "[]";
			var xs = arrObjKeys(obj, inspect);
			if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
			return "[ " + $join.call(xs, ", ") + " ]";
		}
		if (isError(obj)) {
			var parts = arrObjKeys(obj, inspect);
			if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
			if (parts.length === 0) return "[" + String(obj) + "]";
			return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
		}
		if (typeof obj === "object" && customInspect) {
			if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, { depth: maxDepth - depth });
			else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
		}
		if (isMap(obj)) {
			var mapParts = [];
			if (mapForEach) mapForEach.call(obj, function(value, key) {
				mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
			});
			return collectionOf("Map", mapSize.call(obj), mapParts, indent);
		}
		if (isSet(obj)) {
			var setParts = [];
			if (setForEach) setForEach.call(obj, function(value) {
				setParts.push(inspect(value, obj));
			});
			return collectionOf("Set", setSize.call(obj), setParts, indent);
		}
		if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
		if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
		if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
		if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
		if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
		if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
		if (isString(obj)) return markBoxed(inspect(String(obj)));
		if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
		if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) return "{ [object globalThis] }";
		if (!isDate(obj) && !isRegExp(obj)) {
			var ys = arrObjKeys(obj, inspect);
			var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
			var protoTag = obj instanceof Object ? "" : "null prototype";
			var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
			var tag = (isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
			if (ys.length === 0) return tag + "{}";
			if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
			return tag + "{ " + $join.call(ys, ", ") + " }";
		}
		return String(obj);
	};
	function wrapQuotes(s, defaultStyle, opts) {
		var quoteChar = quotes[opts.quoteStyle || defaultStyle];
		return quoteChar + s + quoteChar;
	}
	function quote(s) {
		return $replace.call(String(s), /"/g, "&quot;");
	}
	function canTrustToString(obj) {
		return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
	}
	function isArray(obj) {
		return toStr(obj) === "[object Array]" && canTrustToString(obj);
	}
	function isDate(obj) {
		return toStr(obj) === "[object Date]" && canTrustToString(obj);
	}
	function isRegExp(obj) {
		return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
	}
	function isError(obj) {
		return toStr(obj) === "[object Error]" && canTrustToString(obj);
	}
	function isString(obj) {
		return toStr(obj) === "[object String]" && canTrustToString(obj);
	}
	function isNumber(obj) {
		return toStr(obj) === "[object Number]" && canTrustToString(obj);
	}
	function isBoolean(obj) {
		return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
	}
	function isSymbol(obj) {
		if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
		if (typeof obj === "symbol") return true;
		if (!obj || typeof obj !== "object" || !symToString) return false;
		try {
			symToString.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	function isBigInt(obj) {
		if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
		try {
			bigIntValueOf.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	var hasOwn = Object.prototype.hasOwnProperty || function(key) {
		return key in this;
	};
	function has(obj, key) {
		return hasOwn.call(obj, key);
	}
	function toStr(obj) {
		return objectToString.call(obj);
	}
	function nameOf(f) {
		if (f.name) return f.name;
		var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		if (m) return m[1];
		return null;
	}
	function indexOf(xs, x) {
		if (xs.indexOf) return xs.indexOf(x);
		for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
		return -1;
	}
	function isMap(x) {
		if (!mapSize || !x || typeof x !== "object") return false;
		try {
			mapSize.call(x);
			try {
				setSize.call(x);
			} catch (s) {
				return true;
			}
			return x instanceof Map;
		} catch (e) {}
		return false;
	}
	function isWeakMap(x) {
		if (!weakMapHas || !x || typeof x !== "object") return false;
		try {
			weakMapHas.call(x, weakMapHas);
			try {
				weakSetHas.call(x, weakSetHas);
			} catch (s) {
				return true;
			}
			return x instanceof WeakMap;
		} catch (e) {}
		return false;
	}
	function isWeakRef(x) {
		if (!weakRefDeref || !x || typeof x !== "object") return false;
		try {
			weakRefDeref.call(x);
			return true;
		} catch (e) {}
		return false;
	}
	function isSet(x) {
		if (!setSize || !x || typeof x !== "object") return false;
		try {
			setSize.call(x);
			try {
				mapSize.call(x);
			} catch (m) {
				return true;
			}
			return x instanceof Set;
		} catch (e) {}
		return false;
	}
	function isWeakSet(x) {
		if (!weakSetHas || !x || typeof x !== "object") return false;
		try {
			weakSetHas.call(x, weakSetHas);
			try {
				weakMapHas.call(x, weakMapHas);
			} catch (s) {
				return true;
			}
			return x instanceof WeakSet;
		} catch (e) {}
		return false;
	}
	function isElement(x) {
		if (!x || typeof x !== "object") return false;
		if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
		return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
	}
	function inspectString(str, opts) {
		if (str.length > opts.maxStringLength) {
			var remaining = str.length - opts.maxStringLength;
			var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
			return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		}
		var quoteRE = quoteREs[opts.quoteStyle || "single"];
		quoteRE.lastIndex = 0;
		return wrapQuotes($replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte), "single", opts);
	}
	function lowbyte(c) {
		var n = c.charCodeAt(0);
		var x = {
			8: "b",
			9: "t",
			10: "n",
			12: "f",
			13: "r"
		}[n];
		if (x) return "\\" + x;
		return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
	}
	function markBoxed(str) {
		return "Object(" + str + ")";
	}
	function weakCollectionOf(type) {
		return type + " { ? }";
	}
	function collectionOf(type, size, entries, indent) {
		var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
		return type + " (" + size + ") {" + joinedEntries + "}";
	}
	function singleLineValues(xs) {
		for (var i = 0; i < xs.length; i++) if (indexOf(xs[i], "\n") >= 0) return false;
		return true;
	}
	function getIndent(opts, depth) {
		var baseIndent;
		if (opts.indent === "	") baseIndent = "	";
		else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
		else return null;
		return {
			base: baseIndent,
			prev: $join.call(Array(depth + 1), baseIndent)
		};
	}
	function indentedJoin(xs, indent) {
		if (xs.length === 0) return "";
		var lineJoiner = "\n" + indent.prev + indent.base;
		return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
	}
	function arrObjKeys(obj, inspect) {
		var isArr = isArray(obj);
		var xs = [];
		if (isArr) {
			xs.length = obj.length;
			for (var i = 0; i < obj.length; i++) xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
		}
		var syms = typeof gOPS === "function" ? gOPS(obj) : [];
		var symMap;
		if (hasShammedSymbols) {
			symMap = {};
			for (var k = 0; k < syms.length; k++) symMap["$" + syms[k]] = syms[k];
		}
		for (var key in obj) {
			if (!has(obj, key)) continue;
			if (isArr && String(Number(key)) === key && key < obj.length) continue;
			if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue;
			else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
			else xs.push(key + ": " + inspect(obj[key], obj));
		}
		if (typeof gOPS === "function") {
			for (var j = 0; j < syms.length; j++) if (isEnumerable.call(obj, syms[j])) xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
		}
		return xs;
	}
}));

//#endregion
//#region ../../node_modules/side-channel-list/index.js
var require_side_channel_list = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inspect = require_object_inspect();
	var $TypeError = require_type();
	/** @type {import('./list.d.ts').listGetNode} */
	var listGetNode = function(list, key, isDelete) {
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		for (; (curr = prev.next) != null; prev = curr) if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				curr.next = list.next;
				list.next = curr;
			}
			return curr;
		}
	};
	/** @type {import('./list.d.ts').listGet} */
	var listGet = function(objects, key) {
		if (!objects) return;
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	/** @type {import('./list.d.ts').listSet} */
	var listSet = function(objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) node.value = value;
		else objects.next = {
			key,
			next: objects.next,
			value
		};
	};
	/** @type {import('./list.d.ts').listHas} */
	var listHas = function(objects, key) {
		if (!objects) return false;
		return !!listGetNode(objects, key);
	};
	/** @type {import('./list.d.ts').listDelete} */
	var listDelete = function(objects, key) {
		if (objects) return listGetNode(objects, key, true);
	};
	/** @type {import('.')} */
	module.exports = function getSideChannelList() {
		/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				var root = $o && $o.next;
				var deletedNode = listDelete($o, key);
				if (deletedNode && root && root === deletedNode) $o = void 0;
				return !!deletedNode;
			},
			get: function(key) {
				return listGet($o, key);
			},
			has: function(key) {
				return listHas($o, key);
			},
			set: function(key, value) {
				if (!$o) $o = { next: void 0 };
				listSet($o, key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	module.exports = Object;
}));

//#endregion
//#region ../../node_modules/es-errors/index.js
var require_es_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	module.exports = Error;
}));

//#endregion
//#region ../../node_modules/es-errors/eval.js
var require_eval = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./eval')} */
	module.exports = EvalError;
}));

//#endregion
//#region ../../node_modules/es-errors/range.js
var require_range = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./range')} */
	module.exports = RangeError;
}));

//#endregion
//#region ../../node_modules/es-errors/ref.js
var require_ref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
}));

//#endregion
//#region ../../node_modules/es-errors/syntax.js
var require_syntax = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
}));

//#endregion
//#region ../../node_modules/es-errors/uri.js
var require_uri = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./uri')} */
	module.exports = URIError;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/abs.js
var require_abs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/floor.js
var require_floor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/max.js
var require_max = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./max')} */
	module.exports = Math.max;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/min.js
var require_min = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./min')} */
	module.exports = Math.min;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/pow.js
var require_pow = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/round.js
var require_round = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./round')} */
	module.exports = Math.round;
}));

//#endregion
//#region ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN(a) {
		return a !== a;
	};
}));

//#endregion
//#region ../../node_modules/math-intrinsics/sign.js
var require_sign = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $isNaN = require_isNaN();
	/** @type {import('./sign')} */
	module.exports = function sign(number) {
		if ($isNaN(number) || number === 0) return number;
		return number < 0 ? -1 : 1;
	};
}));

//#endregion
//#region ../../node_modules/gopd/gOPD.js
var require_gOPD = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
}));

//#endregion
//#region ../../node_modules/gopd/index.js
var require_gopd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	var $gOPD = require_gOPD();
	if ($gOPD) try {
		$gOPD([], "length");
	} catch (e) {
		$gOPD = null;
	}
	module.exports = $gOPD;
}));

//#endregion
//#region ../../node_modules/es-define-property/index.js
var require_es_define_property = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('.')} */
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) try {
		$defineProperty({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty = false;
	}
	module.exports = $defineProperty;
}));

//#endregion
//#region ../../node_modules/has-symbols/shams.js
var require_shams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
}));

//#endregion
//#region ../../node_modules/has-symbols/index.js
var require_has_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
}));

//#endregion
//#region ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
}));

//#endregion
//#region ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $Object = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object.getPrototypeOf || null;
}));

//#endregion
//#region ../../node_modules/function-bind/implementation.js
var require_implementation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty(a, b) {
		var arr = [];
		for (var i = 0; i < a.length; i += 1) arr[i] = a[i];
		for (var j = 0; j < b.length; j += 1) arr[j + a.length] = b[j];
		return arr;
	};
	var slicy = function slicy(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) arr[j] = arrLike[i];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs[i] = "$" + i;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty = function Empty() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
}));

//#endregion
//#region ../../node_modules/function-bind/index.js
var require_function_bind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
}));

//#endregion
//#region ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
}));

//#endregion
//#region ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
}));

//#endregion
//#region ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
}));

//#endregion
//#region ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bind = require_function_bind();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind.call($call, $apply);
}));

//#endregion
//#region ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bind = require_function_bind();
	var $TypeError = require_type();
	var $call = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError("a function is required");
		return $actualApply(bind, $call, args);
	};
}));

//#endregion
//#region ../../node_modules/dunder-proto/get.js
var require_get = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object(value));
	} : false;
}));

//#endregion
//#region ../../node_modules/get-proto/index.js
var require_get_proto = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto(O) {
		return reflectGetProto(O);
	} : originalGetProto ? function getProto(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O);
	} : getDunderProto ? function getProto(O) {
		return getDunderProto(O);
	} : null;
}));

//#endregion
//#region ../../node_modules/hasown/index.js
var require_hasown = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind.call(call, $hasOwn);
}));

//#endregion
//#region ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var undefined;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor = require_floor();
	var max = require_max();
	var min = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
		"%AsyncFromSyncIteratorPrototype%": undefined,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
		"%JSON%": typeof JSON === "object" ? JSON : undefined,
		"%Map%": typeof Map === "undefined" ? undefined : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
		"%Symbol%": hasSymbols ? Symbol : undefined,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor,
		"%Math.max%": max,
		"%Math.min%": min,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto) try {
		null.error;
	} catch (e) {
		INTRINSICS["%Error.prototype%"] = getProto(getProto(e));
	}
	var doEval = function doEval(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval("%AsyncGenerator%");
			if (gen && getProto) value = getProto(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind = require_function_bind();
	var hasOwn = require_hasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string, rePropName, function(match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first === "\"" || first === "'" || first === "`" || last === "\"" || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;
					if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
					else value = value[part];
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
}));

//#endregion
//#region ../../node_modules/call-bound/index.js
var require_call_bound = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBindBasic = require_call_bind_apply_helpers();
	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
	/** @type {import('.')} */
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBindBasic([intrinsic]);
		return intrinsic;
	};
}));

//#endregion
//#region ../../node_modules/side-channel-map/index.js
var require_side_channel_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect = require_object_inspect();
	var $TypeError = require_type();
	var $Map = GetIntrinsic("%Map%", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
	var $mapGet = callBound("Map.prototype.get", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
	var $mapSet = callBound("Map.prototype.set", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapHas = callBound("Map.prototype.has", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapDelete = callBound("Map.prototype.delete", true);
	/** @type {<K, V>(thisArg: Map<K, V>) => number} */
	var $mapSize = callBound("Map.prototype.size", true);
	/** @type {import('.')} */
	module.exports = !!$Map && function getSideChannelMap() {
		/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {Map<K, V> | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($m) {
					var result = $mapDelete($m, key);
					if ($mapSize($m) === 0) $m = void 0;
					return result;
				}
				return false;
			},
			get: function(key) {
				if ($m) return $mapGet($m, key);
			},
			has: function(key) {
				if ($m) return $mapHas($m, key);
				return false;
			},
			set: function(key, value) {
				if (!$m) $m = new $Map();
				$mapSet($m, key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect = require_object_inspect();
	var getSideChannelMap = require_side_channel_map();
	var $TypeError = require_type();
	var $WeakMap = GetIntrinsic("%WeakMap%", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
	var $weakMapGet = callBound("WeakMap.prototype.get", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
	var $weakMapSet = callBound("WeakMap.prototype.set", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapHas = callBound("WeakMap.prototype.has", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
	/** @type {import('.')} */
	module.exports = $WeakMap ? function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapDelete($wm, key);
				} else if (getSideChannelMap) {
					if ($m) return $m["delete"](key);
				}
				return false;
			},
			get: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapGet($wm, key);
				}
				return $m && $m.get(key);
			},
			has: function(key) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if ($wm) return $weakMapHas($wm, key);
				}
				return !!$m && $m.has(key);
			},
			set: function(key, value) {
				if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
					if (!$wm) $wm = new $WeakMap();
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) $m = getSideChannelMap();
					/** @type {NonNullable<typeof $m>} */ $m.set(key, value);
				}
			}
		};
		return channel;
	} : getSideChannelMap;
}));

//#endregion
//#region ../../node_modules/side-channel/index.js
var require_side_channel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var $TypeError = require_type();
	var inspect = require_object_inspect();
	var getSideChannelList = require_side_channel_list();
	var getSideChannelMap = require_side_channel_map();
	var makeChannel = require_side_channel_weakmap() || getSideChannelMap || getSideChannelList;
	/** @type {import('.')} */
	module.exports = function getSideChannel() {
		/** @typedef {ReturnType<typeof getSideChannel>} Channel */
		/** @type {Channel | undefined} */ var $channelData;
		/** @type {Channel} */
		var channel = {
			assert: function(key) {
				if (!channel.has(key)) throw new $TypeError("Side channel does not contain " + inspect(key));
			},
			"delete": function(key) {
				return !!$channelData && $channelData["delete"](key);
			},
			get: function(key) {
				return $channelData && $channelData.get(key);
			},
			has: function(key) {
				return !!$channelData && $channelData.has(key);
			},
			set: function(key, value) {
				if (!$channelData) $channelData = makeChannel();
				$channelData.set(key, value);
			}
		};
		return channel;
	};
}));

//#endregion
//#region ../../node_modules/qs/lib/formats.js
var require_formats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	var Format = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	module.exports = {
		"default": Format.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace.call(value, percentTwenties, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format.RFC1738,
		RFC3986: Format.RFC3986
	};
}));

//#endregion
//#region ../../node_modules/qs/lib/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var formats = require_formats();
	var getSideChannel = require_side_channel();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var overflowChannel = getSideChannel();
	var markOverflow = function markOverflow(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
		return obj;
	};
	var isOverflow = function isOverflow(obj) {
		return overflowChannel.has(obj);
	};
	var getMaxIndex = function getMaxIndex(obj) {
		return overflowChannel.get(obj);
	};
	var setMaxIndex = function setMaxIndex(obj, maxIndex) {
		overflowChannel.set(obj, maxIndex);
	};
	var hexTable = function() {
		var array = [];
		for (var i = 0; i < 256; ++i) array[array.length] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
		return array;
	}();
	var compactQueue = function compactQueue(queue) {
		while (queue.length > 1) {
			var item = queue.pop();
			var obj = item.obj[item.prop];
			if (isArray(obj)) {
				var compacted = [];
				for (var j = 0; j < obj.length; ++j) if (typeof obj[j] !== "undefined") compacted[compacted.length] = obj[j];
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject = function arrayToObject(source, options) {
		var obj = options && options.plainObjects ? { __proto__: null } : {};
		for (var i = 0; i < source.length; ++i) if (typeof source[i] !== "undefined") obj[i] = source[i];
		return obj;
	};
	var merge = function merge(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object" && typeof source !== "function") {
			if (isArray(target)) {
				var nextIndex = target.length;
				if (options && typeof options.arrayLimit === "number" && nextIndex > options.arrayLimit) return markOverflow(arrayToObject(target.concat(source), options), nextIndex);
				target[nextIndex] = source;
			} else if (target && typeof target === "object") {
				if (isOverflow(target)) {
					var newIndex = getMaxIndex(target) + 1;
					target[newIndex] = source;
					setMaxIndex(target, newIndex);
				} else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") {
			if (isOverflow(source)) {
				var sourceKeys = Object.keys(source);
				var result = options && options.plainObjects ? {
					__proto__: null,
					0: target
				} : { 0: target };
				for (var m = 0; m < sourceKeys.length; m++) {
					var oldKey = parseInt(sourceKeys[m], 10);
					result[oldKey + 1] = source[sourceKeys[m]];
				}
				return markOverflow(result, getMaxIndex(source) + 1);
			}
			var combined = [target].concat(source);
			if (options && typeof options.arrayLimit === "number" && combined.length > options.arrayLimit) return markOverflow(arrayToObject(combined, options), combined.length - 1);
			return combined;
		}
		var mergeTarget = target;
		if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
		if (isArray(target) && isArray(source)) {
			source.forEach(function(item, i) {
				if (has.call(target, i)) {
					var targetItem = target[i];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i] = merge(targetItem, item, options);
					else target[target.length] = item;
				} else target[i] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key) {
			var value = source[key];
			if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
			else acc[key] = value;
			if (isOverflow(source) && !isOverflow(acc)) markOverflow(acc, getMaxIndex(source));
			if (isOverflow(acc)) {
				var keyNum = parseInt(key, 10);
				if (String(keyNum) === key && keyNum >= 0 && keyNum > getMaxIndex(acc)) setMaxIndex(acc, keyNum);
			}
			return acc;
		}, mergeTarget);
	};
	var assign = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key) {
			acc[key] = source[key];
			return acc;
		}, target);
	};
	var decode = function(str, defaultDecoder, charset) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit = 1024;
	var encode = function encode(str, defaultEncoder, charset, kind, format) {
		if (str.length === 0) return str;
		var string = str;
		if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
		else if (typeof str !== "string") string = String(str);
		if (charset === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
			return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
		});
		var out = "";
		for (var j = 0; j < string.length; j += limit) {
			var segment = string.length >= limit ? string.slice(j, j + limit) : string;
			var arr = [];
			for (var i = 0; i < segment.length; ++i) {
				var c = segment.charCodeAt(i);
				if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
					arr[arr.length] = segment.charAt(i);
					continue;
				}
				if (c < 128) {
					arr[arr.length] = hexTable[c];
					continue;
				}
				if (c < 2048) {
					arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
					continue;
				}
				if (c < 55296 || c >= 57344) {
					arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
					continue;
				}
				i += 1;
				c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
				arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
			}
			out += arr.join("");
		}
		return out;
	};
	var compact = function compact(value) {
		var queue = [{
			obj: { o: value },
			prop: "o"
		}];
		var refs = [];
		for (var i = 0; i < queue.length; ++i) {
			var item = queue[i];
			var obj = item.obj[item.prop];
			var keys = Object.keys(obj);
			for (var j = 0; j < keys.length; ++j) {
				var key = keys[j];
				var val = obj[key];
				if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
					queue[queue.length] = {
						obj,
						prop: key
					};
					refs[refs.length] = val;
				}
			}
		}
		compactQueue(queue);
		return value;
	};
	var isRegExp = function isRegExp(obj) {
		return Object.prototype.toString.call(obj) === "[object RegExp]";
	};
	var isBuffer = function isBuffer(obj) {
		if (!obj || typeof obj !== "object") return false;
		return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	var combine = function combine(a, b, arrayLimit, plainObjects) {
		if (isOverflow(a)) {
			var newIndex = getMaxIndex(a) + 1;
			a[newIndex] = b;
			setMaxIndex(a, newIndex);
			return a;
		}
		var result = [].concat(a, b);
		if (result.length > arrayLimit) return markOverflow(arrayToObject(result, { plainObjects }), result.length - 1);
		return result;
	};
	var maybeMap = function maybeMap(val, fn) {
		if (isArray(val)) {
			var mapped = [];
			for (var i = 0; i < val.length; i += 1) mapped[mapped.length] = fn(val[i]);
			return mapped;
		}
		return fn(val);
	};
	module.exports = {
		arrayToObject,
		assign,
		combine,
		compact,
		decode,
		encode,
		isBuffer,
		isOverflow,
		isRegExp,
		markOverflow,
		maybeMap,
		merge
	};
}));

//#endregion
//#region ../../node_modules/qs/lib/stringify.js
var require_stringify$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getSideChannel = require_side_channel();
	var utils = require_utils$1();
	var formats = require_formats();
	var has = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key) {
			return prefix + "[" + key + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function(arr, valueOrArray) {
		push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO = Date.prototype.toISOString;
	var defaultFormat = formats["default"];
	var defaults = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		commaRoundTrip: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils.encode,
		encodeValuesOnly: false,
		filter: void 0,
		format: defaultFormat,
		formatter: formats.formatters[defaultFormat],
		indices: false,
		serializeDate: function serializeDate(date) {
			return toISO.call(date);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel = {};
	var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
		var obj = object;
		var tmpSc = sideChannel;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
			if (value instanceof Date) return serializeDate(value);
			return value;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format)) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray(obj)) {
			if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray(filter)) objKeys = filter;
		else {
			var keys = Object.keys(obj);
			objKeys = sort ? keys.sort(sort) : keys;
		}
		var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
		var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j = 0; j < objKeys.length; ++j) {
			var key = objKeys[j];
			var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
			var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel.set(object, step);
			var valueSideChannel = getSideChannel();
			valueSideChannel.set(sentinel, sideChannel);
			pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset = opts.charset || defaults.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format = formats["default"];
		if (typeof opts.format !== "undefined") {
			if (!has.call(formats.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format = opts.format;
		}
		var formatter = formats.formatters[format];
		var filter = defaults.filter;
		if (typeof opts.filter === "function" || isArray(opts.filter)) filter = opts.filter;
		var arrayFormat;
		if (opts.arrayFormat in arrayPrefixGenerators) arrayFormat = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat = opts.indices ? "indices" : "repeat";
		else arrayFormat = defaults.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			arrayFormat,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			commaRoundTrip: !!opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
			filter,
			format,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
		};
	};
	module.exports = function(object, opts) {
		var obj = object;
		var options = normalizeStringifyOptions(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel = getSideChannel();
		for (var i = 0; i < objKeys.length; ++i) {
			var key = objKeys[i];
			var value = obj[key];
			if (options.skipNulls && value === null) continue;
			pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
		}
		var joined = keys.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
}));

//#endregion
//#region ../../node_modules/qs/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var utils = require_utils$1();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var defaults = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false,
		throwOnLimitExceeded: false
	};
	var interpretNumericEntities = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue = function(val, options, currentArrayLength) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
		return val;
	};
	var isoSentinel = "utf8=%26%2310003%3B";
	var charsetSentinel = "utf8=%E2%9C%93";
	var parseValues = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
		if (options.throwOnLimitExceeded && parts.length > limit) throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
		var skipIndex = -1;
		var i;
		var charset = options.charset;
		if (options.charsetSentinel) {
			for (i = 0; i < parts.length; ++i) if (parts[i].indexOf("utf8=") === 0) {
				if (parts[i] === charsetSentinel) charset = "utf-8";
				else if (parts[i] === isoSentinel) charset = "iso-8859-1";
				skipIndex = i;
				i = parts.length;
			}
		}
		for (i = 0; i < parts.length; ++i) {
			if (i === skipIndex) continue;
			var part = parts[i];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key;
			var val;
			if (pos === -1) {
				key = options.decoder(part, defaults.decoder, charset, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
				if (key !== null) val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
					return options.decoder(encodedVal, defaults.decoder, charset, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset === "iso-8859-1") val = interpretNumericEntities(String(val));
			if (part.indexOf("[]=") > -1) val = isArray(val) ? [val] : val;
			if (options.comma && isArray(val) && val.length > options.arrayLimit) {
				if (options.throwOnLimitExceeded) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
				val = utils.combine([], val, options.arrayLimit, options.plainObjects);
			}
			if (key !== null) {
				var existing = has.call(obj, key);
				if (existing && options.duplicates === "combine") obj[key] = utils.combine(obj[key], val, options.arrayLimit, options.plainObjects);
				else if (!existing || options.duplicates === "last") obj[key] = val;
			}
		}
		return obj;
	};
	var parseObject = function(chain, val, options, valuesParsed) {
		var currentArrayLength = 0;
		if (chain.length > 0 && chain[chain.length - 1] === "[]") {
			var parentKey = chain.slice(0, -1).join("");
			currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		}
		var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
		for (var i = chain.length - 1; i >= 0; --i) {
			var obj;
			var root = chain[i];
			if (root === "[]" && options.parseArrays) if (utils.isOverflow(leaf)) obj = leaf;
			else obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf, options.arrayLimit, options.plainObjects);
			else {
				obj = options.plainObjects ? { __proto__: null } : {};
				var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index = parseInt(decodedRoot, 10);
				var isValidArrayIndex = !isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays;
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (isValidArrayIndex && index < options.arrayLimit) {
					obj = [];
					obj[index] = leaf;
				} else if (isValidArrayIndex && options.throwOnLimitExceeded) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
				else if (isValidArrayIndex) {
					obj[index] = leaf;
					utils.markOverflow(obj, index);
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var splitKeyIntoSegments = function splitKeyIntoSegments(givenKey, options) {
		var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		if (options.depth <= 0) {
			if (!options.plainObjects && has.call(Object.prototype, key)) {
				if (!options.allowPrototypes) return;
			}
			return [key];
		}
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment = brackets.exec(key);
		var parent = segment ? key.slice(0, segment.index) : key;
		var keys = [];
		if (parent) {
			if (!options.plainObjects && has.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys[keys.length] = parent;
		}
		var i = 0;
		while ((segment = child.exec(key)) !== null && i < options.depth) {
			i += 1;
			var segmentContent = segment[1].slice(1, -1);
			if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
				if (!options.allowPrototypes) return;
			}
			keys[keys.length] = segment[1];
		}
		if (segment) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys[keys.length] = "[" + key.slice(segment.index) + "]";
		}
		return keys;
	};
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var keys = splitKeyIntoSegments(givenKey, options);
		if (!keys) return;
		return parseObject(keys, val, options, valuesParsed);
	};
	var normalizeParseOptions = function normalizeParseOptions(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
		var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
			charset,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
			delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
			throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
		};
	};
	module.exports = function(str, opts) {
		var options = normalizeParseOptions(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? { __proto__: null } : {};
		var tempObj = typeof str === "string" ? parseValues(str, options) : str;
		var obj = options.plainObjects ? { __proto__: null } : {};
		var keys = Object.keys(tempObj);
		for (var i = 0; i < keys.length; ++i) {
			var key = keys[i];
			var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
			obj = utils.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils.compact(obj);
	};
}));

//#endregion
//#region ../../node_modules/qs/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var stringify = require_stringify$1();
	var parse = require_parse();
	var formats = require_formats();
	module.exports = {
		formats,
		parse,
		stringify
	};
}));

//#endregion
//#region ../../node_modules/body-parser/lib/types/urlencoded.js
/*!
* body-parser
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_urlencoded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes = require_bytes();
	var contentType = require_content_type();
	var createError = require_http_errors();
	var debug = require_src$5()("body-parser:urlencoded");
	var deprecate = require_depd()("body-parser");
	var read = require_read();
	var typeis = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = urlencoded;
	/**
	* Cache of parser modules.
	*/
	var parsers = Object.create(null);
	/**
	* Create a middleware to parse urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function urlencoded(options) {
		var opts = options || {};
		if (opts.extended === void 0) deprecate("undefined extended: provide extended option");
		var extended = opts.extended !== false;
		var inflate = opts.inflate !== false;
		var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/x-www-form-urlencoded";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse(body) {
			return body.length ? queryparse(body) : {};
		}
		return function urlencodedParser(req, res, next) {
			if (req._body) {
				debug("body already parsed");
				next();
				return;
			}
			req.body = req.body || {};
			if (!typeis.hasBody(req)) {
				debug("skip empty body");
				next();
				return;
			}
			debug("content-type %j", req.headers["content-type"]);
			if (!shouldParse(req)) {
				debug("skip parsing");
				next();
				return;
			}
			var charset = getCharset(req) || "utf-8";
			if (charset !== "utf-8") {
				debug("invalid charset");
				next(createError(415, "unsupported charset \"" + charset.toUpperCase() + "\"", {
					charset,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req, res, next, parse, debug, {
				debug,
				encoding: charset,
				inflate,
				limit,
				verify
			});
		};
	}
	/**
	* Get the extended query parser.
	*
	* @param {object} options
	*/
	function extendedparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var depth = options.depth !== void 0 ? options.depth : 32;
		var parse = parser$1("qs");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isNaN(depth) || depth < 0) throw new TypeError("option depth must be a zero or a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body) {
			var paramCount = parameterCount(body, parameterLimit);
			if (paramCount === void 0) {
				debug("too many parameters");
				throw createError(413, "too many parameters", { type: "parameters.too.many" });
			}
			var arrayLimit = Math.max(100, paramCount);
			debug("parse extended urlencoding");
			try {
				return parse(body, {
					allowPrototypes: true,
					arrayLimit,
					depth,
					strictDepth: true,
					parameterLimit
				});
			} catch (err) {
				if (err instanceof RangeError) throw createError(400, "The input exceeded the depth", { type: "querystring.parse.rangeError" });
				else throw err;
			}
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req) {
		try {
			return (contentType.parse(req).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Count the number of parameters, stopping once limit reached
	*
	* @param {string} body
	* @param {number} limit
	* @api private
	*/
	function parameterCount(body, limit) {
		var count = 0;
		var index = 0;
		while ((index = body.indexOf("&", index)) !== -1) {
			count++;
			index++;
			if (count === limit) return;
		}
		return count;
	}
	/**
	* Get parser for module name dynamically.
	*
	* @param {string} name
	* @return {function}
	* @api private
	*/
	function parser$1(name) {
		var mod = parsers[name];
		if (mod !== void 0) return mod.parse;
		switch (name) {
			case "qs":
				mod = require_lib();
				break;
			case "querystring":
				mod = require("querystring");
				break;
		}
		parsers[name] = mod;
		return mod.parse;
	}
	/**
	* Get the simple query parser.
	*
	* @param {object} options
	*/
	function simpleparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var parse = parser$1("querystring");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body) {
			if (parameterCount(body, parameterLimit) === void 0) {
				debug("too many parameters");
				throw createError(413, "too many parameters", { type: "parameters.too.many" });
			}
			debug("parse urlencoding");
			return parse(body, void 0, void 0, { maxKeys: parameterLimit });
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req) {
			return Boolean(typeis(req, type));
		};
	}
}));

//#endregion
//#region ../../node_modules/body-parser/index.js
/*!
* body-parser
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_body_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("body-parser");
	/**
	* Cache of loaded parsers.
	* @private
	*/
	var parsers = Object.create(null);
	/**
	* @typedef Parsers
	* @type {function}
	* @property {function} json
	* @property {function} raw
	* @property {function} text
	* @property {function} urlencoded
	*/
	/**
	* Module exports.
	* @type {Parsers}
	*/
	exports = module.exports = deprecate.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
	/**
	* JSON parser.
	* @public
	*/
	Object.defineProperty(exports, "json", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("json")
	});
	/**
	* Raw parser.
	* @public
	*/
	Object.defineProperty(exports, "raw", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("raw")
	});
	/**
	* Text parser.
	* @public
	*/
	Object.defineProperty(exports, "text", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("text")
	});
	/**
	* URL-encoded parser.
	* @public
	*/
	Object.defineProperty(exports, "urlencoded", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("urlencoded")
	});
	/**
	* Create a middleware to parse json and urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @deprecated
	* @public
	*/
	function bodyParser(options) {
		var opts = Object.create(options || null, { type: {
			configurable: true,
			enumerable: true,
			value: void 0,
			writable: true
		} });
		var _urlencoded = exports.urlencoded(opts);
		var _json = exports.json(opts);
		return function bodyParser(req, res, next) {
			_json(req, res, function(err) {
				if (err) return next(err);
				_urlencoded(req, res, next);
			});
		};
	}
	/**
	* Create a getter for loading a parser.
	* @private
	*/
	function createParserGetter(name) {
		return function get() {
			return loadParser(name);
		};
	}
	/**
	* Load a parser module.
	* @private
	*/
	function loadParser(parserName) {
		var parser = parsers[parserName];
		if (parser !== void 0) return parser;
		switch (parserName) {
			case "json":
				parser = require_json();
				break;
			case "raw":
				parser = require_raw();
				break;
			case "text":
				parser = require_text();
				break;
			case "urlencoded":
				parser = require_urlencoded();
				break;
		}
		return parsers[parserName] = parser;
	}
}));

//#endregion
//#region ../../node_modules/merge-descriptors/index.js
/*!
* merge-descriptors
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_merge_descriptors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = merge;
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* Merge the property descriptors of `src` into `dest`
	*
	* @param {object} dest Object to add descriptors to
	* @param {object} src Object to clone descriptors from
	* @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	* @returns {object} Reference to dest
	* @public
	*/
	function merge(dest, src, redefine) {
		if (!dest) throw new TypeError("argument dest is required");
		if (!src) throw new TypeError("argument src is required");
		if (redefine === void 0) redefine = true;
		Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
			if (!redefine && hasOwnProperty.call(dest, name)) return;
			var descriptor = Object.getOwnPropertyDescriptor(src, name);
			Object.defineProperty(dest, name, descriptor);
		});
		return dest;
	}
}));

//#endregion
//#region ../../node_modules/finalhandler/node_modules/ms/index.js
var require_ms$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n, name) {
		if (ms < n) return;
		if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
		return Math.ceil(ms / n) + " " + name + "s";
	}
}));

//#endregion
//#region ../../node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms$3();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i;
		for (i in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug() {
			if (!debug.enabled) return;
			var self = debug;
			var curr = +/* @__PURE__ */ new Date();
			self.diff = curr - (prevTime || curr);
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self, args);
			(debug.log || exports.log || console.log.bind(console)).apply(self, args);
		}
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug);
		return debug;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i = 0; i < len; i++) {
			if (!split[i]) continue;
			namespaces = split[i].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
		for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}));

//#endregion
//#region ../../node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$2();
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var useColors = this.useColors;
		args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ("%%" === match) return;
			index++;
			if ("%c" === match) lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}));

//#endregion
//#region ../../node_modules/finalhandler/node_modules/debug/src/node.js
var require_node$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty$4 = require("tty");
	var util$4 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$2();
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$4.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream$2(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$4.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$4.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$4.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log() {
		return stream.write(util$4.format.apply(util$4, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream$2(fd) {
		var stream;
		switch (process.binding("tty_wrap").guessHandleType(fd)) {
			case "TTY":
				stream = new tty$4.WriteStream(fd);
				stream._type = "tty";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			case "FILE":
				stream = new (require("fs")).SyncWriteStream(fd, { autoClose: false });
				stream._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream = new (require("net")).Socket({
					fd,
					readable: false,
					writable: true
				});
				stream.readable = false;
				stream.read = null;
				stream._type = "pipe";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream.fd = fd;
		stream._isStdio = true;
		return stream;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}));

//#endregion
//#region ../../node_modules/finalhandler/node_modules/debug/src/index.js
var require_src$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser$3();
	else module.exports = require_node$3();
}));

//#endregion
//#region ../../node_modules/encodeurl/index.js
/*!
* encodeurl
* Copyright(c) 2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_encodeurl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = encodeUrl;
	/**
	* RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	* and including invalid escape sequences.
	* @private
	*/
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	/**
	* RegExp to match unmatched surrogate pair.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	/**
	* String to replace unmatched surrogate pair with.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
	/**
	* Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	*
	* This function will take an already-encoded URL and encode all the non-URL
	* code points. This function will not encode the "%" character unless it is
	* not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	* be encoded as `%25foo`).
	*
	* This encode is meant to be "safe" and does not throw errors. It will try as
	* hard as it can to properly encode the given URL, including replacing any raw,
	* unpaired surrogate pairs with the Unicode replacement character prior to
	* encoding.
	*
	* @param {string} url
	* @return {string}
	* @public
	*/
	function encodeUrl(url) {
		return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}
}));

//#endregion
//#region ../../node_modules/escape-html/index.js
/*!
* escape-html
* Copyright(c) 2012-2013 TJ Holowaychuk
* Copyright(c) 2015 Andreas Lubbe
* Copyright(c) 2015 Tiancheng "Timothy" Gu
* MIT Licensed
*/
var require_escape_html = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module variables.
	* @private
	*/
	var matchHtmlRegExp = /["'&<>]/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = escapeHtml;
	/**
	* Escape special characters in the given string of html.
	*
	* @param  {string} string The string to escape for inserting into HTML
	* @return {string}
	* @public
	*/
	function escapeHtml(string) {
		var str = "" + string;
		var match = matchHtmlRegExp.exec(str);
		if (!match) return str;
		var escape;
		var html = "";
		var index = 0;
		var lastIndex = 0;
		for (index = match.index; index < str.length; index++) {
			switch (str.charCodeAt(index)) {
				case 34:
					escape = "&quot;";
					break;
				case 38:
					escape = "&amp;";
					break;
				case 39:
					escape = "&#39;";
					break;
				case 60:
					escape = "&lt;";
					break;
				case 62:
					escape = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index) html += str.substring(lastIndex, index);
			lastIndex = index + 1;
			html += escape;
		}
		return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
}));

//#endregion
//#region ../../node_modules/parseurl/index.js
/*!
* parseurl
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_parseurl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var url$1 = require("url");
	var parse = url$1.parse;
	var Url = url$1.Url;
	/**
	* Module exports.
	* @public
	*/
	module.exports = parseurl;
	module.exports.original = originalurl;
	/**
	* Parse the `req` url with memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function parseurl(req) {
		var url = req.url;
		if (url === void 0) return;
		var parsed = req._parsedUrl;
		if (fresh(url, parsed)) return parsed;
		parsed = fastparse(url);
		parsed._raw = url;
		return req._parsedUrl = parsed;
	}
	/**
	* Parse the `req` original url with fallback and memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function originalurl(req) {
		var url = req.originalUrl;
		if (typeof url !== "string") return parseurl(req);
		var parsed = req._parsedOriginalUrl;
		if (fresh(url, parsed)) return parsed;
		parsed = fastparse(url);
		parsed._raw = url;
		return req._parsedOriginalUrl = parsed;
	}
	/**
	* Parse the `str` url with fast-path short-cut.
	*
	* @param {string} str
	* @return {Object}
	* @private
	*/
	function fastparse(str) {
		if (typeof str !== "string" || str.charCodeAt(0) !== 47) return parse(str);
		var pathname = str;
		var query = null;
		var search = null;
		for (var i = 1; i < str.length; i++) switch (str.charCodeAt(i)) {
			case 63:
				if (search === null) {
					pathname = str.substring(0, i);
					query = str.substring(i + 1);
					search = str.substring(i);
				}
				break;
			case 9:
			case 10:
			case 12:
			case 13:
			case 32:
			case 35:
			case 160:
			case 65279: return parse(str);
		}
		var url = Url !== void 0 ? new Url() : {};
		url.path = str;
		url.href = str;
		url.pathname = pathname;
		if (search !== null) {
			url.query = query;
			url.search = search;
		}
		return url;
	}
	/**
	* Determine if parsed is still fresh for url.
	*
	* @param {string} url
	* @param {object} parsedUrl
	* @return {boolean}
	* @private
	*/
	function fresh(url, parsedUrl) {
		return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url;
	}
}));

//#endregion
//#region ../../node_modules/finalhandler/index.js
/*!
* finalhandler
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_finalhandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src$4()("finalhandler");
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var onFinished = require_on_finished();
	var parseUrl = require_parseurl();
	var statuses = require_statuses();
	var unpipe = require_unpipe();
	/**
	* Module variables.
	* @private
	*/
	var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
	var NEWLINE_REGEXP = /\n/g;
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	var isFinished = onFinished.isFinished;
	/**
	* Create a minimal HTML document.
	*
	* @param {string} message
	* @private
	*/
	function createHtmlDocument(message) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>" + escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;") + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Module exports.
	* @public
	*/
	module.exports = finalhandler;
	/**
	* Create a function to handle the final response.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {Object} [options]
	* @return {Function}
	* @public
	*/
	function finalhandler(req, res, options) {
		var opts = options || {};
		var env = opts.env || process.env.NODE_ENV || "development";
		var onerror = opts.onerror;
		return function(err) {
			var headers;
			var msg;
			var status;
			if (!err && headersSent(res)) {
				debug("cannot 404 after headers sent");
				return;
			}
			if (err) {
				status = getErrorStatusCode(err);
				if (status === void 0) status = getResponseStatusCode(res);
				else headers = getErrorHeaders(err);
				msg = getErrorMessage(err, status, env);
			} else {
				status = 404;
				msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
			}
			debug("default %s", status);
			if (err && onerror) defer(onerror, err, req, res);
			if (headersSent(res)) {
				debug("cannot %d after headers sent", status);
				if (req.socket) req.socket.destroy();
				return;
			}
			send(req, res, status, headers, msg);
		};
	}
	/**
	* Get headers from Error object.
	*
	* @param {Error} err
	* @return {object}
	* @private
	*/
	function getErrorHeaders(err) {
		if (!err.headers || typeof err.headers !== "object") return;
		var headers = Object.create(null);
		var keys = Object.keys(err.headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			headers[key] = err.headers[key];
		}
		return headers;
	}
	/**
	* Get message from Error object, fallback to status message.
	*
	* @param {Error} err
	* @param {number} status
	* @param {string} env
	* @return {string}
	* @private
	*/
	function getErrorMessage(err, status, env) {
		var msg;
		if (env !== "production") {
			msg = err.stack;
			if (!msg && typeof err.toString === "function") msg = err.toString();
		}
		return msg || statuses.message[status];
	}
	/**
	* Get status code from Error object.
	*
	* @param {Error} err
	* @return {number}
	* @private
	*/
	function getErrorStatusCode(err) {
		if (typeof err.status === "number" && err.status >= 400 && err.status < 600) return err.status;
		if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
	}
	/**
	* Get resource name for the request.
	*
	* This is typically just the original pathname of the request
	* but will fallback to "resource" is that cannot be determined.
	*
	* @param {IncomingMessage} req
	* @return {string}
	* @private
	*/
	function getResourceName(req) {
		try {
			return parseUrl.original(req).pathname;
		} catch (e) {
			return "resource";
		}
	}
	/**
	* Get status code from response.
	*
	* @param {OutgoingMessage} res
	* @return {number}
	* @private
	*/
	function getResponseStatusCode(res) {
		var status = res.statusCode;
		if (typeof status !== "number" || status < 400 || status > 599) status = 500;
		return status;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res) {
		return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
	}
	/**
	* Send response.
	*
	* @param {IncomingMessage} req
	* @param {OutgoingMessage} res
	* @param {number} status
	* @param {object} headers
	* @param {string} message
	* @private
	*/
	function send(req, res, status, headers, message) {
		function write() {
			var body = createHtmlDocument(message);
			res.statusCode = status;
			if (req.httpVersionMajor < 2) res.statusMessage = statuses.message[status];
			res.removeHeader("Content-Encoding");
			res.removeHeader("Content-Language");
			res.removeHeader("Content-Range");
			setHeaders(res, headers);
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Content-Type", "text/html; charset=utf-8");
			res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
			if (req.method === "HEAD") {
				res.end();
				return;
			}
			res.end(body, "utf8");
		}
		if (isFinished(req)) {
			write();
			return;
		}
		unpipe(req);
		onFinished(req, write);
		req.resume();
	}
	/**
	* Set response headers from an object.
	*
	* @param {OutgoingMessage} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res, headers) {
		if (!headers) return;
		var keys = Object.keys(headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			res.setHeader(key, headers[key]);
		}
	}
}));

//#endregion
//#region ../../node_modules/express/node_modules/ms/index.js
var require_ms$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n, name) {
		if (ms < n) return;
		if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
		return Math.ceil(ms / n) + " " + name + "s";
	}
}));

//#endregion
//#region ../../node_modules/express/node_modules/debug/src/debug.js
var require_debug$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms$2();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i;
		for (i in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug() {
			if (!debug.enabled) return;
			var self = debug;
			var curr = +/* @__PURE__ */ new Date();
			self.diff = curr - (prevTime || curr);
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self, args);
			(debug.log || exports.log || console.log.bind(console)).apply(self, args);
		}
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug);
		return debug;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i = 0; i < len; i++) {
			if (!split[i]) continue;
			namespaces = split[i].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
		for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}));

//#endregion
//#region ../../node_modules/express/node_modules/debug/src/browser.js
var require_browser$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$1();
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var useColors = this.useColors;
		args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ("%%" === match) return;
			index++;
			if ("%c" === match) lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}));

//#endregion
//#region ../../node_modules/express/node_modules/debug/src/node.js
var require_node$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty$3 = require("tty");
	var util$3 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug$1();
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$3.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream$1(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$3.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$3.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$3.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log() {
		return stream.write(util$3.format.apply(util$3, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream$1(fd) {
		var stream;
		switch (process.binding("tty_wrap").guessHandleType(fd)) {
			case "TTY":
				stream = new tty$3.WriteStream(fd);
				stream._type = "tty";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			case "FILE":
				stream = new (require("fs")).SyncWriteStream(fd, { autoClose: false });
				stream._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream = new (require("net")).Socket({
					fd,
					readable: false,
					writable: true
				});
				stream.readable = false;
				stream.read = null;
				stream._type = "pipe";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream.fd = fd;
		stream._isStdio = true;
		return stream;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}));

//#endregion
//#region ../../node_modules/express/node_modules/debug/src/index.js
var require_src$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser$2();
	else module.exports = require_node$2();
}));

//#endregion
//#region ../../node_modules/array-flatten/array-flatten.js
var require_array_flatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Expose `arrayFlatten`.
	*/
	module.exports = arrayFlatten;
	/**
	* Recursive flatten function with depth.
	*
	* @param  {Array}  array
	* @param  {Array}  result
	* @param  {Number} depth
	* @return {Array}
	*/
	function flattenWithDepth(array, result, depth) {
		for (var i = 0; i < array.length; i++) {
			var value = array[i];
			if (depth > 0 && Array.isArray(value)) flattenWithDepth(value, result, depth - 1);
			else result.push(value);
		}
		return result;
	}
	/**
	* Recursive flatten function. Omitting depth is slightly faster.
	*
	* @param  {Array} array
	* @param  {Array} result
	* @return {Array}
	*/
	function flattenForever(array, result) {
		for (var i = 0; i < array.length; i++) {
			var value = array[i];
			if (Array.isArray(value)) flattenForever(value, result);
			else result.push(value);
		}
		return result;
	}
	/**
	* Flatten an array, with the ability to define a depth.
	*
	* @param  {Array}  array
	* @param  {Number} depth
	* @return {Array}
	*/
	function arrayFlatten(array, depth) {
		if (depth == null) return flattenForever(array, []);
		return flattenWithDepth(array, [], depth);
	}
}));

//#endregion
//#region ../../node_modules/path-to-regexp/index.js
var require_path_to_regexp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Expose `pathToRegexp`.
	*/
	module.exports = pathToRegexp;
	/**
	* Match matching groups in a regular expression.
	*/
	var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
	/**
	* Normalize the given path string,
	* returning a regular expression.
	*
	* An empty array should be passed,
	* which will contain the placeholder
	* key names. For example "/user/:id" will
	* then contain ["id"].
	*
	* @param  {String|RegExp|Array} path
	* @param  {Array} keys
	* @param  {Object} options
	* @return {RegExp}
	* @api private
	*/
	function pathToRegexp(path, keys, options) {
		options = options || {};
		keys = keys || [];
		var strict = options.strict;
		var end = options.end !== false;
		var flags = options.sensitive ? "" : "i";
		var lookahead = options.lookahead !== false;
		var extraOffset = 0;
		var keysOffset = keys.length;
		var i = 0;
		var name = 0;
		var pos = 0;
		var backtrack = "";
		var m;
		if (path instanceof RegExp) {
			while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
				if (m[0][0] === "\\") continue;
				keys.push({
					name: m[1] || name++,
					optional: false,
					offset: m.index
				});
			}
			return path;
		}
		if (Array.isArray(path)) {
			path = path.map(function(value) {
				return pathToRegexp(value, keys, options).source;
			});
			return new RegExp(path.join("|"), flags);
		}
		if (typeof path !== "string") throw new TypeError("path must be a string, array of strings, or regular expression");
		path = path.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match, slash, format, key, capture, star, optional, offset) {
			if (match[0] === "\\") {
				backtrack += match;
				pos += 2;
				return match;
			}
			if (match === ".") {
				backtrack += "\\.";
				extraOffset += 1;
				pos += 1;
				return "\\.";
			}
			if (slash || format) backtrack = "";
			else backtrack += path.slice(pos, offset);
			pos = offset + match.length;
			if (match === "*") {
				extraOffset += 3;
				return "(.*)";
			}
			if (match === "/(") {
				backtrack += "/";
				extraOffset += 2;
				return "/(?:";
			}
			slash = slash || "";
			format = format ? "\\." : "";
			optional = optional || "";
			capture = capture ? capture.replace(/\\.|\*/, function(m) {
				return m === "*" ? "(.*)" : m;
			}) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format + "]+?)";
			keys.push({
				name: key,
				optional: !!optional,
				offset: offset + extraOffset
			});
			var result = "(?:" + format + slash + capture + (star ? "((?:[/" + format + "].+?)?)" : "") + ")" + optional;
			extraOffset += result.length - match.length;
			return result;
		});
		while (m = MATCHING_GROUP_REGEXP.exec(path)) {
			if (m[0][0] === "\\") continue;
			if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) keys.splice(keysOffset + i, 0, {
				name: name++,
				optional: false,
				offset: m.index
			});
			i++;
		}
		path += strict ? "" : path[path.length - 1] === "/" ? "?" : "/?";
		if (end) path += "$";
		else if (path[path.length - 1] !== "/") path += lookahead ? "(?=/|$)" : "(?:/|$)";
		return new RegExp("^" + path, flags);
	}
}));

//#endregion
//#region ../../node_modules/express/lib/router/layer.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_layer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var pathRegexp = require_path_to_regexp();
	var debug = require_src$3()("express:router:layer");
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Layer;
	function Layer(path, options, fn) {
		if (!(this instanceof Layer)) return new Layer(path, options, fn);
		debug("new %o", path);
		var opts = options || {};
		this.handle = fn;
		this.name = fn.name || "<anonymous>";
		this.params = void 0;
		this.path = void 0;
		this.regexp = pathRegexp(path, this.keys = [], opts);
		this.regexp.fast_star = path === "*";
		this.regexp.fast_slash = path === "/" && opts.end === false;
	}
	/**
	* Handle the error for the layer.
	*
	* @param {Error} error
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
		var fn = this.handle;
		if (fn.length !== 4) return next(error);
		try {
			fn(error, req, res, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Handle the request for the layer.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer.prototype.handle_request = function handle(req, res, next) {
		var fn = this.handle;
		if (fn.length > 3) return next();
		try {
			fn(req, res, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Check if this route matches `path`, if so
	* populate `.params`.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	Layer.prototype.match = function match(path) {
		var match;
		if (path != null) {
			if (this.regexp.fast_slash) {
				this.params = {};
				this.path = "";
				return true;
			}
			if (this.regexp.fast_star) {
				this.params = { "0": decode_param(path) };
				this.path = path;
				return true;
			}
			match = this.regexp.exec(path);
		}
		if (!match) {
			this.params = void 0;
			this.path = void 0;
			return false;
		}
		this.params = {};
		this.path = match[0];
		var keys = this.keys;
		var params = this.params;
		for (var i = 1; i < match.length; i++) {
			var prop = keys[i - 1].name;
			var val = decode_param(match[i]);
			if (val !== void 0 || !hasOwnProperty.call(params, prop)) params[prop] = val;
		}
		return true;
	};
	/**
	* Decode param value.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function decode_param(val) {
		if (typeof val !== "string" || val.length === 0) return val;
		try {
			return decodeURIComponent(val);
		} catch (err) {
			if (err instanceof URIError) {
				err.message = "Failed to decode param '" + val + "'";
				err.status = err.statusCode = 400;
			}
			throw err;
		}
	}
}));

//#endregion
//#region ../../node_modules/methods/index.js
/*!
* methods
* Copyright(c) 2013-2014 TJ Holowaychuk
* Copyright(c) 2015-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_methods = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var http$5 = require("http");
	/**
	* Module exports.
	* @public
	*/
	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
	/**
	* Get the current Node.js methods.
	* @private
	*/
	function getCurrentNodeMethods() {
		return http$5.METHODS && http$5.METHODS.map(function lowerCaseMethod(method) {
			return method.toLowerCase();
		});
	}
	/**
	* Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	* @private
	*/
	function getBasicNodeMethods() {
		return [
			"get",
			"post",
			"put",
			"head",
			"delete",
			"options",
			"trace",
			"copy",
			"lock",
			"mkcol",
			"move",
			"purge",
			"propfind",
			"proppatch",
			"unlock",
			"report",
			"mkactivity",
			"checkout",
			"merge",
			"m-search",
			"notify",
			"subscribe",
			"unsubscribe",
			"patch",
			"search",
			"connect"
		];
	}
}));

//#endregion
//#region ../../node_modules/express/lib/router/route.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_route = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src$3()("express:router:route");
	var flatten = require_array_flatten();
	var Layer = require_layer();
	var methods = require_methods();
	/**
	* Module variables.
	* @private
	*/
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Route;
	/**
	* Initialize `Route` with the given `path`,
	*
	* @param {String} path
	* @public
	*/
	function Route(path) {
		this.path = path;
		this.stack = [];
		debug("new %o", path);
		this.methods = {};
	}
	/**
	* Determine if the route handles a given method.
	* @private
	*/
	Route.prototype._handles_method = function _handles_method(method) {
		if (this.methods._all) return true;
		var name = typeof method === "string" ? method.toLowerCase() : method;
		if (name === "head" && !this.methods["head"]) name = "get";
		return Boolean(this.methods[name]);
	};
	/**
	* @return {Array} supported HTTP methods
	* @private
	*/
	Route.prototype._options = function _options() {
		var methods = Object.keys(this.methods);
		if (this.methods.get && !this.methods.head) methods.push("head");
		for (var i = 0; i < methods.length; i++) methods[i] = methods[i].toUpperCase();
		return methods;
	};
	/**
	* dispatch req, res into this route
	* @private
	*/
	Route.prototype.dispatch = function dispatch(req, res, done) {
		var idx = 0;
		var stack = this.stack;
		var sync = 0;
		if (stack.length === 0) return done();
		var method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
		if (method === "head" && !this.methods["head"]) method = "get";
		req.route = this;
		next();
		function next(err) {
			if (err && err === "route") return done();
			if (err && err === "router") return done(err);
			if (++sync > 100) return setImmediate(next, err);
			var layer = stack[idx++];
			if (!layer) return done(err);
			if (layer.method && layer.method !== method) next(err);
			else if (err) layer.handle_error(err, req, res, next);
			else layer.handle_request(req, res, next);
			sync = 0;
		}
	};
	/**
	* Add a handler for all HTTP verbs to this route.
	*
	* Behaves just like middleware and can respond or call `next`
	* to continue processing.
	*
	* You can use multiple `.all` call to add multiple handlers.
	*
	*   function check_something(req, res, next){
	*     next();
	*   };
	*
	*   function validate_user(req, res, next){
	*     next();
	*   };
	*
	*   route
	*   .all(validate_user)
	*   .all(check_something)
	*   .get(function(req, res, next){
	*     res.send('hello world');
	*   });
	*
	* @param {function} handler
	* @return {Route} for chaining
	* @api public
	*/
	Route.prototype.all = function all() {
		var handles = flatten(slice.call(arguments));
		for (var i = 0; i < handles.length; i++) {
			var handle = handles[i];
			if (typeof handle !== "function") {
				var msg = "Route.all() requires a callback function but got a " + toString.call(handle);
				throw new TypeError(msg);
			}
			var layer = Layer("/", {}, handle);
			layer.method = void 0;
			this.methods._all = true;
			this.stack.push(layer);
		}
		return this;
	};
	methods.forEach(function(method) {
		Route.prototype[method] = function() {
			var handles = flatten(slice.call(arguments));
			for (var i = 0; i < handles.length; i++) {
				var handle = handles[i];
				if (typeof handle !== "function") {
					var type = toString.call(handle);
					var msg = "Route." + method + "() requires a callback function but got a " + type;
					throw new Error(msg);
				}
				debug("%s %o", method, this.path);
				var layer = Layer("/", {}, handle);
				layer.method = method;
				this.methods[method] = true;
				this.stack.push(layer);
			}
			return this;
		};
	});
}));

//#endregion
//#region ../../node_modules/utils-merge/index.js
var require_utils_merge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Merge object b with object a.
	*
	*     var a = { foo: 'bar' }
	*       , b = { bar: 'baz' };
	*
	*     merge(a, b);
	*     // => { foo: 'bar', bar: 'baz' }
	*
	* @param {Object} a
	* @param {Object} b
	* @return {Object}
	* @api public
	*/
	exports = module.exports = function(a, b) {
		if (a && b) for (var key in b) a[key] = b[key];
		return a;
	};
}));

//#endregion
//#region ../../node_modules/express/lib/router/index.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_router = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Route = require_route();
	var Layer = require_layer();
	var methods = require_methods();
	var mixin = require_utils_merge();
	var debug = require_src$3()("express:router");
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var parseUrl = require_parseurl();
	var setPrototypeOf = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;
	/**
	* Initialize a new `Router` with the given `options`.
	*
	* @param {Object} [options]
	* @return {Router} which is a callable function
	* @public
	*/
	var proto = module.exports = function(options) {
		var opts = options || {};
		function router(req, res, next) {
			router.handle(req, res, next);
		}
		setPrototypeOf(router, proto);
		router.params = {};
		router._params = [];
		router.caseSensitive = opts.caseSensitive;
		router.mergeParams = opts.mergeParams;
		router.strict = opts.strict;
		router.stack = [];
		return router;
	};
	/**
	* Map the given param placeholder `name`(s) to the given callback.
	*
	* Parameter mapping is used to provide pre-conditions to routes
	* which use normalized placeholders. For example a _:user_id_ parameter
	* could automatically load a user's information from the database without
	* any additional code,
	*
	* The callback uses the same signature as middleware, the only difference
	* being that the value of the placeholder is passed, in this case the _id_
	* of the user. Once the `next()` function is invoked, just like middleware
	* it will continue on to execute the route, or subsequent parameter functions.
	*
	* Just like in middleware, you must either respond to the request or call next
	* to avoid stalling the request.
	*
	*  app.param('user_id', function(req, res, next, id){
	*    User.find(id, function(err, user){
	*      if (err) {
	*        return next(err);
	*      } else if (!user) {
	*        return next(new Error('failed to load user'));
	*      }
	*      req.user = user;
	*      next();
	*    });
	*  });
	*
	* @param {String} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	proto.param = function param(name, fn) {
		if (typeof name === "function") {
			deprecate("router.param(fn): Refactor to use path params");
			this._params.push(name);
			return;
		}
		var params = this._params;
		var len = params.length;
		var ret;
		if (name[0] === ":") {
			deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
			name = name.slice(1);
		}
		for (var i = 0; i < len; ++i) if (ret = params[i](name, fn)) fn = ret;
		if ("function" !== typeof fn) throw new Error("invalid param() call for " + name + ", got " + fn);
		(this.params[name] = this.params[name] || []).push(fn);
		return this;
	};
	/**
	* Dispatch a req, res into the router.
	* @private
	*/
	proto.handle = function handle(req, res, out) {
		var self = this;
		debug("dispatching %s %s", req.method, req.url);
		var idx = 0;
		var protohost = getProtohost(req.url) || "";
		var removed = "";
		var slashAdded = false;
		var sync = 0;
		var paramcalled = {};
		var options = [];
		var stack = self.stack;
		var parentParams = req.params;
		var parentUrl = req.baseUrl || "";
		var done = restore(out, req, "baseUrl", "next", "params");
		req.next = next;
		if (req.method === "OPTIONS") done = wrap(done, function(old, err) {
			if (err || options.length === 0) return old(err);
			sendOptionsResponse(res, options, old);
		});
		req.baseUrl = parentUrl;
		req.originalUrl = req.originalUrl || req.url;
		next();
		function next(err) {
			var layerError = err === "route" ? null : err;
			if (slashAdded) {
				req.url = req.url.slice(1);
				slashAdded = false;
			}
			if (removed.length !== 0) {
				req.baseUrl = parentUrl;
				req.url = protohost + removed + req.url.slice(protohost.length);
				removed = "";
			}
			if (layerError === "router") {
				setImmediate(done, null);
				return;
			}
			if (idx >= stack.length) {
				setImmediate(done, layerError);
				return;
			}
			if (++sync > 100) return setImmediate(next, err);
			var path = getPathname(req);
			if (path == null) return done(layerError);
			var layer;
			var match;
			var route;
			while (match !== true && idx < stack.length) {
				layer = stack[idx++];
				match = matchLayer(layer, path);
				route = layer.route;
				if (typeof match !== "boolean") layerError = layerError || match;
				if (match !== true) continue;
				if (!route) continue;
				if (layerError) {
					match = false;
					continue;
				}
				var method = req.method;
				var has_method = route._handles_method(method);
				if (!has_method && method === "OPTIONS") appendMethods(options, route._options());
				if (!has_method && method !== "HEAD") match = false;
			}
			if (match !== true) return done(layerError);
			if (route) req.route = route;
			req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
			var layerPath = layer.path;
			self.process_params(layer, paramcalled, req, res, function(err) {
				if (err) next(layerError || err);
				else if (route) layer.handle_request(req, res, next);
				else trim_prefix(layer, layerError, layerPath, path);
				sync = 0;
			});
		}
		function trim_prefix(layer, layerError, layerPath, path) {
			if (layerPath.length !== 0) {
				if (layerPath !== path.slice(0, layerPath.length)) {
					next(layerError);
					return;
				}
				var c = path[layerPath.length];
				if (c && c !== "/" && c !== ".") return next(layerError);
				debug("trim prefix (%s) from url %s", layerPath, req.url);
				removed = layerPath;
				req.url = protohost + req.url.slice(protohost.length + removed.length);
				if (!protohost && req.url[0] !== "/") {
					req.url = "/" + req.url;
					slashAdded = true;
				}
				req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
			}
			debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
			if (layerError) layer.handle_error(layerError, req, res, next);
			else layer.handle_request(req, res, next);
		}
	};
	/**
	* Process any parameters for the layer.
	* @private
	*/
	proto.process_params = function process_params(layer, called, req, res, done) {
		var params = this.params;
		var keys = layer.keys;
		if (!keys || keys.length === 0) return done();
		var i = 0;
		var name;
		var paramIndex = 0;
		var key;
		var paramVal;
		var paramCallbacks;
		var paramCalled;
		function param(err) {
			if (err) return done(err);
			if (i >= keys.length) return done();
			paramIndex = 0;
			key = keys[i++];
			name = key.name;
			paramVal = req.params[name];
			paramCallbacks = params[name];
			paramCalled = called[name];
			if (paramVal === void 0 || !paramCallbacks) return param();
			if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
				req.params[name] = paramCalled.value;
				return param(paramCalled.error);
			}
			called[name] = paramCalled = {
				error: null,
				match: paramVal,
				value: paramVal
			};
			paramCallback();
		}
		function paramCallback(err) {
			var fn = paramCallbacks[paramIndex++];
			paramCalled.value = req.params[key.name];
			if (err) {
				paramCalled.error = err;
				param(err);
				return;
			}
			if (!fn) return param();
			try {
				fn(req, res, paramCallback, paramVal, key.name);
			} catch (e) {
				paramCallback(e);
			}
		}
		param();
	};
	/**
	* Use the given middleware function, with optional path, defaulting to "/".
	*
	* Use (like `.all`) will run for any http METHOD, but it will not add
	* handlers for those methods so OPTIONS requests will not consider `.use`
	* functions even if they could respond.
	*
	* The other difference is that _route_ path is stripped and not visible
	* to the handler function. The main effect of this feature is that mounted
	* handlers can operate without any code changes regardless of the "prefix"
	* pathname.
	*
	* @public
	*/
	proto.use = function use(fn) {
		var offset = 0;
		var path = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path = fn;
			}
		}
		var callbacks = flatten(slice.call(arguments, offset));
		if (callbacks.length === 0) throw new TypeError("Router.use() requires a middleware function");
		for (var i = 0; i < callbacks.length; i++) {
			var fn = callbacks[i];
			if (typeof fn !== "function") throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
			debug("use %o %s", path, fn.name || "<anonymous>");
			var layer = new Layer(path, {
				sensitive: this.caseSensitive,
				strict: false,
				end: false
			}, fn);
			layer.route = void 0;
			this.stack.push(layer);
		}
		return this;
	};
	/**
	* Create a new Route for the given path.
	*
	* Each route contains a separate middleware stack and VERB handlers.
	*
	* See the Route api documentation for details on adding handlers
	* and middleware to routes.
	*
	* @param {String} path
	* @return {Route}
	* @public
	*/
	proto.route = function route(path) {
		var route = new Route(path);
		var layer = new Layer(path, {
			sensitive: this.caseSensitive,
			strict: this.strict,
			end: true
		}, route.dispatch.bind(route));
		layer.route = route;
		this.stack.push(layer);
		return route;
	};
	methods.concat("all").forEach(function(method) {
		proto[method] = function(path) {
			var route = this.route(path);
			route[method].apply(route, slice.call(arguments, 1));
			return this;
		};
	});
	function appendMethods(list, addition) {
		for (var i = 0; i < addition.length; i++) {
			var method = addition[i];
			if (list.indexOf(method) === -1) list.push(method);
		}
	}
	function getPathname(req) {
		try {
			return parseUrl(req).pathname;
		} catch (err) {
			return;
		}
	}
	function getProtohost(url) {
		if (typeof url !== "string" || url.length === 0 || url[0] === "/") return;
		var searchIndex = url.indexOf("?");
		var pathLength = searchIndex !== -1 ? searchIndex : url.length;
		var fqdnIndex = url.slice(0, pathLength).indexOf("://");
		return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
	}
	function gettype(obj) {
		var type = typeof obj;
		if (type !== "object") return type;
		return toString.call(obj).replace(objectRegExp, "$1");
	}
	/**
	* Match path to a layer.
	*
	* @param {Layer} layer
	* @param {string} path
	* @private
	*/
	function matchLayer(layer, path) {
		try {
			return layer.match(path);
		} catch (err) {
			return err;
		}
	}
	function mergeParams(params, parent) {
		if (typeof parent !== "object" || !parent) return params;
		var obj = mixin({}, parent);
		if (!(0 in params) || !(0 in parent)) return mixin(obj, params);
		var i = 0;
		var o = 0;
		while (i in params) i++;
		while (o in parent) o++;
		for (i--; i >= 0; i--) {
			params[i + o] = params[i];
			if (i < o) delete params[i];
		}
		return mixin(obj, params);
	}
	function restore(fn, obj) {
		var props = new Array(arguments.length - 2);
		var vals = new Array(arguments.length - 2);
		for (var i = 0; i < props.length; i++) {
			props[i] = arguments[i + 2];
			vals[i] = obj[props[i]];
		}
		return function() {
			for (var i = 0; i < props.length; i++) obj[props[i]] = vals[i];
			return fn.apply(this, arguments);
		};
	}
	function sendOptionsResponse(res, options, next) {
		try {
			var body = options.join(",");
			res.set("Allow", body);
			res.send(body);
		} catch (err) {
			next(err);
		}
	}
	function wrap(old, fn) {
		return function proxy() {
			var args = new Array(arguments.length + 1);
			args[0] = old;
			for (var i = 0, len = arguments.length; i < len; i++) args[i + 1] = arguments[i];
			fn.apply(this, args);
		};
	}
}));

//#endregion
//#region ../../node_modules/express/lib/middleware/init.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_init = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var setPrototypeOf = require_setprototypeof();
	/**
	* Initialization middleware, exposing the
	* request and response to each other, as well
	* as defaulting the X-Powered-By header field.
	*
	* @param {Function} app
	* @return {Function}
	* @api private
	*/
	exports.init = function(app) {
		return function expressInit(req, res, next) {
			if (app.enabled("x-powered-by")) res.setHeader("X-Powered-By", "Express");
			req.res = res;
			res.req = req;
			req.next = next;
			setPrototypeOf(req, app.request);
			setPrototypeOf(res, app.response);
			res.locals = res.locals || Object.create(null);
			next();
		};
	};
}));

//#endregion
//#region ../../node_modules/express/lib/middleware/query.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_query = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var merge = require_utils_merge();
	var parseUrl = require_parseurl();
	var qs = require_lib();
	/**
	* @param {Object} options
	* @return {Function}
	* @api public
	*/
	module.exports = function query(options) {
		var opts = merge({}, options);
		var queryparse = qs.parse;
		if (typeof options === "function") {
			queryparse = options;
			opts = void 0;
		}
		if (opts !== void 0 && opts.allowPrototypes === void 0) opts.allowPrototypes = true;
		return function query(req, res, next) {
			if (!req.query) {
				var val = parseUrl(req).query;
				req.query = queryparse(val, opts);
			}
			next();
		};
	};
}));

//#endregion
//#region ../../node_modules/express/lib/view.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_view = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug = require_src$3()("express:view");
	var path$15 = require("path");
	var fs$20 = require("fs");
	/**
	* Module variables.
	* @private
	*/
	var dirname = path$15.dirname;
	var basename = path$15.basename;
	var extname = path$15.extname;
	var join = path$15.join;
	var resolve = path$15.resolve;
	/**
	* Module exports.
	* @public
	*/
	module.exports = View;
	/**
	* Initialize a new `View` with the given `name`.
	*
	* Options:
	*
	*   - `defaultEngine` the default template engine name
	*   - `engines` template engine require() cache
	*   - `root` root path for view lookup
	*
	* @param {string} name
	* @param {object} options
	* @public
	*/
	function View(name, options) {
		var opts = options || {};
		this.defaultEngine = opts.defaultEngine;
		this.ext = extname(name);
		this.name = name;
		this.root = opts.root;
		if (!this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
		var fileName = name;
		if (!this.ext) {
			this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
			fileName += this.ext;
		}
		if (!opts.engines[this.ext]) {
			var mod = this.ext.slice(1);
			debug("require \"%s\"", mod);
			var fn = require(mod).__express;
			if (typeof fn !== "function") throw new Error("Module \"" + mod + "\" does not provide a view engine.");
			opts.engines[this.ext] = fn;
		}
		this.engine = opts.engines[this.ext];
		this.path = this.lookup(fileName);
	}
	/**
	* Lookup view by the given `name`
	*
	* @param {string} name
	* @private
	*/
	View.prototype.lookup = function lookup(name) {
		var path$67;
		var roots = [].concat(this.root);
		debug("lookup \"%s\"", name);
		for (var i = 0; i < roots.length && !path$67; i++) {
			var root = roots[i];
			var loc = resolve(root, name);
			var dir = dirname(loc);
			var file = basename(loc);
			path$67 = this.resolve(dir, file);
		}
		return path$67;
	};
	/**
	* Render with the given options.
	*
	* @param {object} options
	* @param {function} callback
	* @private
	*/
	View.prototype.render = function render(options, callback) {
		debug("render \"%s\"", this.path);
		this.engine(this.path, options, callback);
	};
	/**
	* Resolve the file within the given directory.
	*
	* @param {string} dir
	* @param {string} file
	* @private
	*/
	View.prototype.resolve = function resolve(dir, file) {
		var ext = this.ext;
		var path$68 = join(dir, file);
		var stat = tryStat(path$68);
		if (stat && stat.isFile()) return path$68;
		path$68 = join(dir, basename(file, ext), "index" + ext);
		stat = tryStat(path$68);
		if (stat && stat.isFile()) return path$68;
	};
	/**
	* Return a stat, maybe.
	*
	* @param {string} path
	* @return {fs.Stats}
	* @private
	*/
	function tryStat(path$69) {
		debug("stat \"%s\"", path$69);
		try {
			return fs$20.statSync(path$69);
		} catch (e) {
			return;
		}
	}
}));

//#endregion
//#region ../../node_modules/express/node_modules/safe-buffer/index.js
var require_safe_buffer$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer$1 = require("buffer");
	var Buffer = buffer$1.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer$1;
	else {
		copyProps(buffer$1, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer.prototype);
	copyProps(Buffer, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer$1.SlowBuffer(size);
	};
}));

//#endregion
//#region ../../node_modules/content-disposition/node_modules/safe-buffer/index.js
var require_safe_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = require("buffer");
	var Buffer = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer.prototype);
	copyProps(Buffer, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}));

//#endregion
//#region ../../node_modules/content-disposition/index.js
/*!
* content-disposition
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_content_disposition = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = contentDisposition;
	module.exports.parse = parse;
	/**
	* Module dependencies.
	* @private
	*/
	var basename = require("path").basename;
	var Buffer = require_safe_buffer().Buffer;
	/**
	* RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	* @private
	*/
	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
	/**
	* RegExp to match percent encoding escape.
	* @private
	*/
	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
	/**
	* RegExp to match non-latin1 characters.
	* @private
	*/
	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	* @private
	*/
	var QESC_REGEXP = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	* @private
	*/
	var QUOTE_REGEXP = /([\\"])/g;
	/**
	* RegExp for various RFC 2616 grammar
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* HT            = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	* @private
	*/
	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
	/**
	* RegExp for various RFC 5987 grammar
	*
	* ext-value     = charset  "'" [ language ] "'" value-chars
	* charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	* mime-charset  = 1*mime-charsetc
	* mime-charsetc = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "%" / "&"
	*               / "+" / "-" / "^" / "_" / "`"
	*               / "{" / "}" / "~"
	* language      = ( 2*3ALPHA [ extlang ] )
	*               / 4ALPHA
	*               / 5*8ALPHA
	* extlang       = *3( "-" 3ALPHA )
	* value-chars   = *( pct-encoded / attr-char )
	* pct-encoded   = "%" HEXDIG HEXDIG
	* attr-char     = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	*               / "^" / "_" / "`" / "|" / "~"
	* @private
	*/
	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
	/**
	* RegExp for various RFC 6266 grammar
	*
	* disposition-type = "inline" | "attachment" | disp-ext-type
	* disp-ext-type    = token
	* disposition-parm = filename-parm | disp-ext-parm
	* filename-parm    = "filename" "=" value
	*                  | "filename*" "=" ext-value
	* disp-ext-parm    = token "=" value
	*                  | ext-token "=" ext-value
	* ext-token        = <the characters in token, followed by "*">
	* @private
	*/
	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
	/**
	* Create an attachment Content-Disposition header.
	*
	* @param {string} [filename]
	* @param {object} [options]
	* @param {string} [options.type=attachment]
	* @param {string|boolean} [options.fallback=true]
	* @return {string}
	* @public
	*/
	function contentDisposition(filename, options) {
		var opts = options || {};
		return format(new ContentDisposition(opts.type || "attachment", createparams(filename, opts.fallback)));
	}
	/**
	* Create parameters object from filename and fallback.
	*
	* @param {string} [filename]
	* @param {string|boolean} [fallback=true]
	* @return {object}
	* @private
	*/
	function createparams(filename, fallback) {
		if (filename === void 0) return;
		var params = {};
		if (typeof filename !== "string") throw new TypeError("filename must be a string");
		if (fallback === void 0) fallback = true;
		if (typeof fallback !== "string" && typeof fallback !== "boolean") throw new TypeError("fallback must be a string or boolean");
		if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError("fallback must be ISO-8859-1 string");
		var name = basename(filename);
		var isQuotedString = TEXT_REGEXP.test(name);
		var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
		var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
		if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params["filename*"] = name;
		if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
		return params;
	}
	/**
	* Format object to Content-Disposition header.
	*
	* @param {object} obj
	* @param {string} obj.type
	* @param {object} [obj.parameters]
	* @return {string}
	* @private
	*/
	function format(obj) {
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = String(type).toLowerCase();
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i = 0; i < params.length; i++) {
				param = params[i];
				var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
				string += "; " + param + "=" + val;
			}
		}
		return string;
	}
	/**
	* Decode a RFC 5987 field value (gracefully).
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function decodefield(str) {
		var match = EXT_VALUE_REGEXP.exec(str);
		if (!match) throw new TypeError("invalid extended field value");
		var charset = match[1].toLowerCase();
		var encoded = match[2];
		var value;
		var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
		switch (charset) {
			case "iso-8859-1":
				value = getlatin1(binary);
				break;
			case "utf-8":
				value = Buffer.from(binary, "binary").toString("utf8");
				break;
			default: throw new TypeError("unsupported charset in extended field");
		}
		return value;
	}
	/**
	* Get ISO-8859-1 version of string.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function getlatin1(val) {
		return String(val).replace(NON_LATIN1_REGEXP, "?");
	}
	/**
	* Parse Content-Disposition header string.
	*
	* @param {string} string
	* @return {object}
	* @public
	*/
	function parse(string) {
		if (!string || typeof string !== "string") throw new TypeError("argument string is required");
		var match = DISPOSITION_TYPE_REGEXP.exec(string);
		if (!match) throw new TypeError("invalid type format");
		var index = match[0].length;
		var type = match[1].toLowerCase();
		var key;
		var names = [];
		var params = {};
		var value;
		index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
		while (match = PARAM_REGEXP.exec(string)) {
			if (match.index !== index) throw new TypeError("invalid parameter format");
			index += match[0].length;
			key = match[1].toLowerCase();
			value = match[2];
			if (names.indexOf(key) !== -1) throw new TypeError("invalid duplicate parameter");
			names.push(key);
			if (key.indexOf("*") + 1 === key.length) {
				key = key.slice(0, -1);
				value = decodefield(value);
				params[key] = value;
				continue;
			}
			if (typeof params[key] === "string") continue;
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
			params[key] = value;
		}
		if (index !== -1 && index !== string.length) throw new TypeError("invalid parameter format");
		return new ContentDisposition(type, params);
	}
	/**
	* Percent decode a single character.
	*
	* @param {string} str
	* @param {string} hex
	* @return {string}
	* @private
	*/
	function pdecode(str, hex) {
		return String.fromCharCode(parseInt(hex, 16));
	}
	/**
	* Percent encode a single character.
	*
	* @param {string} char
	* @return {string}
	* @private
	*/
	function pencode(char) {
		return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
	}
	/**
	* Quote a string for HTTP.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring(val) {
		return "\"" + String(val).replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	/**
	* Encode a Unicode string for HTTP (RFC 5987).
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function ustring(val) {
		var str = String(val);
		return "UTF-8''" + encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
	}
	/**
	* Class for parsed Content-Disposition header for v8 optimization
	*
	* @public
	* @param {string} type
	* @param {object} parameters
	* @constructor
	*/
	function ContentDisposition(type, parameters) {
		this.type = type;
		this.parameters = parameters;
	}
}));

//#endregion
//#region ../../node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		if (ms >= d) return Math.round(ms / d) + "d";
		if (ms >= h) return Math.round(ms / h) + "h";
		if (ms >= m) return Math.round(ms / m) + "m";
		if (ms >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, n, name) {
		if (ms < n) return;
		if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
		return Math.ceil(ms / n) + " " + name + "s";
	}
}));

//#endregion
//#region ../../node_modules/send/node_modules/debug/src/debug.js
var require_debug = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms$1();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i;
		for (i in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug() {
			if (!debug.enabled) return;
			var self = debug;
			var curr = +/* @__PURE__ */ new Date();
			self.diff = curr - (prevTime || curr);
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
				if (match === "%%") return match;
				index++;
				var formatter = exports.formatters[format];
				if ("function" === typeof formatter) {
					var val = args[index];
					match = formatter.call(self, val);
					args.splice(index, 1);
					index--;
				}
				return match;
			});
			exports.formatArgs.call(self, args);
			(debug.log || exports.log || console.log.bind(console)).apply(self, args);
		}
		debug.namespace = namespace;
		debug.enabled = exports.enabled(namespace);
		debug.useColors = exports.useColors();
		debug.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug);
		return debug;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len = split.length;
		for (var i = 0; i < len; i++) {
			if (!split[i]) continue;
			namespaces = split[i].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i, len;
		for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
		for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}));

//#endregion
//#region ../../node_modules/send/node_modules/debug/src/browser.js
var require_browser$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var useColors = this.useColors;
		args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if ("%%" === match) return;
			index++;
			if ("%c" === match) lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}));

//#endregion
//#region ../../node_modules/send/node_modules/debug/src/node.js
var require_node$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty$2 = require("tty");
	var util$2 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key) {
		return /^debug_/i.test(key);
	}).reduce(function(obj, key) {
		var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
			return k.toUpperCase();
		});
		var val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$2.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log() {
		return stream.write(util$2.format.apply(util$2, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream(fd) {
		var stream;
		switch (process.binding("tty_wrap").guessHandleType(fd)) {
			case "TTY":
				stream = new tty$2.WriteStream(fd);
				stream._type = "tty";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			case "FILE":
				stream = new (require("fs")).SyncWriteStream(fd, { autoClose: false });
				stream._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream = new (require("net")).Socket({
					fd,
					readable: false,
					writable: true
				});
				stream.readable = false;
				stream.read = null;
				stream._type = "pipe";
				if (stream._handle && stream._handle.unref) stream._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream.fd = fd;
		stream._isStdio = true;
		return stream;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		var keys = Object.keys(exports.inspectOpts);
		for (var i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}));

//#endregion
//#region ../../node_modules/send/node_modules/debug/src/index.js
var require_src$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser$1();
	else module.exports = require_node$1();
}));

//#endregion
//#region ../../node_modules/etag/index.js
/*!
* etag
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_etag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = etag;
	/**
	* Module dependencies.
	* @private
	*/
	var crypto$1 = require("crypto");
	var Stats = require("fs").Stats;
	/**
	* Module variables.
	* @private
	*/
	var toString = Object.prototype.toString;
	/**
	* Generate an entity tag.
	*
	* @param {Buffer|string} entity
	* @return {string}
	* @private
	*/
	function entitytag(entity) {
		if (entity.length === 0) return "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"";
		var hash = crypto$1.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
		return "\"" + (typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length).toString(16) + "-" + hash + "\"";
	}
	/**
	* Create a simple ETag.
	*
	* @param {string|Buffer|Stats} entity
	* @param {object} [options]
	* @param {boolean} [options.weak]
	* @return {String}
	* @public
	*/
	function etag(entity, options) {
		if (entity == null) throw new TypeError("argument entity is required");
		var isStats = isstats(entity);
		var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
		if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
		var tag = isStats ? stattag(entity) : entitytag(entity);
		return weak ? "W/" + tag : tag;
	}
	/**
	* Determine if object is a Stats object.
	*
	* @param {object} obj
	* @return {boolean}
	* @api private
	*/
	function isstats(obj) {
		if (typeof Stats === "function" && obj instanceof Stats) return true;
		return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
	}
	/**
	* Generate a tag for a stat.
	*
	* @param {object} stat
	* @return {string}
	* @private
	*/
	function stattag(stat) {
		var mtime = stat.mtime.getTime().toString(16);
		return "\"" + stat.size.toString(16) + "-" + mtime + "\"";
	}
}));

//#endregion
//#region ../../node_modules/fresh/index.js
/*!
* fresh
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2016-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_fresh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* RegExp to check for no-cache token in Cache-Control.
	* @private
	*/
	var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = fresh;
	/**
	* Check freshness of the response using request and response headers.
	*
	* @param {Object} reqHeaders
	* @param {Object} resHeaders
	* @return {Boolean}
	* @public
	*/
	function fresh(reqHeaders, resHeaders) {
		var modifiedSince = reqHeaders["if-modified-since"];
		var noneMatch = reqHeaders["if-none-match"];
		if (!modifiedSince && !noneMatch) return false;
		var cacheControl = reqHeaders["cache-control"];
		if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
		if (noneMatch && noneMatch !== "*") {
			var etag = resHeaders["etag"];
			if (!etag) return false;
			var etagStale = true;
			var matches = parseTokenList(noneMatch);
			for (var i = 0; i < matches.length; i++) {
				var match = matches[i];
				if (match === etag || match === "W/" + etag || "W/" + match === etag) {
					etagStale = false;
					break;
				}
			}
			if (etagStale) return false;
		}
		if (modifiedSince) {
			var lastModified = resHeaders["last-modified"];
			if (!lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))) return false;
		}
		return true;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate(date) {
		var timestamp = date && Date.parse(date);
		// istanbul ignore next: guard against date.js Date.parse patching
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(str.substring(start, end));
		return list;
	}
}));

//#endregion
//#region ../../node_modules/send/node_modules/mime/types.json
var require_types = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"application/andrew-inset": ["ez"],
		"application/applixware": ["aw"],
		"application/atom+xml": ["atom"],
		"application/atomcat+xml": ["atomcat"],
		"application/atomsvc+xml": ["atomsvc"],
		"application/bdoc": ["bdoc"],
		"application/ccxml+xml": ["ccxml"],
		"application/cdmi-capability": ["cdmia"],
		"application/cdmi-container": ["cdmic"],
		"application/cdmi-domain": ["cdmid"],
		"application/cdmi-object": ["cdmio"],
		"application/cdmi-queue": ["cdmiq"],
		"application/cu-seeme": ["cu"],
		"application/dash+xml": ["mpd"],
		"application/davmount+xml": ["davmount"],
		"application/docbook+xml": ["dbk"],
		"application/dssc+der": ["dssc"],
		"application/dssc+xml": ["xdssc"],
		"application/ecmascript": ["ecma"],
		"application/emma+xml": ["emma"],
		"application/epub+zip": ["epub"],
		"application/exi": ["exi"],
		"application/font-tdpfr": ["pfr"],
		"application/font-woff": [],
		"application/font-woff2": [],
		"application/geo+json": ["geojson"],
		"application/gml+xml": ["gml"],
		"application/gpx+xml": ["gpx"],
		"application/gxf": ["gxf"],
		"application/gzip": ["gz"],
		"application/hyperstudio": ["stk"],
		"application/inkml+xml": ["ink", "inkml"],
		"application/ipfix": ["ipfix"],
		"application/java-archive": [
			"jar",
			"war",
			"ear"
		],
		"application/java-serialized-object": ["ser"],
		"application/java-vm": ["class"],
		"application/javascript": ["js", "mjs"],
		"application/json": ["json", "map"],
		"application/json5": ["json5"],
		"application/jsonml+json": ["jsonml"],
		"application/ld+json": ["jsonld"],
		"application/lost+xml": ["lostxml"],
		"application/mac-binhex40": ["hqx"],
		"application/mac-compactpro": ["cpt"],
		"application/mads+xml": ["mads"],
		"application/manifest+json": ["webmanifest"],
		"application/marc": ["mrc"],
		"application/marcxml+xml": ["mrcx"],
		"application/mathematica": [
			"ma",
			"nb",
			"mb"
		],
		"application/mathml+xml": ["mathml"],
		"application/mbox": ["mbox"],
		"application/mediaservercontrol+xml": ["mscml"],
		"application/metalink+xml": ["metalink"],
		"application/metalink4+xml": ["meta4"],
		"application/mets+xml": ["mets"],
		"application/mods+xml": ["mods"],
		"application/mp21": ["m21", "mp21"],
		"application/mp4": ["mp4s", "m4p"],
		"application/msword": ["doc", "dot"],
		"application/mxf": ["mxf"],
		"application/octet-stream": [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"exe",
			"dll",
			"deb",
			"dmg",
			"iso",
			"img",
			"msi",
			"msp",
			"msm",
			"buffer"
		],
		"application/oda": ["oda"],
		"application/oebps-package+xml": ["opf"],
		"application/ogg": ["ogx"],
		"application/omdoc+xml": ["omdoc"],
		"application/onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"application/oxps": ["oxps"],
		"application/patch-ops-error+xml": ["xer"],
		"application/pdf": ["pdf"],
		"application/pgp-encrypted": ["pgp"],
		"application/pgp-signature": ["asc", "sig"],
		"application/pics-rules": ["prf"],
		"application/pkcs10": ["p10"],
		"application/pkcs7-mime": ["p7m", "p7c"],
		"application/pkcs7-signature": ["p7s"],
		"application/pkcs8": ["p8"],
		"application/pkix-attr-cert": ["ac"],
		"application/pkix-cert": ["cer"],
		"application/pkix-crl": ["crl"],
		"application/pkix-pkipath": ["pkipath"],
		"application/pkixcmp": ["pki"],
		"application/pls+xml": ["pls"],
		"application/postscript": [
			"ai",
			"eps",
			"ps"
		],
		"application/prs.cww": ["cww"],
		"application/pskc+xml": ["pskcxml"],
		"application/raml+yaml": ["raml"],
		"application/rdf+xml": ["rdf"],
		"application/reginfo+xml": ["rif"],
		"application/relax-ng-compact-syntax": ["rnc"],
		"application/resource-lists+xml": ["rl"],
		"application/resource-lists-diff+xml": ["rld"],
		"application/rls-services+xml": ["rs"],
		"application/rpki-ghostbusters": ["gbr"],
		"application/rpki-manifest": ["mft"],
		"application/rpki-roa": ["roa"],
		"application/rsd+xml": ["rsd"],
		"application/rss+xml": ["rss"],
		"application/rtf": ["rtf"],
		"application/sbml+xml": ["sbml"],
		"application/scvp-cv-request": ["scq"],
		"application/scvp-cv-response": ["scs"],
		"application/scvp-vp-request": ["spq"],
		"application/scvp-vp-response": ["spp"],
		"application/sdp": ["sdp"],
		"application/set-payment-initiation": ["setpay"],
		"application/set-registration-initiation": ["setreg"],
		"application/shf+xml": ["shf"],
		"application/smil+xml": ["smi", "smil"],
		"application/sparql-query": ["rq"],
		"application/sparql-results+xml": ["srx"],
		"application/srgs": ["gram"],
		"application/srgs+xml": ["grxml"],
		"application/sru+xml": ["sru"],
		"application/ssdl+xml": ["ssdl"],
		"application/ssml+xml": ["ssml"],
		"application/tei+xml": ["tei", "teicorpus"],
		"application/thraud+xml": ["tfi"],
		"application/timestamped-data": ["tsd"],
		"application/vnd.3gpp.pic-bw-large": ["plb"],
		"application/vnd.3gpp.pic-bw-small": ["psb"],
		"application/vnd.3gpp.pic-bw-var": ["pvb"],
		"application/vnd.3gpp2.tcap": ["tcap"],
		"application/vnd.3m.post-it-notes": ["pwn"],
		"application/vnd.accpac.simply.aso": ["aso"],
		"application/vnd.accpac.simply.imp": ["imp"],
		"application/vnd.acucobol": ["acu"],
		"application/vnd.acucorp": ["atc", "acutc"],
		"application/vnd.adobe.air-application-installer-package+zip": ["air"],
		"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
		"application/vnd.adobe.fxp": ["fxp", "fxpl"],
		"application/vnd.adobe.xdp+xml": ["xdp"],
		"application/vnd.adobe.xfdf": ["xfdf"],
		"application/vnd.ahead.space": ["ahead"],
		"application/vnd.airzip.filesecure.azf": ["azf"],
		"application/vnd.airzip.filesecure.azs": ["azs"],
		"application/vnd.amazon.ebook": ["azw"],
		"application/vnd.americandynamics.acc": ["acc"],
		"application/vnd.amiga.ami": ["ami"],
		"application/vnd.android.package-archive": ["apk"],
		"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
		"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
		"application/vnd.antix.game-component": ["atx"],
		"application/vnd.apple.installer+xml": ["mpkg"],
		"application/vnd.apple.mpegurl": ["m3u8"],
		"application/vnd.apple.pkpass": ["pkpass"],
		"application/vnd.aristanetworks.swi": ["swi"],
		"application/vnd.astraea-software.iota": ["iota"],
		"application/vnd.audiograph": ["aep"],
		"application/vnd.blueice.multipass": ["mpm"],
		"application/vnd.bmi": ["bmi"],
		"application/vnd.businessobjects": ["rep"],
		"application/vnd.chemdraw+xml": ["cdxml"],
		"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
		"application/vnd.cinderella": ["cdy"],
		"application/vnd.claymore": ["cla"],
		"application/vnd.cloanto.rp9": ["rp9"],
		"application/vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
		"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
		"application/vnd.commonspace": ["csp"],
		"application/vnd.contact.cmsg": ["cdbcmsg"],
		"application/vnd.cosmocaller": ["cmc"],
		"application/vnd.crick.clicker": ["clkx"],
		"application/vnd.crick.clicker.keyboard": ["clkk"],
		"application/vnd.crick.clicker.palette": ["clkp"],
		"application/vnd.crick.clicker.template": ["clkt"],
		"application/vnd.crick.clicker.wordbank": ["clkw"],
		"application/vnd.criticaltools.wbs+xml": ["wbs"],
		"application/vnd.ctc-posml": ["pml"],
		"application/vnd.cups-ppd": ["ppd"],
		"application/vnd.curl.car": ["car"],
		"application/vnd.curl.pcurl": ["pcurl"],
		"application/vnd.dart": ["dart"],
		"application/vnd.data-vision.rdz": ["rdz"],
		"application/vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
		"application/vnd.dece.unspecified": ["uvx", "uvvx"],
		"application/vnd.dece.zip": ["uvz", "uvvz"],
		"application/vnd.denovo.fcselayout-link": ["fe_launch"],
		"application/vnd.dna": ["dna"],
		"application/vnd.dolby.mlp": ["mlp"],
		"application/vnd.dpgraph": ["dpg"],
		"application/vnd.dreamfactory": ["dfac"],
		"application/vnd.ds-keypoint": ["kpxx"],
		"application/vnd.dvb.ait": ["ait"],
		"application/vnd.dvb.service": ["svc"],
		"application/vnd.dynageo": ["geo"],
		"application/vnd.ecowin.chart": ["mag"],
		"application/vnd.enliven": ["nml"],
		"application/vnd.epson.esf": ["esf"],
		"application/vnd.epson.msf": ["msf"],
		"application/vnd.epson.quickanime": ["qam"],
		"application/vnd.epson.salt": ["slt"],
		"application/vnd.epson.ssf": ["ssf"],
		"application/vnd.eszigno3+xml": ["es3", "et3"],
		"application/vnd.ezpix-album": ["ez2"],
		"application/vnd.ezpix-package": ["ez3"],
		"application/vnd.fdf": ["fdf"],
		"application/vnd.fdsn.mseed": ["mseed"],
		"application/vnd.fdsn.seed": ["seed", "dataless"],
		"application/vnd.flographit": ["gph"],
		"application/vnd.fluxtime.clip": ["ftc"],
		"application/vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"application/vnd.frogans.fnc": ["fnc"],
		"application/vnd.frogans.ltf": ["ltf"],
		"application/vnd.fsc.weblaunch": ["fsc"],
		"application/vnd.fujitsu.oasys": ["oas"],
		"application/vnd.fujitsu.oasys2": ["oa2"],
		"application/vnd.fujitsu.oasys3": ["oa3"],
		"application/vnd.fujitsu.oasysgp": ["fg5"],
		"application/vnd.fujitsu.oasysprs": ["bh2"],
		"application/vnd.fujixerox.ddd": ["ddd"],
		"application/vnd.fujixerox.docuworks": ["xdw"],
		"application/vnd.fujixerox.docuworks.binder": ["xbd"],
		"application/vnd.fuzzysheet": ["fzs"],
		"application/vnd.genomatix.tuxedo": ["txd"],
		"application/vnd.geogebra.file": ["ggb"],
		"application/vnd.geogebra.tool": ["ggt"],
		"application/vnd.geometry-explorer": ["gex", "gre"],
		"application/vnd.geonext": ["gxt"],
		"application/vnd.geoplan": ["g2w"],
		"application/vnd.geospace": ["g3w"],
		"application/vnd.gmx": ["gmx"],
		"application/vnd.google-apps.document": ["gdoc"],
		"application/vnd.google-apps.presentation": ["gslides"],
		"application/vnd.google-apps.spreadsheet": ["gsheet"],
		"application/vnd.google-earth.kml+xml": ["kml"],
		"application/vnd.google-earth.kmz": ["kmz"],
		"application/vnd.grafeq": ["gqf", "gqs"],
		"application/vnd.groove-account": ["gac"],
		"application/vnd.groove-help": ["ghf"],
		"application/vnd.groove-identity-message": ["gim"],
		"application/vnd.groove-injector": ["grv"],
		"application/vnd.groove-tool-message": ["gtm"],
		"application/vnd.groove-tool-template": ["tpl"],
		"application/vnd.groove-vcard": ["vcg"],
		"application/vnd.hal+xml": ["hal"],
		"application/vnd.handheld-entertainment+xml": ["zmm"],
		"application/vnd.hbci": ["hbci"],
		"application/vnd.hhe.lesson-player": ["les"],
		"application/vnd.hp-hpgl": ["hpgl"],
		"application/vnd.hp-hpid": ["hpid"],
		"application/vnd.hp-hps": ["hps"],
		"application/vnd.hp-jlyt": ["jlt"],
		"application/vnd.hp-pcl": ["pcl"],
		"application/vnd.hp-pclxl": ["pclxl"],
		"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
		"application/vnd.ibm.minipay": ["mpy"],
		"application/vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"application/vnd.ibm.rights-management": ["irm"],
		"application/vnd.ibm.secure-container": ["sc"],
		"application/vnd.iccprofile": ["icc", "icm"],
		"application/vnd.igloader": ["igl"],
		"application/vnd.immervision-ivp": ["ivp"],
		"application/vnd.immervision-ivu": ["ivu"],
		"application/vnd.insors.igm": ["igm"],
		"application/vnd.intercon.formnet": ["xpw", "xpx"],
		"application/vnd.intergeo": ["i2g"],
		"application/vnd.intu.qbo": ["qbo"],
		"application/vnd.intu.qfx": ["qfx"],
		"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
		"application/vnd.irepository.package+xml": ["irp"],
		"application/vnd.is-xpr": ["xpr"],
		"application/vnd.isac.fcs": ["fcs"],
		"application/vnd.jam": ["jam"],
		"application/vnd.jcp.javame.midlet-rms": ["rms"],
		"application/vnd.jisp": ["jisp"],
		"application/vnd.joost.joda-archive": ["joda"],
		"application/vnd.kahootz": ["ktz", "ktr"],
		"application/vnd.kde.karbon": ["karbon"],
		"application/vnd.kde.kchart": ["chrt"],
		"application/vnd.kde.kformula": ["kfo"],
		"application/vnd.kde.kivio": ["flw"],
		"application/vnd.kde.kontour": ["kon"],
		"application/vnd.kde.kpresenter": ["kpr", "kpt"],
		"application/vnd.kde.kspread": ["ksp"],
		"application/vnd.kde.kword": ["kwd", "kwt"],
		"application/vnd.kenameaapp": ["htke"],
		"application/vnd.kidspiration": ["kia"],
		"application/vnd.kinar": ["kne", "knp"],
		"application/vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"application/vnd.kodak-descriptor": ["sse"],
		"application/vnd.las.las+xml": ["lasxml"],
		"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
		"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
		"application/vnd.lotus-1-2-3": ["123"],
		"application/vnd.lotus-approach": ["apr"],
		"application/vnd.lotus-freelance": ["pre"],
		"application/vnd.lotus-notes": ["nsf"],
		"application/vnd.lotus-organizer": ["org"],
		"application/vnd.lotus-screencam": ["scm"],
		"application/vnd.lotus-wordpro": ["lwp"],
		"application/vnd.macports.portpkg": ["portpkg"],
		"application/vnd.mcd": ["mcd"],
		"application/vnd.medcalcdata": ["mc1"],
		"application/vnd.mediastation.cdkey": ["cdkey"],
		"application/vnd.mfer": ["mwf"],
		"application/vnd.mfmp": ["mfm"],
		"application/vnd.micrografx.flo": ["flo"],
		"application/vnd.micrografx.igx": ["igx"],
		"application/vnd.mif": ["mif"],
		"application/vnd.mobius.daf": ["daf"],
		"application/vnd.mobius.dis": ["dis"],
		"application/vnd.mobius.mbk": ["mbk"],
		"application/vnd.mobius.mqy": ["mqy"],
		"application/vnd.mobius.msl": ["msl"],
		"application/vnd.mobius.plc": ["plc"],
		"application/vnd.mobius.txf": ["txf"],
		"application/vnd.mophun.application": ["mpn"],
		"application/vnd.mophun.certificate": ["mpc"],
		"application/vnd.mozilla.xul+xml": ["xul"],
		"application/vnd.ms-artgalry": ["cil"],
		"application/vnd.ms-cab-compressed": ["cab"],
		"application/vnd.ms-excel": [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		],
		"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
		"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
		"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
		"application/vnd.ms-fontobject": ["eot"],
		"application/vnd.ms-htmlhelp": ["chm"],
		"application/vnd.ms-ims": ["ims"],
		"application/vnd.ms-lrm": ["lrm"],
		"application/vnd.ms-officetheme": ["thmx"],
		"application/vnd.ms-outlook": ["msg"],
		"application/vnd.ms-pki.seccat": ["cat"],
		"application/vnd.ms-pki.stl": ["stl"],
		"application/vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot"
		],
		"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
		"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
		"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
		"application/vnd.ms-project": ["mpp", "mpt"],
		"application/vnd.ms-word.document.macroenabled.12": ["docm"],
		"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
		"application/vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"application/vnd.ms-wpl": ["wpl"],
		"application/vnd.ms-xpsdocument": ["xps"],
		"application/vnd.mseq": ["mseq"],
		"application/vnd.musician": ["mus"],
		"application/vnd.muvee.style": ["msty"],
		"application/vnd.mynfc": ["taglet"],
		"application/vnd.neurolanguage.nlu": ["nlu"],
		"application/vnd.nitf": ["ntf", "nitf"],
		"application/vnd.noblenet-directory": ["nnd"],
		"application/vnd.noblenet-sealer": ["nns"],
		"application/vnd.noblenet-web": ["nnw"],
		"application/vnd.nokia.n-gage.data": ["ngdat"],
		"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
		"application/vnd.nokia.radio-preset": ["rpst"],
		"application/vnd.nokia.radio-presets": ["rpss"],
		"application/vnd.novadigm.edm": ["edm"],
		"application/vnd.novadigm.edx": ["edx"],
		"application/vnd.novadigm.ext": ["ext"],
		"application/vnd.oasis.opendocument.chart": ["odc"],
		"application/vnd.oasis.opendocument.chart-template": ["otc"],
		"application/vnd.oasis.opendocument.database": ["odb"],
		"application/vnd.oasis.opendocument.formula": ["odf"],
		"application/vnd.oasis.opendocument.formula-template": ["odft"],
		"application/vnd.oasis.opendocument.graphics": ["odg"],
		"application/vnd.oasis.opendocument.graphics-template": ["otg"],
		"application/vnd.oasis.opendocument.image": ["odi"],
		"application/vnd.oasis.opendocument.image-template": ["oti"],
		"application/vnd.oasis.opendocument.presentation": ["odp"],
		"application/vnd.oasis.opendocument.presentation-template": ["otp"],
		"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
		"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
		"application/vnd.oasis.opendocument.text": ["odt"],
		"application/vnd.oasis.opendocument.text-master": ["odm"],
		"application/vnd.oasis.opendocument.text-template": ["ott"],
		"application/vnd.oasis.opendocument.text-web": ["oth"],
		"application/vnd.olpc-sugar": ["xo"],
		"application/vnd.oma.dd2+xml": ["dd2"],
		"application/vnd.openofficeorg.extension": ["oxt"],
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
		"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
		"application/vnd.osgeo.mapguide.package": ["mgp"],
		"application/vnd.osgi.dp": ["dp"],
		"application/vnd.osgi.subsystem": ["esa"],
		"application/vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"application/vnd.pawaafile": ["paw"],
		"application/vnd.pg.format": ["str"],
		"application/vnd.pg.osasli": ["ei6"],
		"application/vnd.picsel": ["efif"],
		"application/vnd.pmi.widget": ["wg"],
		"application/vnd.pocketlearn": ["plf"],
		"application/vnd.powerbuilder6": ["pbd"],
		"application/vnd.previewsystems.box": ["box"],
		"application/vnd.proteus.magazine": ["mgz"],
		"application/vnd.publishare-delta-tree": ["qps"],
		"application/vnd.pvi.ptid1": ["ptid"],
		"application/vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"application/vnd.realvnc.bed": ["bed"],
		"application/vnd.recordare.musicxml": ["mxl"],
		"application/vnd.recordare.musicxml+xml": ["musicxml"],
		"application/vnd.rig.cryptonote": ["cryptonote"],
		"application/vnd.rim.cod": ["cod"],
		"application/vnd.rn-realmedia": ["rm"],
		"application/vnd.rn-realmedia-vbr": ["rmvb"],
		"application/vnd.route66.link66+xml": ["link66"],
		"application/vnd.sailingtracker.track": ["st"],
		"application/vnd.seemail": ["see"],
		"application/vnd.sema": ["sema"],
		"application/vnd.semd": ["semd"],
		"application/vnd.semf": ["semf"],
		"application/vnd.shana.informed.formdata": ["ifm"],
		"application/vnd.shana.informed.formtemplate": ["itp"],
		"application/vnd.shana.informed.interchange": ["iif"],
		"application/vnd.shana.informed.package": ["ipk"],
		"application/vnd.simtech-mindmapper": ["twd", "twds"],
		"application/vnd.smaf": ["mmf"],
		"application/vnd.smart.teacher": ["teacher"],
		"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
		"application/vnd.spotfire.dxp": ["dxp"],
		"application/vnd.spotfire.sfs": ["sfs"],
		"application/vnd.stardivision.calc": ["sdc"],
		"application/vnd.stardivision.draw": ["sda"],
		"application/vnd.stardivision.impress": ["sdd"],
		"application/vnd.stardivision.math": ["smf"],
		"application/vnd.stardivision.writer": ["sdw", "vor"],
		"application/vnd.stardivision.writer-global": ["sgl"],
		"application/vnd.stepmania.package": ["smzip"],
		"application/vnd.stepmania.stepchart": ["sm"],
		"application/vnd.sun.wadl+xml": ["wadl"],
		"application/vnd.sun.xml.calc": ["sxc"],
		"application/vnd.sun.xml.calc.template": ["stc"],
		"application/vnd.sun.xml.draw": ["sxd"],
		"application/vnd.sun.xml.draw.template": ["std"],
		"application/vnd.sun.xml.impress": ["sxi"],
		"application/vnd.sun.xml.impress.template": ["sti"],
		"application/vnd.sun.xml.math": ["sxm"],
		"application/vnd.sun.xml.writer": ["sxw"],
		"application/vnd.sun.xml.writer.global": ["sxg"],
		"application/vnd.sun.xml.writer.template": ["stw"],
		"application/vnd.sus-calendar": ["sus", "susp"],
		"application/vnd.svd": ["svd"],
		"application/vnd.symbian.install": ["sis", "sisx"],
		"application/vnd.syncml+xml": ["xsm"],
		"application/vnd.syncml.dm+wbxml": ["bdm"],
		"application/vnd.syncml.dm+xml": ["xdm"],
		"application/vnd.tao.intent-module-archive": ["tao"],
		"application/vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"application/vnd.tmobile-livetv": ["tmo"],
		"application/vnd.trid.tpt": ["tpt"],
		"application/vnd.triscape.mxs": ["mxs"],
		"application/vnd.trueapp": ["tra"],
		"application/vnd.ufdl": ["ufd", "ufdl"],
		"application/vnd.uiq.theme": ["utz"],
		"application/vnd.umajin": ["umj"],
		"application/vnd.unity": ["unityweb"],
		"application/vnd.uoml+xml": ["uoml"],
		"application/vnd.vcx": ["vcx"],
		"application/vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw"
		],
		"application/vnd.visionary": ["vis"],
		"application/vnd.vsf": ["vsf"],
		"application/vnd.wap.wbxml": ["wbxml"],
		"application/vnd.wap.wmlc": ["wmlc"],
		"application/vnd.wap.wmlscriptc": ["wmlsc"],
		"application/vnd.webturbo": ["wtb"],
		"application/vnd.wolfram.player": ["nbp"],
		"application/vnd.wordperfect": ["wpd"],
		"application/vnd.wqd": ["wqd"],
		"application/vnd.wt.stf": ["stf"],
		"application/vnd.xara": ["xar"],
		"application/vnd.xfdl": ["xfdl"],
		"application/vnd.yamaha.hv-dic": ["hvd"],
		"application/vnd.yamaha.hv-script": ["hvs"],
		"application/vnd.yamaha.hv-voice": ["hvp"],
		"application/vnd.yamaha.openscoreformat": ["osf"],
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
		"application/vnd.yamaha.smaf-audio": ["saf"],
		"application/vnd.yamaha.smaf-phrase": ["spf"],
		"application/vnd.yellowriver-custom-menu": ["cmp"],
		"application/vnd.zul": ["zir", "zirz"],
		"application/vnd.zzazz.deck+xml": ["zaz"],
		"application/voicexml+xml": ["vxml"],
		"application/wasm": ["wasm"],
		"application/widget": ["wgt"],
		"application/winhlp": ["hlp"],
		"application/wsdl+xml": ["wsdl"],
		"application/wspolicy+xml": ["wspolicy"],
		"application/x-7z-compressed": ["7z"],
		"application/x-abiword": ["abw"],
		"application/x-ace-compressed": ["ace"],
		"application/x-apple-diskimage": [],
		"application/x-arj": ["arj"],
		"application/x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"application/x-authorware-map": ["aam"],
		"application/x-authorware-seg": ["aas"],
		"application/x-bcpio": ["bcpio"],
		"application/x-bdoc": [],
		"application/x-bittorrent": ["torrent"],
		"application/x-blorb": ["blb", "blorb"],
		"application/x-bzip": ["bz"],
		"application/x-bzip2": ["bz2", "boz"],
		"application/x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		],
		"application/x-cdlink": ["vcd"],
		"application/x-cfs-compressed": ["cfs"],
		"application/x-chat": ["chat"],
		"application/x-chess-pgn": ["pgn"],
		"application/x-chrome-extension": ["crx"],
		"application/x-cocoa": ["cco"],
		"application/x-conference": ["nsc"],
		"application/x-cpio": ["cpio"],
		"application/x-csh": ["csh"],
		"application/x-debian-package": ["udeb"],
		"application/x-dgc-compressed": ["dgc"],
		"application/x-director": [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"application/x-doom": ["wad"],
		"application/x-dtbncx+xml": ["ncx"],
		"application/x-dtbook+xml": ["dtb"],
		"application/x-dtbresource+xml": ["res"],
		"application/x-dvi": ["dvi"],
		"application/x-envoy": ["evy"],
		"application/x-eva": ["eva"],
		"application/x-font-bdf": ["bdf"],
		"application/x-font-ghostscript": ["gsf"],
		"application/x-font-linux-psf": ["psf"],
		"application/x-font-pcf": ["pcf"],
		"application/x-font-snf": ["snf"],
		"application/x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"application/x-freearc": ["arc"],
		"application/x-futuresplash": ["spl"],
		"application/x-gca-compressed": ["gca"],
		"application/x-glulx": ["ulx"],
		"application/x-gnumeric": ["gnumeric"],
		"application/x-gramps-xml": ["gramps"],
		"application/x-gtar": ["gtar"],
		"application/x-hdf": ["hdf"],
		"application/x-httpd-php": ["php"],
		"application/x-install-instructions": ["install"],
		"application/x-iso9660-image": [],
		"application/x-java-archive-diff": ["jardiff"],
		"application/x-java-jnlp-file": ["jnlp"],
		"application/x-latex": ["latex"],
		"application/x-lua-bytecode": ["luac"],
		"application/x-lzh-compressed": ["lzh", "lha"],
		"application/x-makeself": ["run"],
		"application/x-mie": ["mie"],
		"application/x-mobipocket-ebook": ["prc", "mobi"],
		"application/x-ms-application": ["application"],
		"application/x-ms-shortcut": ["lnk"],
		"application/x-ms-wmd": ["wmd"],
		"application/x-ms-wmz": ["wmz"],
		"application/x-ms-xbap": ["xbap"],
		"application/x-msaccess": ["mdb"],
		"application/x-msbinder": ["obd"],
		"application/x-mscardfile": ["crd"],
		"application/x-msclip": ["clp"],
		"application/x-msdos-program": [],
		"application/x-msdownload": ["com", "bat"],
		"application/x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"application/x-msmetafile": [
			"wmf",
			"emf",
			"emz"
		],
		"application/x-msmoney": ["mny"],
		"application/x-mspublisher": ["pub"],
		"application/x-msschedule": ["scd"],
		"application/x-msterminal": ["trm"],
		"application/x-mswrite": ["wri"],
		"application/x-netcdf": ["nc", "cdf"],
		"application/x-ns-proxy-autoconfig": ["pac"],
		"application/x-nzb": ["nzb"],
		"application/x-perl": ["pl", "pm"],
		"application/x-pilot": [],
		"application/x-pkcs12": ["p12", "pfx"],
		"application/x-pkcs7-certificates": ["p7b", "spc"],
		"application/x-pkcs7-certreqresp": ["p7r"],
		"application/x-rar-compressed": ["rar"],
		"application/x-redhat-package-manager": ["rpm"],
		"application/x-research-info-systems": ["ris"],
		"application/x-sea": ["sea"],
		"application/x-sh": ["sh"],
		"application/x-shar": ["shar"],
		"application/x-shockwave-flash": ["swf"],
		"application/x-silverlight-app": ["xap"],
		"application/x-sql": ["sql"],
		"application/x-stuffit": ["sit"],
		"application/x-stuffitx": ["sitx"],
		"application/x-subrip": ["srt"],
		"application/x-sv4cpio": ["sv4cpio"],
		"application/x-sv4crc": ["sv4crc"],
		"application/x-t3vm-image": ["t3"],
		"application/x-tads": ["gam"],
		"application/x-tar": ["tar"],
		"application/x-tcl": ["tcl", "tk"],
		"application/x-tex": ["tex"],
		"application/x-tex-tfm": ["tfm"],
		"application/x-texinfo": ["texinfo", "texi"],
		"application/x-tgif": ["obj"],
		"application/x-ustar": ["ustar"],
		"application/x-virtualbox-hdd": ["hdd"],
		"application/x-virtualbox-ova": ["ova"],
		"application/x-virtualbox-ovf": ["ovf"],
		"application/x-virtualbox-vbox": ["vbox"],
		"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
		"application/x-virtualbox-vdi": ["vdi"],
		"application/x-virtualbox-vhd": ["vhd"],
		"application/x-virtualbox-vmdk": ["vmdk"],
		"application/x-wais-source": ["src"],
		"application/x-web-app-manifest+json": ["webapp"],
		"application/x-x509-ca-cert": [
			"der",
			"crt",
			"pem"
		],
		"application/x-xfig": ["fig"],
		"application/x-xliff+xml": ["xlf"],
		"application/x-xpinstall": ["xpi"],
		"application/x-xz": ["xz"],
		"application/x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"application/xaml+xml": ["xaml"],
		"application/xcap-diff+xml": ["xdf"],
		"application/xenc+xml": ["xenc"],
		"application/xhtml+xml": ["xhtml", "xht"],
		"application/xml": [
			"xml",
			"xsl",
			"xsd",
			"rng"
		],
		"application/xml-dtd": ["dtd"],
		"application/xop+xml": ["xop"],
		"application/xproc+xml": ["xpl"],
		"application/xslt+xml": ["xslt"],
		"application/xspf+xml": ["xspf"],
		"application/xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"application/yang": ["yang"],
		"application/yin+xml": ["yin"],
		"application/zip": ["zip"],
		"audio/3gpp": [],
		"audio/adpcm": ["adp"],
		"audio/basic": ["au", "snd"],
		"audio/midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"audio/mp3": [],
		"audio/mp4": ["m4a", "mp4a"],
		"audio/mpeg": [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		],
		"audio/ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"audio/s3m": ["s3m"],
		"audio/silk": ["sil"],
		"audio/vnd.dece.audio": ["uva", "uvva"],
		"audio/vnd.digital-winds": ["eol"],
		"audio/vnd.dra": ["dra"],
		"audio/vnd.dts": ["dts"],
		"audio/vnd.dts.hd": ["dtshd"],
		"audio/vnd.lucent.voice": ["lvp"],
		"audio/vnd.ms-playready.media.pya": ["pya"],
		"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
		"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
		"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
		"audio/vnd.rip": ["rip"],
		"audio/wav": ["wav"],
		"audio/wave": [],
		"audio/webm": ["weba"],
		"audio/x-aac": ["aac"],
		"audio/x-aiff": [
			"aif",
			"aiff",
			"aifc"
		],
		"audio/x-caf": ["caf"],
		"audio/x-flac": ["flac"],
		"audio/x-m4a": [],
		"audio/x-matroska": ["mka"],
		"audio/x-mpegurl": ["m3u"],
		"audio/x-ms-wax": ["wax"],
		"audio/x-ms-wma": ["wma"],
		"audio/x-pn-realaudio": ["ram", "ra"],
		"audio/x-pn-realaudio-plugin": ["rmp"],
		"audio/x-realaudio": [],
		"audio/x-wav": [],
		"audio/xm": ["xm"],
		"chemical/x-cdx": ["cdx"],
		"chemical/x-cif": ["cif"],
		"chemical/x-cmdf": ["cmdf"],
		"chemical/x-cml": ["cml"],
		"chemical/x-csml": ["csml"],
		"chemical/x-xyz": ["xyz"],
		"font/collection": ["ttc"],
		"font/otf": ["otf"],
		"font/ttf": ["ttf"],
		"font/woff": ["woff"],
		"font/woff2": ["woff2"],
		"image/apng": ["apng"],
		"image/bmp": ["bmp"],
		"image/cgm": ["cgm"],
		"image/g3fax": ["g3"],
		"image/gif": ["gif"],
		"image/ief": ["ief"],
		"image/jp2": ["jp2", "jpg2"],
		"image/jpeg": [
			"jpeg",
			"jpg",
			"jpe"
		],
		"image/jpm": ["jpm"],
		"image/jpx": ["jpx", "jpf"],
		"image/ktx": ["ktx"],
		"image/png": ["png"],
		"image/prs.btif": ["btif"],
		"image/sgi": ["sgi"],
		"image/svg+xml": ["svg", "svgz"],
		"image/tiff": ["tiff", "tif"],
		"image/vnd.adobe.photoshop": ["psd"],
		"image/vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"image/vnd.djvu": ["djvu", "djv"],
		"image/vnd.dvb.subtitle": [],
		"image/vnd.dwg": ["dwg"],
		"image/vnd.dxf": ["dxf"],
		"image/vnd.fastbidsheet": ["fbs"],
		"image/vnd.fpx": ["fpx"],
		"image/vnd.fst": ["fst"],
		"image/vnd.fujixerox.edmics-mmr": ["mmr"],
		"image/vnd.fujixerox.edmics-rlc": ["rlc"],
		"image/vnd.ms-modi": ["mdi"],
		"image/vnd.ms-photo": ["wdp"],
		"image/vnd.net-fpx": ["npx"],
		"image/vnd.wap.wbmp": ["wbmp"],
		"image/vnd.xiff": ["xif"],
		"image/webp": ["webp"],
		"image/x-3ds": ["3ds"],
		"image/x-cmu-raster": ["ras"],
		"image/x-cmx": ["cmx"],
		"image/x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"image/x-icon": ["ico"],
		"image/x-jng": ["jng"],
		"image/x-mrsid-image": ["sid"],
		"image/x-ms-bmp": [],
		"image/x-pcx": ["pcx"],
		"image/x-pict": ["pic", "pct"],
		"image/x-portable-anymap": ["pnm"],
		"image/x-portable-bitmap": ["pbm"],
		"image/x-portable-graymap": ["pgm"],
		"image/x-portable-pixmap": ["ppm"],
		"image/x-rgb": ["rgb"],
		"image/x-tga": ["tga"],
		"image/x-xbitmap": ["xbm"],
		"image/x-xpixmap": ["xpm"],
		"image/x-xwindowdump": ["xwd"],
		"message/rfc822": ["eml", "mime"],
		"model/gltf+json": ["gltf"],
		"model/gltf-binary": ["glb"],
		"model/iges": ["igs", "iges"],
		"model/mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"model/vnd.collada+xml": ["dae"],
		"model/vnd.dwf": ["dwf"],
		"model/vnd.gdl": ["gdl"],
		"model/vnd.gtw": ["gtw"],
		"model/vnd.mts": ["mts"],
		"model/vnd.vtu": ["vtu"],
		"model/vrml": ["wrl", "vrml"],
		"model/x3d+binary": ["x3db", "x3dbz"],
		"model/x3d+vrml": ["x3dv", "x3dvz"],
		"model/x3d+xml": ["x3d", "x3dz"],
		"text/cache-manifest": ["appcache", "manifest"],
		"text/calendar": ["ics", "ifb"],
		"text/coffeescript": ["coffee", "litcoffee"],
		"text/css": ["css"],
		"text/csv": ["csv"],
		"text/hjson": ["hjson"],
		"text/html": [
			"html",
			"htm",
			"shtml"
		],
		"text/jade": ["jade"],
		"text/jsx": ["jsx"],
		"text/less": ["less"],
		"text/markdown": ["markdown", "md"],
		"text/mathml": ["mml"],
		"text/n3": ["n3"],
		"text/plain": [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		],
		"text/prs.lines.tag": ["dsc"],
		"text/richtext": ["rtx"],
		"text/rtf": [],
		"text/sgml": ["sgml", "sgm"],
		"text/slim": ["slim", "slm"],
		"text/stylus": ["stylus", "styl"],
		"text/tab-separated-values": ["tsv"],
		"text/troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"text/turtle": ["ttl"],
		"text/uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"text/vcard": ["vcard"],
		"text/vnd.curl": ["curl"],
		"text/vnd.curl.dcurl": ["dcurl"],
		"text/vnd.curl.mcurl": ["mcurl"],
		"text/vnd.curl.scurl": ["scurl"],
		"text/vnd.dvb.subtitle": ["sub"],
		"text/vnd.fly": ["fly"],
		"text/vnd.fmi.flexstor": ["flx"],
		"text/vnd.graphviz": ["gv"],
		"text/vnd.in3d.3dml": ["3dml"],
		"text/vnd.in3d.spot": ["spot"],
		"text/vnd.sun.j2me.app-descriptor": ["jad"],
		"text/vnd.wap.wml": ["wml"],
		"text/vnd.wap.wmlscript": ["wmls"],
		"text/vtt": ["vtt"],
		"text/x-asm": ["s", "asm"],
		"text/x-c": [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		],
		"text/x-component": ["htc"],
		"text/x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"text/x-handlebars-template": ["hbs"],
		"text/x-java-source": ["java"],
		"text/x-lua": ["lua"],
		"text/x-markdown": ["mkd"],
		"text/x-nfo": ["nfo"],
		"text/x-opml": ["opml"],
		"text/x-org": [],
		"text/x-pascal": ["p", "pas"],
		"text/x-processing": ["pde"],
		"text/x-sass": ["sass"],
		"text/x-scss": ["scss"],
		"text/x-setext": ["etx"],
		"text/x-sfv": ["sfv"],
		"text/x-suse-ymp": ["ymp"],
		"text/x-uuencode": ["uu"],
		"text/x-vcalendar": ["vcs"],
		"text/x-vcard": ["vcf"],
		"text/xml": [],
		"text/yaml": ["yaml", "yml"],
		"video/3gpp": ["3gp", "3gpp"],
		"video/3gpp2": ["3g2"],
		"video/h261": ["h261"],
		"video/h263": ["h263"],
		"video/h264": ["h264"],
		"video/jpeg": ["jpgv"],
		"video/jpm": ["jpgm"],
		"video/mj2": ["mj2", "mjp2"],
		"video/mp2t": ["ts"],
		"video/mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"video/mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		],
		"video/ogg": ["ogv"],
		"video/quicktime": ["qt", "mov"],
		"video/vnd.dece.hd": ["uvh", "uvvh"],
		"video/vnd.dece.mobile": ["uvm", "uvvm"],
		"video/vnd.dece.pd": ["uvp", "uvvp"],
		"video/vnd.dece.sd": ["uvs", "uvvs"],
		"video/vnd.dece.video": ["uvv", "uvvv"],
		"video/vnd.dvb.file": ["dvb"],
		"video/vnd.fvt": ["fvt"],
		"video/vnd.mpegurl": ["mxu", "m4u"],
		"video/vnd.ms-playready.media.pyv": ["pyv"],
		"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
		"video/vnd.vivo": ["viv"],
		"video/webm": ["webm"],
		"video/x-f4v": ["f4v"],
		"video/x-fli": ["fli"],
		"video/x-flv": ["flv"],
		"video/x-m4v": ["m4v"],
		"video/x-matroska": [
			"mkv",
			"mk3d",
			"mks"
		],
		"video/x-mng": ["mng"],
		"video/x-ms-asf": ["asf", "asx"],
		"video/x-ms-vob": ["vob"],
		"video/x-ms-wm": ["wm"],
		"video/x-ms-wmv": ["wmv"],
		"video/x-ms-wmx": ["wmx"],
		"video/x-ms-wvx": ["wvx"],
		"video/x-msvideo": ["avi"],
		"video/x-sgi-movie": ["movie"],
		"video/x-smv": ["smv"],
		"x-conference/x-cooltalk": ["ice"]
	};
}));

//#endregion
//#region ../../node_modules/send/node_modules/mime/mime.js
var require_mime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require("path");
	var fs$19 = require("fs");
	function Mime() {
		this.types = Object.create(null);
		this.extensions = Object.create(null);
	}
	/**
	* Define mimetype -> extension mappings.  Each key is a mime-type that maps
	* to an array of extensions associated with the type.  The first extension is
	* used as the default extension for the type.
	*
	* e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	*
	* @param map (Object) type definitions
	*/
	Mime.prototype.define = function(map) {
		for (var type in map) {
			var exts = map[type];
			for (var i = 0; i < exts.length; i++) {
				if (process.env.DEBUG_MIME && this.types[exts[i]]) console.warn((this._loading || "define()").replace(/.*\//, ""), "changes \"" + exts[i] + "\" extension type from " + this.types[exts[i]] + " to " + type);
				this.types[exts[i]] = type;
			}
			if (!this.extensions[type]) this.extensions[type] = exts[0];
		}
	};
	/**
	* Load an Apache2-style ".types" file
	*
	* This may be called multiple times (it's expected).  Where files declare
	* overlapping types/extensions, the last file wins.
	*
	* @param file (String) path of file to load.
	*/
	Mime.prototype.load = function(file) {
		this._loading = file;
		var map = {};
		fs$19.readFileSync(file, "ascii").split(/[\r\n]+/).forEach(function(line) {
			var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
			map[fields.shift()] = fields;
		});
		this.define(map);
		this._loading = null;
	};
	/**
	* Lookup a mime type based on extension
	*/
	Mime.prototype.lookup = function(path$66, fallback) {
		var ext = path$66.replace(/^.*[\.\/\\]/, "").toLowerCase();
		return this.types[ext] || fallback || this.default_type;
	};
	/**
	* Return file extension associated with a mime type
	*/
	Mime.prototype.extension = function(mimeType) {
		var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
		return this.extensions[type];
	};
	var mime = new Mime();
	mime.define(require_types());
	mime.default_type = mime.lookup("bin");
	mime.Mime = Mime;
	/**
	* Lookup a charset based on mime type.
	*/
	mime.charsets = { lookup: function(mimeType, fallback) {
		return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
	} };
	module.exports = mime;
}));

//#endregion
//#region ../../node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
}));

//#endregion
//#region ../../node_modules/range-parser/index.js
/*!
* range-parser
* Copyright(c) 2012-2014 TJ Holowaychuk
* Copyright(c) 2015-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_range_parser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = rangeParser;
	/**
	* Parse "Range" header `str` relative to the given file `size`.
	*
	* @param {Number} size
	* @param {String} str
	* @param {Object} [options]
	* @return {Array}
	* @public
	*/
	function rangeParser(size, str, options) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var index = str.indexOf("=");
		if (index === -1) return -2;
		var arr = str.slice(index + 1).split(",");
		var ranges = [];
		ranges.type = str.slice(0, index);
		for (var i = 0; i < arr.length; i++) {
			var range = arr[i].split("-");
			var start = parseInt(range[0], 10);
			var end = parseInt(range[1], 10);
			if (isNaN(start)) {
				start = size - end;
				end = size - 1;
			} else if (isNaN(end)) end = size - 1;
			if (end > size - 1) end = size - 1;
			if (isNaN(start) || isNaN(end) || start > end || start < 0) continue;
			ranges.push({
				start,
				end
			});
		}
		if (ranges.length < 1) return -1;
		return options && options.combine ? combineRanges(ranges) : ranges;
	}
	/**
	* Combine overlapping & adjacent ranges.
	* @private
	*/
	function combineRanges(ranges) {
		var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
		for (var j = 0, i = 1; i < ordered.length; i++) {
			var range = ordered[i];
			var current = ordered[j];
			if (range.start > current.end + 1) ordered[++j] = range;
			else if (range.end > current.end) {
				current.end = range.end;
				current.index = Math.min(current.index, range.index);
			}
		}
		ordered.length = j + 1;
		var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
		combined.type = ranges.type;
		return combined;
	}
	/**
	* Map function to add index value to ranges.
	* @private
	*/
	function mapWithIndex(range, index) {
		return {
			start: range.start,
			end: range.end,
			index
		};
	}
	/**
	* Map function to remove index value from ranges.
	* @private
	*/
	function mapWithoutIndex(range) {
		return {
			start: range.start,
			end: range.end
		};
	}
	/**
	* Sort function to sort ranges by index.
	* @private
	*/
	function sortByRangeIndex(a, b) {
		return a.index - b.index;
	}
	/**
	* Sort function to sort ranges by start position.
	* @private
	*/
	function sortByRangeStart(a, b) {
		return a.start - b.start;
	}
}));

//#endregion
//#region ../../node_modules/send/index.js
/*!
* send
* Copyright(c) 2012 TJ Holowaychuk
* Copyright(c) 2014-2022 Douglas Christopher Wilson
* MIT Licensed
*/
var require_send = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError = require_http_errors();
	var debug = require_src$2()("send");
	var deprecate = require_depd()("send");
	var destroy = require_destroy();
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var etag = require_etag();
	var fresh = require_fresh();
	var fs$18 = require("fs");
	var mime = require_mime();
	var ms = require_ms();
	var onFinished = require_on_finished();
	var parseRange = require_range_parser();
	var path$14 = require("path");
	var statuses = require_statuses();
	var Stream = require("stream");
	var util$1 = require("util");
	/**
	* Path function references.
	* @private
	*/
	var extname = path$14.extname;
	var join = path$14.join;
	var normalize = path$14.normalize;
	var resolve = path$14.resolve;
	var sep = path$14.sep;
	/**
	* Regular expression for identifying a bytes Range header.
	* @private
	*/
	var BYTES_RANGE_REGEXP = /^ *bytes=/;
	/**
	* Maximum value allowed for the max age.
	* @private
	*/
	var MAX_MAXAGE = 3600 * 24 * 365 * 1e3;
	/**
	* Regular expression to match a path with a directory up component.
	* @private
	*/
	var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = send;
	module.exports.mime = mime;
	/**
	* Return a `SendStream` for `req` and `path`.
	*
	* @param {object} req
	* @param {string} path
	* @param {object} [options]
	* @return {SendStream}
	* @public
	*/
	function send(req, path$54, options) {
		return new SendStream(req, path$54, options);
	}
	/**
	* Initialize a `SendStream` with the given `path`.
	*
	* @param {Request} req
	* @param {String} path
	* @param {object} [options]
	* @private
	*/
	function SendStream(req, path$55, options) {
		Stream.call(this);
		var opts = options || {};
		this.options = opts;
		this.path = path$55;
		this.req = req;
		this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
		this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
		this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
		this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
		if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") throw new TypeError("dotfiles option must be \"allow\", \"deny\", or \"ignore\"");
		this._hidden = Boolean(opts.hidden);
		if (opts.hidden !== void 0) deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
		if (opts.dotfiles === void 0) this._dotfiles = void 0;
		this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
		this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
		this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
		this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
		this._maxage = opts.maxAge || opts.maxage;
		this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		this._root = opts.root ? resolve(opts.root) : null;
		if (!this._root && opts.from) this.from(opts.from);
	}
	/**
	* Inherits from `Stream`.
	*/
	util$1.inherits(SendStream, Stream);
	/**
	* Enable or disable etag generation.
	*
	* @param {Boolean} val
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.etag = deprecate.function(function etag(val) {
		this._etag = Boolean(val);
		debug("etag %s", this._etag);
		return this;
	}, "send.etag: pass etag as option");
	/**
	* Enable or disable "hidden" (dot) files.
	*
	* @param {Boolean} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.hidden = deprecate.function(function hidden(val) {
		this._hidden = Boolean(val);
		this._dotfiles = void 0;
		debug("hidden %s", this._hidden);
		return this;
	}, "send.hidden: use dotfiles option");
	/**
	* Set index `paths`, set to a falsy
	* value to disable index support.
	*
	* @param {String|Boolean|Array} paths
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.index = deprecate.function(function index(paths) {
		var index = !paths ? [] : normalizeList(paths, "paths argument");
		debug("index %o", paths);
		this._index = index;
		return this;
	}, "send.index: pass index as option");
	/**
	* Set root `path`.
	*
	* @param {String} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.root = function root(path$56) {
		this._root = resolve(String(path$56));
		debug("root %s", this._root);
		return this;
	};
	SendStream.prototype.from = deprecate.function(SendStream.prototype.root, "send.from: pass root as option");
	SendStream.prototype.root = deprecate.function(SendStream.prototype.root, "send.root: pass root as option");
	/**
	* Set max-age to `maxAge`.
	*
	* @param {Number} maxAge
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
		this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		debug("max-age %d", this._maxage);
		return this;
	}, "send.maxage: pass maxAge as option");
	/**
	* Emit error with `status`.
	*
	* @param {number} status
	* @param {Error} [err]
	* @private
	*/
	SendStream.prototype.error = function error(status, err) {
		if (hasListeners(this, "error")) return this.emit("error", createHttpError(status, err));
		var res = this.res;
		var doc = createHtmlDocument("Error", escapeHtml(statuses.message[status] || String(status)));
		clearHeaders(res);
		if (err && err.headers) setHeaders(res, err.headers);
		res.statusCode = status;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.end(doc);
	};
	/**
	* Check if the pathname ends with "/".
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
		return this.path[this.path.length - 1] === "/";
	};
	/**
	* Check if this is a conditional GET request.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isConditionalGET = function isConditionalGET() {
		return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
	};
	/**
	* Check if the request preconditions failed.
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
		var req = this.req;
		var res = this.res;
		var match = req.headers["if-match"];
		if (match) {
			var etag = res.getHeader("ETag");
			return !etag || match !== "*" && parseTokenList(match).every(function(match) {
				return match !== etag && match !== "W/" + etag && "W/" + match !== etag;
			});
		}
		var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
		if (!isNaN(unmodifiedSince)) {
			var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
			return isNaN(lastModified) || lastModified > unmodifiedSince;
		}
		return false;
	};
	/**
	* Strip various content header fields for a change in entity.
	*
	* @private
	*/
	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
		var res = this.res;
		res.removeHeader("Content-Encoding");
		res.removeHeader("Content-Language");
		res.removeHeader("Content-Length");
		res.removeHeader("Content-Range");
		res.removeHeader("Content-Type");
	};
	/**
	* Respond with 304 not modified.
	*
	* @api private
	*/
	SendStream.prototype.notModified = function notModified() {
		var res = this.res;
		debug("not modified");
		this.removeContentHeaderFields();
		res.statusCode = 304;
		res.end();
	};
	/**
	* Raise error that headers already sent.
	*
	* @api private
	*/
	SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
		var err = /* @__PURE__ */ new Error("Can't set headers after they are sent.");
		debug("headers already sent");
		this.error(500, err);
	};
	/**
	* Check if the request is cacheable, aka
	* responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isCachable = function isCachable() {
		var statusCode = this.res.statusCode;
		return statusCode >= 200 && statusCode < 300 || statusCode === 304;
	};
	/**
	* Handle stat() error.
	*
	* @param {Error} error
	* @private
	*/
	SendStream.prototype.onStatError = function onStatError(error) {
		switch (error.code) {
			case "ENAMETOOLONG":
			case "ENOENT":
			case "ENOTDIR":
				this.error(404, error);
				break;
			default:
				this.error(500, error);
				break;
		}
	};
	/**
	* Check if the cache is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isFresh = function isFresh() {
		return fresh(this.req.headers, {
			etag: this.res.getHeader("ETag"),
			"last-modified": this.res.getHeader("Last-Modified")
		});
	};
	/**
	* Check if the range is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isRangeFresh = function isRangeFresh() {
		var ifRange = this.req.headers["if-range"];
		if (!ifRange) return true;
		if (ifRange.indexOf("\"") !== -1) {
			var etag = this.res.getHeader("ETag");
			return Boolean(etag && ifRange.indexOf(etag) !== -1);
		}
		return parseHttpDate(this.res.getHeader("Last-Modified")) <= parseHttpDate(ifRange);
	};
	/**
	* Redirect to path.
	*
	* @param {string} path
	* @private
	*/
	SendStream.prototype.redirect = function redirect(path$57) {
		var res = this.res;
		if (hasListeners(this, "directory")) {
			this.emit("directory", res, path$57);
			return;
		}
		if (this.hasTrailingSlash()) {
			this.error(403);
			return;
		}
		var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
		var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
		res.statusCode = 301;
		res.setHeader("Content-Type", "text/html; charset=UTF-8");
		res.setHeader("Content-Length", Buffer.byteLength(doc));
		res.setHeader("Content-Security-Policy", "default-src 'none'");
		res.setHeader("X-Content-Type-Options", "nosniff");
		res.setHeader("Location", loc);
		res.end(doc);
	};
	/**
	* Pipe to `res.
	*
	* @param {Stream} res
	* @return {Stream} res
	* @api public
	*/
	SendStream.prototype.pipe = function pipe(res) {
		var root = this._root;
		this.res = res;
		var path$58 = decode(this.path);
		if (path$58 === -1) {
			this.error(400);
			return res;
		}
		if (~path$58.indexOf("\0")) {
			this.error(400);
			return res;
		}
		var parts;
		if (root !== null) {
			if (path$58) path$58 = normalize("." + sep + path$58);
			if (UP_PATH_REGEXP.test(path$58)) {
				debug("malicious path \"%s\"", path$58);
				this.error(403);
				return res;
			}
			parts = path$58.split(sep);
			path$58 = normalize(join(root, path$58));
		} else {
			if (UP_PATH_REGEXP.test(path$58)) {
				debug("malicious path \"%s\"", path$58);
				this.error(403);
				return res;
			}
			parts = normalize(path$58).split(sep);
			path$58 = resolve(path$58);
		}
		if (containsDotFile(parts)) {
			var access = this._dotfiles;
			if (access === void 0) access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
			debug("%s dotfile \"%s\"", access, path$58);
			switch (access) {
				case "allow": break;
				case "deny":
					this.error(403);
					return res;
				default:
					this.error(404);
					return res;
			}
		}
		if (this._index.length && this.hasTrailingSlash()) {
			this.sendIndex(path$58);
			return res;
		}
		this.sendFile(path$58);
		return res;
	};
	/**
	* Transfer `path`.
	*
	* @param {String} path
	* @api public
	*/
	SendStream.prototype.send = function send(path$59, stat) {
		var len = stat.size;
		var options = this.options;
		var opts = {};
		var res = this.res;
		var req = this.req;
		var ranges = req.headers.range;
		var offset = options.start || 0;
		if (headersSent(res)) {
			this.headersAlreadySent();
			return;
		}
		debug("pipe \"%s\"", path$59);
		this.setHeader(path$59, stat);
		this.type(path$59);
		if (this.isConditionalGET()) {
			if (this.isPreconditionFailure()) {
				this.error(412);
				return;
			}
			if (this.isCachable() && this.isFresh()) {
				this.notModified();
				return;
			}
		}
		len = Math.max(0, len - offset);
		if (options.end !== void 0) {
			var bytes = options.end - offset + 1;
			if (len > bytes) len = bytes;
		}
		if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
			ranges = parseRange(len, ranges, { combine: true });
			if (!this.isRangeFresh()) {
				debug("range stale");
				ranges = -2;
			}
			if (ranges === -1) {
				debug("range unsatisfiable");
				res.setHeader("Content-Range", contentRange("bytes", len));
				return this.error(416, { headers: { "Content-Range": res.getHeader("Content-Range") } });
			}
			if (ranges !== -2 && ranges.length === 1) {
				debug("range %j", ranges);
				res.statusCode = 206;
				res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
				offset += ranges[0].start;
				len = ranges[0].end - ranges[0].start + 1;
			}
		}
		for (var prop in options) opts[prop] = options[prop];
		opts.start = offset;
		opts.end = Math.max(offset, offset + len - 1);
		res.setHeader("Content-Length", len);
		if (req.method === "HEAD") {
			res.end();
			return;
		}
		this.stream(path$59, opts);
	};
	/**
	* Transfer file for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendFile = function sendFile(path$60) {
		var i = 0;
		var self = this;
		debug("stat \"%s\"", path$60);
		fs$18.stat(path$60, function onstat(err, stat) {
			if (err && err.code === "ENOENT" && !extname(path$60) && path$60[path$60.length - 1] !== sep) return next(err);
			if (err) return self.onStatError(err);
			if (stat.isDirectory()) return self.redirect(path$60);
			self.emit("file", path$60, stat);
			self.send(path$60, stat);
		});
		function next(err) {
			if (self._extensions.length <= i) return err ? self.onStatError(err) : self.error(404);
			var p = path$60 + "." + self._extensions[i++];
			debug("stat \"%s\"", p);
			fs$18.stat(p, function(err, stat) {
				if (err) return next(err);
				if (stat.isDirectory()) return next();
				self.emit("file", p, stat);
				self.send(p, stat);
			});
		}
	};
	/**
	* Transfer index for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendIndex = function sendIndex(path$61) {
		var i = -1;
		var self = this;
		function next(err) {
			if (++i >= self._index.length) {
				if (err) return self.onStatError(err);
				return self.error(404);
			}
			var p = join(path$61, self._index[i]);
			debug("stat \"%s\"", p);
			fs$18.stat(p, function(err, stat) {
				if (err) return next(err);
				if (stat.isDirectory()) return next();
				self.emit("file", p, stat);
				self.send(p, stat);
			});
		}
		next();
	};
	/**
	* Stream `path` to the response.
	*
	* @param {String} path
	* @param {Object} options
	* @api private
	*/
	SendStream.prototype.stream = function stream(path$62, options) {
		var self = this;
		var res = this.res;
		var stream = fs$18.createReadStream(path$62, options);
		this.emit("stream", stream);
		stream.pipe(res);
		function cleanup() {
			destroy(stream, true);
		}
		onFinished(res, cleanup);
		stream.on("error", function onerror(err) {
			cleanup();
			self.onStatError(err);
		});
		stream.on("end", function onend() {
			self.emit("end");
		});
	};
	/**
	* Set content-type based on `path`
	* if it hasn't been explicitly set.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.type = function type(path$63) {
		var res = this.res;
		if (res.getHeader("Content-Type")) return;
		var type = mime.lookup(path$63);
		if (!type) {
			debug("no content-type");
			return;
		}
		var charset = mime.charsets.lookup(type);
		debug("content-type %s", type);
		res.setHeader("Content-Type", type + (charset ? "; charset=" + charset : ""));
	};
	/**
	* Set response header fields, most
	* fields may be pre-defined.
	*
	* @param {String} path
	* @param {Object} stat
	* @api private
	*/
	SendStream.prototype.setHeader = function setHeader(path$64, stat) {
		var res = this.res;
		this.emit("headers", res, path$64, stat);
		if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
			debug("accept ranges");
			res.setHeader("Accept-Ranges", "bytes");
		}
		if (this._cacheControl && !res.getHeader("Cache-Control")) {
			var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
			if (this._immutable) cacheControl += ", immutable";
			debug("cache-control %s", cacheControl);
			res.setHeader("Cache-Control", cacheControl);
		}
		if (this._lastModified && !res.getHeader("Last-Modified")) {
			var modified = stat.mtime.toUTCString();
			debug("modified %s", modified);
			res.setHeader("Last-Modified", modified);
		}
		if (this._etag && !res.getHeader("ETag")) {
			var val = etag(stat);
			debug("etag %s", val);
			res.setHeader("ETag", val);
		}
	};
	/**
	* Clear all headers from a response.
	*
	* @param {object} res
	* @private
	*/
	function clearHeaders(res) {
		var headers = getHeaderNames(res);
		for (var i = 0; i < headers.length; i++) res.removeHeader(headers[i]);
	}
	/**
	* Collapse all leading slashes into a single slash
	*
	* @param {string} str
	* @private
	*/
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str[i] !== "/") break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	/**
	* Determine if path parts contain a dotfile.
	*
	* @api private
	*/
	function containsDotFile(parts) {
		for (var i = 0; i < parts.length; i++) {
			var part = parts[i];
			if (part.length > 1 && part[0] === ".") return true;
		}
		return false;
	}
	/**
	* Create a Content-Range header.
	*
	* @param {string} type
	* @param {number} size
	* @param {array} [range]
	*/
	function contentRange(type, size, range) {
		return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a HttpError object from simple arguments.
	*
	* @param {number} status
	* @param {Error|object} err
	* @private
	*/
	function createHttpError(status, err) {
		if (!err) return createError(status);
		return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
	}
	/**
	* decodeURIComponent.
	*
	* Allows V8 to only deoptimize this fn instead of all
	* of send().
	*
	* @param {String} path
	* @api private
	*/
	function decode(path$65) {
		try {
			return decodeURIComponent(path$65);
		} catch (err) {
			return -1;
		}
	}
	/**
	* Get the header names on a respnse.
	*
	* @param {object} res
	* @returns {array[string]}
	* @private
	*/
	function getHeaderNames(res) {
		return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
	}
	/**
	* Determine if emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function hasListeners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res) {
		return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
	}
	/**
	* Normalize the index option into an array.
	*
	* @param {boolean|string|array} val
	* @param {string} name
	* @private
	*/
	function normalizeList(val, name) {
		var list = [].concat(val || []);
		for (var i = 0; i < list.length; i++) if (typeof list[i] !== "string") throw new TypeError(name + " must be array of strings or false");
		return list;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate(date) {
		var timestamp = date && Date.parse(date);
		return typeof timestamp === "number" ? timestamp : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = str.length; i < len; i++) switch (str.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				if (start !== end) list.push(str.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		if (start !== end) list.push(str.substring(start, end));
		return list;
	}
	/**
	* Set an object of headers on a response.
	*
	* @param {object} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res, headers) {
		var keys = Object.keys(headers);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			res.setHeader(key, headers[key]);
		}
	}
}));

//#endregion
//#region ../../node_modules/forwarded/index.js
/*!
* forwarded
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_forwarded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = forwarded;
	/**
	* Get all addresses in the request, using the `X-Forwarded-For` header.
	*
	* @param {object} req
	* @return {array}
	* @public
	*/
	function forwarded(req) {
		if (!req) throw new TypeError("argument req is required");
		var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
		return [getSocketAddr(req)].concat(proxyAddrs);
	}
	/**
	* Get the socket address for a request.
	*
	* @param {object} req
	* @return {string}
	* @private
	*/
	function getSocketAddr(req) {
		return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
	}
	/**
	* Parse the X-Forwarded-For header.
	*
	* @param {string} header
	* @private
	*/
	function parse(header) {
		var end = header.length;
		var list = [];
		var start = header.length;
		for (var i = header.length - 1; i >= 0; i--) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i;
				break;
			case 44:
				if (start !== end) list.push(header.substring(start, end));
				start = end = i;
				break;
			default:
				start = i;
				break;
		}
		if (start !== end) list.push(header.substring(start, end));
		return list;
	}
}));

//#endregion
//#region ../../node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function() {
		var expandIPv6, ipaddr = {}, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root = this, zoneIndex;
		if (typeof module !== "undefined" && module !== null && module.exports) module.exports = ipaddr;
		else root["ipaddr"] = ipaddr;
		matchCIDR = function(first, second, partSize, cidrBits) {
			var part, shift;
			if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
			part = 0;
			while (cidrBits > 0) {
				shift = partSize - cidrBits;
				if (shift < 0) shift = 0;
				if (first[part] >> shift !== second[part] >> shift) return false;
				cidrBits -= partSize;
				part += 1;
			}
			return true;
		};
		ipaddr.subnetMatch = function(address, rangeList, defaultName) {
			var k, len, rangeName, rangeSubnets, subnet;
			if (defaultName == null) defaultName = "unicast";
			for (rangeName in rangeList) {
				rangeSubnets = rangeList[rangeName];
				if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [rangeSubnets];
				for (k = 0, len = rangeSubnets.length; k < len; k++) {
					subnet = rangeSubnets[k];
					if (address.kind() === subnet[0].kind()) {
						if (address.match.apply(address, subnet)) return rangeName;
					}
				}
			}
			return defaultName;
		};
		ipaddr.IPv4 = (function() {
			function IPv4(octets) {
				var k, len, octet;
				if (octets.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
				for (k = 0, len = octets.length; k < len; k++) {
					octet = octets[k];
					if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
				}
				this.octets = octets;
			}
			IPv4.prototype.kind = function() {
				return "ipv4";
			};
			IPv4.prototype.toString = function() {
				return this.octets.join(".");
			};
			IPv4.prototype.toNormalizedString = function() {
				return this.toString();
			};
			IPv4.prototype.toByteArray = function() {
				return this.octets.slice(0);
			};
			IPv4.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv4") throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
				return matchCIDR(this.octets, other.octets, 8, cidrRange);
			};
			IPv4.prototype.SpecialRanges = {
				unspecified: [[new IPv4([
					0,
					0,
					0,
					0
				]), 8]],
				broadcast: [[new IPv4([
					255,
					255,
					255,
					255
				]), 32]],
				multicast: [[new IPv4([
					224,
					0,
					0,
					0
				]), 4]],
				linkLocal: [[new IPv4([
					169,
					254,
					0,
					0
				]), 16]],
				loopback: [[new IPv4([
					127,
					0,
					0,
					0
				]), 8]],
				carrierGradeNat: [[new IPv4([
					100,
					64,
					0,
					0
				]), 10]],
				"private": [
					[new IPv4([
						10,
						0,
						0,
						0
					]), 8],
					[new IPv4([
						172,
						16,
						0,
						0
					]), 12],
					[new IPv4([
						192,
						168,
						0,
						0
					]), 16]
				],
				reserved: [
					[new IPv4([
						192,
						0,
						0,
						0
					]), 24],
					[new IPv4([
						192,
						0,
						2,
						0
					]), 24],
					[new IPv4([
						192,
						88,
						99,
						0
					]), 24],
					[new IPv4([
						198,
						51,
						100,
						0
					]), 24],
					[new IPv4([
						203,
						0,
						113,
						0
					]), 24],
					[new IPv4([
						240,
						0,
						0,
						0
					]), 4]
				]
			};
			IPv4.prototype.range = function() {
				return ipaddr.subnetMatch(this, this.SpecialRanges);
			};
			IPv4.prototype.toIPv4MappedAddress = function() {
				return ipaddr.IPv6.parse("::ffff:" + this.toString());
			};
			IPv4.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i, k, octet, stop, zeros, zerotable = {
					0: 8,
					128: 7,
					192: 6,
					224: 5,
					240: 4,
					248: 3,
					252: 2,
					254: 1,
					255: 0
				};
				cidr = 0;
				stop = false;
				for (i = k = 3; k >= 0; i = k += -1) {
					octet = this.octets[i];
					if (octet in zerotable) {
						zeros = zerotable[octet];
						if (stop && zeros !== 0) return null;
						if (zeros !== 8) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 32 - cidr;
			};
			return IPv4;
		})();
		ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
		ipv4Regexes = {
			fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
			longValue: new RegExp("^" + ipv4Part + "$", "i")
		};
		ipaddr.IPv4.parser = function(string) {
			var match, parseIntAuto = function(string) {
				if (string[0] === "0" && string[1] !== "x") return parseInt(string, 8);
				else return parseInt(string);
			}, part, shift, value;
			if (match = string.match(ipv4Regexes.fourOctet)) return (function() {
				var k, len, ref = match.slice(1, 6), results = [];
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					results.push(parseIntAuto(part));
				}
				return results;
			})();
			else if (match = string.match(ipv4Regexes.longValue)) {
				value = parseIntAuto(match[1]);
				if (value > 4294967295 || value < 0) throw new Error("ipaddr: address outside defined range");
				return (function() {
					var k, results = [];
					for (shift = k = 0; k <= 24; shift = k += 8) results.push(value >> shift & 255);
					return results;
				})().reverse();
			} else return null;
		};
		ipaddr.IPv6 = (function() {
			function IPv6(parts, zoneId) {
				var i, k, l, len, part, ref;
				if (parts.length === 16) {
					this.parts = [];
					for (i = k = 0; k <= 14; i = k += 2) this.parts.push(parts[i] << 8 | parts[i + 1]);
				} else if (parts.length === 8) this.parts = parts;
				else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
				ref = this.parts;
				for (l = 0, len = ref.length; l < len; l++) {
					part = ref[l];
					if (!(0 <= part && part <= 65535)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
				}
				if (zoneId) this.zoneId = zoneId;
			}
			IPv6.prototype.kind = function() {
				return "ipv6";
			};
			IPv6.prototype.toString = function() {
				return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
			};
			IPv6.prototype.toRFC5952String = function() {
				var bestMatchIndex, bestMatchLength, match, regex = /((^|:)(0(:|$)){2,})/g, string = this.toNormalizedString();
				bestMatchIndex = 0;
				bestMatchLength = -1;
				while (match = regex.exec(string)) if (match[0].length > bestMatchLength) {
					bestMatchIndex = match.index;
					bestMatchLength = match[0].length;
				}
				if (bestMatchLength < 0) return string;
				return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
			};
			IPv6.prototype.toByteArray = function() {
				var bytes = [], k, len, part, ref = this.parts;
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					bytes.push(part >> 8);
					bytes.push(part & 255);
				}
				return bytes;
			};
			IPv6.prototype.toNormalizedString = function() {
				var addr = (function() {
					var k, len, ref = this.parts, results = [];
					for (k = 0, len = ref.length; k < len; k++) {
						part = ref[k];
						results.push(part.toString(16));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.toFixedLengthString = function() {
				var addr = (function() {
					var k, len, ref = this.parts, results = [];
					for (k = 0, len = ref.length; k < len; k++) {
						part = ref[k];
						results.push(part.toString(16).padStart(4, "0"));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv6") throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
				return matchCIDR(this.parts, other.parts, 16, cidrRange);
			};
			IPv6.prototype.SpecialRanges = {
				unspecified: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 128],
				linkLocal: [new IPv6([
					65152,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 10],
				multicast: [new IPv6([
					65280,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 8],
				loopback: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					1
				]), 128],
				uniqueLocal: [new IPv6([
					64512,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 7],
				ipv4Mapped: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					65535,
					0,
					0
				]), 96],
				rfc6145: [new IPv6([
					0,
					0,
					0,
					0,
					65535,
					0,
					0,
					0
				]), 96],
				rfc6052: [new IPv6([
					100,
					65435,
					0,
					0,
					0,
					0,
					0,
					0
				]), 96],
				"6to4": [new IPv6([
					8194,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 16],
				teredo: [new IPv6([
					8193,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32],
				reserved: [[new IPv6([
					8193,
					3512,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32]]
			};
			IPv6.prototype.range = function() {
				return ipaddr.subnetMatch(this, this.SpecialRanges);
			};
			IPv6.prototype.isIPv4MappedAddress = function() {
				return this.range() === "ipv4Mapped";
			};
			IPv6.prototype.toIPv4Address = function() {
				var high, low, ref;
				if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
				ref = this.parts.slice(-2), high = ref[0], low = ref[1];
				return new ipaddr.IPv4([
					high >> 8,
					high & 255,
					low >> 8,
					low & 255
				]);
			};
			IPv6.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i, k, part, stop, zeros, zerotable = {
					0: 16,
					32768: 15,
					49152: 14,
					57344: 13,
					61440: 12,
					63488: 11,
					64512: 10,
					65024: 9,
					65280: 8,
					65408: 7,
					65472: 6,
					65504: 5,
					65520: 4,
					65528: 3,
					65532: 2,
					65534: 1,
					65535: 0
				};
				cidr = 0;
				stop = false;
				for (i = k = 7; k >= 0; i = k += -1) {
					part = this.parts[i];
					if (part in zerotable) {
						zeros = zerotable[part];
						if (stop && zeros !== 0) return null;
						if (zeros !== 16) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 128 - cidr;
			};
			return IPv6;
		})();
		ipv6Part = "(?:[0-9a-f]+::?)+";
		zoneIndex = "%[0-9a-z]{1,}";
		ipv6Regexes = {
			zoneIndex: new RegExp(zoneIndex, "i"),
			"native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
			transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
		};
		expandIPv6 = function(string, parts) {
			var colonCount, lastColon, part, replacement, replacementCount, zoneId;
			if (string.indexOf("::") !== string.lastIndexOf("::")) return null;
			zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
			if (zoneId) {
				zoneId = zoneId.substring(1);
				string = string.replace(/%.+$/, "");
			}
			colonCount = 0;
			lastColon = -1;
			while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) colonCount++;
			if (string.substr(0, 2) === "::") colonCount--;
			if (string.substr(-2, 2) === "::") colonCount--;
			if (colonCount > parts) return null;
			replacementCount = parts - colonCount;
			replacement = ":";
			while (replacementCount--) replacement += "0:";
			string = string.replace("::", replacement);
			if (string[0] === ":") string = string.slice(1);
			if (string[string.length - 1] === ":") string = string.slice(0, -1);
			parts = (function() {
				var k, len, ref = string.split(":"), results = [];
				for (k = 0, len = ref.length; k < len; k++) {
					part = ref[k];
					results.push(parseInt(part, 16));
				}
				return results;
			})();
			return {
				parts,
				zoneId
			};
		};
		ipaddr.IPv6.parser = function(string) {
			var addr, k, len, match, octet, octets, zoneId;
			if (ipv6Regexes["native"].test(string)) return expandIPv6(string, 8);
			else if (match = string.match(ipv6Regexes["transitional"])) {
				zoneId = match[6] || "";
				addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
				if (addr.parts) {
					octets = [
						parseInt(match[2]),
						parseInt(match[3]),
						parseInt(match[4]),
						parseInt(match[5])
					];
					for (k = 0, len = octets.length; k < len; k++) {
						octet = octets[k];
						if (!(0 <= octet && octet <= 255)) return null;
					}
					addr.parts.push(octets[0] << 8 | octets[1]);
					addr.parts.push(octets[2] << 8 | octets[3]);
					return {
						parts: addr.parts,
						zoneId: addr.zoneId
					};
				}
			}
			return null;
		};
		ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
			return this.parser(string) !== null;
		};
		ipaddr.IPv4.isValid = function(string) {
			try {
				new this(this.parser(string));
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr.IPv4.isValidFourPartDecimal = function(string) {
			if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
			else return false;
		};
		ipaddr.IPv6.isValid = function(string) {
			var addr;
			if (typeof string === "string" && string.indexOf(":") === -1) return false;
			try {
				addr = this.parser(string);
				new this(addr.parts, addr.zoneId);
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr.IPv4.parse = function(string) {
			var parts = this.parser(string);
			if (parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(parts);
		};
		ipaddr.IPv6.parse = function(string) {
			var addr = this.parser(string);
			if (addr.parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(addr.parts, addr.zoneId);
		};
		ipaddr.IPv4.parseCIDR = function(string) {
			var maskLength, match, parsed;
			if (match = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match[2]);
				if (maskLength >= 0 && maskLength <= 32) {
					parsed = [this.parse(match[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
		};
		ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
			var filledOctetCount, j, octets;
			prefix = parseInt(prefix);
			if (prefix < 0 || prefix > 32) throw new Error("ipaddr: invalid IPv4 prefix length");
			octets = [
				0,
				0,
				0,
				0
			];
			j = 0;
			filledOctetCount = Math.floor(prefix / 8);
			while (j < filledOctetCount) {
				octets[j] = 255;
				j++;
			}
			if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
			return new this(octets);
		};
		ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
			var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i = 0;
				while (i < 4) {
					octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
					i++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr.IPv4.networkAddressFromCIDR = function(string) {
			var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i = 0;
				while (i < 4) {
					octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
					i++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr.IPv6.parseCIDR = function(string) {
			var maskLength, match, parsed;
			if (match = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match[2]);
				if (maskLength >= 0 && maskLength <= 128) {
					parsed = [this.parse(match[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
		};
		ipaddr.isValid = function(string) {
			return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
		};
		ipaddr.parse = function(string) {
			if (ipaddr.IPv6.isValid(string)) return ipaddr.IPv6.parse(string);
			else if (ipaddr.IPv4.isValid(string)) return ipaddr.IPv4.parse(string);
			else throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
		};
		ipaddr.parseCIDR = function(string) {
			try {
				return ipaddr.IPv6.parseCIDR(string);
			} catch (error1) {
				try {
					return ipaddr.IPv4.parseCIDR(string);
				} catch (error1) {
					throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
				}
			}
		};
		ipaddr.fromByteArray = function(bytes) {
			var length = bytes.length;
			if (length === 4) return new ipaddr.IPv4(bytes);
			else if (length === 16) return new ipaddr.IPv6(bytes);
			else throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
		};
		ipaddr.process = function(string) {
			var addr = this.parse(string);
			if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
			else return addr;
		};
	}).call(exports);
}));

//#endregion
//#region ../../node_modules/proxy-addr/index.js
/*!
* proxy-addr
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_proxy_addr = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = proxyaddr;
	module.exports.all = alladdrs;
	module.exports.compile = compile;
	/**
	* Module dependencies.
	* @private
	*/
	var forwarded = require_forwarded();
	var ipaddr = require_ipaddr();
	/**
	* Variables.
	* @private
	*/
	var DIGIT_REGEXP = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;
	/**
	* Pre-defined IP ranges.
	* @private
	*/
	var IP_RANGES = {
		linklocal: ["169.254.0.0/16", "fe80::/10"],
		loopback: ["127.0.0.1/8", "::1/128"],
		uniquelocal: [
			"10.0.0.0/8",
			"172.16.0.0/12",
			"192.168.0.0/16",
			"fc00::/7"
		]
	};
	/**
	* Get all addresses in the request, optionally stopping
	* at the first untrusted.
	*
	* @param {Object} request
	* @param {Function|Array|String} [trust]
	* @public
	*/
	function alladdrs(req, trust) {
		var addrs = forwarded(req);
		if (!trust) return addrs;
		if (typeof trust !== "function") trust = compile(trust);
		for (var i = 0; i < addrs.length - 1; i++) {
			if (trust(addrs[i], i)) continue;
			addrs.length = i + 1;
		}
		return addrs;
	}
	/**
	* Compile argument into trust function.
	*
	* @param {Array|String} val
	* @private
	*/
	function compile(val) {
		if (!val) throw new TypeError("argument is required");
		var trust;
		if (typeof val === "string") trust = [val];
		else if (Array.isArray(val)) trust = val.slice();
		else throw new TypeError("unsupported trust argument");
		for (var i = 0; i < trust.length; i++) {
			val = trust[i];
			if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) continue;
			val = IP_RANGES[val];
			trust.splice.apply(trust, [i, 1].concat(val));
			i += val.length - 1;
		}
		return compileTrust(compileRangeSubnets(trust));
	}
	/**
	* Compile `arr` elements into range subnets.
	*
	* @param {Array} arr
	* @private
	*/
	function compileRangeSubnets(arr) {
		var rangeSubnets = new Array(arr.length);
		for (var i = 0; i < arr.length; i++) rangeSubnets[i] = parseipNotation(arr[i]);
		return rangeSubnets;
	}
	/**
	* Compile range subnet array into trust function.
	*
	* @param {Array} rangeSubnets
	* @private
	*/
	function compileTrust(rangeSubnets) {
		var len = rangeSubnets.length;
		return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
	}
	/**
	* Parse IP notation string into range subnet.
	*
	* @param {String} note
	* @private
	*/
	function parseipNotation(note) {
		var pos = note.lastIndexOf("/");
		var str = pos !== -1 ? note.substring(0, pos) : note;
		if (!isip(str)) throw new TypeError("invalid IP address: " + str);
		var ip = parseip(str);
		if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
		var max = ip.kind() === "ipv6" ? 128 : 32;
		var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
		if (range === null) range = max;
		else if (DIGIT_REGEXP.test(range)) range = parseInt(range, 10);
		else if (ip.kind() === "ipv4" && isip(range)) range = parseNetmask(range);
		else range = null;
		if (range <= 0 || range > max) throw new TypeError("invalid range on address: " + note);
		return [ip, range];
	}
	/**
	* Parse netmask string into CIDR range.
	*
	* @param {String} netmask
	* @private
	*/
	function parseNetmask(netmask) {
		var ip = parseip(netmask);
		return ip.kind() === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
	}
	/**
	* Determine address of proxied request.
	*
	* @param {Object} request
	* @param {Function|Array|String} trust
	* @public
	*/
	function proxyaddr(req, trust) {
		if (!req) throw new TypeError("req argument is required");
		if (!trust) throw new TypeError("trust argument is required");
		var addrs = alladdrs(req, trust);
		return addrs[addrs.length - 1];
	}
	/**
	* Static trust function to trust nothing.
	*
	* @private
	*/
	function trustNone() {
		return false;
	}
	/**
	* Compile trust function for multiple subnets.
	*
	* @param {Array} subnets
	* @private
	*/
	function trustMulti(subnets) {
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			var ipconv;
			var kind = ip.kind();
			for (var i = 0; i < subnets.length; i++) {
				var subnet = subnets[i];
				var subnetip = subnet[0];
				var subnetkind = subnetip.kind();
				var subnetrange = subnet[1];
				var trusted = ip;
				if (kind !== subnetkind) {
					if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) continue;
					if (!ipconv) ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
					trusted = ipconv;
				}
				if (trusted.match(subnetip, subnetrange)) return true;
			}
			return false;
		};
	}
	/**
	* Compile trust function for single subnet.
	*
	* @param {Object} subnet
	* @private
	*/
	function trustSingle(subnet) {
		var subnetip = subnet[0];
		var subnetkind = subnetip.kind();
		var subnetisipv4 = subnetkind === "ipv4";
		var subnetrange = subnet[1];
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			if (ip.kind() !== subnetkind) {
				if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
				ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
			}
			return ip.match(subnetip, subnetrange);
		};
	}
}));

//#endregion
//#region ../../node_modules/express/lib/utils.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	* @api private
	*/
	var Buffer = require_safe_buffer$1().Buffer;
	var contentDisposition = require_content_disposition();
	var contentType = require_content_type();
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var mime = require_send().mime;
	var etag = require_etag();
	var proxyaddr = require_proxy_addr();
	var qs = require_lib();
	var querystring = require("querystring");
	/**
	* Return strong ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.etag = createETagGenerator({ weak: false });
	/**
	* Return weak ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.wetag = createETagGenerator({ weak: true });
	/**
	* Check if `path` looks absolute.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	exports.isAbsolute = function(path) {
		if ("/" === path[0]) return true;
		if (":" === path[1] && ("\\" === path[2] || "/" === path[2])) return true;
		if ("\\\\" === path.substring(0, 2)) return true;
	};
	/**
	* Flatten the given `arr`.
	*
	* @param {Array} arr
	* @return {Array}
	* @api private
	*/
	exports.flatten = deprecate.function(flatten, "utils.flatten: use array-flatten npm module instead");
	/**
	* Normalize the given `type`, for example "html" becomes "text/html".
	*
	* @param {String} type
	* @return {Object}
	* @api private
	*/
	exports.normalizeType = function(type) {
		return ~type.indexOf("/") ? acceptParams(type) : {
			value: mime.lookup(type),
			params: {}
		};
	};
	/**
	* Normalize `types`, for example "html" becomes "text/html".
	*
	* @param {Array} types
	* @return {Array}
	* @api private
	*/
	exports.normalizeTypes = function(types) {
		var ret = [];
		for (var i = 0; i < types.length; ++i) ret.push(exports.normalizeType(types[i]));
		return ret;
	};
	/**
	* Generate Content-Disposition header appropriate for the filename.
	* non-ascii filenames are urlencoded and a filename* parameter is added
	*
	* @param {String} filename
	* @return {String}
	* @api private
	*/
	exports.contentDisposition = deprecate.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
	/**
	* Parse accept params `str` returning an
	* object with `.value`, `.quality` and `.params`.
	*
	* @param {String} str
	* @return {Object}
	* @api private
	*/
	function acceptParams(str) {
		var parts = str.split(/ *; */);
		var ret = {
			value: parts[0],
			quality: 1,
			params: {}
		};
		for (var i = 1; i < parts.length; ++i) {
			var pms = parts[i].split(/ *= */);
			if ("q" === pms[0]) ret.quality = parseFloat(pms[1]);
			else ret.params[pms[0]] = pms[1];
		}
		return ret;
	}
	/**
	* Compile "etag" value to function.
	*
	* @param  {Boolean|String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileETag = function(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "weak":
				fn = exports.wetag;
				break;
			case false: break;
			case "strong":
				fn = exports.etag;
				break;
			default: throw new TypeError("unknown value for etag function: " + val);
		}
		return fn;
	};
	/**
	* Compile "query parser" value to function.
	*
	* @param  {String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileQueryParser = function compileQueryParser(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "simple":
				fn = querystring.parse;
				break;
			case false:
				fn = newObject;
				break;
			case "extended":
				fn = parseExtendedQueryString;
				break;
			default: throw new TypeError("unknown value for query parser function: " + val);
		}
		return fn;
	};
	/**
	* Compile "proxy trust" value to function.
	*
	* @param  {Boolean|String|Number|Array|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileTrust = function(val) {
		if (typeof val === "function") return val;
		if (val === true) return function() {
			return true;
		};
		if (typeof val === "number") return function(a, i) {
			return i < val;
		};
		if (typeof val === "string") val = val.split(",").map(function(v) {
			return v.trim();
		});
		return proxyaddr.compile(val || []);
	};
	/**
	* Set the charset in a given Content-Type string.
	*
	* @param {String} type
	* @param {String} charset
	* @return {String}
	* @api private
	*/
	exports.setCharset = function setCharset(type, charset) {
		if (!type || !charset) return type;
		var parsed = contentType.parse(type);
		parsed.parameters.charset = charset;
		return contentType.format(parsed);
	};
	/**
	* Create an ETag generator function, generating ETags with
	* the given options.
	*
	* @param {object} options
	* @return {function}
	* @private
	*/
	function createETagGenerator(options) {
		return function generateETag(body, encoding) {
			return etag(!Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body, options);
		};
	}
	/**
	* Parse an extended query string with qs.
	*
	* @param {String} str
	* @return {Object}
	* @private
	*/
	function parseExtendedQueryString(str) {
		return qs.parse(str, { allowPrototypes: true });
	}
	/**
	* Return new empty object.
	*
	* @return {Object}
	* @api private
	*/
	function newObject() {
		return {};
	}
}));

//#endregion
//#region ../../node_modules/express/lib/application.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_application = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var finalhandler = require_finalhandler();
	var Router = require_router();
	var methods = require_methods();
	var middleware = require_init();
	var query = require_query();
	var debug = require_src$3()("express:application");
	var View = require_view();
	var http$4 = require("http");
	var compileETag = require_utils().compileETag;
	var compileQueryParser = require_utils().compileQueryParser;
	var compileTrust = require_utils().compileTrust;
	var deprecate = require_depd()("express");
	var flatten = require_array_flatten();
	var merge = require_utils_merge();
	var resolve$3 = require("path").resolve;
	var setPrototypeOf = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var slice = Array.prototype.slice;
	/**
	* Application prototype.
	*/
	var app = exports = module.exports = {};
	/**
	* Variable for trust proxy inheritance back-compat
	* @private
	*/
	var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
	/**
	* Initialize the server.
	*
	*   - setup default configuration
	*   - setup default middleware
	*   - setup route reflection methods
	*
	* @private
	*/
	app.init = function init() {
		this.cache = {};
		this.engines = {};
		this.settings = {};
		this.defaultConfiguration();
	};
	/**
	* Initialize application configuration.
	* @private
	*/
	app.defaultConfiguration = function defaultConfiguration() {
		var env = process.env.NODE_ENV || "development";
		this.enable("x-powered-by");
		this.set("etag", "weak");
		this.set("env", env);
		this.set("query parser", "extended");
		this.set("subdomain offset", 2);
		this.set("trust proxy", false);
		Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
			configurable: true,
			value: true
		});
		debug("booting in %s mode", env);
		this.on("mount", function onmount(parent) {
			if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
				delete this.settings["trust proxy"];
				delete this.settings["trust proxy fn"];
			}
			setPrototypeOf(this.request, parent.request);
			setPrototypeOf(this.response, parent.response);
			setPrototypeOf(this.engines, parent.engines);
			setPrototypeOf(this.settings, parent.settings);
		});
		this.locals = Object.create(null);
		this.mountpath = "/";
		this.locals.settings = this.settings;
		this.set("view", View);
		this.set("views", resolve$3("views"));
		this.set("jsonp callback name", "callback");
		if (env === "production") this.enable("view cache");
		Object.defineProperty(this, "router", { get: function() {
			throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
		} });
	};
	/**
	* lazily adds the base router if it has not yet been added.
	*
	* We cannot add the base router in the defaultConfiguration because
	* it reads app settings which might be set after that has run.
	*
	* @private
	*/
	app.lazyrouter = function lazyrouter() {
		if (!this._router) {
			this._router = new Router({
				caseSensitive: this.enabled("case sensitive routing"),
				strict: this.enabled("strict routing")
			});
			this._router.use(query(this.get("query parser fn")));
			this._router.use(middleware.init(this));
		}
	};
	/**
	* Dispatch a req, res pair into the application. Starts pipeline processing.
	*
	* If no callback is provided, then default error handlers will respond
	* in the event of an error bubbling through the stack.
	*
	* @private
	*/
	app.handle = function handle(req, res, callback) {
		var router = this._router;
		var done = callback || finalhandler(req, res, {
			env: this.get("env"),
			onerror: logerror.bind(this)
		});
		if (!router) {
			debug("no routes defined on app");
			done();
			return;
		}
		router.handle(req, res, done);
	};
	/**
	* Proxy `Router#use()` to add middleware to the app router.
	* See Router#use() documentation for details.
	*
	* If the _fn_ parameter is an express app, then it will be
	* mounted at the _route_ specified.
	*
	* @public
	*/
	app.use = function use(fn) {
		var offset = 0;
		var path$49 = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path$49 = fn;
			}
		}
		var fns = flatten(slice.call(arguments, offset));
		if (fns.length === 0) throw new TypeError("app.use() requires a middleware function");
		this.lazyrouter();
		var router = this._router;
		fns.forEach(function(fn) {
			if (!fn || !fn.handle || !fn.set) return router.use(path$49, fn);
			debug(".use app under %s", path$49);
			fn.mountpath = path$49;
			fn.parent = this;
			router.use(path$49, function mounted_app(req, res, next) {
				var orig = req.app;
				fn.handle(req, res, function(err) {
					setPrototypeOf(req, orig.request);
					setPrototypeOf(res, orig.response);
					next(err);
				});
			});
			fn.emit("mount", this);
		}, this);
		return this;
	};
	/**
	* Proxy to the app `Router#route()`
	* Returns a new `Route` instance for the _path_.
	*
	* Routes are isolated middleware stacks for specific paths.
	* See the Route api docs for details.
	*
	* @public
	*/
	app.route = function route(path$50) {
		this.lazyrouter();
		return this._router.route(path$50);
	};
	/**
	* Register the given template engine callback `fn`
	* as `ext`.
	*
	* By default will `require()` the engine based on the
	* file extension. For example if you try to render
	* a "foo.ejs" file Express will invoke the following internally:
	*
	*     app.engine('ejs', require('ejs').__express);
	*
	* For engines that do not provide `.__express` out of the box,
	* or if you wish to "map" a different extension to the template engine
	* you may use this method. For example mapping the EJS template engine to
	* ".html" files:
	*
	*     app.engine('html', require('ejs').renderFile);
	*
	* In this case EJS provides a `.renderFile()` method with
	* the same signature that Express expects: `(path, options, callback)`,
	* though note that it aliases this method as `ejs.__express` internally
	* so if you're using ".ejs" extensions you don't need to do anything.
	*
	* Some template engines do not follow this convention, the
	* [Consolidate.js](https://github.com/tj/consolidate.js)
	* library was created to map all of node's popular template
	* engines to follow this convention, thus allowing them to
	* work seamlessly within Express.
	*
	* @param {String} ext
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.engine = function engine(ext, fn) {
		if (typeof fn !== "function") throw new Error("callback function required");
		var extension = ext[0] !== "." ? "." + ext : ext;
		this.engines[extension] = fn;
		return this;
	};
	/**
	* Proxy to `Router#param()` with one added api feature. The _name_ parameter
	* can be an array of names.
	*
	* See the Router#param() docs for more details.
	*
	* @param {String|Array} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.param = function param(name, fn) {
		this.lazyrouter();
		if (Array.isArray(name)) {
			for (var i = 0; i < name.length; i++) this.param(name[i], fn);
			return this;
		}
		this._router.param(name, fn);
		return this;
	};
	/**
	* Assign `setting` to `val`, or return `setting`'s value.
	*
	*    app.set('foo', 'bar');
	*    app.set('foo');
	*    // => "bar"
	*
	* Mounted servers inherit their parent server's settings.
	*
	* @param {String} setting
	* @param {*} [val]
	* @return {Server} for chaining
	* @public
	*/
	app.set = function set(setting, val) {
		if (arguments.length === 1) {
			var settings = this.settings;
			while (settings && settings !== Object.prototype) {
				if (hasOwnProperty.call(settings, setting)) return settings[setting];
				settings = Object.getPrototypeOf(settings);
			}
			return;
		}
		debug("set \"%s\" to %o", setting, val);
		this.settings[setting] = val;
		switch (setting) {
			case "etag":
				this.set("etag fn", compileETag(val));
				break;
			case "query parser":
				this.set("query parser fn", compileQueryParser(val));
				break;
			case "trust proxy":
				this.set("trust proxy fn", compileTrust(val));
				Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
					configurable: true,
					value: false
				});
				break;
		}
		return this;
	};
	/**
	* Return the app's absolute pathname
	* based on the parent(s) that have
	* mounted it.
	*
	* For example if the application was
	* mounted as "/admin", which itself
	* was mounted as "/blog" then the
	* return value would be "/blog/admin".
	*
	* @return {String}
	* @private
	*/
	app.path = function path$51() {
		return this.parent ? this.parent.path() + this.mountpath : "";
	};
	/**
	* Check if `setting` is enabled (truthy).
	*
	*    app.enabled('foo')
	*    // => false
	*
	*    app.enable('foo')
	*    app.enabled('foo')
	*    // => true
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.enabled = function enabled(setting) {
		return Boolean(this.set(setting));
	};
	/**
	* Check if `setting` is disabled.
	*
	*    app.disabled('foo')
	*    // => true
	*
	*    app.enable('foo')
	*    app.disabled('foo')
	*    // => false
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.disabled = function disabled(setting) {
		return !this.set(setting);
	};
	/**
	* Enable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.enable = function enable(setting) {
		return this.set(setting, true);
	};
	/**
	* Disable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.disable = function disable(setting) {
		return this.set(setting, false);
	};
	/**
	* Delegate `.VERB(...)` calls to `router.VERB(...)`.
	*/
	methods.forEach(function(method) {
		app[method] = function(path$52) {
			if (method === "get" && arguments.length === 1) return this.set(path$52);
			this.lazyrouter();
			var route = this._router.route(path$52);
			route[method].apply(route, slice.call(arguments, 1));
			return this;
		};
	});
	/**
	* Special-cased "all" method, applying the given route `path`,
	* middleware, and callback to _every_ HTTP method.
	*
	* @param {String} path
	* @param {Function} ...
	* @return {app} for chaining
	* @public
	*/
	app.all = function all(path$53) {
		this.lazyrouter();
		var route = this._router.route(path$53);
		var args = slice.call(arguments, 1);
		for (var i = 0; i < methods.length; i++) route[methods[i]].apply(route, args);
		return this;
	};
	app.del = deprecate.function(app.delete, "app.del: Use app.delete instead");
	/**
	* Render the given view `name` name with `options`
	* and a callback accepting an error and the
	* rendered template string.
	*
	* Example:
	*
	*    app.render('email', { name: 'Tobi' }, function(err, html){
	*      // ...
	*    })
	*
	* @param {String} name
	* @param {Object|Function} options or fn
	* @param {Function} callback
	* @public
	*/
	app.render = function render(name, options, callback) {
		var cache = this.cache;
		var done = callback;
		var engines = this.engines;
		var opts = options;
		var renderOptions = {};
		var view;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		merge(renderOptions, this.locals);
		if (opts._locals) merge(renderOptions, opts._locals);
		merge(renderOptions, opts);
		if (renderOptions.cache == null) renderOptions.cache = this.enabled("view cache");
		if (renderOptions.cache) view = cache[name];
		if (!view) {
			view = new (this.get("view"))(name, {
				defaultEngine: this.get("view engine"),
				root: this.get("views"),
				engines
			});
			if (!view.path) {
				var dirs = Array.isArray(view.root) && view.root.length > 1 ? "directories \"" + view.root.slice(0, -1).join("\", \"") + "\" or \"" + view.root[view.root.length - 1] + "\"" : "directory \"" + view.root + "\"";
				var err = /* @__PURE__ */ new Error("Failed to lookup view \"" + name + "\" in views " + dirs);
				err.view = view;
				return done(err);
			}
			if (renderOptions.cache) cache[name] = view;
		}
		tryRender(view, renderOptions, done);
	};
	/**
	* Listen for connections.
	*
	* A node `http.Server` is returned, with this
	* application (which is a `Function`) as its
	* callback. If you wish to create both an HTTP
	* and HTTPS server you may do so with the "http"
	* and "https" modules as shown here:
	*
	*    var http = require('http')
	*      , https = require('https')
	*      , express = require('express')
	*      , app = express();
	*
	*    http.createServer(app).listen(80);
	*    https.createServer({ ... }, app).listen(443);
	*
	* @return {http.Server}
	* @public
	*/
	app.listen = function listen() {
		var server = http$4.createServer(this);
		return server.listen.apply(server, arguments);
	};
	/**
	* Log error using console.error.
	*
	* @param {Error} err
	* @private
	*/
	function logerror(err) {
		/* istanbul ignore next */
		if (this.get("env") !== "test") console.error(err.stack || err.toString());
	}
	/**
	* Try rendering a view.
	* @private
	*/
	function tryRender(view, options, callback) {
		try {
			view.render(options, callback);
		} catch (err) {
			callback(err);
		}
	}
}));

//#endregion
//#region ../../node_modules/negotiator/lib/charset.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_charset = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;
	/**
	* Module variables.
	* @private
	*/
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Charset header.
	* @private
	*/
	function parseAcceptCharset(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var charset = parseCharset(accepts[i].trim(), i);
			if (charset) accepts[j++] = charset;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a charset from the Accept-Charset header.
	* @private
	*/
	function parseCharset(str, i) {
		var match = simpleCharsetRegExp.exec(str);
		if (!match) return null;
		var charset = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			charset,
			q,
			i
		};
	}
	/**
	* Get the priority of a charset.
	* @private
	*/
	function getCharsetPriority(charset, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(charset, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the charset.
	* @private
	*/
	function specify(charset, spec, index) {
		var s = 0;
		if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
		else if (spec.charset !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred charsets from an Accept-Charset header.
	* @public
	*/
	function preferredCharsets(accept, provided) {
		var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
		var priorities = provided.map(function getPriority(type, index) {
			return getCharsetPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full charset string.
	* @private
	*/
	function getFullCharset(spec) {
		return spec.charset;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/negotiator/lib/encoding.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;
	/**
	* Module variables.
	* @private
	*/
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Encoding header.
	* @private
	*/
	function parseAcceptEncoding(accept) {
		var accepts = accept.split(",");
		var hasIdentity = false;
		var minQuality = 1;
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var encoding = parseEncoding(accepts[i].trim(), i);
			if (encoding) {
				accepts[j++] = encoding;
				hasIdentity = hasIdentity || specify("identity", encoding);
				minQuality = Math.min(minQuality, encoding.q || 1);
			}
		}
		if (!hasIdentity) accepts[j++] = {
			encoding: "identity",
			q: minQuality,
			i
		};
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse an encoding from the Accept-Encoding header.
	* @private
	*/
	function parseEncoding(str, i) {
		var match = simpleEncodingRegExp.exec(str);
		if (!match) return null;
		var encoding = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			encoding,
			q,
			i
		};
	}
	/**
	* Get the priority of an encoding.
	* @private
	*/
	function getEncodingPriority(encoding, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(encoding, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the encoding.
	* @private
	*/
	function specify(encoding, spec, index) {
		var s = 0;
		if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
		else if (spec.encoding !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred encodings from an Accept-Encoding header.
	* @public
	*/
	function preferredEncodings(accept, provided) {
		var accepts = parseAcceptEncoding(accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
		var priorities = provided.map(function getPriority(type, index) {
			return getEncodingPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full encoding string.
	* @private
	*/
	function getFullEncoding(spec) {
		return spec.encoding;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/negotiator/lib/language.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_language = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;
	/**
	* Module variables.
	* @private
	*/
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Language header.
	* @private
	*/
	function parseAcceptLanguage(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var language = parseLanguage(accepts[i].trim(), i);
			if (language) accepts[j++] = language;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a language from the Accept-Language header.
	* @private
	*/
	function parseLanguage(str, i) {
		var match = simpleLanguageRegExp.exec(str);
		if (!match) return null;
		var prefix = match[1];
		var suffix = match[2];
		var full = prefix;
		if (suffix) full += "-" + suffix;
		var q = 1;
		if (match[3]) {
			var params = match[3].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].split("=");
				if (p[0] === "q") q = parseFloat(p[1]);
			}
		}
		return {
			prefix,
			suffix,
			q,
			i,
			full
		};
	}
	/**
	* Get the priority of a language.
	* @private
	*/
	function getLanguagePriority(language, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(language, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the language.
	* @private
	*/
	function specify(language, spec, index) {
		var p = parseLanguage(language);
		if (!p) return null;
		var s = 0;
		if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
		else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
		else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
		else if (spec.full !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred languages from an Accept-Language header.
	* @public
	*/
	function preferredLanguages(accept, provided) {
		var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
		var priorities = provided.map(function getPriority(type, index) {
			return getLanguagePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full language string.
	* @private
	*/
	function getFullLanguage(spec) {
		return spec.full;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
}));

//#endregion
//#region ../../node_modules/negotiator/lib/mediaType.js
/**
* negotiator
* Copyright(c) 2012 Isaac Z. Schlueter
* Copyright(c) 2014 Federico Romero
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_mediaType = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;
	/**
	* Module variables.
	* @private
	*/
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept header.
	* @private
	*/
	function parseAccept(accept) {
		var accepts = splitMediaTypes(accept);
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var mediaType = parseMediaType(accepts[i].trim(), i);
			if (mediaType) accepts[j++] = mediaType;
		}
		accepts.length = j;
		return accepts;
	}
	/**
	* Parse a media type from the Accept header.
	* @private
	*/
	function parseMediaType(str, i) {
		var match = simpleMediaTypeRegExp.exec(str);
		if (!match) return null;
		var params = Object.create(null);
		var q = 1;
		var subtype = match[2];
		var type = match[1];
		if (match[3]) {
			var kvps = splitParameters(match[3]).map(splitKeyValuePair);
			for (var j = 0; j < kvps.length; j++) {
				var pair = kvps[j];
				var key = pair[0].toLowerCase();
				var val = pair[1];
				var value = val && val[0] === "\"" && val[val.length - 1] === "\"" ? val.substr(1, val.length - 2) : val;
				if (key === "q") {
					q = parseFloat(value);
					break;
				}
				params[key] = value;
			}
		}
		return {
			type,
			subtype,
			params,
			q,
			i
		};
	}
	/**
	* Get the priority of a media type.
	* @private
	*/
	function getMediaTypePriority(type, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(type, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the media type.
	* @private
	*/
	function specify(type, spec, index) {
		var p = parseMediaType(type);
		var s = 0;
		if (!p) return null;
		if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
		else if (spec.type != "*") return null;
		if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
		else if (spec.subtype != "*") return null;
		var keys = Object.keys(spec.params);
		if (keys.length > 0) if (keys.every(function(k) {
			return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
		})) s |= 1;
		else return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	/**
	* Get the preferred media types from an Accept header.
	* @public
	*/
	function preferredMediaTypes(accept, provided) {
		var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
		var priorities = provided.map(function getPriority(type, index) {
			return getMediaTypePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full type string.
	* @private
	*/
	function getFullType(spec) {
		return spec.type + "/" + spec.subtype;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
	/**
	* Count the number of quotes in a string.
	* @private
	*/
	function quoteCount(string) {
		var count = 0;
		var index = 0;
		while ((index = string.indexOf("\"", index)) !== -1) {
			count++;
			index++;
		}
		return count;
	}
	/**
	* Split a key value pair.
	* @private
	*/
	function splitKeyValuePair(str) {
		var index = str.indexOf("=");
		var key;
		var val;
		if (index === -1) key = str;
		else {
			key = str.substr(0, index);
			val = str.substr(index + 1);
		}
		return [key, val];
	}
	/**
	* Split an Accept header into media types.
	* @private
	*/
	function splitMediaTypes(accept) {
		var accepts = accept.split(",");
		for (var i = 1, j = 0; i < accepts.length; i++) if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
		else accepts[j] += "," + accepts[i];
		accepts.length = j + 1;
		return accepts;
	}
	/**
	* Split a string of parameters.
	* @private
	*/
	function splitParameters(str) {
		var parameters = str.split(";");
		for (var i = 1, j = 0; i < parameters.length; i++) if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
		else parameters[j] += ";" + parameters[i];
		parameters.length = j + 1;
		for (var i = 0; i < parameters.length; i++) parameters[i] = parameters[i].trim();
		return parameters;
	}
}));

//#endregion
//#region ../../node_modules/negotiator/index.js
/*!
* negotiator
* Copyright(c) 2012 Federico Romero
* Copyright(c) 2012-2014 Isaac Z. Schlueter
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_negotiator = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var preferredCharsets = require_charset();
	var preferredEncodings = require_encoding();
	var preferredLanguages = require_language();
	var preferredMediaTypes = require_mediaType();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;
	/**
	* Create a Negotiator instance from a request.
	* @param {object} request
	* @public
	*/
	function Negotiator(request) {
		if (!(this instanceof Negotiator)) return new Negotiator(request);
		this.request = request;
	}
	Negotiator.prototype.charset = function charset(available) {
		var set = this.charsets(available);
		return set && set[0];
	};
	Negotiator.prototype.charsets = function charsets(available) {
		return preferredCharsets(this.request.headers["accept-charset"], available);
	};
	Negotiator.prototype.encoding = function encoding(available) {
		var set = this.encodings(available);
		return set && set[0];
	};
	Negotiator.prototype.encodings = function encodings(available) {
		return preferredEncodings(this.request.headers["accept-encoding"], available);
	};
	Negotiator.prototype.language = function language(available) {
		var set = this.languages(available);
		return set && set[0];
	};
	Negotiator.prototype.languages = function languages(available) {
		return preferredLanguages(this.request.headers["accept-language"], available);
	};
	Negotiator.prototype.mediaType = function mediaType(available) {
		var set = this.mediaTypes(available);
		return set && set[0];
	};
	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
		return preferredMediaTypes(this.request.headers.accept, available);
	};
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}));

//#endregion
//#region ../../node_modules/accepts/index.js
/*!
* accepts
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_accepts = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Negotiator = require_negotiator();
	var mime = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Accepts;
	/**
	* Create a new Accepts object for the given req.
	*
	* @param {object} req
	* @public
	*/
	function Accepts(req) {
		if (!(this instanceof Accepts)) return new Accepts(req);
		this.headers = req.headers;
		this.negotiator = new Negotiator(req);
	}
	/**
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single mime type string
	* such as "application/json", the extension name
	* such as "json" or an array `["json", "html", "text/plain"]`. When a list
	* or array is given the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     this.types('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     this.types('html');
	*     // => "html"
	*     this.types('text/html');
	*     // => "text/html"
	*     this.types('json', 'text');
	*     // => "json"
	*     this.types('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     this.types('image/png');
	*     this.types('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     this.types(['html', 'json']);
	*     this.types('html', 'json');
	*     // => "json"
	*
	* @param {String|Array} types...
	* @return {String|Array|Boolean}
	* @public
	*/
	Accepts.prototype.type = Accepts.prototype.types = function(types_) {
		var types = types_;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i];
		}
		if (!types || types.length === 0) return this.negotiator.mediaTypes();
		if (!this.headers.accept) return types[0];
		var mimes = types.map(extToMime);
		var first = this.negotiator.mediaTypes(mimes.filter(validMime))[0];
		return first ? types[mimes.indexOf(first)] : false;
	};
	/**
	* Return accepted encodings or best fit based on `encodings`.
	*
	* Given `Accept-Encoding: gzip, deflate`
	* an array sorted by quality is returned:
	*
	*     ['gzip', 'deflate']
	*
	* @param {String|Array} encodings...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
		var encodings = encodings_;
		if (encodings && !Array.isArray(encodings)) {
			encodings = new Array(arguments.length);
			for (var i = 0; i < encodings.length; i++) encodings[i] = arguments[i];
		}
		if (!encodings || encodings.length === 0) return this.negotiator.encodings();
		return this.negotiator.encodings(encodings)[0] || false;
	};
	/**
	* Return accepted charsets or best fit based on `charsets`.
	*
	* Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	* an array sorted by quality is returned:
	*
	*     ['utf-8', 'utf-7', 'iso-8859-1']
	*
	* @param {String|Array} charsets...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
		var charsets = charsets_;
		if (charsets && !Array.isArray(charsets)) {
			charsets = new Array(arguments.length);
			for (var i = 0; i < charsets.length; i++) charsets[i] = arguments[i];
		}
		if (!charsets || charsets.length === 0) return this.negotiator.charsets();
		return this.negotiator.charsets(charsets)[0] || false;
	};
	/**
	* Return accepted languages or best fit based on `langs`.
	*
	* Given `Accept-Language: en;q=0.8, es, pt`
	* an array sorted by quality is returned:
	*
	*     ['es', 'pt', 'en']
	*
	* @param {String|Array} langs...
	* @return {Array|String}
	* @public
	*/
	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
		var languages = languages_;
		if (languages && !Array.isArray(languages)) {
			languages = new Array(arguments.length);
			for (var i = 0; i < languages.length; i++) languages[i] = arguments[i];
		}
		if (!languages || languages.length === 0) return this.negotiator.languages();
		return this.negotiator.languages(languages)[0] || false;
	};
	/**
	* Convert extnames to mime.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function extToMime(type) {
		return type.indexOf("/") === -1 ? mime.lookup(type) : type;
	}
	/**
	* Check if mime is valid.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function validMime(type) {
		return typeof type === "string";
	}
}));

//#endregion
//#region ../../node_modules/express/lib/request.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var accepts = require_accepts();
	var deprecate = require_depd()("express");
	var isIP = require("net").isIP;
	var typeis = require_type_is();
	var http$3 = require("http");
	var fresh = require_fresh();
	var parseRange = require_range_parser();
	var parse = require_parseurl();
	var proxyaddr = require_proxy_addr();
	/**
	* Request prototype.
	* @public
	*/
	var req = Object.create(http$3.IncomingMessage.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = req;
	/**
	* Return request header.
	*
	* The `Referrer` header field is special-cased,
	* both `Referrer` and `Referer` are interchangeable.
	*
	* Examples:
	*
	*     req.get('Content-Type');
	*     // => "text/plain"
	*
	*     req.get('content-type');
	*     // => "text/plain"
	*
	*     req.get('Something');
	*     // => undefined
	*
	* Aliased as `req.header()`.
	*
	* @param {String} name
	* @return {String}
	* @public
	*/
	req.get = req.header = function header(name) {
		if (!name) throw new TypeError("name argument is required to req.get");
		if (typeof name !== "string") throw new TypeError("name must be a string to req.get");
		var lc = name.toLowerCase();
		switch (lc) {
			case "referer":
			case "referrer": return this.headers.referrer || this.headers.referer;
			default: return this.headers[lc];
		}
	};
	/**
	* To do: update docs.
	*
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single MIME type string
	* such as "application/json", an extension name
	* such as "json", a comma-delimited list such as "json, html, text/plain",
	* an argument list such as `"json", "html", "text/plain"`,
	* or an array `["json", "html", "text/plain"]`. When a list
	* or array is given, the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     req.accepts('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('html');
	*     // => "html"
	*     req.accepts('text/html');
	*     // => "text/html"
	*     req.accepts('json, text');
	*     // => "json"
	*     req.accepts('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('image/png');
	*     req.accepts('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     req.accepts(['html', 'json']);
	*     req.accepts('html', 'json');
	*     req.accepts('html, json');
	*     // => "json"
	*
	* @param {String|Array} type(s)
	* @return {String|Array|Boolean}
	* @public
	*/
	req.accepts = function() {
		var accept = accepts(this);
		return accept.types.apply(accept, arguments);
	};
	/**
	* Check if the given `encoding`s are accepted.
	*
	* @param {String} ...encoding
	* @return {String|Array}
	* @public
	*/
	req.acceptsEncodings = function() {
		var accept = accepts(this);
		return accept.encodings.apply(accept, arguments);
	};
	req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
	/**
	* Check if the given `charset`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...charset
	* @return {String|Array}
	* @public
	*/
	req.acceptsCharsets = function() {
		var accept = accepts(this);
		return accept.charsets.apply(accept, arguments);
	};
	req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
	/**
	* Check if the given `lang`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...lang
	* @return {String|Array}
	* @public
	*/
	req.acceptsLanguages = function() {
		var accept = accepts(this);
		return accept.languages.apply(accept, arguments);
	};
	req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
	/**
	* Parse Range header field, capping to the given `size`.
	*
	* Unspecified ranges such as "0-" require knowledge of your resource length. In
	* the case of a byte range this is of course the total number of bytes. If the
	* Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	* and `-2` when syntactically invalid.
	*
	* When ranges are returned, the array has a "type" property which is the type of
	* range that is required (most commonly, "bytes"). Each array element is an object
	* with a "start" and "end" property for the portion of the range.
	*
	* The "combine" option can be set to `true` and overlapping & adjacent ranges
	* will be combined into a single range.
	*
	* NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	* should respond with 4 users when available, not 3.
	*
	* @param {number} size
	* @param {object} [options]
	* @param {boolean} [options.combine=false]
	* @return {number|array}
	* @public
	*/
	req.range = function range(size, options) {
		var range = this.get("Range");
		if (!range) return;
		return parseRange(size, range, options);
	};
	/**
	* Return the value of param `name` when present or `defaultValue`.
	*
	*  - Checks route placeholders, ex: _/user/:id_
	*  - Checks body params, ex: id=12, {"id":12}
	*  - Checks query string params, ex: ?id=12
	*
	* To utilize request bodies, `req.body`
	* should be an object. This can be done by using
	* the `bodyParser()` middleware.
	*
	* @param {String} name
	* @param {Mixed} [defaultValue]
	* @return {String}
	* @public
	*/
	req.param = function param(name, defaultValue) {
		var params = this.params || {};
		var body = this.body || {};
		var query = this.query || {};
		deprecate("req.param(" + (arguments.length === 1 ? "name" : "name, default") + "): Use req.params, req.body, or req.query instead");
		if (null != params[name] && params.hasOwnProperty(name)) return params[name];
		if (null != body[name]) return body[name];
		if (null != query[name]) return query[name];
		return defaultValue;
	};
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains the given mime `type`.
	*
	* Examples:
	*
	*      // With Content-Type: text/html; charset=utf-8
	*      req.is('html');
	*      req.is('text/html');
	*      req.is('text/*');
	*      // => true
	*
	*      // When Content-Type is application/json
	*      req.is('json');
	*      req.is('application/json');
	*      req.is('application/*');
	*      // => true
	*
	*      req.is('html');
	*      // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	req.is = function is(types) {
		var arr = types;
		if (!Array.isArray(types)) {
			arr = new Array(arguments.length);
			for (var i = 0; i < arr.length; i++) arr[i] = arguments[i];
		}
		return typeis(this, arr);
	};
	/**
	* Return the protocol string "http" or "https"
	* when requested with TLS. When the "trust proxy"
	* setting trusts the socket address, the
	* "X-Forwarded-Proto" header field will be trusted
	* and used if present.
	*
	* If you're running behind a reverse proxy that
	* supplies https for you this may be enabled.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "protocol", function protocol() {
		var proto = this.connection.encrypted ? "https" : "http";
		if (!this.app.get("trust proxy fn")(this.connection.remoteAddress, 0)) return proto;
		var header = this.get("X-Forwarded-Proto") || proto;
		var index = header.indexOf(",");
		return index !== -1 ? header.substring(0, index).trim() : header.trim();
	});
	/**
	* Short-hand for:
	*
	*    req.protocol === 'https'
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "secure", function secure() {
		return this.protocol === "https";
	});
	/**
	* Return the remote address from the trusted proxy.
	*
	* The is the remote address on the socket unless
	* "trust proxy" is set.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "ip", function ip() {
		var trust = this.app.get("trust proxy fn");
		return proxyaddr(this, trust);
	});
	/**
	* When "trust proxy" is set, trusted proxy addresses + client.
	*
	* For example if the value were "client, proxy1, proxy2"
	* you would receive the array `["client", "proxy1", "proxy2"]`
	* where "proxy2" is the furthest down-stream and "proxy1" and
	* "proxy2" were trusted.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req, "ips", function ips() {
		var trust = this.app.get("trust proxy fn");
		var addrs = proxyaddr.all(this, trust);
		addrs.reverse().pop();
		return addrs;
	});
	/**
	* Return subdomains as an array.
	*
	* Subdomains are the dot-separated parts of the host before the main domain of
	* the app. By default, the domain of the app is assumed to be the last two
	* parts of the host. This can be changed by setting "subdomain offset".
	*
	* For example, if the domain is "tobi.ferrets.example.com":
	* If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	* If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req, "subdomains", function subdomains() {
		var hostname = this.hostname;
		if (!hostname) return [];
		var offset = this.app.get("subdomain offset");
		return (!isIP(hostname) ? hostname.split(".").reverse() : [hostname]).slice(offset);
	});
	/**
	* Short-hand for `url.parse(req.url).pathname`.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "path", function path() {
		return parse(this).pathname;
	});
	/**
	* Parse the "Host" header field to a hostname.
	*
	* When the "trust proxy" setting trusts the socket
	* address, the "X-Forwarded-Host" header field will
	* be trusted.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req, "hostname", function hostname() {
		var trust = this.app.get("trust proxy fn");
		var host = this.get("X-Forwarded-Host");
		if (!host || !trust(this.connection.remoteAddress, 0)) host = this.get("Host");
		else if (host.indexOf(",") !== -1) host = host.substring(0, host.indexOf(",")).trimRight();
		if (!host) return;
		var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
		var index = host.indexOf(":", offset);
		return index !== -1 ? host.substring(0, index) : host;
	});
	defineGetter(req, "host", deprecate.function(function host() {
		return this.hostname;
	}, "req.host: Use req.hostname instead"));
	/**
	* Check if the request is fresh, aka
	* Last-Modified and/or the ETag
	* still match.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "fresh", function() {
		var method = this.method;
		var res = this.res;
		var status = res.statusCode;
		if ("GET" !== method && "HEAD" !== method) return false;
		if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
			"etag": res.get("ETag"),
			"last-modified": res.get("Last-Modified")
		});
		return false;
	});
	/**
	* Check if the request is stale, aka
	* "Last-Modified" and / or the "ETag" for the
	* resource has changed.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "stale", function stale() {
		return !this.fresh;
	});
	/**
	* Check if the request was an _XMLHttpRequest_.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req, "xhr", function xhr() {
		return (this.get("X-Requested-With") || "").toLowerCase() === "xmlhttprequest";
	});
	/**
	* Helper function for creating a getter on an object.
	*
	* @param {Object} obj
	* @param {String} name
	* @param {Function} getter
	* @private
	*/
	function defineGetter(obj, name, getter) {
		Object.defineProperty(obj, name, {
			configurable: true,
			enumerable: true,
			get: getter
		});
	}
}));

//#endregion
//#region ../../node_modules/cookie-signature/index.js
var require_cookie_signature = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module dependencies.
	*/
	var crypto = require("crypto");
	/**
	* Sign the given `val` with `secret`.
	*
	* @param {String} val
	* @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
	* @return {String}
	* @api private
	*/
	exports.sign = function(val, secret) {
		if ("string" !== typeof val) throw new TypeError("Cookie value must be provided as a string.");
		if (null == secret) throw new TypeError("Secret key must be provided.");
		return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
	};
	/**
	* Unsign and decode the given `val` with `secret`,
	* returning `false` if the signature is invalid.
	*
	* @param {String} val
	* @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
	* @return {String|Boolean}
	* @api private
	*/
	exports.unsign = function(val, secret) {
		if ("string" !== typeof val) throw new TypeError("Signed cookie string must be provided.");
		if (null == secret) throw new TypeError("Secret key must be provided.");
		var str = val.slice(0, val.lastIndexOf("."));
		return sha1(exports.sign(str, secret)) == sha1(val) ? str : false;
	};
	/**
	* Private
	*/
	function sha1(str) {
		return crypto.createHash("sha1").update(str).digest("hex");
	}
}));

//#endregion
//#region ../../node_modules/cookie/index.js
/*!
* cookie
* Copyright(c) 2012-2014 Roman Shtylman
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_cookie = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Module exports.
	* @public
	*/
	exports.parse = parse;
	exports.serialize = serialize;
	/**
	* Module variables.
	* @private
	*/
	var __toString = Object.prototype.toString;
	var __hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	* RegExp to match cookie-name in RFC 6265 sec 4.1.1
	* This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	* which has been replaced by the token definition in RFC 7230 appendix B.
	*
	* cookie-name       = token
	* token             = 1*tchar
	* tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	*                     "*" / "+" / "-" / "." / "^" / "_" /
	*                     "`" / "|" / "~" / DIGIT / ALPHA
	*/
	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* RegExp to match cookie-value in RFC 6265 sec 4.1.1
	*
	* cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	* cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	*                     ; US-ASCII characters excluding CTLs,
	*                     ; whitespace DQUOTE, comma, semicolon,
	*                     ; and backslash
	*/
	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
	/**
	* RegExp to match domain-value in RFC 6265 sec 4.1.1
	*
	* domain-value      = <subdomain>
	*                     ; defined in [RFC1034], Section 3.5, as
	*                     ; enhanced by [RFC1123], Section 2.1
	* <subdomain>       = <label> | <subdomain> "." <label>
	* <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	*                     Labels must be 63 characters or less.
	*                     'let-dig' not 'letter' in the first char, per RFC1123
	* <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	* <let-dig-hyp>     = <let-dig> | "-"
	* <let-dig>         = <letter> | <digit>
	* <letter>          = any one of the 52 alphabetic characters A through Z in
	*                     upper case and a through z in lower case
	* <digit>           = any one of the ten digits 0 through 9
	*
	* Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	*
	* > (Note that a leading %x2E ("."), if present, is ignored even though that
	* character is not permitted, but a trailing %x2E ("."), if present, will
	* cause the user agent to ignore the attribute.)
	*/
	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	* RegExp to match path-value in RFC 6265 sec 4.1.1
	*
	* path-value        = <any CHAR except CTLs or ";">
	* CHAR              = %x01-7F
	*                     ; defined in RFC 5234 appendix B.1
	*/
	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	/**
	* Parse a cookie header.
	*
	* Parse the given cookie header string into an object
	* The object has the various cookies as keys(names) => values
	*
	* @param {string} str
	* @param {object} [opt]
	* @return {object}
	* @public
	*/
	function parse(str, opt) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var obj = {};
		var len = str.length;
		if (len < 2) return obj;
		var dec = opt && opt.decode || decode;
		var index = 0;
		var eqIdx = 0;
		var endIdx = 0;
		do {
			eqIdx = str.indexOf("=", index);
			if (eqIdx === -1) break;
			endIdx = str.indexOf(";", index);
			if (endIdx === -1) endIdx = len;
			else if (eqIdx > endIdx) {
				index = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			var keyStartIdx = startIndex(str, index, eqIdx);
			var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
			var key = str.slice(keyStartIdx, keyEndIdx);
			if (!__hasOwnProperty.call(obj, key)) {
				var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
				var valEndIdx = endIndex(str, endIdx, valStartIdx);
				if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
					valStartIdx++;
					valEndIdx--;
				}
				obj[key] = tryDecode(str.slice(valStartIdx, valEndIdx), dec);
			}
			index = endIdx + 1;
		} while (index < len);
		return obj;
	}
	function startIndex(str, index, max) {
		do {
			var code = str.charCodeAt(index);
			if (code !== 32 && code !== 9) return index;
		} while (++index < max);
		return max;
	}
	function endIndex(str, index, min) {
		while (index > min) {
			var code = str.charCodeAt(--index);
			if (code !== 32 && code !== 9) return index + 1;
		}
		return min;
	}
	/**
	* Serialize data into a cookie header.
	*
	* Serialize a name value pair into a cookie string suitable for
	* http headers. An optional options object specifies cookie parameters.
	*
	* serialize('foo', 'bar', { httpOnly: true })
	*   => "foo=bar; httpOnly"
	*
	* @param {string} name
	* @param {string} val
	* @param {object} [opt]
	* @return {string}
	* @public
	*/
	function serialize(name, val, opt) {
		var enc = opt && opt.encode || encodeURIComponent;
		if (typeof enc !== "function") throw new TypeError("option encode is invalid");
		if (!cookieNameRegExp.test(name)) throw new TypeError("argument name is invalid");
		var value = enc(val);
		if (!cookieValueRegExp.test(value)) throw new TypeError("argument val is invalid");
		var str = name + "=" + value;
		if (!opt) return str;
		if (null != opt.maxAge) {
			var maxAge = Math.floor(opt.maxAge);
			if (!isFinite(maxAge)) throw new TypeError("option maxAge is invalid");
			str += "; Max-Age=" + maxAge;
		}
		if (opt.domain) {
			if (!domainValueRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
			str += "; Domain=" + opt.domain;
		}
		if (opt.path) {
			if (!pathValueRegExp.test(opt.path)) throw new TypeError("option path is invalid");
			str += "; Path=" + opt.path;
		}
		if (opt.expires) {
			var expires = opt.expires;
			if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError("option expires is invalid");
			str += "; Expires=" + expires.toUTCString();
		}
		if (opt.httpOnly) str += "; HttpOnly";
		if (opt.secure) str += "; Secure";
		if (opt.partitioned) str += "; Partitioned";
		if (opt.priority) switch (typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority) {
			case "low":
				str += "; Priority=Low";
				break;
			case "medium":
				str += "; Priority=Medium";
				break;
			case "high":
				str += "; Priority=High";
				break;
			default: throw new TypeError("option priority is invalid");
		}
		if (opt.sameSite) switch (typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
			case true:
				str += "; SameSite=Strict";
				break;
			case "lax":
				str += "; SameSite=Lax";
				break;
			case "strict":
				str += "; SameSite=Strict";
				break;
			case "none":
				str += "; SameSite=None";
				break;
			default: throw new TypeError("option sameSite is invalid");
		}
		return str;
	}
	/**
	* URL-decode string value. Optimized to skip native call when no %.
	*
	* @param {string} str
	* @returns {string}
	*/
	function decode(str) {
		return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
	}
	/**
	* Determine if value is a Date.
	*
	* @param {*} val
	* @private
	*/
	function isDate(val) {
		return __toString.call(val) === "[object Date]";
	}
	/**
	* Try decoding a string using a decoding function.
	*
	* @param {string} str
	* @param {function} decode
	* @private
	*/
	function tryDecode(str, decode) {
		try {
			return decode(str);
		} catch (e) {
			return str;
		}
	}
}));

//#endregion
//#region ../../node_modules/vary/index.js
/*!
* vary
* Copyright(c) 2014-2017 Douglas Christopher Wilson
* MIT Licensed
*/
var require_vary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module exports.
	*/
	module.exports = vary;
	module.exports.append = append;
	/**
	* RegExp to match field-name in RFC 7230 sec 3.2
	*
	* field-name    = token
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	*/
	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* Append a field to a vary header.
	*
	* @param {String} header
	* @param {String|Array} field
	* @return {String}
	* @public
	*/
	function append(header, field) {
		if (typeof header !== "string") throw new TypeError("header argument is required");
		if (!field) throw new TypeError("field argument is required");
		var fields = !Array.isArray(field) ? parse(String(field)) : field;
		for (var j = 0; j < fields.length; j++) if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError("field argument contains an invalid header name");
		if (header === "*") return header;
		var val = header;
		var vals = parse(header.toLowerCase());
		if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) return "*";
		for (var i = 0; i < fields.length; i++) {
			var fld = fields[i].toLowerCase();
			if (vals.indexOf(fld) === -1) {
				vals.push(fld);
				val = val ? val + ", " + fields[i] : fields[i];
			}
		}
		return val;
	}
	/**
	* Parse a vary header into an array.
	*
	* @param {String} header
	* @return {Array}
	* @private
	*/
	function parse(header) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i = 0, len = header.length; i < len; i++) switch (header.charCodeAt(i)) {
			case 32:
				if (start === end) start = end = i + 1;
				break;
			case 44:
				list.push(header.substring(start, end));
				start = end = i + 1;
				break;
			default:
				end = i + 1;
				break;
		}
		list.push(header.substring(start, end));
		return list;
	}
	/**
	* Mark that a request is varied on a header field.
	*
	* @param {Object} res
	* @param {String|Array} field
	* @public
	*/
	function vary(res, field) {
		if (!res || !res.getHeader || !res.setHeader) throw new TypeError("res argument is required");
		var val = res.getHeader("Vary") || "";
		if (val = append(Array.isArray(val) ? val.join(", ") : String(val), field)) res.setHeader("Vary", val);
	}
}));

//#endregion
//#region ../../node_modules/express/lib/response.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_response = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Buffer = require_safe_buffer$1().Buffer;
	var contentDisposition = require_content_disposition();
	var createError = require_http_errors();
	var deprecate = require_depd()("express");
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var http$2 = require("http");
	var isAbsolute = require_utils().isAbsolute;
	var onFinished = require_on_finished();
	var path$13 = require("path");
	var statuses = require_statuses();
	var merge = require_utils_merge();
	var sign = require_cookie_signature().sign;
	var normalizeType = require_utils().normalizeType;
	var normalizeTypes = require_utils().normalizeTypes;
	var setCharset = require_utils().setCharset;
	var cookie = require_cookie();
	var send = require_send();
	var extname = path$13.extname;
	var mime = send.mime;
	var resolve = path$13.resolve;
	var vary = require_vary();
	/**
	* Response prototype.
	* @public
	*/
	var res = Object.create(http$2.ServerResponse.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = res;
	/**
	* Module variables.
	* @private
	*/
	var charsetRegExp = /;\s*charset\s*=/;
	/**
	* Set status `code`.
	*
	* @param {Number} code
	* @return {ServerResponse}
	* @public
	*/
	res.status = function status(code) {
		if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
		this.statusCode = code;
		return this;
	};
	/**
	* Set Link header field with the given `links`.
	*
	* Examples:
	*
	*    res.links({
	*      next: 'http://api.example.com/users?page=2',
	*      last: 'http://api.example.com/users?page=5'
	*    });
	*
	* @param {Object} links
	* @return {ServerResponse}
	* @public
	*/
	res.links = function(links) {
		var link = this.get("Link") || "";
		if (link) link += ", ";
		return this.set("Link", link + Object.keys(links).map(function(rel) {
			return "<" + links[rel] + ">; rel=\"" + rel + "\"";
		}).join(", "));
	};
	/**
	* Send a response.
	*
	* Examples:
	*
	*     res.send(Buffer.from('wahoo'));
	*     res.send({ some: 'json' });
	*     res.send('<p>some html</p>');
	*
	* @param {string|number|boolean|object|Buffer} body
	* @public
	*/
	res.send = function send(body) {
		var chunk = body;
		var encoding;
		var req = this.req;
		var type;
		var app = this.app;
		if (arguments.length === 2) if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
			deprecate("res.send(body, status): Use res.status(status).send(body) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.send(status, body): Use res.status(status).send(body) instead");
			this.statusCode = arguments[0];
			chunk = arguments[1];
		}
		if (typeof chunk === "number" && arguments.length === 1) {
			if (!this.get("Content-Type")) this.type("txt");
			deprecate("res.send(status): Use res.sendStatus(status) instead");
			this.statusCode = chunk;
			chunk = statuses.message[chunk];
		}
		switch (typeof chunk) {
			case "string":
				if (!this.get("Content-Type")) this.type("html");
				break;
			case "boolean":
			case "number":
			case "object":
				if (chunk === null) chunk = "";
				else if (Buffer.isBuffer(chunk)) {
					if (!this.get("Content-Type")) this.type("bin");
				} else return this.json(chunk);
				break;
		}
		if (typeof chunk === "string") {
			encoding = "utf8";
			type = this.get("Content-Type");
			if (typeof type === "string") this.set("Content-Type", setCharset(type, "utf-8"));
		}
		var etagFn = app.get("etag fn");
		var generateETag = !this.get("ETag") && typeof etagFn === "function";
		var len;
		if (chunk !== void 0) {
			if (Buffer.isBuffer(chunk)) len = chunk.length;
			else if (!generateETag && chunk.length < 1e3) len = Buffer.byteLength(chunk, encoding);
			else {
				chunk = Buffer.from(chunk, encoding);
				encoding = void 0;
				len = chunk.length;
			}
			this.set("Content-Length", len);
		}
		var etag;
		if (generateETag && len !== void 0) {
			if (etag = etagFn(chunk, encoding)) this.set("ETag", etag);
		}
		if (req.fresh) this.statusCode = 304;
		if (204 === this.statusCode || 304 === this.statusCode) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (this.statusCode === 205) {
			this.set("Content-Length", "0");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (req.method === "HEAD") this.end();
		else this.end(chunk, encoding);
		return this;
	};
	/**
	* Send JSON response.
	*
	* Examples:
	*
	*     res.json(null);
	*     res.json({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res.json = function json(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app = this.app;
		var escape = app.get("json escape");
		var replacer = app.get("json replacer");
		var spaces = app.get("json spaces");
		var body = stringify(val, replacer, spaces, escape);
		if (!this.get("Content-Type")) this.set("Content-Type", "application/json");
		return this.send(body);
	};
	/**
	* Send JSON response with JSONP callback support.
	*
	* Examples:
	*
	*     res.jsonp(null);
	*     res.jsonp({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res.jsonp = function jsonp(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app = this.app;
		var escape = app.get("json escape");
		var replacer = app.get("json replacer");
		var spaces = app.get("json spaces");
		var body = stringify(val, replacer, spaces, escape);
		var callback = this.req.query[app.get("jsonp callback name")];
		if (!this.get("Content-Type")) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "application/json");
		}
		if (Array.isArray(callback)) callback = callback[0];
		if (typeof callback === "string" && callback.length !== 0) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "text/javascript");
			callback = callback.replace(/[^\[\]\w$.]/g, "");
			if (body === void 0) body = "";
			else if (typeof body === "string") body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
			body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
		}
		return this.send(body);
	};
	/**
	* Send given HTTP status code.
	*
	* Sets the response status to `statusCode` and the body of the
	* response to the standard description from node's http.STATUS_CODES
	* or the statusCode number if no description.
	*
	* Examples:
	*
	*     res.sendStatus(200);
	*
	* @param {number} statusCode
	* @public
	*/
	res.sendStatus = function sendStatus(statusCode) {
		var body = statuses.message[statusCode] || String(statusCode);
		this.statusCode = statusCode;
		this.type("txt");
		return this.send(body);
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendFile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendFile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendFile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res.sendFile = function sendFile(path$46, options, callback) {
		var done = callback;
		var req = this.req;
		var res = this;
		var next = req.next;
		var opts = options || {};
		if (!path$46) throw new TypeError("path argument is required to res.sendFile");
		if (typeof path$46 !== "string") throw new TypeError("path must be a string to res.sendFile");
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (!opts.root && !isAbsolute(path$46)) throw new TypeError("path must be absolute or specify root to res.sendFile");
		sendfile(res, send(req, encodeURI(path$46), opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendfile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendfile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendfile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res.sendfile = function(path$47, options, callback) {
		var done = callback;
		var req = this.req;
		var res = this;
		var next = req.next;
		var opts = options || {};
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		sendfile(res, send(req, path$47, opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
	/**
	* Transfer the file at the given `path` as an attachment.
	*
	* Optionally providing an alternate attachment `filename`,
	* and optional callback `callback(err)`. The callback is invoked
	* when the data transfer is complete, or when an error has
	* occurred. Be sure to check `res.headersSent` if you plan to respond.
	*
	* Optionally providing an `options` object to use with `res.sendFile()`.
	* This function will set the `Content-Disposition` header, overriding
	* any `Content-Disposition` header passed as header options in order
	* to set the attachment and filename.
	*
	* This method uses `res.sendFile()`.
	*
	* @public
	*/
	res.download = function download(path$48, filename, options, callback) {
		var done = callback;
		var name = filename;
		var opts = options || null;
		if (typeof filename === "function") {
			done = filename;
			name = null;
			opts = null;
		} else if (typeof options === "function") {
			done = options;
			opts = null;
		}
		if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
			name = null;
			opts = filename;
		}
		var headers = { "Content-Disposition": contentDisposition(name || path$48) };
		if (opts && opts.headers) {
			var keys = Object.keys(opts.headers);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (key.toLowerCase() !== "content-disposition") headers[key] = opts.headers[key];
			}
		}
		opts = Object.create(opts);
		opts.headers = headers;
		var fullPath = !opts.root ? resolve(path$48) : path$48;
		return this.sendFile(fullPath, opts, done);
	};
	/**
	* Set _Content-Type_ response header with `type` through `mime.lookup()`
	* when it does not contain "/", or set the Content-Type to `type` otherwise.
	*
	* Examples:
	*
	*     res.type('.html');
	*     res.type('html');
	*     res.type('json');
	*     res.type('application/json');
	*     res.type('png');
	*
	* @param {String} type
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.contentType = res.type = function contentType(type) {
		var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
		return this.set("Content-Type", ct);
	};
	/**
	* Respond to the Acceptable formats using an `obj`
	* of mime-type callbacks.
	*
	* This method uses `req.accepted`, an array of
	* acceptable types ordered by their quality values.
	* When "Accept" is not present the _first_ callback
	* is invoked, otherwise the first match is used. When
	* no match is performed the server responds with
	* 406 "Not Acceptable".
	*
	* Content-Type is set for you, however if you choose
	* you may alter this within the callback using `res.type()`
	* or `res.set('Content-Type', ...)`.
	*
	*    res.format({
	*      'text/plain': function(){
	*        res.send('hey');
	*      },
	*
	*      'text/html': function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      'application/json': function () {
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* In addition to canonicalized MIME types you may
	* also use extnames mapped to these types:
	*
	*    res.format({
	*      text: function(){
	*        res.send('hey');
	*      },
	*
	*      html: function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      json: function(){
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* By default Express passes an `Error`
	* with a `.status` of 406 to `next(err)`
	* if a match is not made. If you provide
	* a `.default` callback it will be invoked
	* instead.
	*
	* @param {Object} obj
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.format = function(obj) {
		var req = this.req;
		var next = req.next;
		var keys = Object.keys(obj).filter(function(v) {
			return v !== "default";
		});
		var key = keys.length > 0 ? req.accepts(keys) : false;
		this.vary("Accept");
		if (key) {
			this.set("Content-Type", normalizeType(key).value);
			obj[key](req, this, next);
		} else if (obj.default) obj.default(req, this, next);
		else next(createError(406, { types: normalizeTypes(keys).map(function(o) {
			return o.value;
		}) }));
		return this;
	};
	/**
	* Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	*
	* @param {String} filename
	* @return {ServerResponse}
	* @public
	*/
	res.attachment = function attachment(filename) {
		if (filename) this.type(extname(filename));
		this.set("Content-Disposition", contentDisposition(filename));
		return this;
	};
	/**
	* Append additional header `field` with value `val`.
	*
	* Example:
	*
	*    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	*    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	*    res.append('Warning', '199 Miscellaneous warning');
	*
	* @param {String} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.append = function append(field, val) {
		var prev = this.get(field);
		var value = val;
		if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
		return this.set(field, value);
	};
	/**
	* Set header `field` to `val`, or pass
	* an object of header fields.
	*
	* Examples:
	*
	*    res.set('Foo', ['bar', 'baz']);
	*    res.set('Accept', 'application/json');
	*    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	*
	* Aliased as `res.header()`.
	*
	* @param {String|Object} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.set = res.header = function header(field, val) {
		if (arguments.length === 2) {
			var value = Array.isArray(val) ? val.map(String) : String(val);
			if (field.toLowerCase() === "content-type") {
				if (Array.isArray(value)) throw new TypeError("Content-Type cannot be set to an Array");
				if (!charsetRegExp.test(value)) {
					var charset = mime.charsets.lookup(value.split(";")[0]);
					if (charset) value += "; charset=" + charset.toLowerCase();
				}
			}
			this.setHeader(field, value);
		} else for (var key in field) this.set(key, field[key]);
		return this;
	};
	/**
	* Get value for header `field`.
	*
	* @param {String} field
	* @return {String}
	* @public
	*/
	res.get = function(field) {
		return this.getHeader(field);
	};
	/**
	* Clear cookie `name`.
	*
	* @param {String} name
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.clearCookie = function clearCookie(name, options) {
		if (options) {
			if (options.maxAge) deprecate("res.clearCookie: Passing \"options.maxAge\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
			if (options.expires) deprecate("res.clearCookie: Passing \"options.expires\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
		}
		var opts = merge({
			expires: /* @__PURE__ */ new Date(1),
			path: "/"
		}, options);
		return this.cookie(name, "", opts);
	};
	/**
	* Set cookie `name` to `value`, with the given `options`.
	*
	* Options:
	*
	*    - `maxAge`   max-age in milliseconds, converted to `expires`
	*    - `signed`   sign the cookie
	*    - `path`     defaults to "/"
	*
	* Examples:
	*
	*    // "Remember Me" for 15 minutes
	*    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	*
	*    // same as above
	*    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	*
	* @param {String} name
	* @param {String|Object} value
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.cookie = function(name, value, options) {
		var opts = merge({}, options);
		var secret = this.req.secret;
		var signed = opts.signed;
		if (signed && !secret) throw new Error("cookieParser(\"secret\") required for signed cookies");
		var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
		if (signed) val = "s:" + sign(val, secret);
		if (opts.maxAge != null) {
			var maxAge = opts.maxAge - 0;
			if (!isNaN(maxAge)) {
				opts.expires = new Date(Date.now() + maxAge);
				opts.maxAge = Math.floor(maxAge / 1e3);
			}
		}
		if (opts.path == null) opts.path = "/";
		this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
		return this;
	};
	/**
	* Set the location header to `url`.
	*
	* The given `url` can also be "back", which redirects
	* to the _Referrer_ or _Referer_ headers or "/".
	*
	* Examples:
	*
	*    res.location('/foo/bar').;
	*    res.location('http://example.com');
	*    res.location('../login');
	*
	* @param {String} url
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.location = function location(url) {
		var loc;
		if (url === "back") {
			deprecate("res.location(\"back\"): use res.location(req.get(\"Referrer\") || \"/\") and refer to https://dub.sh/security-redirect for best practices");
			loc = this.req.get("Referrer") || "/";
		} else loc = String(url);
		return this.set("Location", encodeUrl(loc));
	};
	/**
	* Redirect to the given `url` with optional response `status`
	* defaulting to 302.
	*
	* The resulting `url` is determined by `res.location()`, so
	* it will play nicely with mounted apps, relative paths,
	* `"back"` etc.
	*
	* Examples:
	*
	*    res.redirect('/foo/bar');
	*    res.redirect('http://example.com');
	*    res.redirect(301, 'http://example.com');
	*    res.redirect('../login'); // /blog/post/1 -> /blog/login
	*
	* @public
	*/
	res.redirect = function redirect(url) {
		var address = url;
		var body;
		var status = 302;
		if (arguments.length === 2) if (typeof arguments[0] === "number") {
			status = arguments[0];
			address = arguments[1];
		} else {
			deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
			status = arguments[1];
		}
		address = this.location(address).get("Location");
		this.format({
			text: function() {
				body = statuses.message[status] + ". Redirecting to " + address;
			},
			html: function() {
				var u = escapeHtml(address);
				body = "<p>" + statuses.message[status] + ". Redirecting to " + u + "</p>";
			},
			default: function() {
				body = "";
			}
		});
		this.statusCode = status;
		this.set("Content-Length", Buffer.byteLength(body));
		if (this.req.method === "HEAD") this.end();
		else this.end(body);
	};
	/**
	* Add `field` to Vary. If already present in the Vary set, then
	* this call is simply ignored.
	*
	* @param {Array|String} field
	* @return {ServerResponse} for chaining
	* @public
	*/
	res.vary = function(field) {
		if (!field || Array.isArray(field) && !field.length) {
			deprecate("res.vary(): Provide a field name");
			return this;
		}
		vary(this, field);
		return this;
	};
	/**
	* Render `view` with the given `options` and optional callback `fn`.
	* When a callback function is given a response will _not_ be made
	* automatically, otherwise a response of _200_ and _text/html_ is given.
	*
	* Options:
	*
	*  - `cache`     boolean hinting to the engine it should cache
	*  - `filename`  filename of the view being rendered
	*
	* @public
	*/
	res.render = function render(view, options, callback) {
		var app = this.req.app;
		var done = callback;
		var opts = options || {};
		var req = this.req;
		var self = this;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		opts._locals = self.locals;
		done = done || function(err, str) {
			if (err) return req.next(err);
			self.send(str);
		};
		app.render(view, opts, done);
	};
	function sendfile(res, file, options, callback) {
		var done = false;
		var streaming;
		function onaborted() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("Request aborted");
			err.code = "ECONNABORTED";
			callback(err);
		}
		function ondirectory() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("EISDIR, read");
			err.code = "EISDIR";
			callback(err);
		}
		function onerror(err) {
			if (done) return;
			done = true;
			callback(err);
		}
		function onend() {
			if (done) return;
			done = true;
			callback();
		}
		function onfile() {
			streaming = false;
		}
		function onfinish(err) {
			if (err && err.code === "ECONNRESET") return onaborted();
			if (err) return onerror(err);
			if (done) return;
			setImmediate(function() {
				if (streaming !== false && !done) {
					onaborted();
					return;
				}
				if (done) return;
				done = true;
				callback();
			});
		}
		function onstream() {
			streaming = true;
		}
		file.on("directory", ondirectory);
		file.on("end", onend);
		file.on("error", onerror);
		file.on("file", onfile);
		file.on("stream", onstream);
		onFinished(res, onfinish);
		if (options.headers) file.on("headers", function headers(res) {
			var obj = options.headers;
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				var k = keys[i];
				res.setHeader(k, obj[k]);
			}
		});
		file.pipe(res);
	}
	/**
	* Stringify JSON, like JSON.stringify, but v8 optimized, with the
	* ability to escape characters that can trigger HTML sniffing.
	*
	* @param {*} value
	* @param {function} replacer
	* @param {number} spaces
	* @param {boolean} escape
	* @returns {string}
	* @private
	*/
	function stringify(value, replacer, spaces, escape) {
		var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
		if (escape && typeof json === "string") json = json.replace(/[<>&]/g, function(c) {
			switch (c.charCodeAt(0)) {
				case 60: return "\\u003c";
				case 62: return "\\u003e";
				case 38: return "\\u0026";
				default: return c;
			}
		});
		return json;
	}
}));

//#endregion
//#region ../../node_modules/serve-static/index.js
/*!
* serve-static
* Copyright(c) 2010 Sencha Inc.
* Copyright(c) 2011 TJ Holowaychuk
* Copyright(c) 2014-2016 Douglas Christopher Wilson
* MIT Licensed
*/
var require_serve_static = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var encodeUrl = require_encodeurl();
	var escapeHtml = require_escape_html();
	var parseUrl = require_parseurl();
	var resolve$2 = require("path").resolve;
	var send = require_send();
	var url = require("url");
	/**
	* Module exports.
	* @public
	*/
	module.exports = serveStatic;
	module.exports.mime = send.mime;
	/**
	* @param {string} root
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function serveStatic(root, options) {
		if (!root) throw new TypeError("root path required");
		if (typeof root !== "string") throw new TypeError("root path must be a string");
		var opts = Object.create(options || null);
		var fallthrough = opts.fallthrough !== false;
		var redirect = opts.redirect !== false;
		var setHeaders = opts.setHeaders;
		if (setHeaders && typeof setHeaders !== "function") throw new TypeError("option setHeaders must be function");
		opts.maxage = opts.maxage || opts.maxAge || 0;
		opts.root = resolve$2(root);
		var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
		return function serveStatic(req, res, next) {
			if (req.method !== "GET" && req.method !== "HEAD") {
				if (fallthrough) return next();
				res.statusCode = 405;
				res.setHeader("Allow", "GET, HEAD");
				res.setHeader("Content-Length", "0");
				res.end();
				return;
			}
			var forwardError = !fallthrough;
			var originalUrl = parseUrl.original(req);
			var path$45 = parseUrl(req).pathname;
			if (path$45 === "/" && originalUrl.pathname.substr(-1) !== "/") path$45 = "";
			var stream = send(req, path$45, opts);
			stream.on("directory", onDirectory);
			if (setHeaders) stream.on("headers", setHeaders);
			if (fallthrough) stream.on("file", function onFile() {
				forwardError = true;
			});
			stream.on("error", function error(err) {
				if (forwardError || !(err.statusCode < 500)) {
					next(err);
					return;
				}
				next();
			});
			stream.pipe(res);
		};
	}
	/**
	* Collapse all leading slashes into a single slash
	* @private
	*/
	function collapseLeadingSlashes(str) {
		for (var i = 0; i < str.length; i++) if (str.charCodeAt(i) !== 47) break;
		return i > 1 ? "/" + str.substr(i) : str;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument(title, body) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a directory listener that just 404s.
	* @private
	*/
	function createNotFoundDirectoryListener() {
		return function notFound() {
			this.error(404);
		};
	}
	/**
	* Create a directory listener that performs a redirect.
	* @private
	*/
	function createRedirectDirectoryListener() {
		return function redirect(res) {
			if (this.hasTrailingSlash()) {
				this.error(404);
				return;
			}
			var originalUrl = parseUrl.original(this.req);
			originalUrl.path = null;
			originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
			var loc = encodeUrl(url.format(originalUrl));
			var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
			res.statusCode = 301;
			res.setHeader("Content-Type", "text/html; charset=UTF-8");
			res.setHeader("Content-Length", Buffer.byteLength(doc));
			res.setHeader("Content-Security-Policy", "default-src 'none'");
			res.setHeader("X-Content-Type-Options", "nosniff");
			res.setHeader("Location", loc);
			res.end(doc);
		};
	}
}));

//#endregion
//#region ../../node_modules/express/lib/express.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_express$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bodyParser = require_body_parser();
	var EventEmitter$4 = require("events").EventEmitter;
	var mixin = require_merge_descriptors();
	var proto = require_application();
	var Route = require_route();
	var Router = require_router();
	var req = require_request();
	var res = require_response();
	/**
	* Expose `createApplication()`.
	*/
	exports = module.exports = createApplication;
	/**
	* Create an express application.
	*
	* @return {Function}
	* @api public
	*/
	function createApplication() {
		var app = function(req, res, next) {
			app.handle(req, res, next);
		};
		mixin(app, EventEmitter$4.prototype, false);
		mixin(app, proto, false);
		app.request = Object.create(req, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app
		} });
		app.response = Object.create(res, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app
		} });
		app.init();
		return app;
	}
	/**
	* Expose the prototypes.
	*/
	exports.application = proto;
	exports.request = req;
	exports.response = res;
	/**
	* Expose constructors.
	*/
	exports.Route = Route;
	exports.Router = Router;
	/**
	* Expose middleware
	*/
	exports.json = bodyParser.json;
	exports.query = require_query();
	exports.raw = bodyParser.raw;
	exports.static = require_serve_static();
	exports.text = bodyParser.text;
	exports.urlencoded = bodyParser.urlencoded;
	[
		"bodyParser",
		"compress",
		"cookieSession",
		"session",
		"logger",
		"cookieParser",
		"favicon",
		"responseTime",
		"errorHandler",
		"timeout",
		"methodOverride",
		"vhost",
		"csrf",
		"directory",
		"limit",
		"multipart",
		"staticCache"
	].forEach(function(name) {
		Object.defineProperty(exports, name, {
			get: function() {
				throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
			},
			configurable: true
		});
	});
}));

//#endregion
//#region ../../node_modules/express/index.js
/*!
* express
* Copyright(c) 2009-2013 TJ Holowaychuk
* Copyright(c) 2013 Roman Shtylman
* Copyright(c) 2014-2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_express = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_express$1();
}));

//#endregion
//#region ../../node_modules/totalist/sync/index.mjs
var import_express = /* @__PURE__ */ __toESM(require_express());
function totalist(dir, callback, pre = "") {
	dir = (0, path.resolve)(".", dir);
	let arr = (0, fs.readdirSync)(dir);
	let i = 0, abs, stats;
	for (; i < arr.length; i++) {
		abs = (0, path.join)(dir, arr[i]);
		stats = (0, fs.statSync)(abs);
		stats.isDirectory() ? totalist(abs, callback, (0, path.join)(pre, arr[i])) : callback((0, path.join)(pre, arr[i]), abs, stats);
	}
}

//#endregion
//#region ../../node_modules/@polka/url/build.mjs
/**
* @typedef ParsedURL
* @type {import('.').ParsedURL}
*/
/**
* @typedef Request
* @property {string} url
* @property {ParsedURL} _parsedUrl
*/
/**
* @param {Request} req
* @returns {ParsedURL|void}
*/
function parse$2(req) {
	let raw = req.url;
	if (raw == null) return;
	let prev = req._parsedUrl;
	if (prev && prev.raw === raw) return prev;
	let pathname = raw, search = "", query, hash;
	if (raw.length > 1) {
		let idx = raw.indexOf("#", 1);
		if (idx !== -1) {
			hash = raw.substring(idx);
			pathname = raw.substring(0, idx);
		}
		idx = pathname.indexOf("?", 1);
		if (idx !== -1) {
			search = pathname.substring(idx);
			pathname = pathname.substring(0, idx);
			if (search.length > 1) query = node_querystring.parse(search.substring(1));
		}
	}
	return req._parsedUrl = {
		pathname,
		search,
		query,
		hash,
		raw
	};
}

//#endregion
//#region ../../node_modules/mrmime/index.mjs
const mimes = {
	"3g2": "video/3gpp2",
	"3gp": "video/3gpp",
	"3gpp": "video/3gpp",
	"3mf": "model/3mf",
	"aac": "audio/aac",
	"ac": "application/pkix-attr-cert",
	"adp": "audio/adpcm",
	"adts": "audio/aac",
	"ai": "application/postscript",
	"aml": "application/automationml-aml+xml",
	"amlx": "application/automationml-amlx+zip",
	"amr": "audio/amr",
	"apng": "image/apng",
	"appcache": "text/cache-manifest",
	"appinstaller": "application/appinstaller",
	"appx": "application/appx",
	"appxbundle": "application/appxbundle",
	"asc": "application/pgp-keys",
	"atom": "application/atom+xml",
	"atomcat": "application/atomcat+xml",
	"atomdeleted": "application/atomdeleted+xml",
	"atomsvc": "application/atomsvc+xml",
	"au": "audio/basic",
	"avci": "image/avci",
	"avcs": "image/avcs",
	"avif": "image/avif",
	"aw": "application/applixware",
	"bdoc": "application/bdoc",
	"bin": "application/octet-stream",
	"bmp": "image/bmp",
	"bpk": "application/octet-stream",
	"btf": "image/prs.btif",
	"btif": "image/prs.btif",
	"buffer": "application/octet-stream",
	"ccxml": "application/ccxml+xml",
	"cdfx": "application/cdfx+xml",
	"cdmia": "application/cdmi-capability",
	"cdmic": "application/cdmi-container",
	"cdmid": "application/cdmi-domain",
	"cdmio": "application/cdmi-object",
	"cdmiq": "application/cdmi-queue",
	"cer": "application/pkix-cert",
	"cgm": "image/cgm",
	"cjs": "application/node",
	"class": "application/java-vm",
	"coffee": "text/coffeescript",
	"conf": "text/plain",
	"cpl": "application/cpl+xml",
	"cpt": "application/mac-compactpro",
	"crl": "application/pkix-crl",
	"css": "text/css",
	"csv": "text/csv",
	"cu": "application/cu-seeme",
	"cwl": "application/cwl",
	"cww": "application/prs.cww",
	"davmount": "application/davmount+xml",
	"dbk": "application/docbook+xml",
	"deb": "application/octet-stream",
	"def": "text/plain",
	"deploy": "application/octet-stream",
	"dib": "image/bmp",
	"disposition-notification": "message/disposition-notification",
	"dist": "application/octet-stream",
	"distz": "application/octet-stream",
	"dll": "application/octet-stream",
	"dmg": "application/octet-stream",
	"dms": "application/octet-stream",
	"doc": "application/msword",
	"dot": "application/msword",
	"dpx": "image/dpx",
	"drle": "image/dicom-rle",
	"dsc": "text/prs.lines.tag",
	"dssc": "application/dssc+der",
	"dtd": "application/xml-dtd",
	"dump": "application/octet-stream",
	"dwd": "application/atsc-dwd+xml",
	"ear": "application/java-archive",
	"ecma": "application/ecmascript",
	"elc": "application/octet-stream",
	"emf": "image/emf",
	"eml": "message/rfc822",
	"emma": "application/emma+xml",
	"emotionml": "application/emotionml+xml",
	"eps": "application/postscript",
	"epub": "application/epub+zip",
	"exe": "application/octet-stream",
	"exi": "application/exi",
	"exp": "application/express",
	"exr": "image/aces",
	"ez": "application/andrew-inset",
	"fdf": "application/fdf",
	"fdt": "application/fdt+xml",
	"fits": "image/fits",
	"g3": "image/g3fax",
	"gbr": "application/rpki-ghostbusters",
	"geojson": "application/geo+json",
	"gif": "image/gif",
	"glb": "model/gltf-binary",
	"gltf": "model/gltf+json",
	"gml": "application/gml+xml",
	"gpx": "application/gpx+xml",
	"gram": "application/srgs",
	"grxml": "application/srgs+xml",
	"gxf": "application/gxf",
	"gz": "application/gzip",
	"h261": "video/h261",
	"h263": "video/h263",
	"h264": "video/h264",
	"heic": "image/heic",
	"heics": "image/heic-sequence",
	"heif": "image/heif",
	"heifs": "image/heif-sequence",
	"hej2": "image/hej2k",
	"held": "application/atsc-held+xml",
	"hjson": "application/hjson",
	"hlp": "application/winhlp",
	"hqx": "application/mac-binhex40",
	"hsj2": "image/hsj2",
	"htm": "text/html",
	"html": "text/html",
	"ics": "text/calendar",
	"ief": "image/ief",
	"ifb": "text/calendar",
	"iges": "model/iges",
	"igs": "model/iges",
	"img": "application/octet-stream",
	"in": "text/plain",
	"ini": "text/plain",
	"ink": "application/inkml+xml",
	"inkml": "application/inkml+xml",
	"ipfix": "application/ipfix",
	"iso": "application/octet-stream",
	"its": "application/its+xml",
	"jade": "text/jade",
	"jar": "application/java-archive",
	"jhc": "image/jphc",
	"jls": "image/jls",
	"jp2": "image/jp2",
	"jpe": "image/jpeg",
	"jpeg": "image/jpeg",
	"jpf": "image/jpx",
	"jpg": "image/jpeg",
	"jpg2": "image/jp2",
	"jpgm": "image/jpm",
	"jpgv": "video/jpeg",
	"jph": "image/jph",
	"jpm": "image/jpm",
	"jpx": "image/jpx",
	"js": "text/javascript",
	"json": "application/json",
	"json5": "application/json5",
	"jsonld": "application/ld+json",
	"jsonml": "application/jsonml+json",
	"jsx": "text/jsx",
	"jt": "model/jt",
	"jxl": "image/jxl",
	"jxr": "image/jxr",
	"jxra": "image/jxra",
	"jxrs": "image/jxrs",
	"jxs": "image/jxs",
	"jxsc": "image/jxsc",
	"jxsi": "image/jxsi",
	"jxss": "image/jxss",
	"kar": "audio/midi",
	"ktx": "image/ktx",
	"ktx2": "image/ktx2",
	"less": "text/less",
	"lgr": "application/lgr+xml",
	"list": "text/plain",
	"litcoffee": "text/coffeescript",
	"log": "text/plain",
	"lostxml": "application/lost+xml",
	"lrf": "application/octet-stream",
	"m1v": "video/mpeg",
	"m21": "application/mp21",
	"m2a": "audio/mpeg",
	"m2t": "video/mp2t",
	"m2ts": "video/mp2t",
	"m2v": "video/mpeg",
	"m3a": "audio/mpeg",
	"m4a": "audio/mp4",
	"m4p": "application/mp4",
	"m4s": "video/iso.segment",
	"ma": "application/mathematica",
	"mads": "application/mads+xml",
	"maei": "application/mmt-aei+xml",
	"man": "text/troff",
	"manifest": "text/cache-manifest",
	"map": "application/json",
	"mar": "application/octet-stream",
	"markdown": "text/markdown",
	"mathml": "application/mathml+xml",
	"mb": "application/mathematica",
	"mbox": "application/mbox",
	"md": "text/markdown",
	"mdx": "text/mdx",
	"me": "text/troff",
	"mesh": "model/mesh",
	"meta4": "application/metalink4+xml",
	"metalink": "application/metalink+xml",
	"mets": "application/mets+xml",
	"mft": "application/rpki-manifest",
	"mid": "audio/midi",
	"midi": "audio/midi",
	"mime": "message/rfc822",
	"mj2": "video/mj2",
	"mjp2": "video/mj2",
	"mjs": "text/javascript",
	"mml": "text/mathml",
	"mods": "application/mods+xml",
	"mov": "video/quicktime",
	"mp2": "audio/mpeg",
	"mp21": "application/mp21",
	"mp2a": "audio/mpeg",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mp4a": "audio/mp4",
	"mp4s": "application/mp4",
	"mp4v": "video/mp4",
	"mpd": "application/dash+xml",
	"mpe": "video/mpeg",
	"mpeg": "video/mpeg",
	"mpf": "application/media-policy-dataset+xml",
	"mpg": "video/mpeg",
	"mpg4": "video/mp4",
	"mpga": "audio/mpeg",
	"mpp": "application/dash-patch+xml",
	"mrc": "application/marc",
	"mrcx": "application/marcxml+xml",
	"ms": "text/troff",
	"mscml": "application/mediaservercontrol+xml",
	"msh": "model/mesh",
	"msi": "application/octet-stream",
	"msix": "application/msix",
	"msixbundle": "application/msixbundle",
	"msm": "application/octet-stream",
	"msp": "application/octet-stream",
	"mtl": "model/mtl",
	"mts": "video/mp2t",
	"musd": "application/mmt-usd+xml",
	"mxf": "application/mxf",
	"mxmf": "audio/mobile-xmf",
	"mxml": "application/xv+xml",
	"n3": "text/n3",
	"nb": "application/mathematica",
	"nq": "application/n-quads",
	"nt": "application/n-triples",
	"obj": "model/obj",
	"oda": "application/oda",
	"oga": "audio/ogg",
	"ogg": "audio/ogg",
	"ogv": "video/ogg",
	"ogx": "application/ogg",
	"omdoc": "application/omdoc+xml",
	"onepkg": "application/onenote",
	"onetmp": "application/onenote",
	"onetoc": "application/onenote",
	"onetoc2": "application/onenote",
	"opf": "application/oebps-package+xml",
	"opus": "audio/ogg",
	"otf": "font/otf",
	"owl": "application/rdf+xml",
	"oxps": "application/oxps",
	"p10": "application/pkcs10",
	"p7c": "application/pkcs7-mime",
	"p7m": "application/pkcs7-mime",
	"p7s": "application/pkcs7-signature",
	"p8": "application/pkcs8",
	"pdf": "application/pdf",
	"pfr": "application/font-tdpfr",
	"pgp": "application/pgp-encrypted",
	"pkg": "application/octet-stream",
	"pki": "application/pkixcmp",
	"pkipath": "application/pkix-pkipath",
	"pls": "application/pls+xml",
	"png": "image/png",
	"prc": "model/prc",
	"prf": "application/pics-rules",
	"provx": "application/provenance+xml",
	"ps": "application/postscript",
	"pskcxml": "application/pskc+xml",
	"pti": "image/prs.pti",
	"qt": "video/quicktime",
	"raml": "application/raml+yaml",
	"rapd": "application/route-apd+xml",
	"rdf": "application/rdf+xml",
	"relo": "application/p2p-overlay+xml",
	"rif": "application/reginfo+xml",
	"rl": "application/resource-lists+xml",
	"rld": "application/resource-lists-diff+xml",
	"rmi": "audio/midi",
	"rnc": "application/relax-ng-compact-syntax",
	"rng": "application/xml",
	"roa": "application/rpki-roa",
	"roff": "text/troff",
	"rq": "application/sparql-query",
	"rs": "application/rls-services+xml",
	"rsat": "application/atsc-rsat+xml",
	"rsd": "application/rsd+xml",
	"rsheet": "application/urc-ressheet+xml",
	"rss": "application/rss+xml",
	"rtf": "text/rtf",
	"rtx": "text/richtext",
	"rusd": "application/route-usd+xml",
	"s3m": "audio/s3m",
	"sbml": "application/sbml+xml",
	"scq": "application/scvp-cv-request",
	"scs": "application/scvp-cv-response",
	"sdp": "application/sdp",
	"senmlx": "application/senml+xml",
	"sensmlx": "application/sensml+xml",
	"ser": "application/java-serialized-object",
	"setpay": "application/set-payment-initiation",
	"setreg": "application/set-registration-initiation",
	"sgi": "image/sgi",
	"sgm": "text/sgml",
	"sgml": "text/sgml",
	"shex": "text/shex",
	"shf": "application/shf+xml",
	"shtml": "text/html",
	"sieve": "application/sieve",
	"sig": "application/pgp-signature",
	"sil": "audio/silk",
	"silo": "model/mesh",
	"siv": "application/sieve",
	"slim": "text/slim",
	"slm": "text/slim",
	"sls": "application/route-s-tsid+xml",
	"smi": "application/smil+xml",
	"smil": "application/smil+xml",
	"snd": "audio/basic",
	"so": "application/octet-stream",
	"spdx": "text/spdx",
	"spp": "application/scvp-vp-response",
	"spq": "application/scvp-vp-request",
	"spx": "audio/ogg",
	"sql": "application/sql",
	"sru": "application/sru+xml",
	"srx": "application/sparql-results+xml",
	"ssdl": "application/ssdl+xml",
	"ssml": "application/ssml+xml",
	"stk": "application/hyperstudio",
	"stl": "model/stl",
	"stpx": "model/step+xml",
	"stpxz": "model/step-xml+zip",
	"stpz": "model/step+zip",
	"styl": "text/stylus",
	"stylus": "text/stylus",
	"svg": "image/svg+xml",
	"svgz": "image/svg+xml",
	"swidtag": "application/swid+xml",
	"t": "text/troff",
	"t38": "image/t38",
	"td": "application/urc-targetdesc+xml",
	"tei": "application/tei+xml",
	"teicorpus": "application/tei+xml",
	"text": "text/plain",
	"tfi": "application/thraud+xml",
	"tfx": "image/tiff-fx",
	"tif": "image/tiff",
	"tiff": "image/tiff",
	"toml": "application/toml",
	"tr": "text/troff",
	"trig": "application/trig",
	"ts": "video/mp2t",
	"tsd": "application/timestamped-data",
	"tsv": "text/tab-separated-values",
	"ttc": "font/collection",
	"ttf": "font/ttf",
	"ttl": "text/turtle",
	"ttml": "application/ttml+xml",
	"txt": "text/plain",
	"u3d": "model/u3d",
	"u8dsn": "message/global-delivery-status",
	"u8hdr": "message/global-headers",
	"u8mdn": "message/global-disposition-notification",
	"u8msg": "message/global",
	"ubj": "application/ubjson",
	"uri": "text/uri-list",
	"uris": "text/uri-list",
	"urls": "text/uri-list",
	"vcard": "text/vcard",
	"vrml": "model/vrml",
	"vtt": "text/vtt",
	"vxml": "application/voicexml+xml",
	"war": "application/java-archive",
	"wasm": "application/wasm",
	"wav": "audio/wav",
	"weba": "audio/webm",
	"webm": "video/webm",
	"webmanifest": "application/manifest+json",
	"webp": "image/webp",
	"wgsl": "text/wgsl",
	"wgt": "application/widget",
	"wif": "application/watcherinfo+xml",
	"wmf": "image/wmf",
	"woff": "font/woff",
	"woff2": "font/woff2",
	"wrl": "model/vrml",
	"wsdl": "application/wsdl+xml",
	"wspolicy": "application/wspolicy+xml",
	"x3d": "model/x3d+xml",
	"x3db": "model/x3d+fastinfoset",
	"x3dbz": "model/x3d+binary",
	"x3dv": "model/x3d-vrml",
	"x3dvz": "model/x3d+vrml",
	"x3dz": "model/x3d+xml",
	"xaml": "application/xaml+xml",
	"xav": "application/xcap-att+xml",
	"xca": "application/xcap-caps+xml",
	"xcs": "application/calendar+xml",
	"xdf": "application/xcap-diff+xml",
	"xdssc": "application/dssc+xml",
	"xel": "application/xcap-el+xml",
	"xenc": "application/xenc+xml",
	"xer": "application/patch-ops-error+xml",
	"xfdf": "application/xfdf",
	"xht": "application/xhtml+xml",
	"xhtml": "application/xhtml+xml",
	"xhvml": "application/xv+xml",
	"xlf": "application/xliff+xml",
	"xm": "audio/xm",
	"xml": "text/xml",
	"xns": "application/xcap-ns+xml",
	"xop": "application/xop+xml",
	"xpl": "application/xproc+xml",
	"xsd": "application/xml",
	"xsf": "application/prs.xsf+xml",
	"xsl": "application/xml",
	"xslt": "application/xml",
	"xspf": "application/xspf+xml",
	"xvm": "application/xv+xml",
	"xvml": "application/xv+xml",
	"yaml": "text/yaml",
	"yang": "application/yang",
	"yin": "application/yin+xml",
	"yml": "text/yaml",
	"zip": "application/zip"
};
function lookup(extn) {
	let tmp = ("" + extn).trim().toLowerCase();
	let idx = tmp.lastIndexOf(".");
	return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

//#endregion
//#region ../../node_modules/sirv/build.mjs
const noop = () => {};
function isMatch(uri, arr) {
	for (let i = 0; i < arr.length; i++) if (arr[i].test(uri)) return true;
}
function toAssume(uri, extns) {
	let i = 0, x, len = uri.length - 1;
	if (uri.charCodeAt(len) === 47) uri = uri.substring(0, len);
	let arr = [], tmp = `${uri}/index`;
	for (; i < extns.length; i++) {
		x = extns[i] ? `.${extns[i]}` : "";
		if (uri) arr.push(uri + x);
		arr.push(tmp + x);
	}
	return arr;
}
function viaCache(cache, uri, extns) {
	let i = 0, data, arr = toAssume(uri, extns);
	for (; i < arr.length; i++) if (data = cache[arr[i]]) return data;
}
function viaLocal(dir, isEtag, uri, extns) {
	let i = 0, arr = toAssume(uri, extns);
	let abs, stats, name, headers;
	for (; i < arr.length; i++) {
		abs = (0, node_path.normalize)((0, node_path.join)(dir, name = arr[i]));
		if (abs.startsWith(dir) && node_fs.existsSync(abs)) {
			stats = node_fs.statSync(abs);
			if (stats.isDirectory()) continue;
			headers = toHeaders(name, stats, isEtag);
			headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
			return {
				abs,
				stats,
				headers
			};
		}
	}
}
function is404(req, res) {
	return res.statusCode = 404, res.end();
}
function send(req, res, file, stats, headers) {
	let code = 200, tmp, opts = {};
	headers = { ...headers };
	for (let key in headers) {
		tmp = res.getHeader(key);
		if (tmp) headers[key] = tmp;
	}
	if (tmp = res.getHeader("content-type")) headers["Content-Type"] = tmp;
	if (req.headers.range) {
		code = 206;
		let [x, y] = req.headers.range.replace("bytes=", "").split("-");
		let end = opts.end = parseInt(y, 10) || stats.size - 1;
		let start = opts.start = parseInt(x, 10) || 0;
		if (end >= stats.size) end = stats.size - 1;
		if (start >= stats.size) {
			res.setHeader("Content-Range", `bytes */${stats.size}`);
			res.statusCode = 416;
			return res.end();
		}
		headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
		headers["Content-Length"] = end - start + 1;
		headers["Accept-Ranges"] = "bytes";
	}
	res.writeHead(code, headers);
	node_fs.createReadStream(file, opts).pipe(res);
}
const ENCODING = {
	".br": "br",
	".gz": "gzip"
};
function toHeaders(name, stats, isEtag) {
	let enc = ENCODING[name.slice(-3)];
	let ctype = lookup(name.slice(0, enc && -3)) || "";
	if (ctype === "text/html") ctype += ";charset=utf-8";
	let headers = {
		"Content-Length": stats.size,
		"Content-Type": ctype,
		"Last-Modified": stats.mtime.toUTCString()
	};
	if (enc) headers["Content-Encoding"] = enc;
	if (isEtag) headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
	return headers;
}
function build_default(dir, opts = {}) {
	dir = (0, node_path.resolve)(dir || ".");
	let isNotFound = opts.onNoMatch || is404;
	let setHeaders = opts.setHeaders || noop;
	let extensions = opts.extensions || ["html", "htm"];
	let gzips = opts.gzip && extensions.map((x) => `${x}.gz`).concat("gz");
	let brots = opts.brotli && extensions.map((x) => `${x}.br`).concat("br");
	const FILES = {};
	let fallback = "/";
	let isEtag = !!opts.etag;
	let isSPA = !!opts.single;
	if (typeof opts.single === "string") {
		let idx = opts.single.lastIndexOf(".");
		fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
	}
	let ignores = [];
	if (opts.ignores !== false) {
		ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
		if (opts.dotfiles) ignores.push(/\/\.\w/);
		else ignores.push(/\/\.well-known/);
		[].concat(opts.ignores || []).forEach((x) => {
			ignores.push(new RegExp(x, "i"));
		});
	}
	let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
	if (cc && opts.immutable) cc += ",immutable";
	else if (cc && opts.maxAge === 0) cc += ",must-revalidate";
	if (!opts.dev) totalist(dir, (name, abs, stats) => {
		if (/\.well-known[\\+\/]/.test(name)) {} else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name)) return;
		let headers = toHeaders(name, stats, isEtag);
		if (cc) headers["Cache-Control"] = cc;
		FILES["/" + name.normalize().replace(/\\+/g, "/")] = {
			abs,
			stats,
			headers
		};
	});
	let lookup = opts.dev ? viaLocal.bind(0, dir + node_path.sep, isEtag) : viaCache.bind(0, FILES);
	return function(req, res, next) {
		let extns = [""];
		let pathname = parse$2(req).pathname;
		let val = req.headers["accept-encoding"] || "";
		if (gzips && val.includes("gzip")) extns.unshift(...gzips);
		if (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);
		extns.push(...extensions);
		if (pathname.indexOf("%") !== -1) try {
			pathname = decodeURI(pathname);
		} catch (err) {}
		let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
		if (!data) return next ? next() : isNotFound(req, res);
		if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
			res.writeHead(304);
			return res.end();
		}
		if (gzips || brots) res.setHeader("Vary", "Accept-Encoding");
		setHeaders(res, pathname, data.stats);
		send(req, res, data.abs, data.stats, data.headers);
	};
}

//#endregion
//#region ../../node_modules/ws/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const BINARY_TYPES = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob = typeof Blob !== "undefined";
	if (hasBlob) BINARY_TYPES.push("blob");
	module.exports = {
		BINARY_TYPES,
		CLOSE_TIMEOUT: 3e4,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}));

//#endregion
//#region ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { EMPTY_BUFFER } = require_constants();
	const FastBuffer = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i = 0; i < list.length; i++) {
			const buf = list[i];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[i & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer, mask) {
		for (let i = 0; i < buffer.length; i++) buffer[i] ^= mask[i & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer(data) {
		toBuffer.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat,
		mask: _mask,
		toArrayBuffer,
		toBuffer,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil = require("bufferutil");
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer, mask) {
			if (buffer.length < 32) _unmask(buffer, mask);
			else bufferUtil.unmask(buffer, mask);
		};
	} catch (e) {}
}));

//#endregion
//#region ../../node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter;
}));

//#endregion
//#region ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const zlib = require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode } = require_constants();
	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err = this._inflate[kError];
				if (err) {
					this._inflate.close();
					this._inflate = null;
					callback(err);
					return;
				}
				const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
				callback(null, data);
			});
		}
	};
	module.exports = PerMessageDeflate;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError][kStatusCode] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError]) {
			this[kCallback](this[kError]);
			return;
		}
		err[kStatusCode] = 1007;
		this[kCallback](err);
	}
}));

//#endregion
//#region ../../node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isUtf8 } = require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode(code) {
		return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len = buf.length;
		let i = 0;
		while (i < len) if ((buf[i] & 128) === 0) i++;
		else if ((buf[i] & 224) === 192) {
			if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) return false;
			i += 2;
		} else if ((buf[i] & 240) === 224) {
			if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) return false;
			i += 3;
		} else if ((buf[i] & 248) === 240) {
			if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) return false;
			i += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob,
		isValidStatusCode,
		isValidUTF8: _isValidUTF8,
		tokenChars
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8 = require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
		};
	} catch (e) {}
}));

//#endregion
//#region ../../node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Writable } = require("stream");
	const PerMessageDeflate = require_permessage_deflate();
	const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate.extensionName].decompress(data, this._fin, (err, buf) => {
				if (err) return cb(err);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER);
					this.end();
				} else {
					const code = data.readUInt16BE(0);
					if (!isValidStatusCode(code)) {
						cb(this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err, this.createError);
			err.code = errorCode;
			err[kStatusCode] = statusCode;
			return err;
		}
	};
	module.exports = Receiver;
}));

//#endregion
//#region ../../node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Duplex: Duplex$3 } = require("stream");
	const { randomFillSync } = require("crypto");
	const PerMessageDeflate = require_permessage_deflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
	const { isBlob, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender = class Sender {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP;
			this[kWebSocket] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code, data, mask, cb) {
			let buf;
			if (code === void 0) buf = EMPTY_BUFFER;
			else if (typeof code !== "number" || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer(data);
				byteLength = data.length;
				readOnly = toBuffer.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err) => {
				process.nextTick(onError, this, err, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err, cb) {
		if (typeof cb === "function") cb(err);
		for (let i = 0; i < sender._queue.length; i++) {
			const params = sender._queue[i];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err, cb) {
		callCallbacks(sender, err, cb);
		sender.onerror(err);
	}
}));

//#endregion
//#region ../../node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kForOnEventAttribute, kListener } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event.prototype, "target", { enumerable: true });
	Object.defineProperty(Event.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget = {
		addEventListener(type, handler, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "close") wrapper = function onClose(code, message) {
				const event = new CloseEvent("close", {
					code,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "error") wrapper = function onError(error) {
				const event = new ErrorEvent("error", {
					error,
					message: error.message
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event("open");
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
			wrapper[kListener] = handler;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler) {
			for (const listener of this.listeners(type)) if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event,
		EventTarget,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
}));

//#endregion
//#region ../../node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			code = header.charCodeAt(i);
			if (extensionName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const name = header.slice(start, end);
				if (code === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (paramName === void 0) if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 32 || code === 9) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				push(params, header.slice(start, end), true);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (isEscaping) {
				if (tokenChars[code] !== 1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (start === -1) start = i;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 34 && start !== -1) {
				inQuotes = false;
				end = i;
			} else if (code === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (code === 34 && header.charCodeAt(i - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (start !== -1 && (code === 32 || code === 9)) {
				if (end === -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || inQuotes || code === 32 || code === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format(extensions) {
		return Object.keys(extensions).map((extension) => {
			let configurations = extensions[extension];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format,
		parse
	};
}));

//#endregion
//#region ../../node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$3 = require("events");
	const https = require("https");
	const http$1 = require("http");
	const net = require("net");
	const tls = require("tls");
	const { randomBytes, createHash: createHash$1 } = require("crypto");
	const { Duplex: Duplex$2, Readable: Readable$1 } = require("stream");
	const { URL: URL$1 } = require("url");
	const PerMessageDeflate = require_permessage_deflate();
	const Receiver = require_receiver();
	const Sender = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, CLOSE_TIMEOUT, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format, parse } = require_extension();
	const { toBuffer } = require_buffer_util();
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket = class WebSocket extends EventEmitter$3 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._closeTimeout = options.closeTimeout;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket] = this;
			sender[kWebSocket] = this;
			socket[kWebSocket] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError);
			this._readyState = WebSocket.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate.extensionName]) this._extensions[PerMessageDeflate.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code, data) {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket.CLOSING;
			this._sender.close(code, data, !this._isServer, (err) => {
				if (err) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket.CLOSED) return;
			if (this.readyState === WebSocket.CONNECTING) {
				abortHandshake(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler !== "function") return;
				this.addEventListener(method, handler, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Number} [options.closeTimeout=30000] Duration in milliseconds to wait
	*     for the closing handshake to finish after `websocket.close()` is called
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			closeTimeout: CLOSE_TIMEOUT,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		websocket._closeTimeout = opts.closeTimeout;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$1) parsedUrl = address;
		else try {
			parsedUrl = new URL$1(address);
		} catch (e) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err;
			else {
				emitErrorAndClose(websocket, err);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request = isSecure ? https.request : http$1.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format({ [PerMessageDeflate.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key, value] of Object.entries(headers)) options.headers[key.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req = websocket._req = request(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req);
		} else req = websocket._req = request(opts);
		if (opts.timeout) req.on("timeout", () => {
			abortHandshake(websocket, req, "Opening handshake has timed out");
		});
		req.on("error", (err) => {
			if (req === null || req[kAborted]) return;
			req = websocket._req = null;
			emitErrorAndClose(websocket, err);
		});
		req.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake(websocket, req, "Maximum redirects exceeded");
					return;
				}
				req.abort();
				let addr;
				try {
					addr = new URL$1(location, address);
				} catch (e) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req, res)) abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
		});
		req.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket.CONNECTING) return;
			req = websocket._req = null;
			const upgrade = res.headers.upgrade;
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshake(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions;
				try {
					extensions = parse(secWebSocketExtensions);
				} catch (err) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
					abortHandshake(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
				} catch (err) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req, websocket);
		else req.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err) {
		websocket._readyState = WebSocket.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake(websocket, stream, message) {
		websocket._readyState = WebSocket.CLOSING;
		const err = new Error(message);
		Error.captureStackTrace(err, abortHandshake);
		if (stream.setHeader) {
			stream[kAborted] = true;
			stream.abort();
			if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err);
		} else {
			stream.destroy(err);
			stream.once("error", websocket.emit.bind(websocket, "error"));
			stream.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code, reason) {
		const websocket = this[kWebSocket];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code;
		if (websocket._socket[kWebSocket] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code === 1005) websocket.close();
		else websocket.close(code, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err) {
		const websocket = this[kWebSocket];
		if (websocket._socket[kWebSocket] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream) {
		stream.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err) {
		const websocket = this[kWebSocket];
		if (websocket.readyState === WebSocket.CLOSED) return;
		if (websocket.readyState === WebSocket.OPEN) {
			websocket._readyState = WebSocket.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), websocket._closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket.CLOSING;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
			const chunk = this.read(this._readableState.length);
			websocket._receiver.write(chunk);
		}
		websocket._receiver.end();
		this[kWebSocket] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket];
		websocket._readyState = WebSocket.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError() {
		const websocket = this[kWebSocket];
		this.removeListener("error", socketOnError);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket.CLOSING;
			this.destroy();
		}
	}
}));

//#endregion
//#region ../../node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose(stream) {
		stream.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error(err) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err);
				process.nextTick(emitClose, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error(err) {
				called = true;
				callback(err);
			});
			ws.once("close", function close() {
				if (!called) callback(err);
				process.nextTick(emitClose, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream;
}));

//#endregion
//#region ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			const code = header.charCodeAt(i);
			if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const protocol = header.slice(start, end);
				if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
				protocols.add(protocol);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse };
}));

//#endregion
//#region ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$2 = require("events");
	const http = require("http");
	const { Duplex } = require("stream");
	const { createHash } = require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket = require_websocket();
	const { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer = class extends EventEmitter$2 {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Number} [options.closeTimeout=30000] Duration in milliseconds to
		*     wait for the closing handshake to finish after `websocket.close()` is
		*     called
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				closeTimeout: CLOSE_TIMEOUT,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req, socket, head) => {
						this.handleUpgrade(req, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req) {
			if (this.options.path) {
				const index = req.url.indexOf("?");
				if ((index !== -1 ? req.url.slice(0, index) : req.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req.headers["sec-websocket-key"];
			const upgrade = req.headers.upgrade;
			const version = +req.headers["sec-websocket-version"];
			if (req.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version !== 13 && version !== 8) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err) {
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info = {
					origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req.socket.authorized || req.socket.encrypted),
					req
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info, (verified, code, message, headers) => {
						if (!verified) return abortHandshake(socket, code || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req);
		}
	};
	module.exports = WebSocketServer;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code, message, headers) {
		message = message || http.STATUS_CODES[code];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err, socket, req);
		} else abortHandshake(socket, code, message, headers);
	}
}));

//#endregion
//#region ../../node_modules/ws/wrapper.mjs
var import_stream = /* @__PURE__ */ __toESM(require_stream(), 1);
var import_receiver = /* @__PURE__ */ __toESM(require_receiver(), 1);
var import_sender = /* @__PURE__ */ __toESM(require_sender(), 1);
var import_websocket = /* @__PURE__ */ __toESM(require_websocket(), 1);
var import_websocket_server = /* @__PURE__ */ __toESM(require_websocket_server(), 1);

//#endregion
//#region ../../node_modules/zod/v4/core/core.js
/** A special constant with type `never` */
const NEVER = Object.freeze({ status: "aborted" });
function $constructor(name, initializer, params) {
	function init(inst, def) {
		if (!inst._zod) Object.defineProperty(inst, "_zod", {
			value: {
				def,
				constr: _,
				traits: /* @__PURE__ */ new Set()
			},
			enumerable: false
		});
		if (inst._zod.traits.has(name)) return;
		inst._zod.traits.add(name);
		initializer(inst, def);
		const proto = _.prototype;
		const keys = Object.keys(proto);
		for (let i = 0; i < keys.length; i++) {
			const k = keys[i];
			if (!(k in inst)) inst[k] = proto[k].bind(inst);
		}
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _(def) {
		var _a;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def);
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		for (const fn of inst._zod.deferred) fn();
		return inst;
	}
	Object.defineProperty(_, "init", { value: init });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_, "name", { value: name });
	return _;
}
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
var $ZodEncodeError = class extends Error {
	constructor(name) {
		super(`Encountered unidirectional transform during encode: ${name}`);
		this.name = "ZodEncodeError";
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region ../../node_modules/zod/v4/core/util.js
function getEnumValues(entries) {
	const numericValues = Object.values(entries).filter((v) => typeof v === "number");
	return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function nullish(input) {
	return input === null || input === void 0;
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepString = step.toString();
	let stepDecCount = (stepString.split(".")[1] || "").length;
	if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
		const match = stepString.match(/\d?e-(\d?)/);
		if (match?.[1]) stepDecCount = Number.parseInt(match[1]);
	}
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
	let value = void 0;
	Object.defineProperty(object, key, {
		get() {
			if (value === EVALUATING) return;
			if (value === void 0) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object, key, { value: v });
		},
		configurable: true
	});
}
function assignProp(target, prop, value) {
	Object.defineProperty(target, prop, {
		value,
		writable: true,
		enumerable: true,
		configurable: true
	});
}
function mergeDefs(...defs) {
	const mergedDescriptors = {};
	for (const def of defs) {
		const descriptors = Object.getOwnPropertyDescriptors(def);
		Object.assign(mergedDescriptors, descriptors);
	}
	return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
	return JSON.stringify(str);
}
function slugify$3(input) {
	return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === void 0) return true;
	if (typeof ctor !== "function") return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
function shallowClone(o) {
	if (isPlainObject(o)) return { ...o };
	if (Array.isArray(o)) return [...o];
	return o;
}
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick$1(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	if (checks && checks.length > 0) throw new Error(".pick() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = {};
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				newShape[key] = currDef.shape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function omit(schema, mask) {
	const currDef = schema._zod.def;
	const checks = currDef.checks;
	if (checks && checks.length > 0) throw new Error(".omit() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const newShape = { ...schema._zod.def.shape };
			for (const key in mask) {
				if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				delete newShape[key];
			}
			assignProp(this, "shape", newShape);
			return newShape;
		},
		checks: []
	}));
}
function extend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to extend: expected a plain object");
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) {
		const existingShape = schema._zod.def.shape;
		for (const key in shape) if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
	}
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} }));
}
function safeExtend(schema, shape) {
	if (!isPlainObject(shape)) throw new Error("Invalid input to safeExtend: expected a plain object");
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const _shape = {
			...schema._zod.def.shape,
			...shape
		};
		assignProp(this, "shape", _shape);
		return _shape;
	} }));
}
function merge(a, b) {
	return clone(a, mergeDefs(a._zod.def, {
		get shape() {
			const _shape = {
				...a._zod.def.shape,
				...b._zod.def.shape
			};
			assignProp(this, "shape", _shape);
			return _shape;
		},
		get catchall() {
			return b._zod.def.catchall;
		},
		checks: []
	}));
}
function partial(Class, schema, mask) {
	const checks = schema._zod.def.checks;
	if (checks && checks.length > 0) throw new Error(".partial() cannot be used on object schemas containing refinements");
	return clone(schema, mergeDefs(schema._zod.def, {
		get shape() {
			const oldShape = schema._zod.def.shape;
			const shape = { ...oldShape };
			if (mask) for (const key in mask) {
				if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
				if (!mask[key]) continue;
				shape[key] = Class ? new Class({
					type: "optional",
					innerType: oldShape[key]
				}) : oldShape[key];
			}
			else for (const key in oldShape) shape[key] = Class ? new Class({
				type: "optional",
				innerType: oldShape[key]
			}) : oldShape[key];
			assignProp(this, "shape", shape);
			return shape;
		},
		checks: []
	}));
}
function required(Class, schema, mask) {
	return clone(schema, mergeDefs(schema._zod.def, { get shape() {
		const oldShape = schema._zod.def.shape;
		const shape = { ...oldShape };
		if (mask) for (const key in mask) {
			if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			shape[key] = new Class({
				type: "nonoptional",
				innerType: oldShape[key]
			});
		}
		else for (const key in oldShape) shape[key] = new Class({
			type: "nonoptional",
			innerType: oldShape[key]
		});
		assignProp(this, "shape", shape);
		return shape;
	} }));
}
function aborted(x, startIndex = 0) {
	if (x.aborted === true) return true;
	for (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;
	return false;
}
function prefixIssues(path, issues) {
	return issues.map((iss) => {
		var _a;
		(_a = iss).path ?? (_a.path = []);
		iss.path.unshift(path);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config.customError?.(iss)) ?? unwrapMessage(config.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}
function getLengthableOrigin(input) {
	if (Array.isArray(input)) return "array";
	if (typeof input === "string") return "string";
	return "unknown";
}
function issue(...args) {
	const [iss, input, inst] = args;
	if (typeof iss === "string") return {
		message: iss,
		code: "custom",
		input,
		inst
	};
	return { ...iss };
}

//#endregion
//#region ../../node_modules/zod/v4/core/errors.js
const initializer$1 = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue) => issue.message) {
	const fieldErrors = {};
	const formErrors = [];
	for (const sub of error.issues) if (sub.path.length > 0) {
		fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
		fieldErrors[sub.path[0]].push(mapper(sub));
	} else formErrors.push(mapper(sub));
	return {
		formErrors,
		fieldErrors
	};
}
function formatError(error, mapper = (issue) => issue.message) {
	const fieldErrors = { _errors: [] };
	const processError = (error) => {
		for (const issue of error.issues) if (issue.code === "invalid_union" && issue.errors.length) issue.errors.map((issues) => processError({ issues }));
		else if (issue.code === "invalid_key") processError({ issues: issue.issues });
		else if (issue.code === "invalid_element") processError({ issues: issue.issues });
		else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
		else {
			let curr = fieldErrors;
			let i = 0;
			while (i < issue.path.length) {
				const el = issue.path[i];
				if (!(i === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
				else {
					curr[el] = curr[el] || { _errors: [] };
					curr[el]._errors.push(mapper(issue));
				}
				curr = curr[el];
				i++;
			}
		}
	};
	processError(error);
	return fieldErrors;
}

//#endregion
//#region ../../node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$1 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema, value, ctx);
};
const encode$1 = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
	return _parse(_Err)(schema, value, _ctx);
};
const decode$1 = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync$1 = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync$1 = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode$1 = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
	return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode$1 = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync$1 = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync$1 = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

//#endregion
//#region ../../node_modules/zod/v4/core/regexes.js
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
*
* @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version) => {
	if (!version) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
	return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const e164 = /^\+[1-9]\d{6,14}$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
	const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$1(args) {
	return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
	const time = timeSource({ precision: args.precision });
	const opts = ["Z"];
	if (args.local) opts.push("");
	if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	const timeRegex = `${time}(?:${opts.join("|")})`;
	return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?$/;
const boolean$1 = /^(?:true|false)$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;

//#endregion
//#region ../../node_modules/zod/v4/core/checks.js
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
	var _a;
	inst._zod ?? (inst._zod = {});
	inst._zod.def = def;
	(_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
	number: "number",
	bigint: "bigint",
	object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
		if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
		else bag.exclusiveMaximum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
	$ZodCheck.init(inst, def);
	const origin = numericOriginMap[typeof def.value];
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
		if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
		else bag.exclusiveMinimum = def.value;
	});
	inst._zod.check = (payload) => {
		if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
			input: payload.value,
			inclusive: def.inclusive,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst) => {
		var _a;
		(_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
	});
	inst._zod.check = (payload) => {
		if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
		if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0) return;
		payload.issues.push({
			origin: typeof payload.value,
			code: "not_multiple_of",
			divisor: def.value,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
	$ZodCheck.init(inst, def);
	def.format = def.format || "float64";
	const isInt = def.format?.includes("int");
	const origin = isInt ? "int" : "number";
	const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.format = def.format;
		bag.minimum = minimum;
		bag.maximum = maximum;
		if (isInt) bag.pattern = integer;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (isInt) {
			if (!Number.isInteger(input)) {
				payload.issues.push({
					expected: origin,
					format: def.format,
					code: "invalid_type",
					continue: false,
					input,
					inst
				});
				return;
			}
			if (!Number.isSafeInteger(input)) {
				if (input > 0) payload.issues.push({
					input,
					code: "too_big",
					maximum: Number.MAX_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					inclusive: true,
					continue: !def.abort
				});
				else payload.issues.push({
					input,
					code: "too_small",
					minimum: Number.MIN_SAFE_INTEGER,
					note: "Integers must be within the safe integer range.",
					inst,
					origin,
					inclusive: true,
					continue: !def.abort
				});
				return;
			}
		}
		if (input < minimum) payload.issues.push({
			origin: "number",
			input,
			code: "too_small",
			minimum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
		if (input > maximum) payload.issues.push({
			origin: "number",
			input,
			code: "too_big",
			maximum,
			inclusive: true,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst) => {
		const curr = inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
		if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length <= def.maximum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_big",
			maximum: def.maximum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst) => {
		const curr = inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
		if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		if (input.length >= def.minimum) return;
		const origin = getLengthableOrigin(input);
		payload.issues.push({
			origin,
			code: "too_small",
			minimum: def.minimum,
			inclusive: true,
			input,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
	var _a;
	$ZodCheck.init(inst, def);
	(_a = inst._zod.def).when ?? (_a.when = (payload) => {
		const val = payload.value;
		return !nullish(val) && val.length !== void 0;
	});
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.minimum = def.length;
		bag.maximum = def.length;
		bag.length = def.length;
	});
	inst._zod.check = (payload) => {
		const input = payload.value;
		const length = input.length;
		if (length === def.length) return;
		const origin = getLengthableOrigin(input);
		const tooBig = length > def.length;
		payload.issues.push({
			origin,
			...tooBig ? {
				code: "too_big",
				maximum: def.length
			} : {
				code: "too_small",
				minimum: def.length
			},
			inclusive: true,
			exact: true,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
	var _a, _b;
	$ZodCheck.init(inst, def);
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.format = def.format;
		if (def.pattern) {
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(def.pattern);
		}
	});
	if (def.pattern) (_a = inst._zod).check ?? (_a.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: def.format,
			input: payload.value,
			...def.pattern ? { pattern: def.pattern.toString() } : {},
			inst,
			continue: !def.abort
		});
	});
	else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		def.pattern.lastIndex = 0;
		if (def.pattern.test(payload.value)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "regex",
			input: payload.value,
			pattern: def.pattern.toString(),
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
	def.pattern ?? (def.pattern = lowercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
	def.pattern ?? (def.pattern = uppercase);
	$ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
	$ZodCheck.init(inst, def);
	const escapedRegex = escapeRegex(def.includes);
	const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	def.pattern = pattern;
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.includes(def.includes, def.position)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "includes",
			includes: def.includes,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.startsWith(def.prefix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "starts_with",
			prefix: def.prefix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
	$ZodCheck.init(inst, def);
	const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
	def.pattern ?? (def.pattern = pattern);
	inst._zod.onattach.push((inst) => {
		const bag = inst._zod.bag;
		bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
		bag.patterns.add(pattern);
	});
	inst._zod.check = (payload) => {
		if (payload.value.endsWith(def.suffix)) return;
		payload.issues.push({
			origin: "string",
			code: "invalid_format",
			format: "ends_with",
			suffix: def.suffix,
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
	$ZodCheck.init(inst, def);
	inst._zod.check = (payload) => {
		payload.value = def.tx(payload.value);
	};
});

//#endregion
//#region ../../node_modules/zod/v4/core/doc.js
var Doc = class {
	constructor(args = []) {
		this.content = [];
		this.indent = 0;
		if (this) this.args = args;
	}
	indented(fn) {
		this.indent += 1;
		fn(this);
		this.indent -= 1;
	}
	write(arg) {
		if (typeof arg === "function") {
			arg(this, { execution: "sync" });
			arg(this, { execution: "async" });
			return;
		}
		const lines = arg.split("\n").filter((x) => x);
		const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
		const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
		for (const line of dedented) this.content.push(line);
	}
	compile() {
		const F = Function;
		const args = this?.args;
		const lines = [...(this?.content ?? [``]).map((x) => `  ${x}`)];
		return new F(...args, lines.join("\n"));
	}
};

//#endregion
//#region ../../node_modules/zod/v4/core/versions.js
const version = {
	major: 4,
	minor: 3,
	patch: 6
};

//#endregion
//#region ../../node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
	if (checks.length === 0) {
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) return canary.then((canary) => {
					return handleCanaryResult(canary, payload, ctx);
				});
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result) => runChecks(result, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	defineLazy(inst, "~standard", () => ({
		validate: (value) => {
			try {
				const r = safeParse$1(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_) {
				return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	}));
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
	$ZodCheckStringFormat.init(inst, def);
	$ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
	def.pattern ?? (def.pattern = guid);
	$ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
	if (def.version) {
		const v = {
			v1: 1,
			v2: 2,
			v3: 3,
			v4: 4,
			v5: 5,
			v6: 6,
			v7: 7,
			v8: 8
		}[def.version];
		if (v === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
		def.pattern ?? (def.pattern = uuid(v));
	} else def.pattern ?? (def.pattern = uuid());
	$ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
	def.pattern ?? (def.pattern = email);
	$ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		try {
			const trimmed = payload.value.trim();
			const url = new URL(trimmed);
			if (def.hostname) {
				def.hostname.lastIndex = 0;
				if (!def.hostname.test(url.hostname)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid hostname",
					pattern: def.hostname.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.protocol) {
				def.protocol.lastIndex = 0;
				if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) payload.issues.push({
					code: "invalid_format",
					format: "url",
					note: "Invalid protocol",
					pattern: def.protocol.source,
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
			if (def.normalize) payload.value = url.href;
			else payload.value = trimmed;
			return;
		} catch (_) {
			payload.issues.push({
				code: "invalid_format",
				format: "url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
	def.pattern ?? (def.pattern = emoji());
	$ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
	def.pattern ?? (def.pattern = nanoid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
	def.pattern ?? (def.pattern = cuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
	def.pattern ?? (def.pattern = cuid2);
	$ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
	def.pattern ?? (def.pattern = ulid);
	$ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
	def.pattern ?? (def.pattern = xid);
	$ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
	def.pattern ?? (def.pattern = ksuid);
	$ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
	def.pattern ?? (def.pattern = datetime$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
	def.pattern ?? (def.pattern = date$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
	def.pattern ?? (def.pattern = time$1(def));
	$ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
	def.pattern ?? (def.pattern = duration$1);
	$ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
	def.pattern ?? (def.pattern = ipv4);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
	def.pattern ?? (def.pattern = ipv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.format = `ipv6`;
	inst._zod.check = (payload) => {
		try {
			new URL(`http://[${payload.value}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "ipv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv4);
	$ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
	def.pattern ?? (def.pattern = cidrv6);
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		const parts = payload.value.split("/");
		try {
			if (parts.length !== 2) throw new Error();
			const [address, prefix] = parts;
			if (!prefix) throw new Error();
			const prefixNum = Number(prefix);
			if (`${prefixNum}` !== prefix) throw new Error();
			if (prefixNum < 0 || prefixNum > 128) throw new Error();
			new URL(`http://[${address}]`);
		} catch {
			payload.issues.push({
				code: "invalid_format",
				format: "cidrv6",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		}
	};
});
function isValidBase64(data) {
	if (data === "") return true;
	if (data.length % 4 !== 0) return false;
	try {
		atob(data);
		return true;
	} catch {
		return false;
	}
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
	def.pattern ?? (def.pattern = base64);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64";
	inst._zod.check = (payload) => {
		if (isValidBase64(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
function isValidBase64URL(data) {
	if (!base64url.test(data)) return false;
	const base64 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
	return isValidBase64(base64.padEnd(Math.ceil(base64.length / 4) * 4, "="));
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
	def.pattern ?? (def.pattern = base64url);
	$ZodStringFormat.init(inst, def);
	inst._zod.bag.contentEncoding = "base64url";
	inst._zod.check = (payload) => {
		if (isValidBase64URL(payload.value)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "base64url",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
	def.pattern ?? (def.pattern = e164);
	$ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
	try {
		const tokensParts = token.split(".");
		if (tokensParts.length !== 3) return false;
		const [header] = tokensParts;
		if (!header) return false;
		const parsedHeader = JSON.parse(atob(header));
		if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
		if (!parsedHeader.alg) return false;
		if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
		return true;
	} catch {
		return false;
	}
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	inst._zod.check = (payload) => {
		if (isValidJWT(payload.value, def.alg)) return;
		payload.issues.push({
			code: "invalid_format",
			format: "jwt",
			input: payload.value,
			inst,
			continue: !def.abort
		});
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
	$ZodCheckNumberFormat.init(inst, def);
	$ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = boolean$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Boolean(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "boolean") return payload;
		payload.issues.push({
			expected: "boolean",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		payload.issues.push({
			expected: "never",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i = 0; i < input.length; i++) {
			const item = input[i];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result) => handleArrayResult(result, payload, i)));
			else handleArrayResult(result, payload, i);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
	if (result.issues.length) {
		if (isOptionalOut && !(key in input)) return;
		final.issues.push(...prefixIssues(key, result.issues));
	}
	if (result.value === void 0) {
		if (key in input) final.value[key] = void 0;
	} else final.value[key] = result.value;
}
function normalizeDef(def) {
	const keys = Object.keys(def.shape);
	for (const k of keys) if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys,
		keySet: new Set(keys),
		numKeys: keys.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t = _catchall.def.type;
	const isOptionalOut = _catchall.optout === "optional";
	for (const key in input) {
		if (keySet.has(key)) continue;
		if (t === "never") {
			unrecognized.push(key);
			continue;
		}
		const r = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r instanceof Promise) proms.push(r.then((r) => handlePropertyResult(r, payload, key, input, isOptionalOut)));
		else handlePropertyResult(r, payload, key, input, isOptionalOut);
	}
	if (unrecognized.length) payload.issues.push({
		code: "unrecognized_keys",
		keys: unrecognized,
		input,
		inst
	});
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	if (!Object.getOwnPropertyDescriptor(def, "shape")?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$2 = isObject;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$2(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const el = shape[key];
			const isOptionalOut = el._zod.optout === "optional";
			const r = el._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r instanceof Promise) proms.push(r.then((r) => handlePropertyResult(r, payload, key, input, isOptionalOut)));
			else handlePropertyResult(r, payload, key, input, isOptionalOut);
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
	$ZodObject.init(inst, def);
	const superParse = inst._zod.parse;
	const _normalized = cached(() => normalizeDef(def));
	const generateFastpass = (shape) => {
		const doc = new Doc([
			"shape",
			"payload",
			"ctx"
		]);
		const normalized = _normalized.value;
		const parseStr = (key) => {
			const k = esc(key);
			return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
		};
		doc.write(`const input = payload.value;`);
		const ids = Object.create(null);
		let counter = 0;
		for (const key of normalized.keys) ids[key] = `key_${counter++}`;
		doc.write(`const newResult = {};`);
		for (const key of normalized.keys) {
			const id = ids[key];
			const k = esc(key);
			const isOptionalOut = shape[key]?._zod?.optout === "optional";
			doc.write(`const ${id} = ${parseStr(key)};`);
			if (isOptionalOut) doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
			else doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
		}
		doc.write(`payload.value = newResult;`);
		doc.write(`return payload;`);
		const fn = doc.compile();
		return (payload, ctx) => fn(shape, payload, ctx);
	};
	let fastpass;
	const isObject$1 = isObject;
	const jit = !globalConfig.jitless;
	const allowsEval$1 = allowsEval;
	const fastEnabled = jit && allowsEval$1.value;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
			if (!fastpass) fastpass = generateFastpass(def.shape);
			payload = fastpass(payload, ctx);
			if (!catchall) return payload;
			return handleCatchall([], input, payload, ctx, value, inst);
		}
		return superParse(payload, ctx);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	const nonaborted = results.filter((r) => !aborted(r));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o) => o._zod.pattern)) {
			const patterns = def.options.map((o) => o._zod.pattern);
			return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results) => {
			return handleUnionResults(results, payload, inst, ctx);
		});
	};
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		const left = def.left._zod.run({
			value: input,
			issues: []
		}, ctx);
		const right = def.right._zod.run({
			value: input,
			issues: []
		}, ctx);
		if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left, right]) => {
			return handleIntersectionResults(payload, left, right);
		});
		return handleIntersectionResults(payload, left, right);
	};
});
function mergeValues(a, b) {
	if (a === b) return {
		valid: true,
		data: a
	};
	if (a instanceof Date && b instanceof Date && +a === +b) return {
		valid: true,
		data: a
	};
	if (isPlainObject(a) && isPlainObject(b)) {
		const bKeys = Object.keys(b);
		const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
			};
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return {
			valid: false,
			mergeErrorPath: []
		};
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return {
				valid: false,
				mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
			};
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	}
	return {
		valid: false,
		mergeErrorPath: []
	};
}
function handleIntersectionResults(result, left, right) {
	const unrecKeys = /* @__PURE__ */ new Map();
	let unrecIssue;
	for (const iss of left.issues) if (iss.code === "unrecognized_keys") {
		unrecIssue ?? (unrecIssue = iss);
		for (const k of iss.keys) {
			if (!unrecKeys.has(k)) unrecKeys.set(k, {});
			unrecKeys.get(k).l = true;
		}
	} else result.issues.push(iss);
	for (const iss of right.issues) if (iss.code === "unrecognized_keys") for (const k of iss.keys) {
		if (!unrecKeys.has(k)) unrecKeys.set(k, {});
		unrecKeys.get(k).r = true;
	}
	else result.issues.push(iss);
	const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
	if (bothKeys.length && unrecIssue) result.issues.push({
		...unrecIssue,
		keys: bothKeys
	});
	if (aborted(result)) return result;
	const merged = mergeValues(left.value, right.value);
	if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
	result.value = merged.data;
	return result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
	$ZodType.init(inst, def);
	const values = getEnumValues(def.entries);
	const valuesSet = new Set(values);
	inst._zod.values = valuesSet;
	inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (valuesSet.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values,
			input,
			inst
		});
		return payload;
	};
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		const _out = def.transform(payload.value, payload);
		if (ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {
			payload.value = output;
			return payload;
		});
		if (_out instanceof Promise) throw new $ZodAsyncError();
		payload.value = _out;
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === void 0) return {
		issues: [],
		value: void 0
	};
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r) => handleOptionalResult(r, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === void 0) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
	inst._zod.parse = (payload, ctx) => {
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
	});
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (payload.value === null) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) {
			payload.value = def.defaultValue;
			/**
			* $ZodDefault returns the default value immediately in forward direction.
			* It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
			return payload;
		}
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result) => handleDefaultResult(result, def));
		return handleDefaultResult(result, def);
	};
});
function handleDefaultResult(payload, def) {
	if (payload.value === void 0) payload.value = def.defaultValue;
	return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		if (payload.value === void 0) payload.value = def.defaultValue;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => {
		const v = def.innerType._zod.values;
		return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result) => handleNonOptionalResult(result, inst));
		return handleNonOptionalResult(result, inst);
	};
});
function handleNonOptionalResult(payload, inst) {
	if (!payload.issues.length && payload.value === void 0) payload.issues.push({
		code: "invalid_type",
		expected: "nonoptional",
		input: payload.value,
		inst
	});
	return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then((result) => {
			payload.value = result.value;
			if (result.issues.length) {
				payload.value = def.catchValue({
					...payload,
					error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		});
		payload.value = result.value;
		if (result.issues.length) {
			payload.value = def.catchValue({
				...payload,
				error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
				input: payload.value
			});
			payload.issues = [];
		}
		return payload;
	};
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "values", () => def.in._zod.values);
	defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") {
			const right = def.out._zod.run(payload, ctx);
			if (right instanceof Promise) return right.then((right) => handlePipeResult(right, def.in, ctx));
			return handlePipeResult(right, def.in, ctx);
		}
		const left = def.in._zod.run(payload, ctx);
		if (left instanceof Promise) return left.then((left) => handlePipeResult(left, def.out, ctx));
		return handlePipeResult(left, def.out, ctx);
	};
});
function handlePipeResult(left, next, ctx) {
	if (left.issues.length) {
		left.aborted = true;
		return left;
	}
	return next._zod.run({
		value: left.value,
		issues: left.issues
	}, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
	defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
	inst._zod.parse = (payload, ctx) => {
		if (ctx.direction === "backward") return def.innerType._zod.run(payload, ctx);
		const result = def.innerType._zod.run(payload, ctx);
		if (result instanceof Promise) return result.then(handleReadonlyResult);
		return handleReadonlyResult(result);
	};
});
function handleReadonlyResult(payload) {
	payload.value = Object.freeze(payload.value);
	return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
	$ZodCheck.init(inst, def);
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _) => {
		return payload;
	};
	inst._zod.check = (payload) => {
		const input = payload.value;
		const r = def.fn(input);
		if (r instanceof Promise) return r.then((r) => handleRefineResult(r, payload, input, inst));
		handleRefineResult(r, payload, input, inst);
	};
});
function handleRefineResult(result, payload, input, inst) {
	if (!result) {
		const _iss = {
			code: "custom",
			input,
			inst,
			path: [...inst._zod.def.path ?? []],
			continue: !inst._zod.def.abort
		};
		if (inst._zod.def.params) _iss.params = inst._zod.def.params;
		payload.issues.push(issue(_iss));
	}
}

//#endregion
//#region ../../node_modules/zod/v4/core/registries.js
var _a$1;
var $ZodRegistry = class {
	constructor() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
	}
	add(schema, ..._meta) {
		const meta = _meta[0];
		this._map.set(schema, meta);
		if (meta && typeof meta === "object" && "id" in meta) this._idmap.set(meta.id, schema);
		return this;
	}
	clear() {
		this._map = /* @__PURE__ */ new WeakMap();
		this._idmap = /* @__PURE__ */ new Map();
		return this;
	}
	remove(schema) {
		const meta = this._map.get(schema);
		if (meta && typeof meta === "object" && "id" in meta) this._idmap.delete(meta.id);
		this._map.delete(schema);
		return this;
	}
	get(schema) {
		const p = schema._zod.parent;
		if (p) {
			const pm = { ...this.get(p) ?? {} };
			delete pm.id;
			const f = {
				...pm,
				...this._map.get(schema)
			};
			return Object.keys(f).length ? f : void 0;
		}
		return this._map.get(schema);
	}
	has(schema) {
		return this._map.has(schema);
	}
};
function registry() {
	return new $ZodRegistry();
}
(_a$1 = globalThis).__zod_globalRegistry ?? (_a$1.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;

//#endregion
//#region ../../node_modules/zod/v4/core/api.js
/* @__NO_SIDE_EFFECTS__ */
function _string(Class, params) {
	return new Class({
		type: "string",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _email(Class, params) {
	return new Class({
		type: "string",
		format: "email",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _guid(Class, params) {
	return new Class({
		type: "string",
		format: "guid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuid(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv4(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v4",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv6(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v6",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uuidv7(Class, params) {
	return new Class({
		type: "string",
		format: "uuid",
		check: "string_format",
		abort: false,
		version: "v7",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _url(Class, params) {
	return new Class({
		type: "string",
		format: "url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _emoji(Class, params) {
	return new Class({
		type: "string",
		format: "emoji",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _nanoid(Class, params) {
	return new Class({
		type: "string",
		format: "nanoid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid(Class, params) {
	return new Class({
		type: "string",
		format: "cuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cuid2(Class, params) {
	return new Class({
		type: "string",
		format: "cuid2",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ulid(Class, params) {
	return new Class({
		type: "string",
		format: "ulid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _xid(Class, params) {
	return new Class({
		type: "string",
		format: "xid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ksuid(Class, params) {
	return new Class({
		type: "string",
		format: "ksuid",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv4(Class, params) {
	return new Class({
		type: "string",
		format: "ipv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _ipv6(Class, params) {
	return new Class({
		type: "string",
		format: "ipv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv4(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv4",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _cidrv6(Class, params) {
	return new Class({
		type: "string",
		format: "cidrv6",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64(Class, params) {
	return new Class({
		type: "string",
		format: "base64",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _base64url(Class, params) {
	return new Class({
		type: "string",
		format: "base64url",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _e164(Class, params) {
	return new Class({
		type: "string",
		format: "e164",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _jwt(Class, params) {
	return new Class({
		type: "string",
		format: "jwt",
		check: "string_format",
		abort: false,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDateTime(Class, params) {
	return new Class({
		type: "string",
		format: "datetime",
		check: "string_format",
		offset: false,
		local: false,
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDate(Class, params) {
	return new Class({
		type: "string",
		format: "date",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoTime(Class, params) {
	return new Class({
		type: "string",
		format: "time",
		check: "string_format",
		precision: null,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _isoDuration(Class, params) {
	return new Class({
		type: "string",
		format: "duration",
		check: "string_format",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _number(Class, params) {
	return new Class({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _int(Class, params) {
	return new Class({
		type: "number",
		check: "number_format",
		abort: false,
		format: "safeint",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _boolean(Class, params) {
	return new Class({
		type: "boolean",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _unknown(Class) {
	return new Class({ type: "unknown" });
}
/* @__NO_SIDE_EFFECTS__ */
function _never(Class, params) {
	return new Class({
		type: "never",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lt(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lte(value, params) {
	return new $ZodCheckLessThan({
		check: "less_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gt(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: false
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _gte(value, params) {
	return new $ZodCheckGreaterThan({
		check: "greater_than",
		...normalizeParams(params),
		value,
		inclusive: true
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _multipleOf(value, params) {
	return new $ZodCheckMultipleOf({
		check: "multiple_of",
		...normalizeParams(params),
		value
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _maxLength(maximum, params) {
	return new $ZodCheckMaxLength({
		check: "max_length",
		...normalizeParams(params),
		maximum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _minLength(minimum, params) {
	return new $ZodCheckMinLength({
		check: "min_length",
		...normalizeParams(params),
		minimum
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _length(length, params) {
	return new $ZodCheckLengthEquals({
		check: "length_equals",
		...normalizeParams(params),
		length
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _regex(pattern, params) {
	return new $ZodCheckRegex({
		check: "string_format",
		format: "regex",
		...normalizeParams(params),
		pattern
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _lowercase(params) {
	return new $ZodCheckLowerCase({
		check: "string_format",
		format: "lowercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _uppercase(params) {
	return new $ZodCheckUpperCase({
		check: "string_format",
		format: "uppercase",
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _includes(includes, params) {
	return new $ZodCheckIncludes({
		check: "string_format",
		format: "includes",
		...normalizeParams(params),
		includes
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _startsWith(prefix, params) {
	return new $ZodCheckStartsWith({
		check: "string_format",
		format: "starts_with",
		...normalizeParams(params),
		prefix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _endsWith(suffix, params) {
	return new $ZodCheckEndsWith({
		check: "string_format",
		format: "ends_with",
		...normalizeParams(params),
		suffix
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _overwrite(tx) {
	return new $ZodCheckOverwrite({
		check: "overwrite",
		tx
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _normalize(form) {
	return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
/* @__NO_SIDE_EFFECTS__ */
function _trim() {
	return /* @__PURE__ */ _overwrite((input) => input.trim());
}
/* @__NO_SIDE_EFFECTS__ */
function _toLowerCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _toUpperCase() {
	return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
/* @__NO_SIDE_EFFECTS__ */
function _slugify() {
	return /* @__PURE__ */ _overwrite((input) => slugify$3(input));
}
/* @__NO_SIDE_EFFECTS__ */
function _array(Class, element, params) {
	return new Class({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _refine(Class, fn, _params) {
	return new Class({
		type: "custom",
		check: "custom",
		fn,
		...normalizeParams(_params)
	});
}
/* @__NO_SIDE_EFFECTS__ */
function _superRefine(fn) {
	const ch = /* @__PURE__ */ _check((payload) => {
		payload.addIssue = (issue$2) => {
			if (typeof issue$2 === "string") payload.issues.push(issue(issue$2, payload.value, ch._zod.def));
			else {
				const _issue = issue$2;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = ch);
				_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
				payload.issues.push(issue(_issue));
			}
		};
		return fn(payload.value, payload);
	});
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function _check(fn, params) {
	const ch = new $ZodCheck({
		check: "custom",
		...normalizeParams(params)
	});
	ch._zod.check = fn;
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function describe$1(description) {
	const ch = new $ZodCheck({ check: "describe" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			description
		});
	}];
	ch._zod.check = () => {};
	return ch;
}
/* @__NO_SIDE_EFFECTS__ */
function meta$1(metadata) {
	const ch = new $ZodCheck({ check: "meta" });
	ch._zod.onattach = [(inst) => {
		const existing = globalRegistry.get(inst) ?? {};
		globalRegistry.add(inst, {
			...existing,
			...metadata
		});
	}];
	ch._zod.check = () => {};
	return ch;
}

//#endregion
//#region ../../node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
	let target = params?.target ?? "draft-2020-12";
	if (target === "draft-4") target = "draft-04";
	if (target === "draft-7") target = "draft-07";
	return {
		processors: params.processors ?? {},
		metadataRegistry: params?.metadata ?? globalRegistry,
		target,
		unrepresentable: params?.unrepresentable ?? "throw",
		override: params?.override ?? (() => {}),
		io: params?.io ?? "output",
		counter: 0,
		seen: /* @__PURE__ */ new Map(),
		cycles: params?.cycles ?? "ref",
		reused: params?.reused ?? "inline",
		external: params?.external ?? void 0
	};
}
function process$7(schema, ctx, _params = {
	path: [],
	schemaPath: []
}) {
	var _a;
	const def = schema._zod.def;
	const seen = ctx.seen.get(schema);
	if (seen) {
		seen.count++;
		if (_params.schemaPath.includes(schema)) seen.cycle = _params.path;
		return seen.schema;
	}
	const result = {
		schema: {},
		count: 1,
		cycle: void 0,
		path: _params.path
	};
	ctx.seen.set(schema, result);
	const overrideSchema = schema._zod.toJSONSchema?.();
	if (overrideSchema) result.schema = overrideSchema;
	else {
		const params = {
			..._params,
			schemaPath: [..._params.schemaPath, schema],
			path: _params.path
		};
		if (schema._zod.processJSONSchema) schema._zod.processJSONSchema(ctx, result.schema, params);
		else {
			const _json = result.schema;
			const processor = ctx.processors[def.type];
			if (!processor) throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
			processor(schema, ctx, _json, params);
		}
		const parent = schema._zod.parent;
		if (parent) {
			if (!result.ref) result.ref = parent;
			process$7(parent, ctx, params);
			ctx.seen.get(parent).isParent = true;
		}
	}
	const meta = ctx.metadataRegistry.get(schema);
	if (meta) Object.assign(result.schema, meta);
	if (ctx.io === "input" && isTransforming(schema)) {
		delete result.schema.examples;
		delete result.schema.default;
	}
	if (ctx.io === "input" && result.schema._prefault) (_a = result.schema).default ?? (_a.default = result.schema._prefault);
	delete result.schema._prefault;
	return ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const idToSchema = /* @__PURE__ */ new Map();
	for (const entry of ctx.seen.entries()) {
		const id = ctx.metadataRegistry.get(entry[0])?.id;
		if (id) {
			const existing = idToSchema.get(id);
			if (existing && existing !== entry[0]) throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
			idToSchema.set(id, entry[0]);
		}
	}
	const makeURI = (entry) => {
		const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
		if (ctx.external) {
			const externalId = ctx.external.registry.get(entry[0])?.id;
			const uriGenerator = ctx.external.uri ?? ((id) => id);
			if (externalId) return { ref: uriGenerator(externalId) };
			const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
			entry[1].defId = id;
			return {
				defId: id,
				ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
			};
		}
		if (entry[1] === root) return { ref: "#" };
		const defUriPrefix = `#/${defsSegment}/`;
		const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
		return {
			defId,
			ref: defUriPrefix + defId
		};
	};
	const extractToDef = (entry) => {
		if (entry[1].schema.$ref) return;
		const seen = entry[1];
		const { ref, defId } = makeURI(entry);
		seen.def = { ...seen.schema };
		if (defId) seen.defId = defId;
		const schema = seen.schema;
		for (const key in schema) delete schema[key];
		schema.$ref = ref;
	};
	if (ctx.cycles === "throw") for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.cycle) throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
	}
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (schema === entry[0]) {
			extractToDef(entry);
			continue;
		}
		if (ctx.external) {
			const ext = ctx.external.registry.get(entry[0])?.id;
			if (schema !== entry[0] && ext) {
				extractToDef(entry);
				continue;
			}
		}
		if (ctx.metadataRegistry.get(entry[0])?.id) {
			extractToDef(entry);
			continue;
		}
		if (seen.cycle) {
			extractToDef(entry);
			continue;
		}
		if (seen.count > 1) {
			if (ctx.reused === "ref") {
				extractToDef(entry);
				continue;
			}
		}
	}
}
function finalize(ctx, schema) {
	const root = ctx.seen.get(schema);
	if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
	const flattenRef = (zodSchema) => {
		const seen = ctx.seen.get(zodSchema);
		if (seen.ref === null) return;
		const schema = seen.def ?? seen.schema;
		const _cached = { ...schema };
		const ref = seen.ref;
		seen.ref = null;
		if (ref) {
			flattenRef(ref);
			const refSeen = ctx.seen.get(ref);
			const refSchema = refSeen.schema;
			if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
				schema.allOf = schema.allOf ?? [];
				schema.allOf.push(refSchema);
			} else Object.assign(schema, refSchema);
			Object.assign(schema, _cached);
			if (zodSchema._zod.parent === ref) for (const key in schema) {
				if (key === "$ref" || key === "allOf") continue;
				if (!(key in _cached)) delete schema[key];
			}
			if (refSchema.$ref && refSeen.def) for (const key in schema) {
				if (key === "$ref" || key === "allOf") continue;
				if (key in refSeen.def && JSON.stringify(schema[key]) === JSON.stringify(refSeen.def[key])) delete schema[key];
			}
		}
		const parent = zodSchema._zod.parent;
		if (parent && parent !== ref) {
			flattenRef(parent);
			const parentSeen = ctx.seen.get(parent);
			if (parentSeen?.schema.$ref) {
				schema.$ref = parentSeen.schema.$ref;
				if (parentSeen.def) for (const key in schema) {
					if (key === "$ref" || key === "allOf") continue;
					if (key in parentSeen.def && JSON.stringify(schema[key]) === JSON.stringify(parentSeen.def[key])) delete schema[key];
				}
			}
		}
		ctx.override({
			zodSchema,
			jsonSchema: schema,
			path: seen.path ?? []
		});
	};
	for (const entry of [...ctx.seen.entries()].reverse()) flattenRef(entry[0]);
	const result = {};
	if (ctx.target === "draft-2020-12") result.$schema = "https://json-schema.org/draft/2020-12/schema";
	else if (ctx.target === "draft-07") result.$schema = "http://json-schema.org/draft-07/schema#";
	else if (ctx.target === "draft-04") result.$schema = "http://json-schema.org/draft-04/schema#";
	else if (ctx.target === "openapi-3.0") {}
	if (ctx.external?.uri) {
		const id = ctx.external.registry.get(schema)?.id;
		if (!id) throw new Error("Schema is missing an `id` property");
		result.$id = ctx.external.uri(id);
	}
	Object.assign(result, root.def ?? root.schema);
	const defs = ctx.external?.defs ?? {};
	for (const entry of ctx.seen.entries()) {
		const seen = entry[1];
		if (seen.def && seen.defId) defs[seen.defId] = seen.def;
	}
	if (ctx.external) {} else if (Object.keys(defs).length > 0) if (ctx.target === "draft-2020-12") result.$defs = defs;
	else result.definitions = defs;
	try {
		const finalized = JSON.parse(JSON.stringify(result));
		Object.defineProperty(finalized, "~standard", {
			value: {
				...schema["~standard"],
				jsonSchema: {
					input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
					output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
				}
			},
			enumerable: false,
			writable: false
		});
		return finalized;
	} catch (_err) {
		throw new Error("Error converting schema to JSON.");
	}
}
function isTransforming(_schema, _ctx) {
	const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
	if (ctx.seen.has(_schema)) return false;
	ctx.seen.add(_schema);
	const def = _schema._zod.def;
	if (def.type === "transform") return true;
	if (def.type === "array") return isTransforming(def.element, ctx);
	if (def.type === "set") return isTransforming(def.valueType, ctx);
	if (def.type === "lazy") return isTransforming(def.getter(), ctx);
	if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") return isTransforming(def.innerType, ctx);
	if (def.type === "intersection") return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
	if (def.type === "record" || def.type === "map") return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
	if (def.type === "pipe") return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
	if (def.type === "object") {
		for (const key in def.shape) if (isTransforming(def.shape[key], ctx)) return true;
		return false;
	}
	if (def.type === "union") {
		for (const option of def.options) if (isTransforming(option, ctx)) return true;
		return false;
	}
	if (def.type === "tuple") {
		for (const item of def.items) if (isTransforming(item, ctx)) return true;
		if (def.rest && isTransforming(def.rest, ctx)) return true;
		return false;
	}
	return false;
}
/**
* Creates a toJSONSchema method for a schema instance.
* This encapsulates the logic of initializing context, processing, extracting defs, and finalizing.
*/
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
	const ctx = initializeContext({
		...params,
		processors
	});
	process$7(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
	const { libraryOptions, target } = params ?? {};
	const ctx = initializeContext({
		...libraryOptions ?? {},
		target,
		io,
		processors
	});
	process$7(schema, ctx);
	extractDefs(ctx, schema);
	return finalize(ctx, schema);
};

//#endregion
//#region ../../node_modules/zod/v4/core/json-schema-processors.js
const formatMap = {
	guid: "uuid",
	url: "uri",
	datetime: "date-time",
	json_string: "json-string",
	regex: ""
};
const stringProcessor = (schema, ctx, _json, _params) => {
	const json = _json;
	json.type = "string";
	const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
	if (typeof minimum === "number") json.minLength = minimum;
	if (typeof maximum === "number") json.maxLength = maximum;
	if (format) {
		json.format = formatMap[format] ?? format;
		if (json.format === "") delete json.format;
		if (format === "time") delete json.format;
	}
	if (contentEncoding) json.contentEncoding = contentEncoding;
	if (patterns && patterns.size > 0) {
		const regexes = [...patterns];
		if (regexes.length === 1) json.pattern = regexes[0].source;
		else if (regexes.length > 1) json.allOf = [...regexes.map((regex) => ({
			...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
			pattern: regex.source
		}))];
	}
};
const numberProcessor = (schema, ctx, _json, _params) => {
	const json = _json;
	const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
	if (typeof format === "string" && format.includes("int")) json.type = "integer";
	else json.type = "number";
	if (typeof exclusiveMinimum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json.minimum = exclusiveMinimum;
		json.exclusiveMinimum = true;
	} else json.exclusiveMinimum = exclusiveMinimum;
	if (typeof minimum === "number") {
		json.minimum = minimum;
		if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") if (exclusiveMinimum >= minimum) delete json.minimum;
		else delete json.exclusiveMinimum;
	}
	if (typeof exclusiveMaximum === "number") if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
		json.maximum = exclusiveMaximum;
		json.exclusiveMaximum = true;
	} else json.exclusiveMaximum = exclusiveMaximum;
	if (typeof maximum === "number") {
		json.maximum = maximum;
		if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") if (exclusiveMaximum <= maximum) delete json.maximum;
		else delete json.exclusiveMaximum;
	}
	if (typeof multipleOf === "number") json.multipleOf = multipleOf;
};
const booleanProcessor = (_schema, _ctx, json, _params) => {
	json.type = "boolean";
};
const neverProcessor = (_schema, _ctx, json, _params) => {
	json.not = {};
};
const unknownProcessor = (_schema, _ctx, _json, _params) => {};
const enumProcessor = (schema, _ctx, json, _params) => {
	const def = schema._zod.def;
	const values = getEnumValues(def.entries);
	if (values.every((v) => typeof v === "number")) json.type = "number";
	if (values.every((v) => typeof v === "string")) json.type = "string";
	json.enum = values;
};
const customProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Custom types cannot be represented in JSON Schema");
};
const transformProcessor = (_schema, ctx, _json, _params) => {
	if (ctx.unrepresentable === "throw") throw new Error("Transforms cannot be represented in JSON Schema");
};
const arrayProcessor = (schema, ctx, _json, params) => {
	const json = _json;
	const def = schema._zod.def;
	const { minimum, maximum } = schema._zod.bag;
	if (typeof minimum === "number") json.minItems = minimum;
	if (typeof maximum === "number") json.maxItems = maximum;
	json.type = "array";
	json.items = process$7(def.element, ctx, {
		...params,
		path: [...params.path, "items"]
	});
};
const objectProcessor = (schema, ctx, _json, params) => {
	const json = _json;
	const def = schema._zod.def;
	json.type = "object";
	json.properties = {};
	const shape = def.shape;
	for (const key in shape) json.properties[key] = process$7(shape[key], ctx, {
		...params,
		path: [
			...params.path,
			"properties",
			key
		]
	});
	const allKeys = new Set(Object.keys(shape));
	const requiredKeys = new Set([...allKeys].filter((key) => {
		const v = def.shape[key]._zod;
		if (ctx.io === "input") return v.optin === void 0;
		else return v.optout === void 0;
	}));
	if (requiredKeys.size > 0) json.required = Array.from(requiredKeys);
	if (def.catchall?._zod.def.type === "never") json.additionalProperties = false;
	else if (!def.catchall) {
		if (ctx.io === "output") json.additionalProperties = false;
	} else if (def.catchall) json.additionalProperties = process$7(def.catchall, ctx, {
		...params,
		path: [...params.path, "additionalProperties"]
	});
};
const unionProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const isExclusive = def.inclusive === false;
	const options = def.options.map((x, i) => process$7(x, ctx, {
		...params,
		path: [
			...params.path,
			isExclusive ? "oneOf" : "anyOf",
			i
		]
	}));
	if (isExclusive) json.oneOf = options;
	else json.anyOf = options;
};
const intersectionProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const a = process$7(def.left, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			0
		]
	});
	const b = process$7(def.right, ctx, {
		...params,
		path: [
			...params.path,
			"allOf",
			1
		]
	});
	const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
	json.allOf = [...isSimpleIntersection(a) ? a.allOf : [a], ...isSimpleIntersection(b) ? b.allOf : [b]];
};
const nullableProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	const inner = process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	if (ctx.target === "openapi-3.0") {
		seen.ref = def.innerType;
		json.nullable = true;
	} else json.anyOf = [inner, { type: "null" }];
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	if (ctx.io === "input") json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	let catchValue;
	try {
		catchValue = def.catchValue(void 0);
	} catch {
		throw new Error("Dynamic catch values are not supported in JSON Schema");
	}
	json.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
	process$7(innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
	json.readOnly = true;
};
const optionalProcessor = (schema, ctx, _json, params) => {
	const def = schema._zod.def;
	process$7(def.innerType, ctx, params);
	const seen = ctx.seen.get(schema);
	seen.ref = def.innerType;
};

//#endregion
//#region ../../node_modules/zod/v4/classic/iso.js
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
	$ZodISODateTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function datetime(params) {
	return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
	$ZodISODate.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function date(params) {
	return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
	$ZodISOTime.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function time(params) {
	return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
	$ZodISODuration.init(inst, def);
	ZodStringFormat.init(inst, def);
});
function duration(params) {
	return _isoDuration(ZodISODuration, params);
}

//#endregion
//#region ../../node_modules/zod/v4/classic/errors.js
const initializer = (inst, issues) => {
	$ZodError.init(inst, issues);
	inst.name = "ZodError";
	Object.defineProperties(inst, {
		format: { value: (mapper) => formatError(inst, mapper) },
		flatten: { value: (mapper) => flattenError(inst, mapper) },
		addIssue: { value: (issue) => {
			inst.issues.push(issue);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		addIssues: { value: (issues) => {
			inst.issues.push(...issues);
			inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
		} },
		isEmpty: { get() {
			return inst.issues.length === 0;
		} }
	});
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });

//#endregion
//#region ../../node_modules/zod/v4/classic/parse.js
const parse = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

//#endregion
//#region ../../node_modules/zod/v4/classic/schemas.js
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
	$ZodType.init(inst, def);
	Object.assign(inst["~standard"], { jsonSchema: {
		input: createStandardJSONSchemaMethod(inst, "input"),
		output: createStandardJSONSchemaMethod(inst, "output")
	} });
	inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
	inst.def = def;
	inst.type = def.type;
	Object.defineProperty(inst, "_def", { value: def });
	inst.check = (...checks) => {
		return inst.clone(mergeDefs(def, { checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
			check: ch,
			def: { check: "custom" },
			onattach: []
		} } : ch)] }), { parent: true });
	};
	inst.with = inst.check;
	inst.clone = (def, params) => clone(inst, def, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta) => {
		reg.add(inst, meta);
		return inst;
	});
	inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
	inst.spa = inst.safeParseAsync;
	inst.encode = (data, params) => encode(inst, data, params);
	inst.decode = (data, params) => decode(inst, data, params);
	inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
	inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
	inst.safeEncode = (data, params) => safeEncode(inst, data, params);
	inst.safeDecode = (data, params) => safeDecode(inst, data, params);
	inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
	inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
	inst.refine = (check, params) => inst.check(refine(check, params));
	inst.superRefine = (refinement) => inst.check(superRefine(refinement));
	inst.overwrite = (fn) => inst.check(_overwrite(fn));
	inst.optional = () => optional(inst);
	inst.exactOptional = () => exactOptional(inst);
	inst.nullable = () => nullable(inst);
	inst.nullish = () => optional(nullable(inst));
	inst.nonoptional = (params) => nonoptional(inst, params);
	inst.array = () => array(inst);
	inst.or = (arg) => union([inst, arg]);
	inst.and = (arg) => intersection(inst, arg);
	inst.transform = (tx) => pipe(inst, transform(tx));
	inst.default = (def) => _default(inst, def);
	inst.prefault = (def) => prefault(inst, def);
	inst.catch = (params) => _catch(inst, params);
	inst.pipe = (target) => pipe(inst, target);
	inst.readonly = () => readonly(inst);
	inst.describe = (description) => {
		const cl = inst.clone();
		globalRegistry.add(cl, { description });
		return cl;
	};
	Object.defineProperty(inst, "description", {
		get() {
			return globalRegistry.get(inst)?.description;
		},
		configurable: true
	});
	inst.meta = (...args) => {
		if (args.length === 0) return globalRegistry.get(inst);
		const cl = inst.clone();
		globalRegistry.add(cl, args[0]);
		return cl;
	};
	inst.isOptional = () => inst.safeParse(void 0).success;
	inst.isNullable = () => inst.safeParse(null).success;
	inst.apply = (fn) => fn(inst);
	return inst;
});
/** @internal */
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
	const bag = inst._zod.bag;
	inst.format = bag.format ?? null;
	inst.minLength = bag.minimum ?? null;
	inst.maxLength = bag.maximum ?? null;
	inst.regex = (...args) => inst.check(_regex(...args));
	inst.includes = (...args) => inst.check(_includes(...args));
	inst.startsWith = (...args) => inst.check(_startsWith(...args));
	inst.endsWith = (...args) => inst.check(_endsWith(...args));
	inst.min = (...args) => inst.check(_minLength(...args));
	inst.max = (...args) => inst.check(_maxLength(...args));
	inst.length = (...args) => inst.check(_length(...args));
	inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
	inst.lowercase = (params) => inst.check(_lowercase(params));
	inst.uppercase = (params) => inst.check(_uppercase(params));
	inst.trim = () => inst.check(_trim());
	inst.normalize = (...args) => inst.check(_normalize(...args));
	inst.toLowerCase = () => inst.check(_toLowerCase());
	inst.toUpperCase = () => inst.check(_toUpperCase());
	inst.slugify = () => inst.check(_slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
	$ZodString.init(inst, def);
	_ZodString.init(inst, def);
	inst.email = (params) => inst.check(_email(ZodEmail, params));
	inst.url = (params) => inst.check(_url(ZodURL, params));
	inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
	inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
	inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
	inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
	inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
	inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
	inst.guid = (params) => inst.check(_guid(ZodGUID, params));
	inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
	inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
	inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
	inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
	inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
	inst.xid = (params) => inst.check(_xid(ZodXID, params));
	inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
	inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
	inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
	inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
	inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
	inst.e164 = (params) => inst.check(_e164(ZodE164, params));
	inst.datetime = (params) => inst.check(datetime(params));
	inst.date = (params) => inst.check(date(params));
	inst.time = (params) => inst.check(time(params));
	inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
	return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
	$ZodStringFormat.init(inst, def);
	_ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
	$ZodEmail.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
	$ZodGUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
	$ZodUUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
	$ZodURL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
	$ZodEmoji.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
	$ZodNanoID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
	$ZodCUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
	$ZodCUID2.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
	$ZodULID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
	$ZodXID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
	$ZodKSUID.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
	$ZodIPv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
	$ZodIPv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
	$ZodCIDRv4.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
	$ZodCIDRv6.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
	$ZodBase64.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
	$ZodBase64URL.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
	$ZodE164.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
	$ZodJWT.init(inst, def);
	ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
	inst.gt = (value, params) => inst.check(_gt(value, params));
	inst.gte = (value, params) => inst.check(_gte(value, params));
	inst.min = (value, params) => inst.check(_gte(value, params));
	inst.lt = (value, params) => inst.check(_lt(value, params));
	inst.lte = (value, params) => inst.check(_lte(value, params));
	inst.max = (value, params) => inst.check(_lte(value, params));
	inst.int = (params) => inst.check(int(params));
	inst.safe = (params) => inst.check(int(params));
	inst.positive = (params) => inst.check(_gt(0, params));
	inst.nonnegative = (params) => inst.check(_gte(0, params));
	inst.negative = (params) => inst.check(_lt(0, params));
	inst.nonpositive = (params) => inst.check(_lte(0, params));
	inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
	inst.step = (value, params) => inst.check(_multipleOf(value, params));
	inst.finite = () => inst;
	const bag = inst._zod.bag;
	inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
	inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
	inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
	inst.isFinite = true;
	inst.format = bag.format ?? null;
});
function number(params) {
	return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
	$ZodNumberFormat.init(inst, def);
	ZodNumber.init(inst, def);
});
function int(params) {
	return _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
	$ZodBoolean.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
});
function boolean(params) {
	return _boolean(ZodBoolean, params);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
	return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
	$ZodNever.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never$1(params) {
	return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
	inst.element = def.element;
	inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
	inst.nonempty = (params) => inst.check(_minLength(1, params));
	inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
	inst.length = (len, params) => inst.check(_length(len, params));
	inst.unwrap = () => inst.element;
});
function array(element, params) {
	return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
	$ZodObjectJIT.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
	defineLazy(inst, "shape", () => {
		return def.shape;
	});
	inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
	inst.catchall = (catchall) => inst.clone({
		...inst._zod.def,
		catchall
	});
	inst.passthrough = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.loose = () => inst.clone({
		...inst._zod.def,
		catchall: unknown()
	});
	inst.strict = () => inst.clone({
		...inst._zod.def,
		catchall: never$1()
	});
	inst.strip = () => inst.clone({
		...inst._zod.def,
		catchall: void 0
	});
	inst.extend = (incoming) => {
		return extend(inst, incoming);
	};
	inst.safeExtend = (incoming) => {
		return safeExtend(inst, incoming);
	};
	inst.merge = (other) => merge(inst, other);
	inst.pick = (mask) => pick$1(inst, mask);
	inst.omit = (mask) => omit(inst, mask);
	inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
	inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
	return new ZodObject({
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	});
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
	inst.options = def.options;
});
function union(options, params) {
	return new ZodUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
	$ZodIntersection.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
	return new ZodIntersection({
		type: "intersection",
		left,
		right
	});
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
	$ZodEnum.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
	inst.enum = def.entries;
	inst.options = Object.values(def.entries);
	const keys = new Set(Object.keys(def.entries));
	inst.extract = (values, params) => {
		const newEntries = {};
		for (const value of values) if (keys.has(value)) newEntries[value] = def.entries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
	inst.exclude = (values, params) => {
		const newEntries = { ...def.entries };
		for (const value of values) if (keys.has(value)) delete newEntries[value];
		else throw new Error(`Key ${value} not found in enum`);
		return new ZodEnum({
			...def,
			checks: [],
			...normalizeParams(params),
			entries: newEntries
		});
	};
});
function _enum(values, params) {
	return new ZodEnum({
		type: "enum",
		entries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,
		...normalizeParams(params)
	});
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
	$ZodTransform.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
	inst._zod.parse = (payload, _ctx) => {
		if (_ctx.direction === "backward") throw new $ZodEncodeError(inst.constructor.name);
		payload.addIssue = (issue$1) => {
			if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def));
			else {
				const _issue = issue$1;
				if (_issue.fatal) _issue.continue = false;
				_issue.code ?? (_issue.code = "custom");
				_issue.input ?? (_issue.input = payload.value);
				_issue.inst ?? (_issue.inst = inst);
				payload.issues.push(issue(_issue));
			}
		};
		const output = def.transform(payload.value, payload);
		if (output instanceof Promise) return output.then((output) => {
			payload.value = output;
			return payload;
		});
		payload.value = output;
		return payload;
	};
});
function transform(fn) {
	return new ZodTransform({
		type: "transform",
		transform: fn
	});
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
	return new ZodOptional({
		type: "optional",
		innerType
	});
}
const ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
	$ZodExactOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
	return new ZodExactOptional({
		type: "optional",
		innerType
	});
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
	$ZodNullable.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
	return new ZodNullable({
		type: "nullable",
		innerType
	});
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
	$ZodDefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
	return new ZodDefault({
		type: "default",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
	$ZodPrefault.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
	return new ZodPrefault({
		type: "prefault",
		innerType,
		get defaultValue() {
			return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
		}
	});
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
	$ZodNonOptional.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
	return new ZodNonOptional({
		type: "nonoptional",
		innerType,
		...normalizeParams(params)
	});
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
	$ZodCatch.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
	inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
	return new ZodCatch({
		type: "catch",
		innerType,
		catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
	});
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
	$ZodPipe.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
	inst.in = def.in;
	inst.out = def.out;
});
function pipe(in_, out) {
	return new ZodPipe({
		type: "pipe",
		in: in_,
		out
	});
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
	$ZodReadonly.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
	inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
	return new ZodReadonly({
		type: "readonly",
		innerType
	});
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
	$ZodCustom.init(inst, def);
	ZodType.init(inst, def);
	inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function refine(fn, _params = {}) {
	return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
	return _superRefine(fn);
}
const describe = describe$1;
const meta = meta$1;

//#endregion
//#region src/mcp-server.ts
function createMcpServer(deps) {
	const { wss, questionQueue, pendingAnswers, currentLifecycleState, broadcast } = deps;
	const server = new _modelcontextprotocol_sdk_server_mcp_js.McpServer({
		name: "maxsim-dashboard",
		version: "1.0.0"
	});
	server.tool("ask_question", "Present a question to the dashboard user and wait for their answer", {
		question: string(),
		options: array(object({
			value: string(),
			label: string(),
			description: string().optional()
		})).optional(),
		allow_free_text: boolean().default(true)
	}, async ({ question, options, allow_free_text }) => {
		const questionId = (0, node_crypto.randomUUID)();
		const pending = {
			id: questionId,
			question,
			options: options ?? [],
			allowFreeText: allow_free_text,
			receivedAt: Date.now()
		};
		questionQueue.push(pending);
		broadcast(wss, {
			type: "question-received",
			question: pending,
			queueLength: questionQueue.length
		});
		const answer = await new Promise((resolve) => {
			pendingAnswers.set(questionId, resolve);
		});
		const idx = questionQueue.findIndex((q) => q.id === questionId);
		if (idx !== -1) questionQueue.splice(idx, 1);
		broadcast(wss, {
			type: "answer-given",
			questionId,
			remainingQueue: questionQueue.length
		});
		return { content: [{
			type: "text",
			text: answer
		}] };
	});
	server.tool("submit_lifecycle_event", "Broadcast a workflow lifecycle event to connected dashboard clients", {
		event_type: _enum([
			"phase-started",
			"phase-complete",
			"plan-started",
			"plan-complete"
		]),
		phase_name: string(),
		phase_number: string(),
		step: number().optional(),
		total_steps: number().optional()
	}, async ({ event_type, phase_name, phase_number, step, total_steps }) => {
		const event = {
			event_type,
			phase_name,
			phase_number,
			step: step ?? null,
			total_steps: total_steps ?? null,
			timestamp: Date.now()
		};
		currentLifecycleState.value = event;
		broadcast(wss, {
			type: "lifecycle",
			event
		});
		return { content: [{
			type: "text",
			text: `Event recorded: ${event_type} for Phase ${phase_number} (${phase_name})`
		}] };
	});
	server.tool("get_phase_status", "Get current question queue length and lifecycle state", {}, async () => {
		const status = {
			pendingQuestions: questionQueue.length,
			questions: questionQueue.map((q) => ({
				id: q.id,
				question: q.question,
				receivedAt: q.receivedAt
			})),
			lifecycleState: currentLifecycleState.value
		};
		return { content: [{
			type: "text",
			text: JSON.stringify(status, null, 2)
		}] };
	});
	return server;
}

//#endregion
//#region ../../node_modules/address/dist/esm/address.js
function getDefaultInterfaceName() {
	let val = "eth";
	const platform = node_os.default.platform();
	if (platform === "darwin") val = "en";
	else if (platform === "win32") val = void 0;
	return val;
}
function matchName(actualFamily, expectedFamily) {
	if (expectedFamily === "IPv4") return actualFamily === "IPv4" || actualFamily === 4;
	if (expectedFamily === "IPv6") return actualFamily === "IPv6" || actualFamily === 6;
	return actualFamily === expectedFamily;
}
function findAddressFromInterface(items, expectedFamily, ignoreLoAddress = false) {
	let firstMatchItem;
	for (const item of items) if (matchName(item.family, expectedFamily)) {
		if (ignoreLoAddress && item.address.startsWith("127.")) continue;
		if (expectedFamily === "IPv6") {
			if (item.scopeid === 0) return item;
			if (!firstMatchItem) firstMatchItem = item;
		} else return item;
	}
	return firstMatchItem;
}
function getInterfaceAddress(family, name) {
	const interfaces = node_os.default.networkInterfaces();
	const noName = !name;
	name = name || getDefaultInterfaceName();
	family = family || "IPv4";
	if (name) for (let i = -1; i < 8; i++) {
		const items = interfaces[name + (i >= 0 ? i : "")];
		if (items) {
			const item = findAddressFromInterface(items, family);
			if (item) return item;
		}
	}
	if (noName) for (const k in interfaces) {
		const items = interfaces[k];
		if (items) {
			const item = findAddressFromInterface(items, family, true);
			if (item) return item;
		}
	}
}
/**
* Get current machine IPv4
*
* interfaceName: interface name, default is 'eth' on linux, 'en' on mac os.
*/
function ip(interfaceName) {
	return getInterfaceAddress("IPv4", interfaceName)?.address;
}

//#endregion
//#region ../../node_modules/detect-port/dist/esm/detect-port.js
const debug$2 = (0, node_util.debuglog)("detect-port");
var IPAddressNotAvailableError = class extends Error {
	constructor(options) {
		super("The IP address is not available on this machine", options);
		this.name = this.constructor.name;
		Error.captureStackTrace(this, this.constructor);
	}
};
function detectPort(port, callback) {
	let hostname = "";
	if (port && typeof port === "object") {
		hostname = port.hostname;
		callback = port.callback;
		port = port.port;
	} else if (typeof port === "function") {
		callback = port;
		port = void 0;
	}
	port = parseInt(port) || 0;
	let maxPort = port + 10;
	if (maxPort > 65535) maxPort = 65535;
	debug$2("detect free port between [%s, %s)", port, maxPort);
	if (typeof callback === "function") return tryListen(port, maxPort, hostname).then((port) => callback(null, port)).catch(callback);
	return tryListen(port, maxPort, hostname);
}
async function handleError(port, maxPort, hostname) {
	if (port >= maxPort) {
		debug$2("port: %s >= maxPort: %s, give up and use random port", port, maxPort);
		port = 0;
		maxPort = 0;
	}
	return await tryListen(port, maxPort, hostname);
}
async function tryListen(port, maxPort, hostname) {
	if (hostname) try {
		return await listen(port, hostname);
	} catch (err) {
		if (err.code === "EADDRNOTAVAIL") throw new IPAddressNotAvailableError({ cause: err });
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port);
	} catch (err) {
		if (port === 0) throw err;
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "0.0.0.0");
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "127.0.0.1");
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
	try {
		await listen(port, "localhost");
	} catch (err) {
		if (err.code !== "EADDRNOTAVAIL") return await handleError(++port, maxPort, hostname);
	}
	try {
		return await listen(port, ip());
	} catch (err) {
		return await handleError(++port, maxPort, hostname);
	}
}
function listen(port, hostname) {
	const server = (0, node_net.createServer)();
	return new Promise((resolve, reject) => {
		server.once("error", (err) => {
			debug$2("listen %s:%s error: %s", hostname, port, err);
			server.close();
			if (err.code === "ENOTFOUND") {
				debug$2("ignore dns ENOTFOUND error, get free %s:%s", hostname, port);
				return resolve(port);
			}
			return reject(err);
		});
		debug$2("try listen %d on %s", port, hostname);
		server.listen(port, hostname, () => {
			port = server.address().port;
			debug$2("get free %s:%s", hostname, port);
			server.close();
			return resolve(port);
		});
	});
}

//#endregion
//#region ../../node_modules/detect-port/dist/esm/wait-port.js
const debug$1 = (0, node_util.debuglog)("detect-port:wait-port");

//#endregion
//#region ../../node_modules/detect-port/dist/esm/index.js
var esm_default = detectPort;

//#endregion
//#region ../../node_modules/is-docker/index.js
let isDockerCached;
function hasDockerEnv() {
	try {
		node_fs.default.statSync("/.dockerenv");
		return true;
	} catch {
		return false;
	}
}
function hasDockerCGroup() {
	try {
		return node_fs.default.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
	} catch {
		return false;
	}
}
function isDocker() {
	if (isDockerCached === void 0) isDockerCached = hasDockerEnv() || hasDockerCGroup();
	return isDockerCached;
}

//#endregion
//#region ../../node_modules/is-inside-container/index.js
let cachedResult;
const hasContainerEnv = () => {
	try {
		node_fs.default.statSync("/run/.containerenv");
		return true;
	} catch {
		return false;
	}
};
function isInsideContainer() {
	if (cachedResult === void 0) cachedResult = hasContainerEnv() || isDocker();
	return cachedResult;
}

//#endregion
//#region ../../node_modules/is-wsl/index.js
const isWsl = () => {
	if (node_process.default.platform !== "linux") return false;
	if (node_os.default.release().toLowerCase().includes("microsoft")) {
		if (isInsideContainer()) return false;
		return true;
	}
	try {
		if (node_fs.default.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft")) return !isInsideContainer();
	} catch {}
	if (node_fs.default.existsSync("/proc/sys/fs/binfmt_misc/WSLInterop") || node_fs.default.existsSync("/run/WSL")) return !isInsideContainer();
	return false;
};
var is_wsl_default = node_process.default.env.__IS_WSL_TEST__ ? isWsl : isWsl();

//#endregion
//#region ../../node_modules/wsl-utils/index.js
const wslDrivesMountPoint = (() => {
	const defaultMountPoint = "/mnt/";
	let mountPoint;
	return async function() {
		if (mountPoint) return mountPoint;
		const configFilePath = "/etc/wsl.conf";
		let isConfigFileExists = false;
		try {
			await node_fs_promises.default.access(configFilePath, node_fs_promises.constants.F_OK);
			isConfigFileExists = true;
		} catch {}
		if (!isConfigFileExists) return defaultMountPoint;
		const configContent = await node_fs_promises.default.readFile(configFilePath, { encoding: "utf8" });
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
		if (!configMountPoint) return defaultMountPoint;
		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
		return mountPoint;
	};
})();
const powerShellPathFromWsl = async () => {
	return `${await wslDrivesMountPoint()}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
const powerShellPath = async () => {
	if (is_wsl_default) return powerShellPathFromWsl();
	return `${node_process.default.env.SYSTEMROOT || node_process.default.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
};

//#endregion
//#region ../../node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
	const define = (value) => Object.defineProperty(object, propertyName, {
		value,
		enumerable: true,
		writable: true
	});
	Object.defineProperty(object, propertyName, {
		configurable: true,
		enumerable: true,
		get() {
			const result = valueGetter();
			define(result);
			return result;
		},
		set(value) {
			define(value);
		}
	});
	return object;
}

//#endregion
//#region ../../node_modules/default-browser-id/index.js
const execFileAsync$3 = (0, node_util.promisify)(node_child_process.execFile);
async function defaultBrowserId() {
	if (node_process.default.platform !== "darwin") throw new Error("macOS only");
	const { stdout } = await execFileAsync$3("defaults", [
		"read",
		"com.apple.LaunchServices/com.apple.launchservices.secure",
		"LSHandlers"
	]);
	const browserId = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout)?.groups.id ?? "com.apple.Safari";
	if (browserId === "com.apple.safari") return "com.apple.Safari";
	return browserId;
}

//#endregion
//#region ../../node_modules/run-applescript/index.js
const execFileAsync$2 = (0, node_util.promisify)(node_child_process.execFile);
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
	if (node_process.default.platform !== "darwin") throw new Error("macOS only");
	const outputArguments = humanReadableOutput ? [] : ["-ss"];
	const execOptions = {};
	if (signal) execOptions.signal = signal;
	const { stdout } = await execFileAsync$2("osascript", [
		"-e",
		script,
		outputArguments
	], execOptions);
	return stdout.trim();
}

//#endregion
//#region ../../node_modules/bundle-name/index.js
async function bundleName(bundleId) {
	return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

//#endregion
//#region ../../node_modules/default-browser/windows.js
const execFileAsync$1 = (0, node_util.promisify)(node_child_process.execFile);
const windowsBrowserProgIds = {
	MSEdgeHTM: {
		name: "Edge",
		id: "com.microsoft.edge"
	},
	MSEdgeBHTML: {
		name: "Edge Beta",
		id: "com.microsoft.edge.beta"
	},
	MSEdgeDHTML: {
		name: "Edge Dev",
		id: "com.microsoft.edge.dev"
	},
	AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
		name: "Edge",
		id: "com.microsoft.edge.old"
	},
	ChromeHTML: {
		name: "Chrome",
		id: "com.google.chrome"
	},
	ChromeBHTML: {
		name: "Chrome Beta",
		id: "com.google.chrome.beta"
	},
	ChromeDHTML: {
		name: "Chrome Dev",
		id: "com.google.chrome.dev"
	},
	ChromiumHTM: {
		name: "Chromium",
		id: "org.chromium.Chromium"
	},
	BraveHTML: {
		name: "Brave",
		id: "com.brave.Browser"
	},
	BraveBHTML: {
		name: "Brave Beta",
		id: "com.brave.Browser.beta"
	},
	BraveDHTML: {
		name: "Brave Dev",
		id: "com.brave.Browser.dev"
	},
	BraveSSHTM: {
		name: "Brave Nightly",
		id: "com.brave.Browser.nightly"
	},
	FirefoxURL: {
		name: "Firefox",
		id: "org.mozilla.firefox"
	},
	OperaStable: {
		name: "Opera",
		id: "com.operasoftware.Opera"
	},
	VivaldiHTM: {
		name: "Vivaldi",
		id: "com.vivaldi.Vivaldi"
	},
	"IE.HTTP": {
		name: "Internet Explorer",
		id: "com.microsoft.ie"
	}
};
const _windowsBrowserProgIdMap = new Map(Object.entries(windowsBrowserProgIds));
var UnknownBrowserError = class extends Error {};
async function defaultBrowser$1(_execFileAsync = execFileAsync$1) {
	const { stdout } = await _execFileAsync("reg", [
		"QUERY",
		" HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
		"/v",
		"ProgId"
	]);
	const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
	if (!match) throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
	const { id } = match.groups;
	const dotIndex = id.lastIndexOf(".");
	const hyphenIndex = id.lastIndexOf("-");
	const baseIdByDot = dotIndex === -1 ? void 0 : id.slice(0, dotIndex);
	const baseIdByHyphen = hyphenIndex === -1 ? void 0 : id.slice(0, hyphenIndex);
	return windowsBrowserProgIds[id] ?? windowsBrowserProgIds[baseIdByDot] ?? windowsBrowserProgIds[baseIdByHyphen] ?? {
		name: id,
		id
	};
}

//#endregion
//#region ../../node_modules/default-browser/index.js
const execFileAsync = (0, node_util.promisify)(node_child_process.execFile);
const titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser() {
	if (node_process.default.platform === "darwin") {
		const id = await defaultBrowserId();
		return {
			name: await bundleName(id),
			id
		};
	}
	if (node_process.default.platform === "linux") {
		const { stdout } = await execFileAsync("xdg-mime", [
			"query",
			"default",
			"x-scheme-handler/http"
		]);
		const id = stdout.trim();
		return {
			name: titleize(id.replace(/.desktop$/, "").replace("-", " ")),
			id
		};
	}
	if (node_process.default.platform === "win32") return defaultBrowser$1();
	throw new Error("Only macOS, Linux, and Windows are supported");
}

//#endregion
//#region ../../node_modules/open/index.js
const execFile = (0, node_util.promisify)(node_child_process.default.execFile);
const __dirname$1 = node_path.default.dirname((0, node_url.fileURLToPath)(require("url").pathToFileURL(__filename).href));
const localXdgOpenPath = node_path.default.join(__dirname$1, "xdg-open");
const { platform, arch } = node_process.default;
/**
Get the default browser name in Windows from WSL.

@returns {Promise<string>} Browser name.
*/
async function getWindowsDefaultBrowserFromWsl() {
	const powershellPath = await powerShellPath();
	const rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
	const { stdout } = await execFile(powershellPath, [
		"-NoProfile",
		"-NonInteractive",
		"-ExecutionPolicy",
		"Bypass",
		"-EncodedCommand",
		node_buffer.Buffer.from(rawCommand, "utf16le").toString("base64")
	], { encoding: "utf8" });
	const progId = stdout.trim();
	const browserMap = {
		ChromeHTML: "com.google.chrome",
		BraveHTML: "com.brave.Browser",
		MSEdgeHTM: "com.microsoft.edge",
		FirefoxURL: "org.mozilla.firefox"
	};
	return browserMap[progId] ? { id: browserMap[progId] } : {};
}
const pTryEach = async (array, mapper) => {
	let latestError;
	for (const item of array) try {
		return await mapper(item);
	} catch (error) {
		latestError = error;
	}
	throw latestError;
};
const baseOpen = async (options) => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options
	};
	if (Array.isArray(options.app)) return pTryEach(options.app, (singleApp) => baseOpen({
		...options,
		app: singleApp
	}));
	let { name: app, arguments: appArguments = [] } = options.app ?? {};
	appArguments = [...appArguments];
	if (Array.isArray(app)) return pTryEach(app, (appName) => baseOpen({
		...options,
		app: {
			name: appName,
			arguments: appArguments
		}
	}));
	if (app === "browser" || app === "browserPrivate") {
		const ids = {
			"com.google.chrome": "chrome",
			"google-chrome.desktop": "chrome",
			"com.brave.Browser": "brave",
			"org.mozilla.firefox": "firefox",
			"firefox.desktop": "firefox",
			"com.microsoft.msedge": "edge",
			"com.microsoft.edge": "edge",
			"com.microsoft.edgemac": "edge",
			"microsoft-edge.desktop": "edge"
		};
		const flags = {
			chrome: "--incognito",
			brave: "--incognito",
			firefox: "--private-window",
			edge: "--inPrivate"
		};
		const browser = is_wsl_default ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser();
		if (browser.id in ids) {
			const browserName = ids[browser.id];
			if (app === "browserPrivate") appArguments.push(flags[browserName]);
			return baseOpen({
				...options,
				app: {
					name: apps[browserName],
					arguments: appArguments
				}
			});
		}
		throw new Error(`${browser.name} is not supported as a default browser`);
	}
	let command;
	const cliArguments = [];
	const childProcessOptions = {};
	if (platform === "darwin") {
		command = "open";
		if (options.wait) cliArguments.push("--wait-apps");
		if (options.background) cliArguments.push("--background");
		if (options.newInstance) cliArguments.push("--new");
		if (app) cliArguments.push("-a", app);
	} else if (platform === "win32" || is_wsl_default && !isInsideContainer() && !app) {
		command = await powerShellPath();
		cliArguments.push("-NoProfile", "-NonInteractive", "-ExecutionPolicy", "Bypass", "-EncodedCommand");
		if (!is_wsl_default) childProcessOptions.windowsVerbatimArguments = true;
		const encodedArguments = ["Start"];
		if (options.wait) encodedArguments.push("-Wait");
		if (app) {
			encodedArguments.push(`"\`"${app}\`""`);
			if (options.target) appArguments.push(options.target);
		} else if (options.target) encodedArguments.push(`"${options.target}"`);
		if (appArguments.length > 0) {
			appArguments = appArguments.map((argument) => `"\`"${argument}\`""`);
			encodedArguments.push("-ArgumentList", appArguments.join(","));
		}
		options.target = node_buffer.Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
	} else {
		if (app) command = app;
		else {
			const isBundled = !__dirname$1 || __dirname$1 === "/";
			let exeLocalXdgOpen = false;
			try {
				await node_fs_promises.default.access(localXdgOpenPath, node_fs_promises.constants.X_OK);
				exeLocalXdgOpen = true;
			} catch {}
			command = node_process.default.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen) ? "xdg-open" : localXdgOpenPath;
		}
		if (appArguments.length > 0) cliArguments.push(...appArguments);
		if (!options.wait) {
			childProcessOptions.stdio = "ignore";
			childProcessOptions.detached = true;
		}
	}
	if (platform === "darwin" && appArguments.length > 0) cliArguments.push("--args", ...appArguments);
	if (options.target) cliArguments.push(options.target);
	const subprocess = node_child_process.default.spawn(command, cliArguments, childProcessOptions);
	if (options.wait) return new Promise((resolve, reject) => {
		subprocess.once("error", reject);
		subprocess.once("close", (exitCode) => {
			if (!options.allowNonzeroExitCode && exitCode > 0) {
				reject(/* @__PURE__ */ new Error(`Exited with code ${exitCode}`));
				return;
			}
			resolve(subprocess);
		});
	});
	subprocess.unref();
	return subprocess;
};
const open$1 = (target, options) => {
	if (typeof target !== "string") throw new TypeError("Expected a `target`");
	return baseOpen({
		...options,
		target
	});
};
function detectArchBinary(binary) {
	if (typeof binary === "string" || Array.isArray(binary)) return binary;
	const { [arch]: archBinary } = binary;
	if (!archBinary) throw new Error(`${arch} is not supported`);
	return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
	if (wsl && is_wsl_default) return detectArchBinary(wsl);
	if (!platformBinary) throw new Error(`${platform} is not supported`);
	return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
	darwin: "google chrome",
	win32: "chrome",
	linux: [
		"google-chrome",
		"google-chrome-stable",
		"chromium"
	]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
	x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
} }));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
	darwin: "brave browser",
	win32: "brave",
	linux: ["brave-browser", "brave"]
}, { wsl: {
	ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
	x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
} }));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
	darwin: "firefox",
	win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
	linux: "firefox"
}, { wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe" }));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
	darwin: "microsoft edge",
	win32: "msedge",
	linux: ["microsoft-edge", "microsoft-edge-dev"]
}, { wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" }));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");

//#endregion
//#region ../../node_modules/debug/src/common.js
var require_common = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug(...args) {
				if (!debug.enabled) return;
				const self = debug;
				const curr = Number(/* @__PURE__ */ new Date());
				self.diff = curr - (prevTime || curr);
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self, args);
				(self.log || createDebug.log).apply(self, args);
			}
			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy;
			Object.defineProperty(debug, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug);
			return debug;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}));

//#endregion
//#region ../../node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}));

//#endregion
//#region ../../node_modules/has-flag/index.js
var require_has_flag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
}));

//#endregion
//#region ../../node_modules/supports-color/index.js
var require_supports_color = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const os$4 = require("os");
	const tty$1 = require("tty");
	const hasFlag = require_has_flag();
	const { env } = process;
	let forceColor;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) forceColor = 0;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) forceColor = 1;
	if ("FORCE_COLOR" in env) if (env.FORCE_COLOR === "true") forceColor = 1;
	else if (env.FORCE_COLOR === "false") forceColor = 0;
	else forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	function translateLevel(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) return 0;
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
		if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
		const min = forceColor || 0;
		if (env.TERM === "dumb") return min;
		if (process.platform === "win32") {
			const osRelease = os$4.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE"
			].some((sign) => sign in env) || env.CI_NAME === "codeship") return 1;
			return min;
		}
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if (env.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
		if ("COLORTERM" in env) return 1;
		return min;
	}
	function getSupportLevel(stream) {
		return translateLevel(supportsColor(stream, stream && stream.isTTY));
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty$1.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty$1.isatty(2)))
	};
}));

//#endregion
//#region ../../node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty = require("tty");
	const util = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = require_supports_color();
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		const { namespace: name, useColors } = this;
		if (useColors) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log(...args) {
		return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug) {
		debug.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts);
	};
}));

//#endregion
//#region ../../node_modules/debug/src/index.js
var require_src$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node();
}));

//#endregion
//#region ../../node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	const fs_1 = require("fs");
	const log = __importDefault(require_src$1()).default("@kwsites/file-exists");
	function check(path, isFile, isDirectory) {
		log(`checking %s`, path);
		try {
			const stat = fs_1.statSync(path);
			if (stat.isFile() && isFile) {
				log(`[OK] path represents a file`);
				return true;
			}
			if (stat.isDirectory() && isDirectory) {
				log(`[OK] path represents a directory`);
				return true;
			}
			log(`[FAIL] path represents something other than a file or directory`);
			return false;
		} catch (e) {
			if (e.code === "ENOENT") {
				log(`[FAIL] path is not accessible: %o`, e);
				return false;
			}
			log(`[FATAL] %o`, e);
			throw e;
		}
	}
	/**
	* Synchronous validation of a path existing either as a file or as a directory.
	*
	* @param {string} path The path to check
	* @param {number} type One or both of the exported numeric constants
	*/
	function exists(path, type = exports.READABLE) {
		return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
	}
	exports.exists = exists;
	/**
	* Constant representing a file
	*/
	exports.FILE = 1;
	/**
	* Constant representing a folder
	*/
	exports.FOLDER = 2;
	/**
	* Constant representing either a file or a folder
	*/
	exports.READABLE = exports.FILE + exports.FOLDER;
}));

//#endregion
//#region ../../node_modules/@kwsites/file-exists/dist/index.js
var require_dist$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	function __export(m) {
		for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(require_src());
}));

//#endregion
//#region ../../node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDeferred = exports.deferred = void 0;
	/**
	* Creates a new `DeferredPromise`
	*
	* ```typescript
	import {deferred} from '@kwsites/promise-deferred`;
	```
	*/
	function deferred() {
		let done;
		let fail;
		let status = "pending";
		return {
			promise: new Promise((_done, _fail) => {
				done = _done;
				fail = _fail;
			}),
			done(result) {
				if (status === "pending") {
					status = "resolved";
					done(result);
				}
			},
			fail(error) {
				if (status === "pending") {
					status = "rejected";
					fail(error);
				}
			},
			get fulfilled() {
				return status !== "pending";
			},
			get status() {
				return status;
			}
		};
	}
	exports.deferred = deferred;
	/**
	* Alias of the exported `deferred` function, to help consumers wanting to use `deferred` as the
	* local variable name rather than the factory import name, without needing to rename on import.
	*
	* ```typescript
	import {createDeferred} from '@kwsites/promise-deferred`;
	```
	*/
	exports.createDeferred = deferred;
}));

//#endregion
//#region ../../node_modules/simple-git/dist/esm/index.js
var import_dist$1 = require_dist$2();
var import_src = /* @__PURE__ */ __toESM(require_src$1(), 1);
var import_dist$2 = require_dist$1();
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
	return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
function pathspec(...paths) {
	const key = new String(paths);
	cache.set(key, paths);
	return key;
}
function isPathSpec(path) {
	return path instanceof String && cache.has(path);
}
var cache;
var init_pathspec = __esm({ "src/lib/args/pathspec.ts"() {
	"use strict";
	cache = /* @__PURE__ */ new WeakMap();
} });
var GitError;
var init_git_error = __esm({ "src/lib/errors/git-error.ts"() {
	"use strict";
	GitError = class extends Error {
		constructor(task, message) {
			super(message);
			this.task = task;
			Object.setPrototypeOf(this, new.target.prototype);
		}
	};
} });
var GitResponseError;
var init_git_response_error = __esm({ "src/lib/errors/git-response-error.ts"() {
	"use strict";
	init_git_error();
	GitResponseError = class extends GitError {
		constructor(git, message) {
			super(void 0, message || String(git));
			this.git = git;
		}
	};
} });
var TaskConfigurationError;
var init_task_configuration_error = __esm({ "src/lib/errors/task-configuration-error.ts"() {
	"use strict";
	init_git_error();
	TaskConfigurationError = class extends GitError {
		constructor(message) {
			super(void 0, message);
		}
	};
} });
function asFunction(source) {
	if (typeof source !== "function") return NOOP;
	return source;
}
function isUserFunction(source) {
	return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
	const index = input.indexOf(char);
	if (index <= 0) return [input, ""];
	return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
	return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
	if (isArrayLike(input) && input.length > offset) return input[input.length - 1 - offset];
}
function isArrayLike(input) {
	return filterHasLength(input);
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
	return input.split(separator).reduce((output, line) => {
		const lineContent = trimmed2 ? line.trim() : line;
		if (lineContent) output.push(lineContent);
		return output;
	}, []);
}
function forEachLineWithContent(input, callback) {
	return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
	return (0, import_dist$1.exists)(path, import_dist$1.FOLDER);
}
function append(target, item) {
	if (Array.isArray(target)) {
		if (!target.includes(item)) target.push(item);
	} else target.add(item);
	return item;
}
function including(target, item) {
	if (Array.isArray(target) && !target.includes(item)) target.push(item);
	return target;
}
function remove(target, item) {
	if (Array.isArray(target)) {
		const index = target.indexOf(item);
		if (index >= 0) target.splice(index, 1);
	} else target.delete(item);
	return item;
}
function asArray(source) {
	return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
	return str.replace(/[\s-]+(.)/g, (_all, chr) => {
		return chr.toUpperCase();
	});
}
function asStringArray(source) {
	return asArray(source).map((item) => {
		return item instanceof String ? item : String(item);
	});
}
function asNumber(source, onNaN = 0) {
	if (source == null) return onNaN;
	const num = parseInt(source, 10);
	return Number.isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
	const output = [];
	for (let i = 0, max = input.length; i < max; i++) output.push(prefix, input[i]);
	return output;
}
function bufferToString(input) {
	return (Array.isArray(input) ? node_buffer.Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
	const out = {};
	properties.forEach((key) => {
		if (source[key] !== void 0) out[key] = source[key];
	});
	return out;
}
function delay(duration = 0) {
	return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
	if (input === false) return;
	return input;
}
var NULL, NOOP, objectToString;
var init_util = __esm({ "src/lib/utils/util.ts"() {
	"use strict";
	init_argument_filters();
	NULL = "\0";
	NOOP = () => {};
	objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
} });
function filterType(input, filter, def) {
	if (filter(input)) return input;
	return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
	const type = isPathSpec(input) ? "string" : typeof input;
	return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
	return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
	return typeof input === "function";
}
var filterArray, filterNumber, filterString, filterStringOrStringArray, filterHasLength;
var init_argument_filters = __esm({ "src/lib/utils/argument-filters.ts"() {
	"use strict";
	init_pathspec();
	init_util();
	filterArray = (input) => {
		return Array.isArray(input);
	};
	filterNumber = (input) => {
		return typeof input === "number";
	};
	filterString = (input) => {
		return typeof input === "string";
	};
	filterStringOrStringArray = (input) => {
		return filterString(input) || Array.isArray(input) && input.every(filterString);
	};
	filterHasLength = (input) => {
		if (input == null || "number|boolean|function".includes(typeof input)) return false;
		return typeof input.length === "number";
	};
} });
var ExitCodes;
var init_exit_codes = __esm({ "src/lib/utils/exit-codes.ts"() {
	"use strict";
	ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
		ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
		ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
		ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
		ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
		return ExitCodes2;
	})(ExitCodes || {});
} });
var GitOutputStreams;
var init_git_output_streams = __esm({ "src/lib/utils/git-output-streams.ts"() {
	"use strict";
	GitOutputStreams = class _GitOutputStreams {
		constructor(stdOut, stdErr) {
			this.stdOut = stdOut;
			this.stdErr = stdErr;
		}
		asStrings() {
			return new _GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
		}
	};
} });
function useMatchesDefault() {
	throw new Error(`LineParser:useMatches not implemented`);
}
var LineParser, RemoteLineParser;
var init_line_parser = __esm({ "src/lib/utils/line-parser.ts"() {
	"use strict";
	LineParser = class {
		constructor(regExp, useMatches) {
			this.matches = [];
			this.useMatches = useMatchesDefault;
			this.parse = (line, target) => {
				this.resetMatches();
				if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) return false;
				return this.useMatches(target, this.prepareMatches()) !== false;
			};
			this._regExp = Array.isArray(regExp) ? regExp : [regExp];
			if (useMatches) this.useMatches = useMatches;
		}
		resetMatches() {
			this.matches.length = 0;
		}
		prepareMatches() {
			return this.matches;
		}
		addMatch(reg, index, line) {
			const matched = line && reg.exec(line);
			if (matched) this.pushMatch(index, matched);
			return !!matched;
		}
		pushMatch(_index, matched) {
			this.matches.push(...matched.slice(1));
		}
	};
	RemoteLineParser = class extends LineParser {
		addMatch(reg, index, line) {
			return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
		}
		pushMatch(index, matched) {
			if (index > 0 || matched.length > 1) super.pushMatch(index, matched);
		}
	};
} });
function createInstanceConfig(...options) {
	const baseDir = process.cwd();
	const config = Object.assign({
		baseDir,
		...defaultOptions$1
	}, ...options.filter((o) => typeof o === "object" && o));
	config.baseDir = config.baseDir || baseDir;
	config.trimmed = config.trimmed === true;
	return config;
}
var defaultOptions$1;
var init_simple_git_options = __esm({ "src/lib/utils/simple-git-options.ts"() {
	"use strict";
	defaultOptions$1 = {
		binary: "git",
		maxConcurrentProcesses: 5,
		config: [],
		trimmed: false
	};
} });
function appendTaskOptions(options, commands = []) {
	if (!filterPlainObject(options)) return commands;
	return Object.keys(options).reduce((commands2, key) => {
		const value = options[key];
		if (isPathSpec(value)) commands2.push(value);
		else if (filterPrimitives(value, ["boolean"])) commands2.push(key + "=" + value);
		else if (Array.isArray(value)) {
			for (const v of value) if (!filterPrimitives(v, ["string", "number"])) commands2.push(key + "=" + v);
		} else commands2.push(key);
		return commands2;
	}, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
	const command = [];
	for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) if ("string|number".includes(typeof args[i])) command.push(String(args[i]));
	appendTaskOptions(trailingOptionsArgument(args), command);
	if (!objectOnly) command.push(...trailingArrayArgument(args));
	return command;
}
function trailingArrayArgument(args) {
	return asStringArray(filterType(last(args, typeof last(args) === "function" ? 1 : 0), filterArray, []));
}
function trailingOptionsArgument(args) {
	return filterType(last(args, filterFunction(last(args)) ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
	const callback = asFunction(last(args));
	return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({ "src/lib/utils/task-options.ts"() {
	"use strict";
	init_argument_filters();
	init_util();
	init_pathspec();
} });
function callTaskParser(parser4, streams) {
	return parser4(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
	asArray(texts).forEach((text) => {
		for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
			const line = (offset = 0) => {
				if (i + offset >= max) return;
				return lines[i + offset];
			};
			parsers12.some(({ parse }) => parse(line, result));
		}
	});
	return result;
}
var init_task_parser = __esm({ "src/lib/utils/task-parser.ts"() {
	"use strict";
	init_util();
} });
var utils_exports = {};
__export(utils_exports, {
	ExitCodes: () => ExitCodes,
	GitOutputStreams: () => GitOutputStreams,
	LineParser: () => LineParser,
	NOOP: () => NOOP,
	NULL: () => NULL,
	RemoteLineParser: () => RemoteLineParser,
	append: () => append,
	appendTaskOptions: () => appendTaskOptions,
	asArray: () => asArray,
	asCamelCase: () => asCamelCase,
	asFunction: () => asFunction,
	asNumber: () => asNumber,
	asStringArray: () => asStringArray,
	bufferToString: () => bufferToString,
	callTaskParser: () => callTaskParser,
	createInstanceConfig: () => createInstanceConfig,
	delay: () => delay,
	filterArray: () => filterArray,
	filterFunction: () => filterFunction,
	filterHasLength: () => filterHasLength,
	filterNumber: () => filterNumber,
	filterPlainObject: () => filterPlainObject,
	filterPrimitives: () => filterPrimitives,
	filterString: () => filterString,
	filterStringOrStringArray: () => filterStringOrStringArray,
	filterType: () => filterType,
	first: () => first,
	folderExists: () => folderExists,
	forEachLineWithContent: () => forEachLineWithContent,
	getTrailingOptions: () => getTrailingOptions,
	including: () => including,
	isUserFunction: () => isUserFunction,
	last: () => last,
	objectToString: () => objectToString,
	orVoid: () => orVoid,
	parseStringResponse: () => parseStringResponse,
	pick: () => pick,
	prefixedArray: () => prefixedArray,
	remove: () => remove,
	splitOn: () => splitOn,
	toLinesWithContent: () => toLinesWithContent,
	trailingFunctionArgument: () => trailingFunctionArgument,
	trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({ "src/lib/utils/index.ts"() {
	"use strict";
	init_argument_filters();
	init_exit_codes();
	init_git_output_streams();
	init_line_parser();
	init_simple_git_options();
	init_task_options();
	init_task_parser();
	init_util();
} });
var check_is_repo_exports = {};
__export(check_is_repo_exports, {
	CheckRepoActions: () => CheckRepoActions,
	checkIsBareRepoTask: () => checkIsBareRepoTask,
	checkIsRepoRootTask: () => checkIsRepoRootTask,
	checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
	switch (action) {
		case "bare": return checkIsBareRepoTask();
		case "root": return checkIsRepoRootTask();
	}
	return {
		commands: ["rev-parse", "--is-inside-work-tree"],
		format: "utf-8",
		onError,
		parser
	};
}
function checkIsRepoRootTask() {
	return {
		commands: ["rev-parse", "--git-dir"],
		format: "utf-8",
		onError,
		parser(path) {
			return /^\.(git)?$/.test(path.trim());
		}
	};
}
function checkIsBareRepoTask() {
	return {
		commands: ["rev-parse", "--is-bare-repository"],
		format: "utf-8",
		onError,
		parser
	};
}
function isNotRepoMessage(error) {
	return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions, onError, parser;
var init_check_is_repo = __esm({ "src/lib/tasks/check-is-repo.ts"() {
	"use strict";
	init_utils();
	CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
		CheckRepoActions2["BARE"] = "bare";
		CheckRepoActions2["IN_TREE"] = "tree";
		CheckRepoActions2["IS_REPO_ROOT"] = "root";
		return CheckRepoActions2;
	})(CheckRepoActions || {});
	onError = ({ exitCode }, error, done, fail) => {
		if (exitCode === 128 && isNotRepoMessage(error)) return done(Buffer.from("false"));
		fail(error);
	};
	parser = (text) => {
		return text.trim() === "true";
	};
} });
function cleanSummaryParser(dryRun, text) {
	const summary = new CleanResponse(dryRun);
	const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
	toLinesWithContent(text).forEach((line) => {
		const removed = line.replace(regexp, "");
		summary.paths.push(removed);
		(isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
	});
	return summary;
}
var CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;
var init_CleanSummary = __esm({ "src/lib/responses/CleanSummary.ts"() {
	"use strict";
	init_utils();
	CleanResponse = class {
		constructor(dryRun) {
			this.dryRun = dryRun;
			this.paths = [];
			this.files = [];
			this.folders = [];
		}
	};
	removalRegexp = /^[a-z]+\s*/i;
	dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
	isFolderRegexp = /\/$/;
} });
var task_exports = {};
__export(task_exports, {
	EMPTY_COMMANDS: () => EMPTY_COMMANDS,
	adhocExecTask: () => adhocExecTask,
	configurationErrorTask: () => configurationErrorTask,
	isBufferTask: () => isBufferTask,
	isEmptyTask: () => isEmptyTask,
	straightThroughBufferTask: () => straightThroughBufferTask,
	straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser4) {
	return {
		commands: EMPTY_COMMANDS,
		format: "empty",
		parser: parser4
	};
}
function configurationErrorTask(error) {
	return {
		commands: EMPTY_COMMANDS,
		format: "empty",
		parser() {
			throw typeof error === "string" ? new TaskConfigurationError(error) : error;
		}
	};
}
function straightThroughStringTask(commands, trimmed2 = false) {
	return {
		commands,
		format: "utf-8",
		parser(text) {
			return trimmed2 ? String(text).trim() : text;
		}
	};
}
function straightThroughBufferTask(commands) {
	return {
		commands,
		format: "buffer",
		parser(buffer) {
			return buffer;
		}
	};
}
function isBufferTask(task) {
	return task.format === "buffer";
}
function isEmptyTask(task) {
	return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({ "src/lib/tasks/task.ts"() {
	"use strict";
	init_task_configuration_error();
	EMPTY_COMMANDS = [];
} });
var clean_exports = {};
__export(clean_exports, {
	CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
	CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
	CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
	CleanOptions: () => CleanOptions,
	cleanTask: () => cleanTask,
	cleanWithOptionsTask: () => cleanWithOptionsTask,
	isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
	const { cleanMode, options, valid } = getCleanOptions(mode);
	if (!cleanMode) return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
	if (!valid.options) return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
	options.push(...customArgs);
	if (options.some(isInteractiveMode)) return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
	return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
	return {
		commands: [
			"clean",
			`-${mode}`,
			...customArgs
		],
		format: "utf-8",
		parser(text) {
			return cleanSummaryParser(mode === "n", text);
		}
	};
}
function isCleanOptionsArray(input) {
	return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
	let cleanMode;
	let options = [];
	let valid = {
		cleanMode: false,
		options: true
	};
	input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
		if (isCleanMode(char)) {
			cleanMode = char;
			valid.cleanMode = true;
		} else valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
	});
	return {
		cleanMode,
		options,
		valid
	};
}
function isCleanMode(cleanMode) {
	return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
	return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
	if (/^-[^\-]/.test(option)) return option.indexOf("i") > 0;
	return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;
var init_clean = __esm({ "src/lib/tasks/clean.ts"() {
	"use strict";
	init_CleanSummary();
	init_utils();
	init_task();
	CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
	CONFIG_ERROR_MODE_REQUIRED = "Git clean mode parameter (\"n\" or \"f\") is required";
	CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
	CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
		CleanOptions2["DRY_RUN"] = "n";
		CleanOptions2["FORCE"] = "f";
		CleanOptions2["IGNORED_INCLUDED"] = "x";
		CleanOptions2["IGNORED_ONLY"] = "X";
		CleanOptions2["EXCLUDING"] = "e";
		CleanOptions2["QUIET"] = "q";
		CleanOptions2["RECURSIVE"] = "d";
		return CleanOptions2;
	})(CleanOptions || {});
	CleanOptionValues = /* @__PURE__ */ new Set(["i", ...asStringArray(Object.values(CleanOptions))]);
} });
function configListParser(text) {
	const config = new ConfigList();
	for (const item of configParser(text)) config.addValue(item.file, String(item.key), item.value);
	return config;
}
function configGetParser(text, key) {
	let value = null;
	const values = [];
	const scopes = /* @__PURE__ */ new Map();
	for (const item of configParser(text, key)) {
		if (item.key !== key) continue;
		values.push(value = item.value);
		if (!scopes.has(item.file)) scopes.set(item.file, []);
		scopes.get(item.file).push(value);
	}
	return {
		key,
		paths: Array.from(scopes.keys()),
		scopes,
		value,
		values
	};
}
function configFilePath(filePath) {
	return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
	const lines = text.split("\0");
	for (let i = 0, max = lines.length - 1; i < max;) {
		const file = configFilePath(lines[i++]);
		let value = lines[i++];
		let key = requestedKey;
		if (value.includes("\n")) {
			const line = splitOn(value, "\n");
			key = line[0];
			value = line[1];
		}
		yield {
			file,
			key,
			value
		};
	}
}
var ConfigList;
var init_ConfigList = __esm({ "src/lib/responses/ConfigList.ts"() {
	"use strict";
	init_utils();
	ConfigList = class {
		constructor() {
			this.files = [];
			this.values = /* @__PURE__ */ Object.create(null);
		}
		get all() {
			if (!this._all) this._all = this.files.reduce((all, file) => {
				return Object.assign(all, this.values[file]);
			}, {});
			return this._all;
		}
		addFile(file) {
			if (!(file in this.values)) {
				const latest = last(this.files);
				this.values[file] = latest ? Object.create(this.values[latest]) : {};
				this.files.push(file);
			}
			return this.values[file];
		}
		addValue(file, key, value) {
			const values = this.addFile(file);
			if (!Object.hasOwn(values, key)) values[key] = value;
			else if (Array.isArray(values[key])) values[key].push(value);
			else values[key] = [values[key], value];
			this._all = void 0;
		}
	};
} });
function asConfigScope(scope, fallback) {
	if (typeof scope === "string" && Object.hasOwn(GitConfigScope, scope)) return scope;
	return fallback;
}
function addConfigTask(key, value, append2, scope) {
	const commands = ["config", `--${scope}`];
	if (append2) commands.push("--add");
	commands.push(key, value);
	return {
		commands,
		format: "utf-8",
		parser(text) {
			return text;
		}
	};
}
function getConfigTask(key, scope) {
	const commands = [
		"config",
		"--null",
		"--show-origin",
		"--get-all",
		key
	];
	if (scope) commands.splice(1, 0, `--${scope}`);
	return {
		commands,
		format: "utf-8",
		parser(text) {
			return configGetParser(text, key);
		}
	};
}
function listConfigTask(scope) {
	const commands = [
		"config",
		"--list",
		"--show-origin",
		"--null"
	];
	if (scope) commands.push(`--${scope}`);
	return {
		commands,
		format: "utf-8",
		parser(text) {
			return configListParser(text);
		}
	};
}
function config_default() {
	return {
		addConfig(key, value, ...rest) {
			return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], "local")), trailingFunctionArgument(arguments));
		},
		getConfig(key, scope) {
			return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));
		},
		listConfig(...rest) {
			return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));
		}
	};
}
var GitConfigScope;
var init_config = __esm({ "src/lib/tasks/config.ts"() {
	"use strict";
	init_ConfigList();
	init_utils();
	GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
		GitConfigScope2["system"] = "system";
		GitConfigScope2["global"] = "global";
		GitConfigScope2["local"] = "local";
		GitConfigScope2["worktree"] = "worktree";
		return GitConfigScope2;
	})(GitConfigScope || {});
} });
function isDiffNameStatus(input) {
	return diffNameStatus.has(input);
}
var DiffNameStatus, diffNameStatus;
var init_diff_name_status = __esm({ "src/lib/tasks/diff-name-status.ts"() {
	"use strict";
	DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
		DiffNameStatus2["ADDED"] = "A";
		DiffNameStatus2["COPIED"] = "C";
		DiffNameStatus2["DELETED"] = "D";
		DiffNameStatus2["MODIFIED"] = "M";
		DiffNameStatus2["RENAMED"] = "R";
		DiffNameStatus2["CHANGED"] = "T";
		DiffNameStatus2["UNMERGED"] = "U";
		DiffNameStatus2["UNKNOWN"] = "X";
		DiffNameStatus2["BROKEN"] = "B";
		return DiffNameStatus2;
	})(DiffNameStatus || {});
	diffNameStatus = new Set(Object.values(DiffNameStatus));
} });
function grepQueryBuilder(...params) {
	return new GrepQuery().param(...params);
}
function parseGrep(grep) {
	const paths = /* @__PURE__ */ new Set();
	const results = {};
	forEachLineWithContent(grep, (input) => {
		const [path, line, preview] = input.split(NULL);
		paths.add(path);
		(results[path] = results[path] || []).push({
			line: asNumber(line),
			path,
			preview
		});
	});
	return {
		paths,
		results
	};
}
function grep_default() {
	return { grep(searchTerm) {
		const then = trailingFunctionArgument(arguments);
		const options = getTrailingOptions(arguments);
		for (const option of disallowedOptions) if (options.includes(option)) return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
		if (typeof searchTerm === "string") searchTerm = grepQueryBuilder().param(searchTerm);
		const commands = [
			"grep",
			"--null",
			"-n",
			"--full-name",
			...options,
			...searchTerm
		];
		return this._runTask({
			commands,
			format: "utf-8",
			parser(stdOut) {
				return parseGrep(stdOut);
			}
		}, then);
	} };
}
var disallowedOptions, Query, _a, GrepQuery;
var init_grep = __esm({ "src/lib/tasks/grep.ts"() {
	"use strict";
	init_utils();
	init_task();
	disallowedOptions = ["-h"];
	Query = Symbol("grepQuery");
	GrepQuery = class {
		constructor() {
			this[_a] = [];
		}
		*[(_a = Query, Symbol.iterator)]() {
			for (const query of this[Query]) yield query;
		}
		and(...and) {
			and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
			return this;
		}
		param(...param) {
			this[Query].push(...prefixedArray(param, "-e"));
			return this;
		}
	};
} });
var reset_exports = {};
__export(reset_exports, {
	ResetMode: () => ResetMode,
	getResetMode: () => getResetMode,
	resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
	const commands = ["reset"];
	if (isValidResetMode(mode)) commands.push(`--${mode}`);
	commands.push(...customArgs);
	return straightThroughStringTask(commands);
}
function getResetMode(mode) {
	if (isValidResetMode(mode)) return mode;
	switch (typeof mode) {
		case "string":
		case "undefined": return "soft";
	}
}
function isValidResetMode(mode) {
	return typeof mode === "string" && validResetModes.includes(mode);
}
var ResetMode, validResetModes;
var init_reset = __esm({ "src/lib/tasks/reset.ts"() {
	"use strict";
	init_utils();
	init_task();
	ResetMode = /* @__PURE__ */ ((ResetMode2) => {
		ResetMode2["MIXED"] = "mixed";
		ResetMode2["SOFT"] = "soft";
		ResetMode2["HARD"] = "hard";
		ResetMode2["MERGE"] = "merge";
		ResetMode2["KEEP"] = "keep";
		return ResetMode2;
	})(ResetMode || {});
	validResetModes = asStringArray(Object.values(ResetMode));
} });
function createLog() {
	return (0, import_src.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
	if (!prefix || !String(prefix).replace(/\s*/, "")) return !forward ? to : (message, ...args) => {
		to(message, ...args);
		forward(message, ...args);
	};
	return (message, ...args) => {
		to(`%s ${message}`, prefix, ...args);
		if (forward) forward(message, ...args);
	};
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
	if (typeof name === "string") return name;
	const childNamespace = childDebugger && childDebugger.namespace || "";
	if (childNamespace.startsWith(parentNamespace)) return childNamespace.substr(parentNamespace.length + 1);
	return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
	const labelPrefix = label && `[${label}]` || "";
	const spawned = [];
	const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
	const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
	return step(initialStep);
	function sibling(name, initial) {
		return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
	}
	function step(phase) {
		const stepPrefix = phase && `[${phase}]` || "";
		const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
		const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
		return Object.assign(debugDebugger ? debug2 : info, {
			label,
			sibling,
			info,
			step
		});
	}
}
var init_git_logger = __esm({ "src/lib/git-logger.ts"() {
	"use strict";
	init_utils();
	import_src.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
	import_src.default.formatters.B = (value) => {
		if (Buffer.isBuffer(value)) return value.toString("utf8");
		return objectToString(value);
	};
} });
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({ "src/lib/runners/tasks-pending-queue.ts"() {
	"use strict";
	init_git_error();
	init_git_logger();
	TasksPendingQueue = class _TasksPendingQueue {
		constructor(logLabel = "GitExecutor") {
			this.logLabel = logLabel;
			this._queue = /* @__PURE__ */ new Map();
		}
		withProgress(task) {
			return this._queue.get(task);
		}
		createProgress(task) {
			const name = _TasksPendingQueue.getName(task.commands[0]);
			return {
				task,
				logger: createLogger(this.logLabel, name),
				name
			};
		}
		push(task) {
			const progress = this.createProgress(task);
			progress.logger("Adding task to the queue, commands = %o", task.commands);
			this._queue.set(task, progress);
			return progress;
		}
		fatal(err) {
			for (const [task, { logger }] of Array.from(this._queue.entries())) {
				if (task === err.task) {
					logger.info(`Failed %o`, err);
					logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
				} else logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
				this.complete(task);
			}
			if (this._queue.size !== 0) throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
		}
		complete(task) {
			if (this.withProgress(task)) this._queue.delete(task);
		}
		attempt(task) {
			const progress = this.withProgress(task);
			if (!progress) throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
			progress.logger("Starting task");
			return progress;
		}
		static getName(name = "empty") {
			return `task:${name}:${++_TasksPendingQueue.counter}`;
		}
		static {
			this.counter = 0;
		}
	};
} });
function pluginContext(task, commands) {
	return {
		method: first(task.commands) || "",
		commands
	};
}
function onErrorReceived(target, logger) {
	return (err) => {
		logger(`[ERROR] child process exception %o`, err);
		target.push(Buffer.from(String(err.stack), "ascii"));
	};
}
function onDataReceived(target, name, logger, output) {
	return (buffer) => {
		logger(`%s received %L bytes`, name, buffer);
		output(`%B`, buffer);
		target.push(buffer);
	};
}
var GitExecutorChain;
var init_git_executor_chain = __esm({ "src/lib/runners/git-executor-chain.ts"() {
	"use strict";
	init_git_error();
	init_task();
	init_utils();
	init_tasks_pending_queue();
	GitExecutorChain = class {
		constructor(_executor, _scheduler, _plugins) {
			this._executor = _executor;
			this._scheduler = _scheduler;
			this._plugins = _plugins;
			this._chain = Promise.resolve();
			this._queue = new TasksPendingQueue();
		}
		get cwd() {
			return this._cwd || this._executor.cwd;
		}
		set cwd(cwd) {
			this._cwd = cwd;
		}
		get env() {
			return this._executor.env;
		}
		get outputHandler() {
			return this._executor.outputHandler;
		}
		chain() {
			return this;
		}
		push(task) {
			this._queue.push(task);
			return this._chain = this._chain.then(() => this.attemptTask(task));
		}
		async attemptTask(task) {
			const onScheduleComplete = await this._scheduler.next();
			const onQueueComplete = () => this._queue.complete(task);
			try {
				const { logger } = this._queue.attempt(task);
				return await (isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger));
			} catch (e) {
				throw this.onFatalException(task, e);
			} finally {
				onQueueComplete();
				onScheduleComplete();
			}
		}
		onFatalException(task, e) {
			const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
			this._chain = Promise.resolve();
			this._queue.fatal(gitError);
			return gitError;
		}
		async attemptRemoteTask(task, logger) {
			const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
			const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
			const raw = await this.gitResponse(task, binary, args, this.outputHandler, logger.step("SPAWN"));
			const outputStreams = await this.handleTaskData(task, args, raw, logger.step("HANDLE"));
			logger(`passing response to task's parser as a %s`, task.format);
			if (isBufferTask(task)) return callTaskParser(task.parser, outputStreams);
			return callTaskParser(task.parser, outputStreams.asStrings());
		}
		async attemptEmptyTask(task, logger) {
			logger(`empty task bypassing child process to call to task's parser`);
			return task.parser(this);
		}
		handleTaskData(task, args, result, logger) {
			const { exitCode, rejection, stdOut, stdErr } = result;
			return new Promise((done, fail) => {
				logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
				const { error } = this._plugins.exec("task.error", { error: rejection }, {
					...pluginContext(task, args),
					...result
				});
				if (error && task.onError) {
					logger.info(`exitCode=%s handling with custom error handler`);
					return task.onError(result, error, (newStdOut) => {
						logger.info(`custom error handler treated as success`);
						logger(`custom error returned a %s`, objectToString(newStdOut));
						done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
					}, fail);
				}
				if (error) {
					logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
					return fail(error);
				}
				logger.info(`retrieving task output complete`);
				done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
			});
		}
		async gitResponse(task, command, args, outputHandler, logger) {
			const outputLogger = logger.sibling("output");
			const spawnOptions = this._plugins.exec("spawn.options", {
				cwd: this.cwd,
				env: this.env,
				windowsHide: true
			}, pluginContext(task, task.commands));
			return new Promise((done) => {
				const stdOut = [];
				const stdErr = [];
				logger.info(`%s %o`, command, args);
				logger("%O", spawnOptions);
				let rejection = this._beforeSpawn(task, args);
				if (rejection) return done({
					stdOut,
					stdErr,
					exitCode: 9901,
					rejection
				});
				this._plugins.exec("spawn.before", void 0, {
					...pluginContext(task, args),
					kill(reason) {
						rejection = reason || rejection;
					}
				});
				const spawned = (0, child_process.spawn)(command, args, spawnOptions);
				spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut")));
				spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr")));
				spawned.on("error", onErrorReceived(stdErr, logger));
				if (outputHandler) {
					logger(`Passing child process stdOut/stdErr to custom outputHandler`);
					outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
				}
				this._plugins.exec("spawn.after", void 0, {
					...pluginContext(task, args),
					spawned,
					close(exitCode, reason) {
						done({
							stdOut,
							stdErr,
							exitCode,
							rejection: rejection || reason
						});
					},
					kill(reason) {
						if (spawned.killed) return;
						rejection = reason;
						spawned.kill("SIGINT");
					}
				});
			});
		}
		_beforeSpawn(task, args) {
			let rejection;
			this._plugins.exec("spawn.before", void 0, {
				...pluginContext(task, args),
				kill(reason) {
					rejection = reason || rejection;
				}
			});
			return rejection;
		}
	};
} });
var git_executor_exports = {};
__export(git_executor_exports, { GitExecutor: () => GitExecutor });
var GitExecutor;
var init_git_executor = __esm({ "src/lib/runners/git-executor.ts"() {
	"use strict";
	init_git_executor_chain();
	GitExecutor = class {
		constructor(cwd, _scheduler, _plugins) {
			this.cwd = cwd;
			this._scheduler = _scheduler;
			this._plugins = _plugins;
			this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
		}
		chain() {
			return new GitExecutorChain(this, this._scheduler, this._plugins);
		}
		push(task) {
			return this._chain.push(task);
		}
	};
} });
function taskCallback(task, response, callback = NOOP) {
	const onSuccess = (data) => {
		callback(null, data);
	};
	const onError2 = (err) => {
		if (err?.task === task) callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);
	};
	response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
	let log = (name) => {
		console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
		log = NOOP;
	};
	return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
	function descriptorReducer(all, name) {
		if (name in err) return all;
		all[name] = {
			enumerable: false,
			configurable: false,
			get() {
				log(name);
				return err.git[name];
			}
		};
		return all;
	}
}
var init_task_callback = __esm({ "src/lib/task-callback.ts"() {
	"use strict";
	init_git_response_error();
	init_utils();
} });
function changeWorkingDirectoryTask(directory, root) {
	return adhocExecTask((instance) => {
		if (!folderExists(directory)) throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
		return (root || instance).cwd = directory;
	});
}
var init_change_working_directory = __esm({ "src/lib/tasks/change-working-directory.ts"() {
	"use strict";
	init_utils();
	init_task();
} });
function checkoutTask(args) {
	const commands = ["checkout", ...args];
	if (commands[1] === "-b" && commands.includes("-B")) commands[1] = remove(commands, "-B");
	return straightThroughStringTask(commands);
}
function checkout_default() {
	return {
		checkout() {
			return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));
		},
		checkoutBranch(branchName, startPoint) {
			return this._runTask(checkoutTask([
				"-b",
				branchName,
				startPoint,
				...getTrailingOptions(arguments)
			]), trailingFunctionArgument(arguments));
		},
		checkoutLocalBranch(branchName) {
			return this._runTask(checkoutTask([
				"-b",
				branchName,
				...getTrailingOptions(arguments)
			]), trailingFunctionArgument(arguments));
		}
	};
}
var init_checkout = __esm({ "src/lib/tasks/checkout.ts"() {
	"use strict";
	init_utils();
	init_task();
} });
function countObjectsResponse() {
	return {
		count: 0,
		garbage: 0,
		inPack: 0,
		packs: 0,
		prunePackable: 0,
		size: 0,
		sizeGarbage: 0,
		sizePack: 0
	};
}
function count_objects_default() {
	return { countObjects() {
		return this._runTask({
			commands: ["count-objects", "--verbose"],
			format: "utf-8",
			parser(stdOut) {
				return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
			}
		});
	} };
}
var parser2;
var init_count_objects = __esm({ "src/lib/tasks/count-objects.ts"() {
	"use strict";
	init_utils();
	parser2 = new LineParser(/([a-z-]+): (\d+)$/, (result, [key, value]) => {
		const property = asCamelCase(key);
		if (Object.hasOwn(result, property)) result[property] = asNumber(value);
	});
} });
function parseCommitResult(stdOut) {
	return parseStringResponse({
		author: null,
		branch: "",
		commit: "",
		root: false,
		summary: {
			changes: 0,
			insertions: 0,
			deletions: 0
		}
	}, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({ "src/lib/parsers/parse-commit.ts"() {
	"use strict";
	init_utils();
	parsers = [
		new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
			result.branch = branch;
			result.commit = commit;
			result.root = !!root;
		}),
		new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
			const parts = author.split("<");
			const email = parts.pop();
			if (!email || !email.includes("@")) return;
			result.author = {
				email: email.substr(0, email.length - 1),
				name: parts.join("<").trim()
			};
		}),
		new LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
			result.summary.changes = parseInt(changes, 10) || 0;
			result.summary.insertions = parseInt(insertions, 10) || 0;
			result.summary.deletions = parseInt(deletions, 10) || 0;
		}),
		new LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
			result.summary.changes = parseInt(changes, 10) || 0;
			const count = parseInt(lines, 10) || 0;
			if (direction === "-") result.summary.deletions = count;
			else if (direction === "+") result.summary.insertions = count;
		})
	];
} });
function commitTask(message, files, customArgs) {
	return {
		commands: [
			"-c",
			"core.abbrev=40",
			"commit",
			...prefixedArray(message, "-m"),
			...files,
			...customArgs
		],
		format: "utf-8",
		parser: parseCommitResult
	};
}
function commit_default() {
	return { commit(message, ...rest) {
		const next = trailingFunctionArgument(arguments);
		const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...asStringArray(filterType(rest[1], filterArray, [])), ...getTrailingOptions(arguments, 0, true)]);
		return this._runTask(task, next);
	} };
	function rejectDeprecatedSignatures(message) {
		return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
	}
}
var init_commit = __esm({ "src/lib/tasks/commit.ts"() {
	"use strict";
	init_parse_commit();
	init_utils();
	init_task();
} });
function first_commit_default() {
	return { firstCommit() {
		return this._runTask(straightThroughStringTask([
			"rev-list",
			"--max-parents=0",
			"HEAD"
		], true), trailingFunctionArgument(arguments));
	} };
}
var init_first_commit = __esm({ "src/lib/tasks/first-commit.ts"() {
	"use strict";
	init_utils();
	init_task();
} });
function hashObjectTask(filePath, write) {
	const commands = ["hash-object", filePath];
	if (write) commands.push("-w");
	return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({ "src/lib/tasks/hash-object.ts"() {
	"use strict";
	init_task();
} });
function parseInit(bare, path, text) {
	const response = String(text).trim();
	let result;
	if (result = initResponseRegex.exec(response)) return new InitSummary(bare, path, false, result[1]);
	if (result = reInitResponseRegex.exec(response)) return new InitSummary(bare, path, true, result[1]);
	let gitDir = "";
	const tokens = response.split(" ");
	while (tokens.length) if (tokens.shift() === "in") {
		gitDir = tokens.join(" ");
		break;
	}
	return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary, initResponseRegex, reInitResponseRegex;
var init_InitSummary = __esm({ "src/lib/responses/InitSummary.ts"() {
	"use strict";
	InitSummary = class {
		constructor(bare, path, existing, gitDir) {
			this.bare = bare;
			this.path = path;
			this.existing = existing;
			this.gitDir = gitDir;
		}
	};
	initResponseRegex = /^Init.+ repository in (.+)$/;
	reInitResponseRegex = /^Rein.+ in (.+)$/;
} });
function hasBareCommand(command) {
	return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
	const commands = ["init", ...customArgs];
	if (bare && !hasBareCommand(commands)) commands.splice(1, 0, bareCommand);
	return {
		commands,
		format: "utf-8",
		parser(text) {
			return parseInit(commands.includes("--bare"), path, text);
		}
	};
}
var bareCommand;
var init_init = __esm({ "src/lib/tasks/init.ts"() {
	"use strict";
	init_InitSummary();
	bareCommand = "--bare";
} });
function logFormatFromCommand(customArgs) {
	for (let i = 0; i < customArgs.length; i++) {
		const format = logFormatRegex.exec(customArgs[i]);
		if (format) return `--${format[1]}`;
	}
	return "";
}
function isLogFormat(customArg) {
	return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({ "src/lib/args/log-format.ts"() {
	"use strict";
	logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
} });
var DiffSummary;
var init_DiffSummary = __esm({ "src/lib/responses/DiffSummary.ts"() {
	"use strict";
	DiffSummary = class {
		constructor() {
			this.changed = 0;
			this.deletions = 0;
			this.insertions = 0;
			this.files = [];
		}
	};
} });
function getDiffParser(format = "") {
	const parser4 = diffSummaryParsers[format];
	return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;
var init_parse_diff_summary = __esm({ "src/lib/parsers/parse-diff-summary.ts"() {
	"use strict";
	init_log_format();
	init_DiffSummary();
	init_diff_name_status();
	init_utils();
	statParser = [
		new LineParser(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
			result.files.push({
				file: file.trim(),
				changes: asNumber(changes),
				insertions: alterations.replace(/[^+]/g, "").length,
				deletions: alterations.replace(/[^-]/g, "").length,
				binary: false
			});
		}),
		new LineParser(/^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
			result.files.push({
				file: file.trim(),
				before: asNumber(before),
				after: asNumber(after),
				binary: true
			});
		}),
		new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
			const inserted = /(\d+) i/.exec(summary);
			const deleted = /(\d+) d/.exec(summary);
			result.changed = asNumber(changed);
			result.insertions = asNumber(inserted?.[1]);
			result.deletions = asNumber(deleted?.[1]);
		})
	];
	numStatParser = [new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
		const insertions = asNumber(changesInsert);
		const deletions = asNumber(changesDelete);
		result.changed++;
		result.insertions += insertions;
		result.deletions += deletions;
		result.files.push({
			file,
			changes: insertions + deletions,
			insertions,
			deletions,
			binary: false
		});
	}), new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
		result.changed++;
		result.files.push({
			file,
			after: 0,
			before: 0,
			binary: true
		});
	})];
	nameOnlyParser = [new LineParser(/(.+)$/, (result, [file]) => {
		result.changed++;
		result.files.push({
			file,
			changes: 0,
			insertions: 0,
			deletions: 0,
			binary: false
		});
	})];
	nameStatusParser = [new LineParser(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (result, [status, similarity, from, _to, to]) => {
		result.changed++;
		result.files.push({
			file: to ?? from,
			changes: 0,
			insertions: 0,
			deletions: 0,
			binary: false,
			status: orVoid(isDiffNameStatus(status) && status),
			from: orVoid(!!to && from !== to && from),
			similarity: asNumber(similarity)
		});
	})];
	diffSummaryParsers = {
		[""]: statParser,
		["--stat"]: statParser,
		["--numstat"]: numStatParser,
		["--name-status"]: nameStatusParser,
		["--name-only"]: nameOnlyParser
	};
} });
function lineBuilder(tokens, fields) {
	return fields.reduce((line, field, index) => {
		line[field] = tokens[index] || "";
		return line;
	}, /* @__PURE__ */ Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
	const parseDiffResult = getDiffParser(logFormat);
	return function(stdOut) {
		const all = toLinesWithContent(stdOut.trim(), false, START_BOUNDARY).map(function(item) {
			const lineDetail = item.split(COMMIT_BOUNDARY);
			const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
			if (lineDetail.length > 1 && !!lineDetail[1].trim()) listLogLine.diff = parseDiffResult(lineDetail[1]);
			return listLogLine;
		});
		return {
			all,
			latest: all.length && all[0] || null,
			total: all.length
		};
	};
}
var START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;
var init_parse_list_log_summary = __esm({ "src/lib/parsers/parse-list-log-summary.ts"() {
	"use strict";
	init_utils();
	init_parse_diff_summary();
	init_log_format();
	START_BOUNDARY = " ";
	COMMIT_BOUNDARY = " ";
	SPLITTER = "  ";
	defaultFieldNames = [
		"hash",
		"date",
		"message",
		"refs",
		"author_name",
		"author_email"
	];
} });
var diff_exports = {};
__export(diff_exports, {
	diffSummaryTask: () => diffSummaryTask,
	validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
	let logFormat = logFormatFromCommand(customArgs);
	const commands = ["diff"];
	if (logFormat === "") {
		logFormat = "--stat";
		commands.push("--stat=4096");
	}
	commands.push(...customArgs);
	return validateLogFormatConfig(commands) || {
		commands,
		format: "utf-8",
		parser: getDiffParser(logFormat)
	};
}
function validateLogFormatConfig(customArgs) {
	const flags = customArgs.filter(isLogFormat);
	if (flags.length > 1) return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
	if (flags.length && customArgs.includes("-z")) return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
}
var init_diff = __esm({ "src/lib/tasks/diff.ts"() {
	"use strict";
	init_log_format();
	init_parse_diff_summary();
	init_task();
} });
function prettyFormat(format, splitter) {
	const fields = [];
	const formatStr = [];
	Object.keys(format).forEach((field) => {
		fields.push(field);
		formatStr.push(String(format[field]));
	});
	return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
	return Object.keys(input).reduce((out, key) => {
		if (!(key in excludeOptions)) out[key] = input[key];
		return out;
	}, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
	const splitter = filterType(opt.splitter, filterString, SPLITTER);
	const [fields, formatStr] = prettyFormat(filterPlainObject(opt.format) ? opt.format : {
		hash: "%H",
		date: opt.strictDate === false ? "%ai" : "%aI",
		message: "%s",
		refs: "%D",
		body: opt.multiLine ? "%B" : "%b",
		author_name: opt.mailMap !== false ? "%aN" : "%an",
		author_email: opt.mailMap !== false ? "%aE" : "%ae"
	}, splitter);
	const suffix = [];
	const command = [`--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`, ...customArgs];
	const maxCount = opt.n || opt["max-count"] || opt.maxCount;
	if (maxCount) command.push(`--max-count=${maxCount}`);
	if (opt.from || opt.to) {
		const rangeOperator = opt.symmetric !== false ? "..." : "..";
		suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
	}
	if (filterString(opt.file)) command.push("--follow", pathspec(opt.file));
	appendTaskOptions(userOptions(opt), command);
	return {
		fields,
		splitter,
		commands: [...command, ...suffix]
	};
}
function logTask(splitter, fields, customArgs) {
	const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
	return {
		commands: ["log", ...customArgs],
		format: "utf-8",
		parser: parser4
	};
}
function log_default() {
	return { log(...rest) {
		const next = trailingFunctionArgument(arguments);
		const options = parseLogOptions(trailingOptionsArgument(arguments), asStringArray(filterType(arguments[0], filterArray, [])));
		const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
		return this._runTask(task, next);
	} };
	function createLogTask(options) {
		return logTask(options.splitter, options.fields, options.commands);
	}
	function rejectDeprecatedSignatures(from, to) {
		return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
	}
}
var excludeOptions;
var init_log = __esm({ "src/lib/tasks/log.ts"() {
	"use strict";
	init_log_format();
	init_pathspec();
	init_parse_list_log_summary();
	init_utils();
	init_task();
	init_diff();
	excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
		excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
		excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
		excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
		excludeOptions2[excludeOptions2["n"] = 3] = "n";
		excludeOptions2[excludeOptions2["file"] = 4] = "file";
		excludeOptions2[excludeOptions2["format"] = 5] = "format";
		excludeOptions2[excludeOptions2["from"] = 6] = "from";
		excludeOptions2[excludeOptions2["to"] = 7] = "to";
		excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
		excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
		excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
		excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
		excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
		return excludeOptions2;
	})(excludeOptions || {});
} });
var MergeSummaryConflict, MergeSummaryDetail;
var init_MergeSummary = __esm({ "src/lib/responses/MergeSummary.ts"() {
	"use strict";
	MergeSummaryConflict = class {
		constructor(reason, file = null, meta) {
			this.reason = reason;
			this.file = file;
			this.meta = meta;
		}
		toString() {
			return `${this.file}:${this.reason}`;
		}
	};
	MergeSummaryDetail = class {
		constructor() {
			this.conflicts = [];
			this.merges = [];
			this.result = "success";
		}
		get failed() {
			return this.conflicts.length > 0;
		}
		get reason() {
			return this.result;
		}
		toString() {
			if (this.conflicts.length) return `CONFLICTS: ${this.conflicts.join(", ")}`;
			return "OK";
		}
	};
} });
var PullSummary, PullFailedSummary;
var init_PullSummary = __esm({ "src/lib/responses/PullSummary.ts"() {
	"use strict";
	PullSummary = class {
		constructor() {
			this.remoteMessages = { all: [] };
			this.created = [];
			this.deleted = [];
			this.files = [];
			this.deletions = {};
			this.insertions = {};
			this.summary = {
				changes: 0,
				deletions: 0,
				insertions: 0
			};
		}
	};
	PullFailedSummary = class {
		constructor() {
			this.remote = "";
			this.hash = {
				local: "",
				remote: ""
			};
			this.branch = {
				local: "",
				remote: ""
			};
			this.message = "";
		}
		toString() {
			return this.message;
		}
	};
} });
function objectEnumerationResult(remoteMessages) {
	return remoteMessages.objects = remoteMessages.objects || {
		compressing: 0,
		counting: 0,
		enumerating: 0,
		packReused: 0,
		reused: {
			count: 0,
			delta: 0
		},
		total: {
			count: 0,
			delta: 0
		}
	};
}
function asObjectCount(source) {
	const count = /^\s*(\d+)/.exec(source);
	const delta = /delta (\d+)/i.exec(source);
	return {
		count: asNumber(count && count[1] || "0"),
		delta: asNumber(delta && delta[1] || "0")
	};
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({ "src/lib/parsers/parse-remote-objects.ts"() {
	"use strict";
	init_utils();
	remoteMessagesObjectParsers = [
		new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
			const key = action.toLowerCase();
			const enumeration = objectEnumerationResult(result.remoteMessages);
			Object.assign(enumeration, { [key]: asNumber(count) });
		}),
		new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
			const key = action.toLowerCase();
			const enumeration = objectEnumerationResult(result.remoteMessages);
			Object.assign(enumeration, { [key]: asNumber(count) });
		}),
		new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
			const objects = objectEnumerationResult(result.remoteMessages);
			objects.total = asObjectCount(total);
			objects.reused = asObjectCount(reused);
			objects.packReused = asNumber(packReused);
		})
	];
} });
function parseRemoteMessages(_stdOut, stdErr) {
	return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2, RemoteMessageSummary;
var init_parse_remote_messages = __esm({ "src/lib/parsers/parse-remote-messages.ts"() {
	"use strict";
	init_utils();
	init_parse_remote_objects();
	parsers2 = [
		new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
			result.remoteMessages.all.push(text.trim());
			return false;
		}),
		...remoteMessagesObjectParsers,
		new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
			result.remoteMessages.pullRequestUrl = pullRequestUrl;
		}),
		new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
			result.remoteMessages.vulnerabilities = {
				count: asNumber(count),
				summary,
				url
			};
		})
	];
	RemoteMessageSummary = class {
		constructor() {
			this.all = [];
		}
	};
} });
function parsePullErrorResult(stdOut, stdErr) {
	const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
	return pullError.message && pullError;
}
var FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;
var init_parse_pull = __esm({ "src/lib/parsers/parse-pull.ts"() {
	"use strict";
	init_PullSummary();
	init_utils();
	init_parse_remote_messages();
	FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
	SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
	ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
	parsers3 = [
		new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
			result.files.push(file);
			if (insertions) result.insertions[file] = insertions.length;
			if (deletions) result.deletions[file] = deletions.length;
		}),
		new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
			if (insertions !== void 0 || deletions !== void 0) {
				result.summary.changes = +changes || 0;
				result.summary.insertions = +insertions || 0;
				result.summary.deletions = +deletions || 0;
				return true;
			}
			return false;
		}),
		new LineParser(ACTION_REGEX, (result, [action, file]) => {
			append(result.files, file);
			append(action === "create" ? result.created : result.deleted, file);
		})
	];
	errorParsers = [
		new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
		new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
		new LineParser(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
			result.branch.local = branchLocal;
			result.hash.local = hashLocal;
			result.branch.remote = branchRemote;
			result.hash.remote = hashRemote;
		})
	];
	parsePullDetail = (stdOut, stdErr) => {
		return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
	};
	parsePullResult = (stdOut, stdErr) => {
		return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
	};
} });
var parsers4, parseMergeResult, parseMergeDetail;
var init_parse_merge = __esm({ "src/lib/parsers/parse-merge.ts"() {
	"use strict";
	init_MergeSummary();
	init_utils();
	init_parse_pull();
	parsers4 = [
		new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
			summary.merges.push(autoMerge);
		}),
		new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
			summary.conflicts.push(new MergeSummaryConflict(reason, file));
		}),
		new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
			summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
		}),
		new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
			summary.conflicts.push(new MergeSummaryConflict(reason, null));
		}),
		new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
			summary.result = result;
		})
	];
	parseMergeResult = (stdOut, stdErr) => {
		return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
	};
	parseMergeDetail = (stdOut) => {
		return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
	};
} });
function mergeTask(customArgs) {
	if (!customArgs.length) return configurationErrorTask("Git.merge requires at least one option");
	return {
		commands: ["merge", ...customArgs],
		format: "utf-8",
		parser(stdOut, stdErr) {
			const merge = parseMergeResult(stdOut, stdErr);
			if (merge.failed) throw new GitResponseError(merge);
			return merge;
		}
	};
}
var init_merge = __esm({ "src/lib/tasks/merge.ts"() {
	"use strict";
	init_git_response_error();
	init_parse_merge();
	init_task();
} });
function pushResultPushedItem(local, remote, status) {
	const deleted = status.includes("deleted");
	const tag = status.includes("tag") || /^refs\/tags/.test(local);
	const alreadyUpdated = !status.includes("new");
	return {
		deleted,
		tag,
		branch: !tag,
		new: !alreadyUpdated,
		alreadyUpdated,
		local,
		remote
	};
}
var parsers5, parsePushResult, parsePushDetail;
var init_parse_push = __esm({ "src/lib/parsers/parse-push.ts"() {
	"use strict";
	init_utils();
	init_parse_remote_messages();
	parsers5 = [
		new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
			result.repo = repo;
		}),
		new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
			result.ref = {
				...result.ref || {},
				local
			};
		}),
		new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
			result.pushed.push(pushResultPushedItem(local, remote, type));
		}),
		new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
			result.branch = {
				...result.branch || {},
				local,
				remote,
				remoteName
			};
		}),
		new LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
			result.update = {
				head: {
					local,
					remote
				},
				hash: {
					from,
					to
				}
			};
		})
	];
	parsePushResult = (stdOut, stdErr) => {
		const pushDetail = parsePushDetail(stdOut, stdErr);
		const responseDetail = parseRemoteMessages(stdOut, stdErr);
		return {
			...pushDetail,
			...responseDetail
		};
	};
	parsePushDetail = (stdOut, stdErr) => {
		return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
	};
} });
var push_exports = {};
__export(push_exports, {
	pushTagsTask: () => pushTagsTask,
	pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
	append(customArgs, "--tags");
	return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
	const commands = ["push", ...customArgs];
	if (ref.branch) commands.splice(1, 0, ref.branch);
	if (ref.remote) commands.splice(1, 0, ref.remote);
	remove(commands, "-v");
	append(commands, "--verbose");
	append(commands, "--porcelain");
	return {
		commands,
		format: "utf-8",
		parser: parsePushResult
	};
}
var init_push = __esm({ "src/lib/tasks/push.ts"() {
	"use strict";
	init_parse_push();
	init_utils();
} });
function show_default() {
	return {
		showBuffer() {
			const commands = ["show", ...getTrailingOptions(arguments, 1)];
			if (!commands.includes("--binary")) commands.splice(1, 0, "--binary");
			return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));
		},
		show() {
			const commands = ["show", ...getTrailingOptions(arguments, 1)];
			return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));
		}
	};
}
var init_show = __esm({ "src/lib/tasks/show.ts"() {
	"use strict";
	init_utils();
	init_task();
} });
var fromPathRegex, FileStatusSummary;
var init_FileStatusSummary = __esm({ "src/lib/responses/FileStatusSummary.ts"() {
	"use strict";
	fromPathRegex = /^(.+)\0(.+)$/;
	FileStatusSummary = class {
		constructor(path, index, working_dir) {
			this.path = path;
			this.index = index;
			this.working_dir = working_dir;
			if (index === "R" || working_dir === "R") {
				const detail = fromPathRegex.exec(path) || [
					null,
					path,
					path
				];
				this.from = detail[2] || "";
				this.path = detail[1] || "";
			}
		}
	};
} });
function renamedFile(line) {
	const [to, from] = line.split(NULL);
	return {
		from: from || to,
		to
	};
}
function parser3(indexX, indexY, handler) {
	return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
	return indexY.map((y) => parser3(indexX, y, (result, file) => result.conflicted.push(file)));
}
function splitLine(result, lineStr) {
	const trimmed2 = lineStr.trim();
	switch (" ") {
		case trimmed2.charAt(2): return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.slice(3));
		case trimmed2.charAt(1): return data(" ", trimmed2.charAt(0), trimmed2.slice(2));
		default: return;
	}
	function data(index, workingDir, path) {
		const raw = `${index}${workingDir}`;
		const handler = parsers6.get(raw);
		if (handler) handler(result, path);
		if (raw !== "##" && raw !== "!!") result.files.push(new FileStatusSummary(path, index, workingDir));
	}
}
var StatusSummary, parsers6, parseStatusSummary;
var init_StatusSummary = __esm({ "src/lib/responses/StatusSummary.ts"() {
	"use strict";
	init_utils();
	init_FileStatusSummary();
	StatusSummary = class {
		constructor() {
			this.not_added = [];
			this.conflicted = [];
			this.created = [];
			this.deleted = [];
			this.ignored = void 0;
			this.modified = [];
			this.renamed = [];
			this.files = [];
			this.staged = [];
			this.ahead = 0;
			this.behind = 0;
			this.current = null;
			this.tracking = null;
			this.detached = false;
			this.isClean = () => {
				return !this.files.length;
			};
		}
	};
	parsers6 = new Map([
		parser3(" ", "A", (result, file) => result.created.push(file)),
		parser3(" ", "D", (result, file) => result.deleted.push(file)),
		parser3(" ", "M", (result, file) => result.modified.push(file)),
		parser3("A", " ", (result, file) => {
			result.created.push(file);
			result.staged.push(file);
		}),
		parser3("A", "M", (result, file) => {
			result.created.push(file);
			result.staged.push(file);
			result.modified.push(file);
		}),
		parser3("D", " ", (result, file) => {
			result.deleted.push(file);
			result.staged.push(file);
		}),
		parser3("M", " ", (result, file) => {
			result.modified.push(file);
			result.staged.push(file);
		}),
		parser3("M", "M", (result, file) => {
			result.modified.push(file);
			result.staged.push(file);
		}),
		parser3("R", " ", (result, file) => {
			result.renamed.push(renamedFile(file));
		}),
		parser3("R", "M", (result, file) => {
			const renamed = renamedFile(file);
			result.renamed.push(renamed);
			result.modified.push(renamed.to);
		}),
		parser3("!", "!", (_result, _file) => {
			(_result.ignored = _result.ignored || []).push(_file);
		}),
		parser3("?", "?", (result, file) => result.not_added.push(file)),
		...conflicts("A", "A", "U"),
		...conflicts("D", "D", "U"),
		...conflicts("U", "A", "D", "U"),
		["##", (result, line) => {
			const aheadReg = /ahead (\d+)/;
			const behindReg = /behind (\d+)/;
			const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
			const trackingReg = /\.{3}(\S*)/;
			const onEmptyBranchReg = /\son\s(\S+?)(?=\.{3}|$)/;
			let regexResult = aheadReg.exec(line);
			result.ahead = regexResult && +regexResult[1] || 0;
			regexResult = behindReg.exec(line);
			result.behind = regexResult && +regexResult[1] || 0;
			regexResult = currentReg.exec(line);
			result.current = filterType(regexResult?.[1], filterString, null);
			regexResult = trackingReg.exec(line);
			result.tracking = filterType(regexResult?.[1], filterString, null);
			regexResult = onEmptyBranchReg.exec(line);
			if (regexResult) result.current = filterType(regexResult?.[1], filterString, result.current);
			result.detached = /\(no branch\)/.test(line);
		}]
	]);
	parseStatusSummary = function(text) {
		const lines = text.split(NULL);
		const status = new StatusSummary();
		for (let i = 0, l = lines.length; i < l;) {
			let line = lines[i++].trim();
			if (!line) continue;
			if (line.charAt(0) === "R") line += NULL + (lines[i++] || "");
			splitLine(status, line);
		}
		return status;
	};
} });
function statusTask(customArgs) {
	return {
		format: "utf-8",
		commands: [
			"status",
			"--porcelain",
			"-b",
			"-u",
			"--null",
			...customArgs.filter((arg) => !ignoredOptions.includes(arg))
		],
		parser(text) {
			return parseStatusSummary(text);
		}
	};
}
var ignoredOptions;
var init_status = __esm({ "src/lib/tasks/status.ts"() {
	"use strict";
	init_StatusSummary();
	ignoredOptions = ["--null", "-z"];
} });
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
	return Object.defineProperty({
		major,
		minor,
		patch,
		agent,
		installed
	}, "toString", {
		value() {
			return `${this.major}.${this.minor}.${this.patch}`;
		},
		configurable: false,
		enumerable: false
	});
}
function notInstalledResponse() {
	return versionResponse(0, 0, 0, "", false);
}
function version_default() {
	return { version() {
		return this._runTask({
			commands: ["--version"],
			format: "utf-8",
			parser: versionParser,
			onError(result, error, done, fail) {
				if (result.exitCode === -2) return done(Buffer.from(NOT_INSTALLED));
				fail(error);
			}
		});
	} };
}
function versionParser(stdOut) {
	if (stdOut === NOT_INSTALLED) return notInstalledResponse();
	return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED, parsers7;
var init_version = __esm({ "src/lib/tasks/version.ts"() {
	"use strict";
	init_utils();
	NOT_INSTALLED = "installed=false";
	parsers7 = [new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
		Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
	}), new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
		Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
	})];
} });
var simple_git_api_exports = {};
__export(simple_git_api_exports, { SimpleGitApi: () => SimpleGitApi });
var SimpleGitApi;
var init_simple_git_api = __esm({ "src/lib/simple-git-api.ts"() {
	"use strict";
	init_task_callback();
	init_change_working_directory();
	init_checkout();
	init_count_objects();
	init_commit();
	init_config();
	init_first_commit();
	init_grep();
	init_hash_object();
	init_init();
	init_log();
	init_merge();
	init_push();
	init_show();
	init_status();
	init_task();
	init_version();
	init_utils();
	SimpleGitApi = class {
		constructor(_executor) {
			this._executor = _executor;
		}
		_runTask(task, then) {
			const chain = this._executor.chain();
			const promise = chain.push(task);
			if (then) taskCallback(task, promise, then);
			return Object.create(this, {
				then: { value: promise.then.bind(promise) },
				catch: { value: promise.catch.bind(promise) },
				_executor: { value: chain }
			});
		}
		add(files) {
			return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
		}
		cwd(directory) {
			const next = trailingFunctionArgument(arguments);
			if (typeof directory === "string") return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
			if (typeof directory?.path === "string") return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);
			return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
		}
		hashObject(path, write) {
			return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));
		}
		init(bare) {
			return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
		}
		merge() {
			return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
		}
		mergeFromTo(remote, branch) {
			if (!(filterString(remote) && filterString(branch))) return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
			return this._runTask(mergeTask([
				remote,
				branch,
				...getTrailingOptions(arguments)
			]), trailingFunctionArgument(arguments, false));
		}
		outputHandler(handler) {
			this._executor.outputHandler = handler;
			return this;
		}
		push() {
			const task = pushTask({
				remote: filterType(arguments[0], filterString),
				branch: filterType(arguments[1], filterString)
			}, getTrailingOptions(arguments));
			return this._runTask(task, trailingFunctionArgument(arguments));
		}
		stash() {
			return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
		}
		status() {
			return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
		}
	};
	Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), count_objects_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());
} });
var scheduler_exports = {};
__export(scheduler_exports, { Scheduler: () => Scheduler });
var createScheduledTask, Scheduler;
var init_scheduler = __esm({ "src/lib/runners/scheduler.ts"() {
	"use strict";
	init_utils();
	init_git_logger();
	createScheduledTask = /* @__PURE__ */ (() => {
		let id = 0;
		return () => {
			id++;
			const { promise, done } = (0, import_dist$2.createDeferred)();
			return {
				promise,
				done,
				id
			};
		};
	})();
	Scheduler = class {
		constructor(concurrency = 2) {
			this.concurrency = concurrency;
			this.logger = createLogger("", "scheduler");
			this.pending = [];
			this.running = [];
			this.logger(`Constructed, concurrency=%s`, concurrency);
		}
		schedule() {
			if (!this.pending.length || this.running.length >= this.concurrency) {
				this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
				return;
			}
			const task = append(this.running, this.pending.shift());
			this.logger(`Attempting id=%s`, task.id);
			task.done(() => {
				this.logger(`Completing id=`, task.id);
				remove(this.running, task);
				this.schedule();
			});
		}
		next() {
			const { promise, id } = append(this.pending, createScheduledTask());
			this.logger(`Scheduling id=%s`, id);
			this.schedule();
			return promise;
		}
	};
} });
var apply_patch_exports = {};
__export(apply_patch_exports, { applyPatchTask: () => applyPatchTask });
function applyPatchTask(patches, customArgs) {
	return straightThroughStringTask([
		"apply",
		...customArgs,
		...patches
	]);
}
var init_apply_patch = __esm({ "src/lib/tasks/apply-patch.ts"() {
	"use strict";
	init_task();
} });
function branchDeletionSuccess(branch, hash) {
	return {
		branch,
		hash,
		success: true
	};
}
function branchDeletionFailure(branch) {
	return {
		branch,
		hash: null,
		success: false
	};
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({ "src/lib/responses/BranchDeleteSummary.ts"() {
	"use strict";
	BranchDeletionBatch = class {
		constructor() {
			this.all = [];
			this.branches = {};
			this.errors = [];
		}
		get success() {
			return !this.errors.length;
		}
	};
} });
function hasBranchDeletionError(data, processExitCode) {
	return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;
var init_parse_branch_delete = __esm({ "src/lib/parsers/parse-branch-delete.ts"() {
	"use strict";
	init_BranchDeleteSummary();
	init_utils();
	deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
	deleteErrorRegex = /^error[^']+'([^']+)'/m;
	parsers8 = [new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
		const deletion = branchDeletionSuccess(branch, hash);
		result.all.push(deletion);
		result.branches[branch] = deletion;
	}), new LineParser(deleteErrorRegex, (result, [branch]) => {
		const deletion = branchDeletionFailure(branch);
		result.errors.push(deletion);
		result.all.push(deletion);
		result.branches[branch] = deletion;
	})];
	parseBranchDeletions = (stdOut, stdErr) => {
		return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
	};
} });
var BranchSummaryResult;
var init_BranchSummary = __esm({ "src/lib/responses/BranchSummary.ts"() {
	"use strict";
	BranchSummaryResult = class {
		constructor() {
			this.all = [];
			this.branches = {};
			this.current = "";
			this.detached = false;
		}
		push(status, detached, name, commit, label) {
			if (status === "*") {
				this.detached = detached;
				this.current = name;
			}
			this.all.push(name);
			this.branches[name] = {
				current: status === "*",
				linkedWorkTree: status === "+",
				name,
				commit,
				label
			};
		}
	};
} });
function branchStatus(input) {
	return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut, currentOnly = false) {
	return parseStringResponse(new BranchSummaryResult(), currentOnly ? [currentBranchParser] : parsers9, stdOut);
}
var parsers9, currentBranchParser;
var init_parse_branch = __esm({ "src/lib/parsers/parse-branch.ts"() {
	"use strict";
	init_BranchSummary();
	init_utils();
	parsers9 = [new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
		result.push(branchStatus(current), true, name, commit, label);
	}), new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
		result.push(branchStatus(current), false, name, commit, label);
	})];
	currentBranchParser = new LineParser(/^(\S+)$/s, (result, [name]) => {
		result.push("*", false, name, "", "");
	});
} });
var branch_exports = {};
__export(branch_exports, {
	branchLocalTask: () => branchLocalTask,
	branchTask: () => branchTask,
	containsDeleteBranchCommand: () => containsDeleteBranchCommand,
	deleteBranchTask: () => deleteBranchTask,
	deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
	const deleteCommands = [
		"-d",
		"-D",
		"--delete"
	];
	return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
	const isDelete = containsDeleteBranchCommand(customArgs);
	const isCurrentOnly = customArgs.includes("--show-current");
	const commands = ["branch", ...customArgs];
	if (commands.length === 1) commands.push("-a");
	if (!commands.includes("-v")) commands.splice(1, 0, "-v");
	return {
		format: "utf-8",
		commands,
		parser(stdOut, stdErr) {
			if (isDelete) return parseBranchDeletions(stdOut, stdErr).all[0];
			return parseBranchSummary(stdOut, isCurrentOnly);
		}
	};
}
function branchLocalTask() {
	return {
		format: "utf-8",
		commands: ["branch", "-v"],
		parser(stdOut) {
			return parseBranchSummary(stdOut);
		}
	};
}
function deleteBranchesTask(branches, forceDelete = false) {
	return {
		format: "utf-8",
		commands: [
			"branch",
			"-v",
			forceDelete ? "-D" : "-d",
			...branches
		],
		parser(stdOut, stdErr) {
			return parseBranchDeletions(stdOut, stdErr);
		},
		onError({ exitCode, stdOut }, error, done, fail) {
			if (!hasBranchDeletionError(String(error), exitCode)) return fail(error);
			done(stdOut);
		}
	};
}
function deleteBranchTask(branch, forceDelete = false) {
	const task = {
		format: "utf-8",
		commands: [
			"branch",
			"-v",
			forceDelete ? "-D" : "-d",
			branch
		],
		parser(stdOut, stdErr) {
			return parseBranchDeletions(stdOut, stdErr).branches[branch];
		},
		onError({ exitCode, stdErr, stdOut }, error, _, fail) {
			if (!hasBranchDeletionError(String(error), exitCode)) return fail(error);
			throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
		}
	};
	return task;
}
var init_branch = __esm({ "src/lib/tasks/branch.ts"() {
	"use strict";
	init_git_response_error();
	init_parse_branch_delete();
	init_parse_branch();
	init_utils();
} });
function toPath(input) {
	const path = input.trim().replace(/^["']|["']$/g, "");
	return path && (0, node_path.normalize)(path);
}
var parseCheckIgnore;
var init_CheckIgnore = __esm({ "src/lib/responses/CheckIgnore.ts"() {
	"use strict";
	parseCheckIgnore = (text) => {
		return text.split(/\n/g).map(toPath).filter(Boolean);
	};
} });
var check_ignore_exports = {};
__export(check_ignore_exports, { checkIgnoreTask: () => checkIgnoreTask });
function checkIgnoreTask(paths) {
	return {
		commands: ["check-ignore", ...paths],
		format: "utf-8",
		parser: parseCheckIgnore
	};
}
var init_check_ignore = __esm({ "src/lib/tasks/check-ignore.ts"() {
	"use strict";
	init_CheckIgnore();
} });
var clone_exports = {};
__export(clone_exports, {
	cloneMirrorTask: () => cloneMirrorTask,
	cloneTask: () => cloneTask
});
function disallowedCommand(command) {
	return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
	const commands = ["clone", ...customArgs];
	filterString(repo) && commands.push(repo);
	filterString(directory) && commands.push(directory);
	if (commands.find(disallowedCommand)) return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
	return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
	append(customArgs, "--mirror");
	return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({ "src/lib/tasks/clone.ts"() {
	"use strict";
	init_task();
	init_utils();
} });
function parseFetchResult(stdOut, stdErr) {
	return parseStringResponse({
		raw: stdOut,
		remote: null,
		branches: [],
		tags: [],
		updated: [],
		deleted: []
	}, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({ "src/lib/parsers/parse-fetch.ts"() {
	"use strict";
	init_utils();
	parsers10 = [
		new LineParser(/From (.+)$/, (result, [remote]) => {
			result.remote = remote;
		}),
		new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
			result.branches.push({
				name,
				tracking
			});
		}),
		new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
			result.tags.push({
				name,
				tracking
			});
		}),
		new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
			result.deleted.push({ tracking });
		}),
		new LineParser(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (result, [from, to, name, tracking]) => {
			result.updated.push({
				name,
				tracking,
				to,
				from
			});
		})
	];
} });
var fetch_exports = {};
__export(fetch_exports, { fetchTask: () => fetchTask });
function disallowedCommand2(command) {
	return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
	const commands = ["fetch", ...customArgs];
	if (remote && branch) commands.push(remote, branch);
	if (commands.find(disallowedCommand2)) return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
	return {
		commands,
		format: "utf-8",
		parser: parseFetchResult
	};
}
var init_fetch = __esm({ "src/lib/tasks/fetch.ts"() {
	"use strict";
	init_parse_fetch();
	init_task();
} });
function parseMoveResult(stdOut) {
	return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({ "src/lib/parsers/parse-move.ts"() {
	"use strict";
	init_utils();
	parsers11 = [new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
		result.moves.push({
			from,
			to
		});
	})];
} });
var move_exports = {};
__export(move_exports, { moveTask: () => moveTask });
function moveTask(from, to) {
	return {
		commands: [
			"mv",
			"-v",
			...asArray(from),
			to
		],
		format: "utf-8",
		parser: parseMoveResult
	};
}
var init_move = __esm({ "src/lib/tasks/move.ts"() {
	"use strict";
	init_parse_move();
	init_utils();
} });
var pull_exports = {};
__export(pull_exports, { pullTask: () => pullTask });
function pullTask(remote, branch, customArgs) {
	const commands = ["pull", ...customArgs];
	if (remote && branch) commands.splice(1, 0, remote, branch);
	return {
		commands,
		format: "utf-8",
		parser(stdOut, stdErr) {
			return parsePullResult(stdOut, stdErr);
		},
		onError(result, _error, _done, fail) {
			const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
			if (pullError) return fail(new GitResponseError(pullError));
			fail(_error);
		}
	};
}
var init_pull = __esm({ "src/lib/tasks/pull.ts"() {
	"use strict";
	init_git_response_error();
	init_parse_pull();
	init_utils();
} });
function parseGetRemotes(text) {
	const remotes = {};
	forEach(text, ([name]) => remotes[name] = { name });
	return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
	const remotes = {};
	forEach(text, ([name, url, purpose]) => {
		if (!Object.hasOwn(remotes, name)) remotes[name] = {
			name,
			refs: {
				fetch: "",
				push: ""
			}
		};
		if (purpose && url) remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
	});
	return Object.values(remotes);
}
function forEach(text, handler) {
	forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({ "src/lib/responses/GetRemoteSummary.ts"() {
	"use strict";
	init_utils();
} });
var remote_exports = {};
__export(remote_exports, {
	addRemoteTask: () => addRemoteTask,
	getRemotesTask: () => getRemotesTask,
	listRemotesTask: () => listRemotesTask,
	remoteTask: () => remoteTask,
	removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
	return straightThroughStringTask([
		"remote",
		"add",
		...customArgs,
		remoteName,
		remoteRepo
	]);
}
function getRemotesTask(verbose) {
	const commands = ["remote"];
	if (verbose) commands.push("-v");
	return {
		commands,
		format: "utf-8",
		parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
	};
}
function listRemotesTask(customArgs) {
	const commands = [...customArgs];
	if (commands[0] !== "ls-remote") commands.unshift("ls-remote");
	return straightThroughStringTask(commands);
}
function remoteTask(customArgs) {
	const commands = [...customArgs];
	if (commands[0] !== "remote") commands.unshift("remote");
	return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
	return straightThroughStringTask([
		"remote",
		"remove",
		remoteName
	]);
}
var init_remote = __esm({ "src/lib/tasks/remote.ts"() {
	"use strict";
	init_GetRemoteSummary();
	init_task();
} });
var stash_list_exports = {};
__export(stash_list_exports, { stashListTask: () => stashListTask });
function stashListTask(opt = {}, customArgs) {
	const options = parseLogOptions(opt);
	const commands = [
		"stash",
		"list",
		...options.commands,
		...customArgs
	];
	const parser4 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
	return validateLogFormatConfig(commands) || {
		commands,
		format: "utf-8",
		parser: parser4
	};
}
var init_stash_list = __esm({ "src/lib/tasks/stash-list.ts"() {
	"use strict";
	init_log_format();
	init_parse_list_log_summary();
	init_diff();
	init_log();
} });
var sub_module_exports = {};
__export(sub_module_exports, {
	addSubModuleTask: () => addSubModuleTask,
	initSubModuleTask: () => initSubModuleTask,
	subModuleTask: () => subModuleTask,
	updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
	return subModuleTask([
		"add",
		repo,
		path
	]);
}
function initSubModuleTask(customArgs) {
	return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
	const commands = [...customArgs];
	if (commands[0] !== "submodule") commands.unshift("submodule");
	return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
	return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({ "src/lib/tasks/sub-module.ts"() {
	"use strict";
	init_task();
} });
function singleSorted(a, b) {
	const aIsNum = Number.isNaN(a);
	if (aIsNum !== Number.isNaN(b)) return aIsNum ? 1 : -1;
	return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
	return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
	return input.trim();
}
function toNumber(input) {
	if (typeof input === "string") return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
	return 0;
}
var TagList, parseTagList;
var init_TagList = __esm({ "src/lib/responses/TagList.ts"() {
	"use strict";
	TagList = class {
		constructor(all, latest) {
			this.all = all;
			this.latest = latest;
		}
	};
	parseTagList = function(data, customSort = false) {
		const tags = data.split("\n").map(trimmed).filter(Boolean);
		if (!customSort) tags.sort(function(tagA, tagB) {
			const partsA = tagA.split(".");
			const partsB = tagB.split(".");
			if (partsA.length === 1 || partsB.length === 1) return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
			for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
				const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
				if (diff) return diff;
			}
			return 0;
		});
		const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
		return new TagList(tags, latest);
	};
} });
var tag_exports = {};
__export(tag_exports, {
	addAnnotatedTagTask: () => addAnnotatedTagTask,
	addTagTask: () => addTagTask,
	tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
	const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
	return {
		format: "utf-8",
		commands: [
			"tag",
			"-l",
			...customArgs
		],
		parser(text) {
			return parseTagList(text, hasCustomSort);
		}
	};
}
function addTagTask(name) {
	return {
		format: "utf-8",
		commands: ["tag", name],
		parser() {
			return { name };
		}
	};
}
function addAnnotatedTagTask(name, tagMessage) {
	return {
		format: "utf-8",
		commands: [
			"tag",
			"-a",
			"-m",
			tagMessage,
			name
		],
		parser() {
			return { name };
		}
	};
}
var init_tag = __esm({ "src/lib/tasks/tag.ts"() {
	"use strict";
	init_TagList();
} });
var require_git = __commonJS({ "src/git.js"(exports, module) {
	"use strict";
	var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));
	var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
	var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));
	var { adhocExecTask: adhocExecTask2, configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));
	var { asArray: asArray2, filterArray: filterArray2, filterPrimitives: filterPrimitives2, filterString: filterString2, filterStringOrStringArray: filterStringOrStringArray2, filterType: filterType2, getTrailingOptions: getTrailingOptions2, trailingFunctionArgument: trailingFunctionArgument2, trailingOptionsArgument: trailingOptionsArgument2 } = (init_utils(), __toCommonJS(utils_exports));
	var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
	var { branchTask: branchTask2, branchLocalTask: branchLocalTask2, deleteBranchesTask: deleteBranchesTask2, deleteBranchTask: deleteBranchTask2 } = (init_branch(), __toCommonJS(branch_exports));
	var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
	var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
	var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));
	var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));
	var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));
	var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));
	var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));
	var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));
	var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));
	var { addRemoteTask: addRemoteTask2, getRemotesTask: getRemotesTask2, listRemotesTask: listRemotesTask2, remoteTask: remoteTask2, removeRemoteTask: removeRemoteTask2 } = (init_remote(), __toCommonJS(remote_exports));
	var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));
	var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));
	var { addSubModuleTask: addSubModuleTask2, initSubModuleTask: initSubModuleTask2, subModuleTask: subModuleTask2, updateSubModuleTask: updateSubModuleTask2 } = (init_sub_module(), __toCommonJS(sub_module_exports));
	var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));
	var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));
	function Git2(options, plugins) {
		this._plugins = plugins;
		this._executor = new GitExecutor2(options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);
		this._trimmed = options.trimmed;
	}
	(Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
	Git2.prototype.customBinary = function(command) {
		this._plugins.reconfigure("binary", command);
		return this;
	};
	Git2.prototype.env = function(name, value) {
		if (arguments.length === 1 && typeof name === "object") this._executor.env = name;
		else (this._executor.env = this._executor.env || {})[name] = value;
		return this;
	};
	Git2.prototype.stashList = function(options) {
		return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));
	};
	function createCloneTask(api, task, repoPath, localPath) {
		if (typeof repoPath !== "string") return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
		return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
	}
	Git2.prototype.clone = function() {
		return this._runTask(createCloneTask("clone", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.mirror = function() {
		return this._runTask(createCloneTask("mirror", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.mv = function(from, to) {
		return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.checkoutLatestTag = function(then) {
		var git = this;
		return this.pull(function() {
			git.tags(function(err, tags) {
				git.checkout(tags.latest, then);
			});
		});
	};
	Git2.prototype.pull = function(remote, branch, options, then) {
		return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.fetch = function(remote, branch) {
		return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.silent = function(silence) {
		return this._runTask(adhocExecTask2(() => console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this method will be removed.")));
	};
	Git2.prototype.tags = function(options, then) {
		return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.rebase = function() {
		return this._runTask(straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.reset = function(mode) {
		return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.revert = function(commit) {
		const next = trailingFunctionArgument2(arguments);
		if (typeof commit !== "string") return this._runTask(configurationErrorTask2("Commit must be a string"), next);
		return this._runTask(straightThroughStringTask2([
			"revert",
			...getTrailingOptions2(arguments, 0, true),
			commit
		]), next);
	};
	Git2.prototype.addTag = function(name) {
		const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
		return this._runTask(task, trailingFunctionArgument2(arguments));
	};
	Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
		return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
		return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
		return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.branch = function(options, then) {
		return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.branchLocal = function(then) {
		return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.raw = function(commands) {
		const createRestCommands = !Array.isArray(commands);
		const command = [].slice.call(createRestCommands ? arguments : commands, 0);
		for (let i = 0; i < command.length && createRestCommands; i++) if (!filterPrimitives2(command[i])) {
			command.splice(i, command.length - i);
			break;
		}
		command.push(...getTrailingOptions2(arguments, 0, true));
		var next = trailingFunctionArgument2(arguments);
		if (!command.length) return this._runTask(configurationErrorTask2("Raw: must supply one or more command to execute"), next);
		return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
	};
	Git2.prototype.submoduleAdd = function(repo, path, then) {
		return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.submoduleUpdate = function(args, then) {
		return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.submoduleInit = function(args, then) {
		return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.subModule = function(options, then) {
		return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.listRemote = function() {
		return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
		return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.removeRemote = function(remoteName, then) {
		return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.getRemotes = function(verbose, then) {
		return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.remote = function(options, then) {
		return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.tag = function(options, then) {
		const command = getTrailingOptions2(arguments);
		if (command[0] !== "tag") command.unshift("tag");
		return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.updateServerInfo = function(then) {
		return this._runTask(straightThroughStringTask2(["update-server-info"]), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.pushTags = function(remote, then) {
		const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));
		return this._runTask(task, trailingFunctionArgument2(arguments));
	};
	Git2.prototype.rm = function(files) {
		return this._runTask(straightThroughStringTask2([
			"rm",
			"-f",
			...asArray2(files)
		]), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.rmKeepLocal = function(files) {
		return this._runTask(straightThroughStringTask2([
			"rm",
			"--cached",
			...asArray2(files)
		]), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.catFile = function(options, then) {
		return this._catFile("utf-8", arguments);
	};
	Git2.prototype.binaryCatFile = function() {
		return this._catFile("buffer", arguments);
	};
	Git2.prototype._catFile = function(format, args) {
		var handler = trailingFunctionArgument2(args);
		var command = ["cat-file"];
		var options = args[0];
		if (typeof options === "string") return this._runTask(configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"), handler);
		if (Array.isArray(options)) command.push.apply(command, options);
		const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
		return this._runTask(task, handler);
	};
	Git2.prototype.diff = function(options, then) {
		const task = filterString2(options) ? configurationErrorTask2("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
		return this._runTask(task, trailingFunctionArgument2(arguments));
	};
	Git2.prototype.diffSummary = function() {
		return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.applyPatch = function(patches) {
		const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
		return this._runTask(task, trailingFunctionArgument2(arguments));
	};
	Git2.prototype.revparse = function() {
		const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
		return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.clean = function(mode, options, then) {
		const usingCleanOptionsArray = isCleanOptionsArray2(mode);
		const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
		const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
		return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.exec = function(then) {
		return this._runTask({
			commands: [],
			format: "utf-8",
			parser() {
				if (typeof then === "function") then();
			}
		});
	};
	Git2.prototype.clearQueue = function() {
		return this._runTask(adhocExecTask2(() => console.warn("simple-git deprecation notice: clearQueue() is deprecated and will be removed, switch to using the abortPlugin instead.")));
	};
	Git2.prototype.checkIgnore = function(pathnames, then) {
		return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));
	};
	Git2.prototype.checkIsRepo = function(checkType, then) {
		return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));
	};
	module.exports = Git2;
} });
init_pathspec();
init_git_error();
init_git_error();
init_git_error();
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
init_utils();
init_utils();
var never = (0, import_dist$2.deferred)().promise;
init_utils();
init_git_error();
init_utils();
init_utils();
init_utils();
init_pathspec();
init_utils();
var Git = require_git();
init_git_response_error();

//#endregion
//#region ../../node_modules/slugify/slugify.js
var require_slugify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(name, root, factory) {
		if (typeof exports === "object") {
			module.exports = factory();
			module.exports["default"] = factory();
		} else if (typeof define === "function" && define.amd) define(factory);
		else root[name] = factory();
	})("slugify", exports, function() {
		var charMap = JSON.parse("{\"$\":\"dollar\",\"%\":\"percent\",\"&\":\"and\",\"<\":\"less\",\">\":\"greater\",\"|\":\"or\",\"\":\"cent\",\"\":\"pound\",\"\":\"currency\",\"\":\"yen\",\"\":\"(c)\",\"\":\"a\",\"\":\"(r)\",\"\":\"o\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"AE\",\"\":\"C\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"D\",\"\":\"N\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"Y\",\"\":\"TH\",\"\":\"ss\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"ae\",\"\":\"c\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"d\",\"\":\"n\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"y\",\"\":\"th\",\"\":\"y\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"C\",\"\":\"c\",\"\":\"C\",\"\":\"c\",\"\":\"D\",\"\":\"d\",\"\":\"DJ\",\"\":\"dj\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"G\",\"\":\"g\",\"\":\"G\",\"\":\"g\",\"\":\"I\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"k\",\"\":\"k\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"OE\",\"\":\"oe\",\"\":\"R\",\"\":\"r\",\"\":\"R\",\"\":\"r\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"T\",\"\":\"t\",\"\":\"U\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"W\",\"\":\"w\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"E\",\"\":\"f\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"LJ\",\"\":\"lj\",\"\":\"NJ\",\"\":\"nj\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"e\",\"\":\"o\",\"\":\"A\",\"\":\"E\",\"\":\"H\",\"\":\"I\",\"\":\"O\",\"\":\"Y\",\"\":\"W\",\"\":\"i\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"H\",\"\":\"8\",\"\":\"I\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"3\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"Y\",\"\":\"F\",\"\":\"X\",\"\":\"PS\",\"\":\"W\",\"\":\"I\",\"\":\"Y\",\"\":\"a\",\"\":\"e\",\"\":\"h\",\"\":\"i\",\"\":\"y\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"z\",\"\":\"h\",\"\":\"8\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"3\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"s\",\"\":\"t\",\"\":\"y\",\"\":\"f\",\"\":\"x\",\"\":\"ps\",\"\":\"w\",\"\":\"i\",\"\":\"y\",\"\":\"o\",\"\":\"y\",\"\":\"w\",\"\":\"Yo\",\"\":\"DJ\",\"\":\"Ye\",\"\":\"I\",\"\":\"Yi\",\"\":\"J\",\"\":\"LJ\",\"\":\"NJ\",\"\":\"C\",\"\":\"DZ\",\"\":\"A\",\"\":\"B\",\"\":\"V\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Zh\",\"\":\"Z\",\"\":\"I\",\"\":\"J\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"U\",\"\":\"F\",\"\":\"H\",\"\":\"C\",\"\":\"Ch\",\"\":\"Sh\",\"\":\"Sh\",\"\":\"U\",\"\":\"Y\",\"\":\"\",\"\":\"E\",\"\":\"Yu\",\"\":\"Ya\",\"\":\"a\",\"\":\"b\",\"\":\"v\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"zh\",\"\":\"z\",\"\":\"i\",\"\":\"j\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"h\",\"\":\"c\",\"\":\"ch\",\"\":\"sh\",\"\":\"sh\",\"\":\"u\",\"\":\"y\",\"\":\"\",\"\":\"e\",\"\":\"yu\",\"\":\"ya\",\"\":\"yo\",\"\":\"dj\",\"\":\"ye\",\"\":\"i\",\"\":\"yi\",\"\":\"j\",\"\":\"lj\",\"\":\"nj\",\"\":\"c\",\"\":\"u\",\"\":\"dz\",\"\":\"G\",\"\":\"g\",\"\":\"GH\",\"\":\"gh\",\"\":\"KH\",\"\":\"kh\",\"\":\"NG\",\"\":\"ng\",\"\":\"UE\",\"\":\"ue\",\"\":\"U\",\"\":\"u\",\"\":\"H\",\"\":\"h\",\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"E'\",\"\":\"Y'\",\"\":\"T'\",\"\":\"JH\",\"\":\"I\",\"\":\"L\",\"\":\"X\",\"\":\"C'\",\"\":\"K\",\"\":\"H\",\"\":\"D'\",\"\":\"GH\",\"\":\"TW\",\"\":\"M\",\"\":\"Y\",\"\":\"N\",\"\":\"SH\",\"\":\"CH\",\"\":\"P\",\"\":\"J\",\"\":\"R'\",\"\":\"S\",\"\":\"V\",\"\":\"T\",\"\":\"R\",\"\":\"C\",\"\":\"P'\",\"\":\"Q'\",\"\":\"O''\",\"\":\"F\",\"\":\"EV\",\"\":\"a\",\"\":\"aa\",\"\":\"a\",\"\":\"u\",\"\":\"i\",\"\":\"e\",\"\":\"a\",\"\":\"b\",\"\":\"h\",\"\":\"t\",\"\":\"th\",\"\":\"j\",\"\":\"h\",\"\":\"kh\",\"\":\"d\",\"\":\"th\",\"\":\"r\",\"\":\"z\",\"\":\"s\",\"\":\"sh\",\"\":\"s\",\"\":\"dh\",\"\":\"t\",\"\":\"z\",\"\":\"a\",\"\":\"gh\",\"\":\"f\",\"\":\"q\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"h\",\"\":\"w\",\"\":\"a\",\"\":\"y\",\"\":\"an\",\"\":\"on\",\"\":\"en\",\"\":\"a\",\"\":\"u\",\"\":\"e\",\"\":\"\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"p\",\"\":\"ch\",\"\":\"zh\",\"\":\"k\",\"\":\"g\",\"\":\"y\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"baht\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"v\",\"\":\"z\",\"\":\"t\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"zh\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"k\",\"\":\"gh\",\"\":\"q\",\"\":\"sh\",\"\":\"ch\",\"\":\"ts\",\"\":\"dz\",\"\":\"ts\",\"\":\"ch\",\"\":\"kh\",\"\":\"j\",\"\":\"h\",\"\":\"S\",\"\":\"s\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"SS\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"-\",\"\":\"'\",\"\":\"'\",\"\":\"\\\"\",\"\":\"\\\"\",\"\":\"\\\"\",\"\":\"+\",\"\":\"*\",\"\":\"...\",\"\":\"ecu\",\"\":\"cruzeiro\",\"\":\"french franc\",\"\":\"lira\",\"\":\"mill\",\"\":\"naira\",\"\":\"peseta\",\"\":\"rupee\",\"\":\"won\",\"\":\"new shequel\",\"\":\"dong\",\"\":\"euro\",\"\":\"kip\",\"\":\"tugrik\",\"\":\"drachma\",\"\":\"penny\",\"\":\"peso\",\"\":\"guarani\",\"\":\"austral\",\"\":\"hryvnia\",\"\":\"cedi\",\"\":\"kazakhstani tenge\",\"\":\"indian rupee\",\"\":\"turkish lira\",\"\":\"russian ruble\",\"\":\"bitcoin\",\"\":\"sm\",\"\":\"tm\",\"\":\"d\",\"\":\"delta\",\"\":\"sum\",\"\":\"infinity\",\"\":\"love\",\"\":\"yuan\",\"\":\"yen\",\"\":\"rial\",\"\":\"laa\",\"\":\"laa\",\"\":\"lai\",\"\":\"la\"}");
		var locales = JSON.parse("{\"bg\":{\"\":\"Y\",\"\":\"Ts\",\"\":\"Sht\",\"\":\"A\",\"\":\"Y\",\"\":\"y\",\"\":\"ts\",\"\":\"sht\",\"\":\"a\",\"\":\"y\"},\"de\":{\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"UE\",\"\":\"ue\",\"\":\"ss\",\"%\":\"prozent\",\"&\":\"und\",\"|\":\"oder\",\"\":\"summe\",\"\":\"unendlich\",\"\":\"liebe\"},\"es\":{\"%\":\"por ciento\",\"&\":\"y\",\"<\":\"menor que\",\">\":\"mayor que\",\"|\":\"o\",\"\":\"centavos\",\"\":\"libras\",\"\":\"moneda\",\"\":\"francos\",\"\":\"suma\",\"\":\"infinito\",\"\":\"amor\"},\"fr\":{\"%\":\"pourcent\",\"&\":\"et\",\"<\":\"plus petit\",\">\":\"plus grand\",\"|\":\"ou\",\"\":\"centime\",\"\":\"livre\",\"\":\"devise\",\"\":\"franc\",\"\":\"somme\",\"\":\"infini\",\"\":\"amour\"},\"pt\":{\"%\":\"porcento\",\"&\":\"e\",\"<\":\"menor\",\">\":\"maior\",\"|\":\"ou\",\"\":\"centavo\",\"\":\"soma\",\"\":\"libra\",\"\":\"infinito\",\"\":\"amor\"},\"uk\":{\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Ts\",\"\":\"ts\",\"\":\"Kh\",\"\":\"kh\",\"\":\"Shch\",\"\":\"shch\",\"\":\"H\",\"\":\"h\"},\"vi\":{\"\":\"D\",\"\":\"d\"},\"da\":{\"\":\"OE\",\"\":\"oe\",\"\":\"AA\",\"\":\"aa\",\"%\":\"procent\",\"&\":\"og\",\"|\":\"eller\",\"$\":\"dollar\",\"<\":\"mindre end\",\">\":\"strre end\"},\"nb\":{\"&\":\"og\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"},\"it\":{\"&\":\"e\"},\"nl\":{\"&\":\"en\"},\"sv\":{\"&\":\"och\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"}}");
		function replace(string, options) {
			if (typeof string !== "string") throw new Error("slugify: string argument expected");
			options = typeof options === "string" ? { replacement: options } : options || {};
			var locale = locales[options.locale] || {};
			var replacement = options.replacement === void 0 ? "-" : options.replacement;
			var trim = options.trim === void 0 ? true : options.trim;
			var slug = string.normalize().split("").reduce(function(result, ch) {
				var appendChar = locale[ch];
				if (appendChar === void 0) appendChar = charMap[ch];
				if (appendChar === void 0) appendChar = ch;
				if (appendChar === replacement) appendChar = " ";
				return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
			}, "");
			if (options.strict) slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
			if (trim) slug = slug.trim();
			slug = slug.replace(/\s+/g, replacement);
			if (options.lower) slug = slug.toLowerCase();
			return slug;
		}
		replace.extend = function(customMap) {
			Object.assign(charMap, customMap);
		};
		return replace;
	});
}));

//#endregion
//#region ../cli/src/core/core.ts
/**
* Core  Shared utilities, constants, and internal helpers
*
* Ported from maxsim/bin/lib/core.cjs
*/
var import_slugify = /* @__PURE__ */ __toESM(require_slugify());
function normalizePhaseName(phase) {
	const match = phase.match(/^(\d+)([A-Z])?(\.\d+)?/i);
	if (!match) return phase;
	const padded = match[1].padStart(2, "0");
	const letter = match[2] ? match[2].toUpperCase() : "";
	const decimal = match[3] || "";
	return padded + letter + decimal;
}
function comparePhaseNum(a, b) {
	const pa = String(a).match(/^(\d+)([A-Z])?(\.\d+)?/i);
	const pb = String(b).match(/^(\d+)([A-Z])?(\.\d+)?/i);
	if (!pa || !pb) return String(a).localeCompare(String(b));
	const intDiff = parseInt(pa[1], 10) - parseInt(pb[1], 10);
	if (intDiff !== 0) return intDiff;
	const la = (pa[2] || "").toUpperCase();
	const lb = (pb[2] || "").toUpperCase();
	if (la !== lb) {
		if (!la) return -1;
		if (!lb) return 1;
		return la < lb ? -1 : 1;
	}
	return (pa[3] ? parseFloat(pa[3]) : -1) - (pb[3] ? parseFloat(pb[3]) : -1);
}
/**
* Returns the canonical regex for matching Phase heading lines in ROADMAP.md.
*
* General form (no escapedPhaseNum):
*   Matches: ## Phase 03: Name Here
*   Group 1: phase number string (e.g. "03", "3A", "2.1")
*   Group 2: phase name string (e.g. "Name Here")
*
* Specific form (with escapedPhaseNum):
*   Matches: ## Phase 03: Name Here
*   Group 1: phase name string only
*
* @param escapedPhaseNum - regex-escaped phase number string to match a specific phase
* @param flags - regex flags (default: 'gi')
*/
function getPhasePattern(escapedPhaseNum, flags = "gim") {
	if (escapedPhaseNum) return new RegExp(`^#{2,4}\\s*Phase\\s+${escapedPhaseNum}:\\s*([^\\n]+)`, flags);
	return new RegExp(`^#{2,4}\\s*Phase\\s+(\\d+[A-Z]?(?:\\.\\d+)?)\\s*:\\s*([^\\n]+)`, flags);
}

//#endregion
//#region ../../node_modules/yaml/dist/nodes/identity.js
var require_identity = /* @__PURE__ */ __commonJSMin(((exports) => {
	const ALIAS = Symbol.for("yaml.alias");
	const DOC = Symbol.for("yaml.document");
	const MAP = Symbol.for("yaml.map");
	const PAIR = Symbol.for("yaml.pair");
	const SCALAR = Symbol.for("yaml.scalar");
	const SEQ = Symbol.for("yaml.seq");
	const NODE_TYPE = Symbol.for("yaml.node.type");
	const isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
	const isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
	const isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
	const isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
	const isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
	const isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
	function isCollection(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case MAP:
			case SEQ: return true;
		}
		return false;
	}
	function isNode(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case ALIAS:
			case MAP:
			case SCALAR:
			case SEQ: return true;
		}
		return false;
	}
	const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
	exports.ALIAS = ALIAS;
	exports.DOC = DOC;
	exports.MAP = MAP;
	exports.NODE_TYPE = NODE_TYPE;
	exports.PAIR = PAIR;
	exports.SCALAR = SCALAR;
	exports.SEQ = SEQ;
	exports.hasAnchor = hasAnchor;
	exports.isAlias = isAlias;
	exports.isCollection = isCollection;
	exports.isDocument = isDocument;
	exports.isMap = isMap;
	exports.isNode = isNode;
	exports.isPair = isPair;
	exports.isScalar = isScalar;
	exports.isSeq = isSeq;
}));

//#endregion
//#region ../../node_modules/yaml/dist/visit.js
var require_visit = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	const BREAK = Symbol("break visit");
	const SKIP = Symbol("skip children");
	const REMOVE = Symbol("remove node");
	/**
	* Apply a visitor to an AST node or document.
	*
	* Walks through the tree (depth-first) starting from `node`, calling a
	* `visitor` function with three arguments:
	*   - `key`: For sequence values and map `Pair`, the node's index in the
	*     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	*     `null` for the root node.
	*   - `node`: The current node.
	*   - `path`: The ancestry of the current node.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this node, continue with next
	*     sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current node, then continue with the next one
	*   - `Node`: Replace the current node, then continue by visiting it
	*   - `number`: While iterating the items of a sequence or map, set the index
	*     of the next step. This is useful especially if the index of the current
	*     node has changed.
	*
	* If `visitor` is a single function, it will be called with all values
	* encountered in the tree, including e.g. `null` values. Alternatively,
	* separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	* `Alias` and `Scalar` node. To define the same visitor function for more than
	* one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	* and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	* specific defined one will be used for each node.
	*/
	function visit(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity.isDocument(node)) {
			if (visit_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE) node.contents = null;
		} else visit_(null, node, visitor_, Object.freeze([]));
	}
	/** Terminate visit traversal completely */
	visit.BREAK = BREAK;
	/** Do not visit the children of the current node */
	visit.SKIP = SKIP;
	/** Remove the current node */
	visit.REMOVE = REMOVE;
	function visit_(key, node, visitor, path) {
		const ctrl = callVisitor(key, node, visitor, path);
		if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
			replaceNode(key, path, ctrl);
			return visit_(key, ctrl, visitor, path);
		}
		if (typeof ctrl !== "symbol") {
			if (identity.isCollection(node)) {
				path = Object.freeze(path.concat(node));
				for (let i = 0; i < node.items.length; ++i) {
					const ci = visit_(i, node.items[i], visitor, path);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						node.items.splice(i, 1);
						i -= 1;
					}
				}
			} else if (identity.isPair(node)) {
				path = Object.freeze(path.concat(node));
				const ck = visit_("key", node.key, visitor, path);
				if (ck === BREAK) return BREAK;
				else if (ck === REMOVE) node.key = null;
				const cv = visit_("value", node.value, visitor, path);
				if (cv === BREAK) return BREAK;
				else if (cv === REMOVE) node.value = null;
			}
		}
		return ctrl;
	}
	/**
	* Apply an async visitor to an AST node or document.
	*
	* Walks through the tree (depth-first) starting from `node`, calling a
	* `visitor` function with three arguments:
	*   - `key`: For sequence values and map `Pair`, the node's index in the
	*     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
	*     `null` for the root node.
	*   - `node`: The current node.
	*   - `path`: The ancestry of the current node.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `Promise`: Must resolve to one of the following values
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this node, continue with next
	*     sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current node, then continue with the next one
	*   - `Node`: Replace the current node, then continue by visiting it
	*   - `number`: While iterating the items of a sequence or map, set the index
	*     of the next step. This is useful especially if the index of the current
	*     node has changed.
	*
	* If `visitor` is a single function, it will be called with all values
	* encountered in the tree, including e.g. `null` values. Alternatively,
	* separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
	* `Alias` and `Scalar` node. To define the same visitor function for more than
	* one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
	* and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
	* specific defined one will be used for each node.
	*/
	async function visitAsync(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity.isDocument(node)) {
			if (await visitAsync_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE) node.contents = null;
		} else await visitAsync_(null, node, visitor_, Object.freeze([]));
	}
	/** Terminate visit traversal completely */
	visitAsync.BREAK = BREAK;
	/** Do not visit the children of the current node */
	visitAsync.SKIP = SKIP;
	/** Remove the current node */
	visitAsync.REMOVE = REMOVE;
	async function visitAsync_(key, node, visitor, path) {
		const ctrl = await callVisitor(key, node, visitor, path);
		if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
			replaceNode(key, path, ctrl);
			return visitAsync_(key, ctrl, visitor, path);
		}
		if (typeof ctrl !== "symbol") {
			if (identity.isCollection(node)) {
				path = Object.freeze(path.concat(node));
				for (let i = 0; i < node.items.length; ++i) {
					const ci = await visitAsync_(i, node.items[i], visitor, path);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						node.items.splice(i, 1);
						i -= 1;
					}
				}
			} else if (identity.isPair(node)) {
				path = Object.freeze(path.concat(node));
				const ck = await visitAsync_("key", node.key, visitor, path);
				if (ck === BREAK) return BREAK;
				else if (ck === REMOVE) node.key = null;
				const cv = await visitAsync_("value", node.value, visitor, path);
				if (cv === BREAK) return BREAK;
				else if (cv === REMOVE) node.value = null;
			}
		}
		return ctrl;
	}
	function initVisitor(visitor) {
		if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
			Alias: visitor.Node,
			Map: visitor.Node,
			Scalar: visitor.Node,
			Seq: visitor.Node
		}, visitor.Value && {
			Map: visitor.Value,
			Scalar: visitor.Value,
			Seq: visitor.Value
		}, visitor.Collection && {
			Map: visitor.Collection,
			Seq: visitor.Collection
		}, visitor);
		return visitor;
	}
	function callVisitor(key, node, visitor, path) {
		if (typeof visitor === "function") return visitor(key, node, path);
		if (identity.isMap(node)) return visitor.Map?.(key, node, path);
		if (identity.isSeq(node)) return visitor.Seq?.(key, node, path);
		if (identity.isPair(node)) return visitor.Pair?.(key, node, path);
		if (identity.isScalar(node)) return visitor.Scalar?.(key, node, path);
		if (identity.isAlias(node)) return visitor.Alias?.(key, node, path);
	}
	function replaceNode(key, path, node) {
		const parent = path[path.length - 1];
		if (identity.isCollection(parent)) parent.items[key] = node;
		else if (identity.isPair(parent)) if (key === "key") parent.key = node;
		else parent.value = node;
		else if (identity.isDocument(parent)) parent.contents = node;
		else {
			const pt = identity.isAlias(parent) ? "alias" : "scalar";
			throw new Error(`Cannot replace node with ${pt} parent`);
		}
	}
	exports.visit = visit;
	exports.visitAsync = visitAsync;
}));

//#endregion
//#region ../../node_modules/yaml/dist/doc/directives.js
var require_directives = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var visit = require_visit();
	const escapeChars = {
		"!": "%21",
		",": "%2C",
		"[": "%5B",
		"]": "%5D",
		"{": "%7B",
		"}": "%7D"
	};
	const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
	var Directives = class Directives {
		constructor(yaml, tags) {
			/**
			* The directives-end/doc-start marker `---`. If `null`, a marker may still be
			* included in the document's stringified representation.
			*/
			this.docStart = null;
			/** The doc-end marker `...`.  */
			this.docEnd = false;
			this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
			this.tags = Object.assign({}, Directives.defaultTags, tags);
		}
		clone() {
			const copy = new Directives(this.yaml, this.tags);
			copy.docStart = this.docStart;
			return copy;
		}
		/**
		* During parsing, get a Directives instance for the current document and
		* update the stream state according to the current version's spec.
		*/
		atDocument() {
			const res = new Directives(this.yaml, this.tags);
			switch (this.yaml.version) {
				case "1.1":
					this.atNextDocument = true;
					break;
				case "1.2":
					this.atNextDocument = false;
					this.yaml = {
						explicit: Directives.defaultYaml.explicit,
						version: "1.2"
					};
					this.tags = Object.assign({}, Directives.defaultTags);
					break;
			}
			return res;
		}
		/**
		* @param onError - May be called even if the action was successful
		* @returns `true` on success
		*/
		add(line, onError) {
			if (this.atNextDocument) {
				this.yaml = {
					explicit: Directives.defaultYaml.explicit,
					version: "1.1"
				};
				this.tags = Object.assign({}, Directives.defaultTags);
				this.atNextDocument = false;
			}
			const parts = line.trim().split(/[ \t]+/);
			const name = parts.shift();
			switch (name) {
				case "%TAG": {
					if (parts.length !== 2) {
						onError(0, "%TAG directive should contain exactly two parts");
						if (parts.length < 2) return false;
					}
					const [handle, prefix] = parts;
					this.tags[handle] = prefix;
					return true;
				}
				case "%YAML": {
					this.yaml.explicit = true;
					if (parts.length !== 1) {
						onError(0, "%YAML directive should contain exactly one part");
						return false;
					}
					const [version] = parts;
					if (version === "1.1" || version === "1.2") {
						this.yaml.version = version;
						return true;
					} else {
						const isValid = /^\d+\.\d+$/.test(version);
						onError(6, `Unsupported YAML version ${version}`, isValid);
						return false;
					}
				}
				default:
					onError(0, `Unknown directive ${name}`, true);
					return false;
			}
		}
		/**
		* Resolves a tag, matching handles to those defined in %TAG directives.
		*
		* @returns Resolved tag, which may also be the non-specific tag `'!'` or a
		*   `'!local'` tag, or `null` if unresolvable.
		*/
		tagName(source, onError) {
			if (source === "!") return "!";
			if (source[0] !== "!") {
				onError(`Not a valid tag: ${source}`);
				return null;
			}
			if (source[1] === "<") {
				const verbatim = source.slice(2, -1);
				if (verbatim === "!" || verbatim === "!!") {
					onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
					return null;
				}
				if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
				return verbatim;
			}
			const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
			if (!suffix) onError(`The ${source} tag has no suffix`);
			const prefix = this.tags[handle];
			if (prefix) try {
				return prefix + decodeURIComponent(suffix);
			} catch (error) {
				onError(String(error));
				return null;
			}
			if (handle === "!") return source;
			onError(`Could not resolve tag: ${source}`);
			return null;
		}
		/**
		* Given a fully resolved tag, returns its printable string form,
		* taking into account current tag prefixes and defaults.
		*/
		tagString(tag) {
			for (const [handle, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
			return tag[0] === "!" ? tag : `!<${tag}>`;
		}
		toString(doc) {
			const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
			const tagEntries = Object.entries(this.tags);
			let tagNames;
			if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
				const tags = {};
				visit.visit(doc.contents, (_key, node) => {
					if (identity.isNode(node) && node.tag) tags[node.tag] = true;
				});
				tagNames = Object.keys(tags);
			} else tagNames = [];
			for (const [handle, prefix] of tagEntries) {
				if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
				if (!doc || tagNames.some((tn) => tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
			}
			return lines.join("\n");
		}
	};
	Directives.defaultYaml = {
		explicit: false,
		version: "1.2"
	};
	Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
	exports.Directives = Directives;
}));

//#endregion
//#region ../../node_modules/yaml/dist/doc/anchors.js
var require_anchors = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var visit = require_visit();
	/**
	* Verify that the input string is a valid anchor.
	*
	* Will throw on errors.
	*/
	function anchorIsValid(anchor) {
		if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
			const msg = `Anchor must not contain whitespace or control characters: ${JSON.stringify(anchor)}`;
			throw new Error(msg);
		}
		return true;
	}
	function anchorNames(root) {
		const anchors = /* @__PURE__ */ new Set();
		visit.visit(root, { Value(_key, node) {
			if (node.anchor) anchors.add(node.anchor);
		} });
		return anchors;
	}
	/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
	function findNewAnchor(prefix, exclude) {
		for (let i = 1;; ++i) {
			const name = `${prefix}${i}`;
			if (!exclude.has(name)) return name;
		}
	}
	function createNodeAnchors(doc, prefix) {
		const aliasObjects = [];
		const sourceObjects = /* @__PURE__ */ new Map();
		let prevAnchors = null;
		return {
			onAnchor: (source) => {
				aliasObjects.push(source);
				prevAnchors ?? (prevAnchors = anchorNames(doc));
				const anchor = findNewAnchor(prefix, prevAnchors);
				prevAnchors.add(anchor);
				return anchor;
			},
			setAnchors: () => {
				for (const source of aliasObjects) {
					const ref = sourceObjects.get(source);
					if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) ref.node.anchor = ref.anchor;
					else {
						const error = /* @__PURE__ */ new Error("Failed to resolve repeated object (this should not happen)");
						error.source = source;
						throw error;
					}
				}
			},
			sourceObjects
		};
	}
	exports.anchorIsValid = anchorIsValid;
	exports.anchorNames = anchorNames;
	exports.createNodeAnchors = createNodeAnchors;
	exports.findNewAnchor = findNewAnchor;
}));

//#endregion
//#region ../../node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
	* in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
	* 2021 edition: https://tc39.es/ecma262/#sec-json.parse
	*
	* Includes extensions for handling Map and Set objects.
	*/
	function applyReviver(reviver, obj, key, val) {
		if (val && typeof val === "object") if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
			const v0 = val[i];
			const v1 = applyReviver(reviver, val, String(i), v0);
			if (v1 === void 0) delete val[i];
			else if (v1 !== v0) val[i] = v1;
		}
		else if (val instanceof Map) for (const k of Array.from(val.keys())) {
			const v0 = val.get(k);
			const v1 = applyReviver(reviver, val, k, v0);
			if (v1 === void 0) val.delete(k);
			else if (v1 !== v0) val.set(k, v1);
		}
		else if (val instanceof Set) for (const v0 of Array.from(val)) {
			const v1 = applyReviver(reviver, val, v0, v0);
			if (v1 === void 0) val.delete(v0);
			else if (v1 !== v0) {
				val.delete(v0);
				val.add(v1);
			}
		}
		else for (const [k, v0] of Object.entries(val)) {
			const v1 = applyReviver(reviver, val, k, v0);
			if (v1 === void 0) delete val[k];
			else if (v1 !== v0) val[k] = v1;
		}
		return reviver.call(obj, key, val);
	}
	exports.applyReviver = applyReviver;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/toJS.js
var require_toJS = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	/**
	* Recursively convert any node or its contents to native JavaScript
	*
	* @param value - The input value
	* @param arg - If `value` defines a `toJSON()` method, use this
	*   as its first argument
	* @param ctx - Conversion context, originally set in Document#toJS(). If
	*   `{ keep: true }` is not set, output should be suitable for JSON
	*   stringification.
	*/
	function toJS(value, arg, ctx) {
		if (Array.isArray(value)) return value.map((v, i) => toJS(v, String(i), ctx));
		if (value && typeof value.toJSON === "function") {
			if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
			const data = {
				aliasCount: 0,
				count: 1,
				res: void 0
			};
			ctx.anchors.set(value, data);
			ctx.onCreate = (res) => {
				data.res = res;
				delete ctx.onCreate;
			};
			const res = value.toJSON(arg, ctx);
			if (ctx.onCreate) ctx.onCreate(res);
			return res;
		}
		if (typeof value === "bigint" && !ctx?.keep) return Number(value);
		return value;
	}
	exports.toJS = toJS;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/Node.js
var require_Node = /* @__PURE__ */ __commonJSMin(((exports) => {
	var applyReviver = require_applyReviver();
	var identity = require_identity();
	var toJS = require_toJS();
	var NodeBase = class {
		constructor(type) {
			Object.defineProperty(this, identity.NODE_TYPE, { value: type });
		}
		/** Create a copy of this node.  */
		clone() {
			const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (this.range) copy.range = this.range.slice();
			return copy;
		}
		/** A plain JavaScript representation of this node. */
		toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc,
				keep: true,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS.toJS(this, "", ctx);
			if (typeof onAnchor === "function") for (const { count, res } of ctx.anchors.values()) onAnchor(res, count);
			return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
		}
	};
	exports.NodeBase = NodeBase;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/Alias.js
var require_Alias = /* @__PURE__ */ __commonJSMin(((exports) => {
	var anchors = require_anchors();
	var visit = require_visit();
	var identity = require_identity();
	var Node = require_Node();
	var toJS = require_toJS();
	var Alias = class extends Node.NodeBase {
		constructor(source) {
			super(identity.ALIAS);
			this.source = source;
			Object.defineProperty(this, "tag", { set() {
				throw new Error("Alias nodes cannot have tags");
			} });
		}
		/**
		* Resolve the value of this alias within `doc`, finding the last
		* instance of the `source` anchor before this node.
		*/
		resolve(doc, ctx) {
			let nodes;
			if (ctx?.aliasResolveCache) nodes = ctx.aliasResolveCache;
			else {
				nodes = [];
				visit.visit(doc, { Node: (_key, node) => {
					if (identity.isAlias(node) || identity.hasAnchor(node)) nodes.push(node);
				} });
				if (ctx) ctx.aliasResolveCache = nodes;
			}
			let found = void 0;
			for (const node of nodes) {
				if (node === this) break;
				if (node.anchor === this.source) found = node;
			}
			return found;
		}
		toJSON(_arg, ctx) {
			if (!ctx) return { source: this.source };
			const { anchors, doc, maxAliasCount } = ctx;
			const source = this.resolve(doc, ctx);
			if (!source) {
				const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
				throw new ReferenceError(msg);
			}
			let data = anchors.get(source);
			if (!data) {
				toJS.toJS(source, null, ctx);
				data = anchors.get(source);
			}
			/* istanbul ignore if */
			if (data?.res === void 0) throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
			if (maxAliasCount >= 0) {
				data.count += 1;
				if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
				if (data.count * data.aliasCount > maxAliasCount) throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
			}
			return data.res;
		}
		toString(ctx, _onComment, _onChompKeep) {
			const src = `*${this.source}`;
			if (ctx) {
				anchors.anchorIsValid(this.source);
				if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
					const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
					throw new Error(msg);
				}
				if (ctx.implicitKey) return `${src} `;
			}
			return src;
		}
	};
	function getAliasCount(doc, node, anchors) {
		if (identity.isAlias(node)) {
			const source = node.resolve(doc);
			const anchor = anchors && source && anchors.get(source);
			return anchor ? anchor.count * anchor.aliasCount : 0;
		} else if (identity.isCollection(node)) {
			let count = 0;
			for (const item of node.items) {
				const c = getAliasCount(doc, item, anchors);
				if (c > count) count = c;
			}
			return count;
		} else if (identity.isPair(node)) {
			const kc = getAliasCount(doc, node.key, anchors);
			const vc = getAliasCount(doc, node.value, anchors);
			return Math.max(kc, vc);
		}
		return 1;
	}
	exports.Alias = Alias;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Node = require_Node();
	var toJS = require_toJS();
	const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
	var Scalar = class extends Node.NodeBase {
		constructor(value) {
			super(identity.SCALAR);
			this.value = value;
		}
		toJSON(arg, ctx) {
			return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
		}
		toString() {
			return String(this.value);
		}
	};
	Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
	Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
	Scalar.PLAIN = "PLAIN";
	Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
	Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
	exports.Scalar = Scalar;
	exports.isScalarValue = isScalarValue;
}));

//#endregion
//#region ../../node_modules/yaml/dist/doc/createNode.js
var require_createNode = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var identity = require_identity();
	var Scalar = require_Scalar();
	const defaultTagPrefix = "tag:yaml.org,2002:";
	function findTagObject(value, tagName, tags) {
		if (tagName) {
			const match = tags.filter((t) => t.tag === tagName);
			const tagObj = match.find((t) => !t.format) ?? match[0];
			if (!tagObj) throw new Error(`Tag ${tagName} not found`);
			return tagObj;
		}
		return tags.find((t) => t.identify?.(value) && !t.format);
	}
	function createNode(value, tagName, ctx) {
		if (identity.isDocument(value)) value = value.contents;
		if (identity.isNode(value)) return value;
		if (identity.isPair(value)) {
			const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
			map.items.push(value);
			return map;
		}
		if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) value = value.valueOf();
		const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
		let ref = void 0;
		if (aliasDuplicateObjects && value && typeof value === "object") {
			ref = sourceObjects.get(value);
			if (ref) {
				ref.anchor ?? (ref.anchor = onAnchor(value));
				return new Alias.Alias(ref.anchor);
			} else {
				ref = {
					anchor: null,
					node: null
				};
				sourceObjects.set(value, ref);
			}
		}
		if (tagName?.startsWith("!!")) tagName = defaultTagPrefix + tagName.slice(2);
		let tagObj = findTagObject(value, tagName, schema.tags);
		if (!tagObj) {
			if (value && typeof value.toJSON === "function") value = value.toJSON();
			if (!value || typeof value !== "object") {
				const node = new Scalar.Scalar(value);
				if (ref) ref.node = node;
				return node;
			}
			tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
		}
		if (onTagObj) {
			onTagObj(tagObj);
			delete ctx.onTagObj;
		}
		const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
		if (tagName) node.tag = tagName;
		else if (!tagObj.default) node.tag = tagObj.tag;
		if (ref) ref.node = node;
		return node;
	}
	exports.createNode = createNode;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/Collection.js
var require_Collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var identity = require_identity();
	var Node = require_Node();
	function collectionFromPath(schema, path, value) {
		let v = value;
		for (let i = path.length - 1; i >= 0; --i) {
			const k = path[i];
			if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
				const a = [];
				a[k] = v;
				v = a;
			} else v = new Map([[k, v]]);
		}
		return createNode.createNode(v, void 0, {
			aliasDuplicateObjects: false,
			keepUndefined: false,
			onAnchor: () => {
				throw new Error("This should not happen, please report a bug.");
			},
			schema,
			sourceObjects: /* @__PURE__ */ new Map()
		});
	}
	const isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
	var Collection = class extends Node.NodeBase {
		constructor(type, schema) {
			super(type);
			Object.defineProperty(this, "schema", {
				value: schema,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
		/**
		* Create a copy of this collection.
		*
		* @param schema - If defined, overwrites the original's schema
		*/
		clone(schema) {
			const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (schema) copy.schema = schema;
			copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
			if (this.range) copy.range = this.range.slice();
			return copy;
		}
		/**
		* Adds a value to the collection. For `!!map` and `!!omap` the value must
		* be a Pair instance or a `{ key, value }` object, which may not have a key
		* that already exists in the map.
		*/
		addIn(path, value) {
			if (isEmptyPath(path)) this.add(value);
			else {
				const [key, ...rest] = path;
				const node = this.get(key, true);
				if (identity.isCollection(node)) node.addIn(rest, value);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
		/**
		* Removes a value from the collection.
		* @returns `true` if the item was found and removed.
		*/
		deleteIn(path) {
			const [key, ...rest] = path;
			if (rest.length === 0) return this.delete(key);
			const node = this.get(key, true);
			if (identity.isCollection(node)) return node.deleteIn(rest);
			else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
		}
		/**
		* Returns item at `key`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		getIn(path, keepScalar) {
			const [key, ...rest] = path;
			const node = this.get(key, true);
			if (rest.length === 0) return !keepScalar && identity.isScalar(node) ? node.value : node;
			else return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
		}
		hasAllNullValues(allowScalar) {
			return this.items.every((node) => {
				if (!identity.isPair(node)) return false;
				const n = node.value;
				return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
			});
		}
		/**
		* Checks if the collection includes a value with the key `key`.
		*/
		hasIn(path) {
			const [key, ...rest] = path;
			if (rest.length === 0) return this.has(key);
			const node = this.get(key, true);
			return identity.isCollection(node) ? node.hasIn(rest) : false;
		}
		/**
		* Sets a value in this collection. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		setIn(path, value) {
			const [key, ...rest] = path;
			if (rest.length === 0) this.set(key, value);
			else {
				const node = this.get(key, true);
				if (identity.isCollection(node)) node.setIn(rest, value);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
	};
	exports.Collection = Collection;
	exports.collectionFromPath = collectionFromPath;
	exports.isEmptyPath = isEmptyPath;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Stringifies a comment.
	*
	* Empty comment lines are left empty,
	* lines consisting of a single space are replaced by `#`,
	* and all other lines are prefixed with a `#`.
	*/
	const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
	function indentComment(comment, indent) {
		if (/^\n+$/.test(comment)) return comment.substring(1);
		return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
	}
	const lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
	exports.indentComment = indentComment;
	exports.lineComment = lineComment;
	exports.stringifyComment = stringifyComment;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = /* @__PURE__ */ __commonJSMin(((exports) => {
	const FOLD_FLOW = "flow";
	const FOLD_BLOCK = "block";
	const FOLD_QUOTED = "quoted";
	/**
	* Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	* not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	* terminated with `\n` and started with `indent`.
	*/
	function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
		if (!lineWidth || lineWidth < 0) return text;
		if (lineWidth < minContentWidth) minContentWidth = 0;
		const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
		if (text.length <= endStep) return text;
		const folds = [];
		const escapedFolds = {};
		let end = lineWidth - indent.length;
		if (typeof indentAtStart === "number") if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
		else end = lineWidth - indentAtStart;
		let split = void 0;
		let prev = void 0;
		let overflow = false;
		let i = -1;
		let escStart = -1;
		let escEnd = -1;
		if (mode === FOLD_BLOCK) {
			i = consumeMoreIndentedLines(text, i, indent.length);
			if (i !== -1) end = i + endStep;
		}
		for (let ch; ch = text[i += 1];) {
			if (mode === FOLD_QUOTED && ch === "\\") {
				escStart = i;
				switch (text[i + 1]) {
					case "x":
						i += 3;
						break;
					case "u":
						i += 5;
						break;
					case "U":
						i += 9;
						break;
					default: i += 1;
				}
				escEnd = i;
			}
			if (ch === "\n") {
				if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i, indent.length);
				end = i + indent.length + endStep;
				split = void 0;
			} else {
				if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
					const next = text[i + 1];
					if (next && next !== " " && next !== "\n" && next !== "	") split = i;
				}
				if (i >= end) if (split) {
					folds.push(split);
					end = split + endStep;
					split = void 0;
				} else if (mode === FOLD_QUOTED) {
					while (prev === " " || prev === "	") {
						prev = ch;
						ch = text[i += 1];
						overflow = true;
					}
					const j = i > escEnd + 1 ? i - 2 : escStart - 1;
					if (escapedFolds[j]) return text;
					folds.push(j);
					escapedFolds[j] = true;
					end = j + endStep;
					split = void 0;
				} else overflow = true;
			}
			prev = ch;
		}
		if (overflow && onOverflow) onOverflow();
		if (folds.length === 0) return text;
		if (onFold) onFold();
		let res = text.slice(0, folds[0]);
		for (let i = 0; i < folds.length; ++i) {
			const fold = folds[i];
			const end = folds[i + 1] || text.length;
			if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;
			else {
				if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
				res += `\n${indent}${text.slice(fold + 1, end)}`;
			}
		}
		return res;
	}
	/**
	* Presumes `i + 1` is at the start of a line
	* @returns index of last newline in more-indented block
	*/
	function consumeMoreIndentedLines(text, i, indent) {
		let end = i;
		let start = i + 1;
		let ch = text[start];
		while (ch === " " || ch === "	") if (i < start + indent) ch = text[++i];
		else {
			do
				ch = text[++i];
			while (ch && ch !== "\n");
			end = i;
			start = i + 1;
			ch = text[start];
		}
		return end;
	}
	exports.FOLD_BLOCK = FOLD_BLOCK;
	exports.FOLD_FLOW = FOLD_FLOW;
	exports.FOLD_QUOTED = FOLD_QUOTED;
	exports.foldFlowLines = foldFlowLines;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var foldFlowLines = require_foldFlowLines();
	const getFoldOptions = (ctx, isBlock) => ({
		indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
		lineWidth: ctx.options.lineWidth,
		minContentWidth: ctx.options.minContentWidth
	});
	const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
	function lineLengthOverLimit(str, lineWidth, indentLength) {
		if (!lineWidth || lineWidth < 0) return false;
		const limit = lineWidth - indentLength;
		const strLen = str.length;
		if (strLen <= limit) return false;
		for (let i = 0, start = 0; i < strLen; ++i) if (str[i] === "\n") {
			if (i - start > limit) return true;
			start = i + 1;
			if (strLen - start <= limit) return false;
		}
		return true;
	}
	function doubleQuotedString(value, ctx) {
		const json = JSON.stringify(value);
		if (ctx.options.doubleQuotedAsJSON) return json;
		const { implicitKey } = ctx;
		const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
		const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
		let str = "";
		let start = 0;
		for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
			if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
				str += json.slice(start, i) + "\\ ";
				i += 1;
				start = i;
				ch = "\\";
			}
			if (ch === "\\") switch (json[i + 1]) {
				case "u":
					{
						str += json.slice(start, i);
						const code = json.substr(i + 2, 4);
						switch (code) {
							case "0000":
								str += "\\0";
								break;
							case "0007":
								str += "\\a";
								break;
							case "000b":
								str += "\\v";
								break;
							case "001b":
								str += "\\e";
								break;
							case "0085":
								str += "\\N";
								break;
							case "00a0":
								str += "\\_";
								break;
							case "2028":
								str += "\\L";
								break;
							case "2029":
								str += "\\P";
								break;
							default: if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
							else str += json.substr(i, 6);
						}
						i += 5;
						start = i + 1;
					}
					break;
				case "n":
					if (implicitKey || json[i + 2] === "\"" || json.length < minMultiLineLength) i += 1;
					else {
						str += json.slice(start, i) + "\n\n";
						while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== "\"") {
							str += "\n";
							i += 2;
						}
						str += indent;
						if (json[i + 2] === " ") str += "\\";
						i += 1;
						start = i + 1;
					}
					break;
				default: i += 1;
			}
		}
		str = start ? str + json.slice(start) : json;
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
	}
	function singleQuotedString(value, ctx) {
		if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
		const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
		const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
		return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function quotedString(value, ctx) {
		const { singleQuote } = ctx.options;
		let qs;
		if (singleQuote === false) qs = doubleQuotedString;
		else {
			const hasDouble = value.includes("\"");
			const hasSingle = value.includes("'");
			if (hasDouble && !hasSingle) qs = singleQuotedString;
			else if (hasSingle && !hasDouble) qs = doubleQuotedString;
			else qs = singleQuote ? singleQuotedString : doubleQuotedString;
		}
		return qs(value, ctx);
	}
	let blockEndNewlines;
	try {
		blockEndNewlines = /* @__PURE__ */ new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
	} catch {
		blockEndNewlines = /\n+(?!\n|$)/g;
	}
	function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
		const { blockQuote, commentString, lineWidth } = ctx.options;
		if (!blockQuote || /\n[\t ]+$/.test(value)) return quotedString(value, ctx);
		const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
		const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
		if (!value) return literal ? "|\n" : ">\n";
		let chomp;
		let endStart;
		for (endStart = value.length; endStart > 0; --endStart) {
			const ch = value[endStart - 1];
			if (ch !== "\n" && ch !== "	" && ch !== " ") break;
		}
		let end = value.substring(endStart);
		const endNlPos = end.indexOf("\n");
		if (endNlPos === -1) chomp = "-";
		else if (value === end || endNlPos !== end.length - 1) {
			chomp = "+";
			if (onChompKeep) onChompKeep();
		} else chomp = "";
		if (end) {
			value = value.slice(0, -end.length);
			if (end[end.length - 1] === "\n") end = end.slice(0, -1);
			end = end.replace(blockEndNewlines, `$&${indent}`);
		}
		let startWithSpace = false;
		let startEnd;
		let startNlPos = -1;
		for (startEnd = 0; startEnd < value.length; ++startEnd) {
			const ch = value[startEnd];
			if (ch === " ") startWithSpace = true;
			else if (ch === "\n") startNlPos = startEnd;
			else break;
		}
		let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
		if (start) {
			value = value.substring(start.length);
			start = start.replace(/\n+/g, `$&${indent}`);
		}
		let header = (startWithSpace ? indent ? "2" : "1" : "") + chomp;
		if (comment) {
			header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
			if (onComment) onComment();
		}
		if (!literal) {
			const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
			let literalFallback = false;
			const foldOptions = getFoldOptions(ctx, true);
			if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) foldOptions.onOverflow = () => {
				literalFallback = true;
			};
			const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
			if (!literalFallback) return `>${header}\n${indent}${body}`;
		}
		value = value.replace(/\n+/g, `$&${indent}`);
		return `|${header}\n${indent}${start}${value}${end}`;
	}
	function plainString(item, ctx, onComment, onChompKeep) {
		const { type, value } = item;
		const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
		if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
		if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
		if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
		if (containsDocumentMarker(value)) {
			if (indent === "") {
				ctx.forceBlockIndent = true;
				return blockString(item, ctx, onComment, onChompKeep);
			} else if (implicitKey && indent === indentStep) return quotedString(value, ctx);
		}
		const str = value.replace(/\n+/g, `$&\n${indent}`);
		if (actualString) {
			const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
			const { compat, tags } = ctx.doc.schema;
			if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
		}
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function stringifyString(item, ctx, onComment, onChompKeep) {
		const { implicitKey, inFlow } = ctx;
		const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
		let { type } = item;
		if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
			if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
		}
		const _stringify = (_type) => {
			switch (_type) {
				case Scalar.Scalar.BLOCK_FOLDED:
				case Scalar.Scalar.BLOCK_LITERAL: return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
				case Scalar.Scalar.QUOTE_DOUBLE: return doubleQuotedString(ss.value, ctx);
				case Scalar.Scalar.QUOTE_SINGLE: return singleQuotedString(ss.value, ctx);
				case Scalar.Scalar.PLAIN: return plainString(ss, ctx, onComment, onChompKeep);
				default: return null;
			}
		};
		let res = _stringify(type);
		if (res === null) {
			const { defaultKeyType, defaultStringType } = ctx.options;
			const t = implicitKey && defaultKeyType || defaultStringType;
			res = _stringify(t);
			if (res === null) throw new Error(`Unsupported default string type ${t}`);
		}
		return res;
	}
	exports.stringifyString = stringifyString;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringify.js
var require_stringify = /* @__PURE__ */ __commonJSMin(((exports) => {
	var anchors = require_anchors();
	var identity = require_identity();
	var stringifyComment = require_stringifyComment();
	var stringifyString = require_stringifyString();
	function createStringifyContext(doc, options) {
		const opt = Object.assign({
			blockQuote: true,
			commentString: stringifyComment.stringifyComment,
			defaultKeyType: null,
			defaultStringType: "PLAIN",
			directives: null,
			doubleQuotedAsJSON: false,
			doubleQuotedMinMultiLineLength: 40,
			falseStr: "false",
			flowCollectionPadding: true,
			indentSeq: true,
			lineWidth: 80,
			minContentWidth: 20,
			nullStr: "null",
			simpleKeys: false,
			singleQuote: null,
			trueStr: "true",
			verifyAliasOrder: true
		}, doc.schema.toStringOptions, options);
		let inFlow;
		switch (opt.collectionStyle) {
			case "block":
				inFlow = false;
				break;
			case "flow":
				inFlow = true;
				break;
			default: inFlow = null;
		}
		return {
			anchors: /* @__PURE__ */ new Set(),
			doc,
			flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
			indent: "",
			indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
			inFlow,
			options: opt
		};
	}
	function getTagObject(tags, item) {
		if (item.tag) {
			const match = tags.filter((t) => t.tag === item.tag);
			if (match.length > 0) return match.find((t) => t.format === item.format) ?? match[0];
		}
		let tagObj = void 0;
		let obj;
		if (identity.isScalar(item)) {
			obj = item.value;
			let match = tags.filter((t) => t.identify?.(obj));
			if (match.length > 1) {
				const testMatch = match.filter((t) => t.test);
				if (testMatch.length > 0) match = testMatch;
			}
			tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
		} else {
			obj = item;
			tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
		}
		if (!tagObj) {
			const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
			throw new Error(`Tag not resolved for ${name} value`);
		}
		return tagObj;
	}
	function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
		if (!doc.directives) return "";
		const props = [];
		const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
		if (anchor && anchors.anchorIsValid(anchor)) {
			anchors$1.add(anchor);
			props.push(`&${anchor}`);
		}
		const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
		if (tag) props.push(doc.directives.tagString(tag));
		return props.join(" ");
	}
	function stringify(item, ctx, onComment, onChompKeep) {
		if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
		if (identity.isAlias(item)) {
			if (ctx.doc.directives) return item.toString(ctx);
			if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
			else {
				if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
				else ctx.resolvedAliases = new Set([item]);
				item = item.resolve(ctx.doc);
			}
		}
		let tagObj = void 0;
		const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
		tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
		const props = stringifyProps(node, tagObj, ctx);
		if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
		const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
		if (!props) return str;
		return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
	}
	exports.createStringifyContext = createStringifyContext;
	exports.stringify = stringify;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
		const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
		let keyComment = identity.isNode(key) && key.comment || null;
		if (simpleKeys) {
			if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
			if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") throw new Error("With simple keys, collection cannot be used as a key value");
		}
		let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
		ctx = Object.assign({}, ctx, {
			allNullValues: false,
			implicitKey: !explicitKey && (simpleKeys || !allNullValues),
			indent: indent + indentStep
		});
		let keyCommentDone = false;
		let chompKeep = false;
		let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
		if (!explicitKey && !ctx.inFlow && str.length > 1024) {
			if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
			explicitKey = true;
		}
		if (ctx.inFlow) {
			if (allNullValues || value == null) {
				if (keyCommentDone && onComment) onComment();
				return str === "" ? "?" : explicitKey ? `? ${str}` : str;
			}
		} else if (allNullValues && !simpleKeys || value == null && explicitKey) {
			str = `? ${str}`;
			if (keyComment && !keyCommentDone) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
			else if (chompKeep && onChompKeep) onChompKeep();
			return str;
		}
		if (keyCommentDone) keyComment = null;
		if (explicitKey) {
			if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
			str = `? ${str}\n${indent}:`;
		} else {
			str = `${str}:`;
			if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
		}
		let vsb, vcb, valueComment;
		if (identity.isNode(value)) {
			vsb = !!value.spaceBefore;
			vcb = value.commentBefore;
			valueComment = value.comment;
		} else {
			vsb = false;
			vcb = null;
			valueComment = null;
			if (value && typeof value === "object") value = doc.createNode(value);
		}
		ctx.implicitKey = false;
		if (!explicitKey && !keyComment && identity.isScalar(value)) ctx.indentAtStart = str.length + 1;
		chompKeep = false;
		if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) ctx.indent = ctx.indent.substring(2);
		let valueCommentDone = false;
		const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
		let ws = " ";
		if (keyComment || vsb || vcb) {
			ws = vsb ? "\n" : "";
			if (vcb) {
				const cs = commentString(vcb);
				ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
			}
			if (valueStr === "" && !ctx.inFlow) {
				if (ws === "\n" && valueComment) ws = "\n\n";
			} else ws += `\n${ctx.indent}`;
		} else if (!explicitKey && identity.isCollection(value)) {
			const vs0 = valueStr[0];
			const nl0 = valueStr.indexOf("\n");
			const hasNewline = nl0 !== -1;
			const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
			if (hasNewline || !flow) {
				let hasPropsLine = false;
				if (hasNewline && (vs0 === "&" || vs0 === "!")) {
					let sp0 = valueStr.indexOf(" ");
					if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
					if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
				}
				if (!hasPropsLine) ws = `\n${ctx.indent}`;
			}
		} else if (valueStr === "" || valueStr[0] === "\n") ws = "";
		str += ws + valueStr;
		if (ctx.inFlow) {
			if (valueCommentDone && onComment) onComment();
		} else if (valueComment && !valueCommentDone) str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
		else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	exports.stringifyPair = stringifyPair;
}));

//#endregion
//#region ../../node_modules/yaml/dist/log.js
var require_log = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process$3 = require("process");
	function debug(logLevel, ...messages) {
		if (logLevel === "debug") console.log(...messages);
	}
	function warn(logLevel, warning) {
		if (logLevel === "debug" || logLevel === "warn") if (typeof node_process$3.emitWarning === "function") node_process$3.emitWarning(warning);
		else console.warn(warning);
	}
	exports.debug = debug;
	exports.warn = warn;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	const MERGE_KEY = "<<";
	const merge = {
		identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
		default: "key",
		tag: "tag:yaml.org,2002:merge",
		test: /^<<$/,
		resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), { addToJSMap: addMergeToJSMap }),
		stringify: () => MERGE_KEY
	};
	const isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
	function addMergeToJSMap(ctx, map, value) {
		value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
		if (identity.isSeq(value)) for (const it of value.items) mergeValue(ctx, map, it);
		else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map, it);
		else mergeValue(ctx, map, value);
	}
	function mergeValue(ctx, map, value) {
		const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
		if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
		const srcMap = source.toJSON(null, ctx, Map);
		for (const [key, value] of srcMap) if (map instanceof Map) {
			if (!map.has(key)) map.set(key, value);
		} else if (map instanceof Set) map.add(key);
		else if (!Object.prototype.hasOwnProperty.call(map, key)) Object.defineProperty(map, key, {
			value,
			writable: true,
			enumerable: true,
			configurable: true
		});
		return map;
	}
	exports.addMergeToJSMap = addMergeToJSMap;
	exports.isMergeKey = isMergeKey;
	exports.merge = merge;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var log = require_log();
	var merge = require_merge();
	var stringify = require_stringify();
	var identity = require_identity();
	var toJS = require_toJS();
	function addPairToJSMap(ctx, map, { key, value }) {
		if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value);
		else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map, value);
		else {
			const jsKey = toJS.toJS(key, "", ctx);
			if (map instanceof Map) map.set(jsKey, toJS.toJS(value, jsKey, ctx));
			else if (map instanceof Set) map.add(jsKey);
			else {
				const stringKey = stringifyKey(key, jsKey, ctx);
				const jsValue = toJS.toJS(value, stringKey, ctx);
				if (stringKey in map) Object.defineProperty(map, stringKey, {
					value: jsValue,
					writable: true,
					enumerable: true,
					configurable: true
				});
				else map[stringKey] = jsValue;
			}
		}
		return map;
	}
	function stringifyKey(key, jsKey, ctx) {
		if (jsKey === null) return "";
		if (typeof jsKey !== "object") return String(jsKey);
		if (identity.isNode(key) && ctx?.doc) {
			const strCtx = stringify.createStringifyContext(ctx.doc, {});
			strCtx.anchors = /* @__PURE__ */ new Set();
			for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
			strCtx.inFlow = true;
			strCtx.inStringifyKey = true;
			const strKey = key.toString(strCtx);
			if (!ctx.mapKeyWarned) {
				let jsonStr = JSON.stringify(strKey);
				if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + "...\"";
				log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
				ctx.mapKeyWarned = true;
			}
			return strKey;
		}
		return JSON.stringify(jsKey);
	}
	exports.addPairToJSMap = addPairToJSMap;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/Pair.js
var require_Pair = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var stringifyPair = require_stringifyPair();
	var addPairToJSMap = require_addPairToJSMap();
	var identity = require_identity();
	function createPair(key, value, ctx) {
		return new Pair(createNode.createNode(key, void 0, ctx), createNode.createNode(value, void 0, ctx));
	}
	var Pair = class Pair {
		constructor(key, value = null) {
			Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
			this.key = key;
			this.value = value;
		}
		clone(schema) {
			let { key, value } = this;
			if (identity.isNode(key)) key = key.clone(schema);
			if (identity.isNode(value)) value = value.clone(schema);
			return new Pair(key, value);
		}
		toJSON(_, ctx) {
			const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			return addPairToJSMap.addPairToJSMap(ctx, pair, this);
		}
		toString(ctx, onComment, onChompKeep) {
			return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
		}
	};
	exports.Pair = Pair;
	exports.createPair = createPair;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyCollection(collection, ctx, options) {
		return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
	}
	function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
		const { indent, options: { commentString } } = ctx;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			type: null
		});
		let chompKeep = false;
		const lines = [];
		for (let i = 0; i < items.length; ++i) {
			const item = items[i];
			let comment = null;
			if (identity.isNode(item)) {
				if (!chompKeep && item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
				if (item.comment) comment = item.comment;
			} else if (identity.isPair(item)) {
				const ik = identity.isNode(item.key) ? item.key : null;
				if (ik) {
					if (!chompKeep && ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
				}
			}
			chompKeep = false;
			let str = stringify.stringify(item, itemCtx, () => comment = null, () => chompKeep = true);
			if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
			if (chompKeep && comment) chompKeep = false;
			lines.push(blockItemPrefix + str);
		}
		let str;
		if (lines.length === 0) str = flowChars.start + flowChars.end;
		else {
			str = lines[0];
			for (let i = 1; i < lines.length; ++i) {
				const line = lines[i];
				str += line ? `\n${indent}${line}` : "\n";
			}
		}
		if (comment) {
			str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
			if (onComment) onComment();
		} else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
		const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
		itemIndent += indentStep;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			inFlow: true,
			type: null
		});
		let reqNewline = false;
		let linesAtValue = 0;
		const lines = [];
		for (let i = 0; i < items.length; ++i) {
			const item = items[i];
			let comment = null;
			if (identity.isNode(item)) {
				if (item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, false);
				if (item.comment) comment = item.comment;
			} else if (identity.isPair(item)) {
				const ik = identity.isNode(item.key) ? item.key : null;
				if (ik) {
					if (ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, false);
					if (ik.comment) reqNewline = true;
				}
				const iv = identity.isNode(item.value) ? item.value : null;
				if (iv) {
					if (iv.comment) comment = iv.comment;
					if (iv.commentBefore) reqNewline = true;
				} else if (item.value == null && ik?.comment) comment = ik.comment;
			}
			if (comment) reqNewline = true;
			let str = stringify.stringify(item, itemCtx, () => comment = null);
			if (i < items.length - 1) str += ",";
			if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
			if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
			lines.push(str);
			linesAtValue = lines.length;
		}
		const { start, end } = flowChars;
		if (lines.length === 0) return start + end;
		else {
			if (!reqNewline) {
				const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
				reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
			}
			if (reqNewline) {
				let str = start;
				for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
				return `${str}\n${indent}${end}`;
			} else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
		}
	}
	function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
		if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
		if (comment) {
			const ic = stringifyComment.indentComment(commentString(comment), indent);
			lines.push(ic.trimStart());
		}
	}
	exports.stringifyCollection = stringifyCollection;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyCollection = require_stringifyCollection();
	var addPairToJSMap = require_addPairToJSMap();
	var Collection = require_Collection();
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	function findPair(items, key) {
		const k = identity.isScalar(key) ? key.value : key;
		for (const it of items) if (identity.isPair(it)) {
			if (it.key === key || it.key === k) return it;
			if (identity.isScalar(it.key) && it.key.value === k) return it;
		}
	}
	var YAMLMap = class extends Collection.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:map";
		}
		constructor(schema) {
			super(identity.MAP, schema);
			this.items = [];
		}
		/**
		* A generic collection parsing method that can be extended
		* to other node classes that inherit from YAMLMap
		*/
		static from(schema, obj, ctx) {
			const { keepUndefined, replacer } = ctx;
			const map = new this(schema);
			const add = (key, value) => {
				if (typeof replacer === "function") value = replacer.call(obj, key, value);
				else if (Array.isArray(replacer) && !replacer.includes(key)) return;
				if (value !== void 0 || keepUndefined) map.items.push(Pair.createPair(key, value, ctx));
			};
			if (obj instanceof Map) for (const [key, value] of obj) add(key, value);
			else if (obj && typeof obj === "object") for (const key of Object.keys(obj)) add(key, obj[key]);
			if (typeof schema.sortMapEntries === "function") map.items.sort(schema.sortMapEntries);
			return map;
		}
		/**
		* Adds a value to the collection.
		*
		* @param overwrite - If not set `true`, using a key that is already in the
		*   collection will throw. Otherwise, overwrites the previous value.
		*/
		add(pair, overwrite) {
			let _pair;
			if (identity.isPair(pair)) _pair = pair;
			else if (!pair || typeof pair !== "object" || !("key" in pair)) _pair = new Pair.Pair(pair, pair?.value);
			else _pair = new Pair.Pair(pair.key, pair.value);
			const prev = findPair(this.items, _pair.key);
			const sortEntries = this.schema?.sortMapEntries;
			if (prev) {
				if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
				if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;
				else prev.value = _pair.value;
			} else if (sortEntries) {
				const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
				if (i === -1) this.items.push(_pair);
				else this.items.splice(i, 0, _pair);
			} else this.items.push(_pair);
		}
		delete(key) {
			const it = findPair(this.items, key);
			if (!it) return false;
			return this.items.splice(this.items.indexOf(it), 1).length > 0;
		}
		get(key, keepScalar) {
			const node = findPair(this.items, key)?.value;
			return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
		}
		has(key) {
			return !!findPair(this.items, key);
		}
		set(key, value) {
			this.add(new Pair.Pair(key, value), true);
		}
		/**
		* @param ctx - Conversion context, originally set in Document#toJS()
		* @param {Class} Type - If set, forces the returned collection type
		* @returns Instance of Type, Map, or Object
		*/
		toJSON(_, ctx, Type) {
			const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			if (ctx?.onCreate) ctx.onCreate(map);
			for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
			return map;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			for (const item of this.items) if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
			if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, { allNullValues: true });
			return stringifyCollection.stringifyCollection(this, ctx, {
				blockItemPrefix: "",
				flowChars: {
					start: "{",
					end: "}"
				},
				itemIndent: ctx.indent || "",
				onChompKeep,
				onComment
			});
		}
	};
	exports.YAMLMap = YAMLMap;
	exports.findPair = findPair;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/common/map.js
var require_map = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var YAMLMap = require_YAMLMap();
	const map = {
		collection: "map",
		default: true,
		nodeClass: YAMLMap.YAMLMap,
		tag: "tag:yaml.org,2002:map",
		resolve(map, onError) {
			if (!identity.isMap(map)) onError("Expected a mapping for this tag");
			return map;
		},
		createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
	};
	exports.map = map;
}));

//#endregion
//#region ../../node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var stringifyCollection = require_stringifyCollection();
	var Collection = require_Collection();
	var identity = require_identity();
	var Scalar = require_Scalar();
	var toJS = require_toJS();
	var YAMLSeq = class extends Collection.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:seq";
		}
		constructor(schema) {
			super(identity.SEQ, schema);
			this.items = [];
		}
		add(value) {
			this.items.push(value);
		}
		/**
		* Removes a value from the collection.
		*
		* `key` must contain a representation of an integer for this to succeed.
		* It may be wrapped in a `Scalar`.
		*
		* @returns `true` if the item was found and removed.
		*/
		delete(key) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return false;
			return this.items.splice(idx, 1).length > 0;
		}
		get(key, keepScalar) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return void 0;
			const it = this.items[idx];
			return !keepScalar && identity.isScalar(it) ? it.value : it;
		}
		/**
		* Checks if the collection includes a value with the key `key`.
		*
		* `key` must contain a representation of an integer for this to succeed.
		* It may be wrapped in a `Scalar`.
		*/
		has(key) {
			const idx = asItemIndex(key);
			return typeof idx === "number" && idx < this.items.length;
		}
		/**
		* Sets a value in this collection. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*
		* If `key` does not contain a representation of an integer, this will throw.
		* It may be wrapped in a `Scalar`.
		*/
		set(key, value) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
			const prev = this.items[idx];
			if (identity.isScalar(prev) && Scalar.isScalarValue(value)) prev.value = value;
			else this.items[idx] = value;
		}
		toJSON(_, ctx) {
			const seq = [];
			if (ctx?.onCreate) ctx.onCreate(seq);
			let i = 0;
			for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
			return seq;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			return stringifyCollection.stringifyCollection(this, ctx, {
				blockItemPrefix: "- ",
				flowChars: {
					start: "[",
					end: "]"
				},
				itemIndent: (ctx.indent || "") + "  ",
				onChompKeep,
				onComment
			});
		}
		static from(schema, obj, ctx) {
			const { replacer } = ctx;
			const seq = new this(schema);
			if (obj && Symbol.iterator in Object(obj)) {
				let i = 0;
				for (let it of obj) {
					if (typeof replacer === "function") {
						const key = obj instanceof Set ? it : String(i++);
						it = replacer.call(obj, key, it);
					}
					seq.items.push(createNode.createNode(it, void 0, ctx));
				}
			}
			return seq;
		}
	};
	function asItemIndex(key) {
		let idx = identity.isScalar(key) ? key.value : key;
		if (idx && typeof idx === "string") idx = Number(idx);
		return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
	}
	exports.YAMLSeq = YAMLSeq;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/common/seq.js
var require_seq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var YAMLSeq = require_YAMLSeq();
	const seq = {
		collection: "seq",
		default: true,
		nodeClass: YAMLSeq.YAMLSeq,
		tag: "tag:yaml.org,2002:seq",
		resolve(seq, onError) {
			if (!identity.isSeq(seq)) onError("Expected a sequence for this tag");
			return seq;
		},
		createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
	};
	exports.seq = seq;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/common/string.js
var require_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyString = require_stringifyString();
	const string = {
		identify: (value) => typeof value === "string",
		default: true,
		tag: "tag:yaml.org,2002:str",
		resolve: (str) => str,
		stringify(item, ctx, onComment, onChompKeep) {
			ctx = Object.assign({ actualString: true }, ctx);
			return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
		}
	};
	exports.string = string;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/common/null.js
var require_null = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	const nullTag = {
		identify: (value) => value == null,
		createNode: () => new Scalar.Scalar(null),
		default: true,
		tag: "tag:yaml.org,2002:null",
		test: /^(?:~|[Nn]ull|NULL)?$/,
		resolve: () => new Scalar.Scalar(null),
		stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
	};
	exports.nullTag = nullTag;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/core/bool.js
var require_bool$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	const boolTag = {
		identify: (value) => typeof value === "boolean",
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
		resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
		stringify({ source, value }, ctx) {
			if (source && boolTag.test.test(source)) {
				if (value === (source[0] === "t" || source[0] === "T")) return source;
			}
			return value ? ctx.options.trueStr : ctx.options.falseStr;
		}
	};
	exports.boolTag = boolTag;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = /* @__PURE__ */ __commonJSMin(((exports) => {
	function stringifyNumber({ format, minFractionDigits, tag, value }) {
		if (typeof value === "bigint") return String(value);
		const num = typeof value === "number" ? value : Number(value);
		if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
		let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
		if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
			let i = n.indexOf(".");
			if (i < 0) {
				i = n.length;
				n += ".";
			}
			let d = minFractionDigits - (n.length - i - 1);
			while (d-- > 0) n += "0";
		}
		return n;
	}
	exports.stringifyNumber = stringifyNumber;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/core/float.js
var require_float$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var stringifyNumber = require_stringifyNumber();
	const floatNaN = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber.stringifyNumber
	};
	const floatExp = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
		}
	};
	const float = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
		resolve(str) {
			const node = new Scalar.Scalar(parseFloat(str));
			const dot = str.indexOf(".");
			if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
			return node;
		},
		stringify: stringifyNumber.stringifyNumber
	};
	exports.float = float;
	exports.floatExp = floatExp;
	exports.floatNaN = floatNaN;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/core/int.js
var require_int$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
	const intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
	function intStringify(node, radix, prefix) {
		const { value } = node;
		if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
		return stringifyNumber.stringifyNumber(node);
	}
	const intOct = {
		identify: (value) => intIdentify(value) && value >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^0o[0-7]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
		stringify: (node) => intStringify(node, 8, "0o")
	};
	const int = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
		stringify: stringifyNumber.stringifyNumber
	};
	const intHex = {
		identify: (value) => intIdentify(value) && value >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^0x[0-9a-fA-F]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
		stringify: (node) => intStringify(node, 16, "0x")
	};
	exports.int = int;
	exports.intHex = intHex;
	exports.intOct = intOct;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/core/schema.js
var require_schema$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var bool = require_bool$1();
	var float = require_float$1();
	var int = require_int$1();
	const schema = [
		map.map,
		seq.seq,
		string.string,
		_null.nullTag,
		bool.boolTag,
		int.intOct,
		int.int,
		int.intHex,
		float.floatNaN,
		float.floatExp,
		float.float
	];
	exports.schema = schema;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/json/schema.js
var require_schema$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var map = require_map();
	var seq = require_seq();
	function intIdentify(value) {
		return typeof value === "bigint" || Number.isInteger(value);
	}
	const stringifyJSON = ({ value }) => JSON.stringify(value);
	const jsonScalars = [
		{
			identify: (value) => typeof value === "string",
			default: true,
			tag: "tag:yaml.org,2002:str",
			resolve: (str) => str,
			stringify: stringifyJSON
		},
		{
			identify: (value) => value == null,
			createNode: () => new Scalar.Scalar(null),
			default: true,
			tag: "tag:yaml.org,2002:null",
			test: /^null$/,
			resolve: () => null,
			stringify: stringifyJSON
		},
		{
			identify: (value) => typeof value === "boolean",
			default: true,
			tag: "tag:yaml.org,2002:bool",
			test: /^true$|^false$/,
			resolve: (str) => str === "true",
			stringify: stringifyJSON
		},
		{
			identify: intIdentify,
			default: true,
			tag: "tag:yaml.org,2002:int",
			test: /^-?(?:0|[1-9][0-9]*)$/,
			resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
			stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
		},
		{
			identify: (value) => typeof value === "number",
			default: true,
			tag: "tag:yaml.org,2002:float",
			test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
			resolve: (str) => parseFloat(str),
			stringify: stringifyJSON
		}
	];
	const schema = [map.map, seq.seq].concat(jsonScalars, {
		default: true,
		tag: "",
		test: /^/,
		resolve(str, onError) {
			onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
			return str;
		}
	});
	exports.schema = schema;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_buffer$1 = require("buffer");
	var Scalar = require_Scalar();
	var stringifyString = require_stringifyString();
	const binary = {
		identify: (value) => value instanceof Uint8Array,
		default: false,
		tag: "tag:yaml.org,2002:binary",
		resolve(src, onError) {
			if (typeof node_buffer$1.Buffer === "function") return node_buffer$1.Buffer.from(src, "base64");
			else if (typeof atob === "function") {
				const str = atob(src.replace(/[\n\r]/g, ""));
				const buffer = new Uint8Array(str.length);
				for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
				return buffer;
			} else {
				onError("This environment does not support reading binary tags; either Buffer or atob is required");
				return src;
			}
		},
		stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
			if (!value) return "";
			const buf = value;
			let str;
			if (typeof node_buffer$1.Buffer === "function") str = buf instanceof node_buffer$1.Buffer ? buf.toString("base64") : node_buffer$1.Buffer.from(buf.buffer).toString("base64");
			else if (typeof btoa === "function") {
				let s = "";
				for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
				str = btoa(s);
			} else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
			type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
			if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
				const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
				const n = Math.ceil(str.length / lineWidth);
				const lines = new Array(n);
				for (let i = 0, o = 0; i < n; ++i, o += lineWidth) lines[i] = str.substr(o, lineWidth);
				str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
			}
			return stringifyString.stringifyString({
				comment,
				type,
				value: str
			}, ctx, onComment, onChompKeep);
		}
	};
	exports.binary = binary;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	var YAMLSeq = require_YAMLSeq();
	function resolvePairs(seq, onError) {
		if (identity.isSeq(seq)) for (let i = 0; i < seq.items.length; ++i) {
			let item = seq.items[i];
			if (identity.isPair(item)) continue;
			else if (identity.isMap(item)) {
				if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
				const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
				if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
				if (item.comment) {
					const cn = pair.value ?? pair.key;
					cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
				}
				item = pair;
			}
			seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
		}
		else onError("Expected a sequence for this tag");
		return seq;
	}
	function createPairs(schema, iterable, ctx) {
		const { replacer } = ctx;
		const pairs = new YAMLSeq.YAMLSeq(schema);
		pairs.tag = "tag:yaml.org,2002:pairs";
		let i = 0;
		if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
			if (typeof replacer === "function") it = replacer.call(iterable, String(i++), it);
			let key, value;
			if (Array.isArray(it)) if (it.length === 2) {
				key = it[0];
				value = it[1];
			} else throw new TypeError(`Expected [key, value] tuple: ${it}`);
			else if (it && it instanceof Object) {
				const keys = Object.keys(it);
				if (keys.length === 1) {
					key = keys[0];
					value = it[key];
				} else throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
			} else key = it;
			pairs.items.push(Pair.createPair(key, value, ctx));
		}
		return pairs;
	}
	const pairs = {
		collection: "seq",
		default: false,
		tag: "tag:yaml.org,2002:pairs",
		resolve: resolvePairs,
		createNode: createPairs
	};
	exports.createPairs = createPairs;
	exports.pairs = pairs;
	exports.resolvePairs = resolvePairs;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var toJS = require_toJS();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var pairs = require_pairs();
	var YAMLOMap = class YAMLOMap extends YAMLSeq.YAMLSeq {
		constructor() {
			super();
			this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
			this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
			this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
			this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
			this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
			this.tag = YAMLOMap.tag;
		}
		/**
		* If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
		* but TypeScript won't allow widening the signature of a child method.
		*/
		toJSON(_, ctx) {
			if (!ctx) return super.toJSON(_);
			const map = /* @__PURE__ */ new Map();
			if (ctx?.onCreate) ctx.onCreate(map);
			for (const pair of this.items) {
				let key, value;
				if (identity.isPair(pair)) {
					key = toJS.toJS(pair.key, "", ctx);
					value = toJS.toJS(pair.value, key, ctx);
				} else key = toJS.toJS(pair, "", ctx);
				if (map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
				map.set(key, value);
			}
			return map;
		}
		static from(schema, iterable, ctx) {
			const pairs$1 = pairs.createPairs(schema, iterable, ctx);
			const omap = new this();
			omap.items = pairs$1.items;
			return omap;
		}
	};
	YAMLOMap.tag = "tag:yaml.org,2002:omap";
	const omap = {
		collection: "seq",
		identify: (value) => value instanceof Map,
		nodeClass: YAMLOMap,
		default: false,
		tag: "tag:yaml.org,2002:omap",
		resolve(seq, onError) {
			const pairs$1 = pairs.resolvePairs(seq, onError);
			const seenKeys = [];
			for (const { key } of pairs$1.items) if (identity.isScalar(key)) if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
			else seenKeys.push(key.value);
			return Object.assign(new YAMLOMap(), pairs$1);
		},
		createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
	};
	exports.YAMLOMap = YAMLOMap;
	exports.omap = omap;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	function boolStringify({ value, source }, ctx) {
		if (source && (value ? trueTag : falseTag).test.test(source)) return source;
		return value ? ctx.options.trueStr : ctx.options.falseStr;
	}
	const trueTag = {
		identify: (value) => value === true,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
		resolve: () => new Scalar.Scalar(true),
		stringify: boolStringify
	};
	const falseTag = {
		identify: (value) => value === false,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
		resolve: () => new Scalar.Scalar(false),
		stringify: boolStringify
	};
	exports.falseTag = falseTag;
	exports.trueTag = trueTag;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var stringifyNumber = require_stringifyNumber();
	const floatNaN = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber.stringifyNumber
	};
	const floatExp = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str.replace(/_/g, "")),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
		}
	};
	const float = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
		resolve(str) {
			const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
			const dot = str.indexOf(".");
			if (dot !== -1) {
				const f = str.substring(dot + 1).replace(/_/g, "");
				if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
			}
			return node;
		},
		stringify: stringifyNumber.stringifyNumber
	};
	exports.float = float;
	exports.floatExp = floatExp;
	exports.floatNaN = floatNaN;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
	function intResolve(str, offset, radix, { intAsBigInt }) {
		const sign = str[0];
		if (sign === "-" || sign === "+") offset += 1;
		str = str.substring(offset).replace(/_/g, "");
		if (intAsBigInt) {
			switch (radix) {
				case 2:
					str = `0b${str}`;
					break;
				case 8:
					str = `0o${str}`;
					break;
				case 16:
					str = `0x${str}`;
					break;
			}
			const n = BigInt(str);
			return sign === "-" ? BigInt(-1) * n : n;
		}
		const n = parseInt(str, radix);
		return sign === "-" ? -1 * n : n;
	}
	function intStringify(node, radix, prefix) {
		const { value } = node;
		if (intIdentify(value)) {
			const str = value.toString(radix);
			return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
		}
		return stringifyNumber.stringifyNumber(node);
	}
	const intBin = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "BIN",
		test: /^[-+]?0b[0-1_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
		stringify: (node) => intStringify(node, 2, "0b")
	};
	const intOct = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^[-+]?0[0-7_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
		stringify: (node) => intStringify(node, 8, "0")
	};
	const int = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9][0-9_]*$/,
		resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
		stringify: stringifyNumber.stringifyNumber
	};
	const intHex = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^[-+]?0x[0-9a-fA-F_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
		stringify: (node) => intStringify(node, 16, "0x")
	};
	exports.int = int;
	exports.intBin = intBin;
	exports.intHex = intHex;
	exports.intOct = intOct;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var YAMLSet = class YAMLSet extends YAMLMap.YAMLMap {
		constructor(schema) {
			super(schema);
			this.tag = YAMLSet.tag;
		}
		add(key) {
			let pair;
			if (identity.isPair(key)) pair = key;
			else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new Pair.Pair(key.key, null);
			else pair = new Pair.Pair(key, null);
			if (!YAMLMap.findPair(this.items, pair.key)) this.items.push(pair);
		}
		/**
		* If `keepPair` is `true`, returns the Pair matching `key`.
		* Otherwise, returns the value of that Pair's key.
		*/
		get(key, keepPair) {
			const pair = YAMLMap.findPair(this.items, key);
			return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
		}
		set(key, value) {
			if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
			const prev = YAMLMap.findPair(this.items, key);
			if (prev && !value) this.items.splice(this.items.indexOf(prev), 1);
			else if (!prev && value) this.items.push(new Pair.Pair(key));
		}
		toJSON(_, ctx) {
			return super.toJSON(_, ctx, Set);
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
			else throw new Error("Set items must all have null values");
		}
		static from(schema, iterable, ctx) {
			const { replacer } = ctx;
			const set = new this(schema);
			if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) {
				if (typeof replacer === "function") value = replacer.call(iterable, value, value);
				set.items.push(Pair.createPair(value, null, ctx));
			}
			return set;
		}
	};
	YAMLSet.tag = "tag:yaml.org,2002:set";
	const set = {
		collection: "map",
		identify: (value) => value instanceof Set,
		nodeClass: YAMLSet,
		default: false,
		tag: "tag:yaml.org,2002:set",
		createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
		resolve(map, onError) {
			if (identity.isMap(map)) if (map.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map);
			else onError("Set items must all have null values");
			else onError("Expected a mapping for this tag");
			return map;
		}
	};
	exports.YAMLSet = YAMLSet;
	exports.set = set;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	/** Internal types handle bigint as number, because TS can't figure it out. */
	function parseSexagesimal(str, asBigInt) {
		const sign = str[0];
		const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
		const num = (n) => asBigInt ? BigInt(n) : Number(n);
		const res = parts.replace(/_/g, "").split(":").reduce((res, p) => res * num(60) + num(p), num(0));
		return sign === "-" ? num(-1) * res : res;
	}
	/**
	* hhhh:mm:ss.sss
	*
	* Internal types handle bigint as number, because TS can't figure it out.
	*/
	function stringifySexagesimal(node) {
		let { value } = node;
		let num = (n) => n;
		if (typeof value === "bigint") num = (n) => BigInt(n);
		else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
		let sign = "";
		if (value < 0) {
			sign = "-";
			value *= num(-1);
		}
		const _60 = num(60);
		const parts = [value % _60];
		if (value < 60) parts.unshift(0);
		else {
			value = (value - parts[0]) / _60;
			parts.unshift(value % _60);
			if (value >= 60) {
				value = (value - parts[0]) / _60;
				parts.unshift(value);
			}
		}
		return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
	}
	const intTime = {
		identify: (value) => typeof value === "bigint" || Number.isInteger(value),
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
		resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
		stringify: stringifySexagesimal
	};
	const floatTime = {
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
		resolve: (str) => parseSexagesimal(str, false),
		stringify: stringifySexagesimal
	};
	const timestamp = {
		identify: (value) => value instanceof Date,
		default: true,
		tag: "tag:yaml.org,2002:timestamp",
		test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
		resolve(str) {
			const match = str.match(timestamp.test);
			if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
			const [, year, month, day, hour, minute, second] = match.map(Number);
			const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
			let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
			const tz = match[8];
			if (tz && tz !== "Z") {
				let d = parseSexagesimal(tz, false);
				if (Math.abs(d) < 30) d *= 60;
				date -= 6e4 * d;
			}
			return new Date(date);
		},
		stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
	};
	exports.floatTime = floatTime;
	exports.intTime = intTime;
	exports.timestamp = timestamp;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var binary = require_binary();
	var bool = require_bool();
	var float = require_float();
	var int = require_int();
	var merge = require_merge();
	var omap = require_omap();
	var pairs = require_pairs();
	var set = require_set();
	var timestamp = require_timestamp();
	const schema = [
		map.map,
		seq.seq,
		string.string,
		_null.nullTag,
		bool.trueTag,
		bool.falseTag,
		int.intBin,
		int.intOct,
		int.int,
		int.intHex,
		float.floatNaN,
		float.floatExp,
		float.float,
		binary.binary,
		merge.merge,
		omap.omap,
		pairs.pairs,
		set.set,
		timestamp.intTime,
		timestamp.floatTime,
		timestamp.timestamp
	];
	exports.schema = schema;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/tags.js
var require_tags = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var bool = require_bool$1();
	var float = require_float$1();
	var int = require_int$1();
	var schema = require_schema$2();
	var schema$1 = require_schema$1();
	var binary = require_binary();
	var merge = require_merge();
	var omap = require_omap();
	var pairs = require_pairs();
	var schema$2 = require_schema();
	var set = require_set();
	var timestamp = require_timestamp();
	const schemas = new Map([
		["core", schema.schema],
		["failsafe", [
			map.map,
			seq.seq,
			string.string
		]],
		["json", schema$1.schema],
		["yaml11", schema$2.schema],
		["yaml-1.1", schema$2.schema]
	]);
	const tagsByName = {
		binary: binary.binary,
		bool: bool.boolTag,
		float: float.float,
		floatExp: float.floatExp,
		floatNaN: float.floatNaN,
		floatTime: timestamp.floatTime,
		int: int.int,
		intHex: int.intHex,
		intOct: int.intOct,
		intTime: timestamp.intTime,
		map: map.map,
		merge: merge.merge,
		null: _null.nullTag,
		omap: omap.omap,
		pairs: pairs.pairs,
		seq: seq.seq,
		set: set.set,
		timestamp: timestamp.timestamp
	};
	const coreKnownTags = {
		"tag:yaml.org,2002:binary": binary.binary,
		"tag:yaml.org,2002:merge": merge.merge,
		"tag:yaml.org,2002:omap": omap.omap,
		"tag:yaml.org,2002:pairs": pairs.pairs,
		"tag:yaml.org,2002:set": set.set,
		"tag:yaml.org,2002:timestamp": timestamp.timestamp
	};
	function getTags(customTags, schemaName, addMergeTag) {
		const schemaTags = schemas.get(schemaName);
		if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
		let tags = schemaTags;
		if (!tags) if (Array.isArray(customTags)) tags = [];
		else {
			const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
			throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
		}
		if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag);
		else if (typeof customTags === "function") tags = customTags(tags.slice());
		if (addMergeTag) tags = tags.concat(merge.merge);
		return tags.reduce((tags, tag) => {
			const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
			if (!tagObj) {
				const tagName = JSON.stringify(tag);
				const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
				throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
			}
			if (!tags.includes(tagObj)) tags.push(tagObj);
			return tags;
		}, []);
	}
	exports.coreKnownTags = coreKnownTags;
	exports.getTags = getTags;
}));

//#endregion
//#region ../../node_modules/yaml/dist/schema/Schema.js
var require_Schema = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var map = require_map();
	var seq = require_seq();
	var string = require_string();
	var tags = require_tags();
	const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
	var Schema = class Schema {
		constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
			this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
			this.name = typeof schema === "string" && schema || "core";
			this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
			this.tags = tags.getTags(customTags, this.name, merge);
			this.toStringOptions = toStringDefaults ?? null;
			Object.defineProperty(this, identity.MAP, { value: map.map });
			Object.defineProperty(this, identity.SCALAR, { value: string.string });
			Object.defineProperty(this, identity.SEQ, { value: seq.seq });
			this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
		}
		clone() {
			const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
			copy.tags = this.tags.slice();
			return copy;
		}
	};
	exports.Schema = Schema;
}));

//#endregion
//#region ../../node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyDocument(doc, options) {
		const lines = [];
		let hasDirectives = options.directives === true;
		if (options.directives !== false && doc.directives) {
			const dir = doc.directives.toString(doc);
			if (dir) {
				lines.push(dir);
				hasDirectives = true;
			} else if (doc.directives.docStart) hasDirectives = true;
		}
		if (hasDirectives) lines.push("---");
		const ctx = stringify.createStringifyContext(doc, options);
		const { commentString } = ctx.options;
		if (doc.commentBefore) {
			if (lines.length !== 1) lines.unshift("");
			const cs = commentString(doc.commentBefore);
			lines.unshift(stringifyComment.indentComment(cs, ""));
		}
		let chompKeep = false;
		let contentComment = null;
		if (doc.contents) {
			if (identity.isNode(doc.contents)) {
				if (doc.contents.spaceBefore && hasDirectives) lines.push("");
				if (doc.contents.commentBefore) {
					const cs = commentString(doc.contents.commentBefore);
					lines.push(stringifyComment.indentComment(cs, ""));
				}
				ctx.forceBlockIndent = !!doc.comment;
				contentComment = doc.contents.comment;
			}
			const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
			let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
			if (contentComment) body += stringifyComment.lineComment(body, "", commentString(contentComment));
			if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") lines[lines.length - 1] = `--- ${body}`;
			else lines.push(body);
		} else lines.push(stringify.stringify(doc.contents, ctx));
		if (doc.directives?.docEnd) if (doc.comment) {
			const cs = commentString(doc.comment);
			if (cs.includes("\n")) {
				lines.push("...");
				lines.push(stringifyComment.indentComment(cs, ""));
			} else lines.push(`... ${cs}`);
		} else lines.push("...");
		else {
			let dc = doc.comment;
			if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
			if (dc) {
				if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
				lines.push(stringifyComment.indentComment(commentString(dc), ""));
			}
		}
		return lines.join("\n") + "\n";
	}
	exports.stringifyDocument = stringifyDocument;
}));

//#endregion
//#region ../../node_modules/yaml/dist/doc/Document.js
var require_Document = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var Collection = require_Collection();
	var identity = require_identity();
	var Pair = require_Pair();
	var toJS = require_toJS();
	var Schema = require_Schema();
	var stringifyDocument = require_stringifyDocument();
	var anchors = require_anchors();
	var applyReviver = require_applyReviver();
	var createNode = require_createNode();
	var directives = require_directives();
	var Document = class Document {
		constructor(value, replacer, options) {
			/** A comment before this Document */
			this.commentBefore = null;
			/** A comment immediately after this Document */
			this.comment = null;
			/** Errors encountered during parsing. */
			this.errors = [];
			/** Warnings encountered during parsing. */
			this.warnings = [];
			Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
			let _replacer = null;
			if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
			else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const opt = Object.assign({
				intAsBigInt: false,
				keepSourceTokens: false,
				logLevel: "warn",
				prettyErrors: true,
				strict: true,
				stringKeys: false,
				uniqueKeys: true,
				version: "1.2"
			}, options);
			this.options = opt;
			let { version } = opt;
			if (options?._directives) {
				this.directives = options._directives.atDocument();
				if (this.directives.yaml.explicit) version = this.directives.yaml.version;
			} else this.directives = new directives.Directives({ version });
			this.setSchema(version, options);
			this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
		}
		/**
		* Create a deep copy of this Document and its contents.
		*
		* Custom Node values that inherit from `Object` still refer to their original instances.
		*/
		clone() {
			const copy = Object.create(Document.prototype, { [identity.NODE_TYPE]: { value: identity.DOC } });
			copy.commentBefore = this.commentBefore;
			copy.comment = this.comment;
			copy.errors = this.errors.slice();
			copy.warnings = this.warnings.slice();
			copy.options = Object.assign({}, this.options);
			if (this.directives) copy.directives = this.directives.clone();
			copy.schema = this.schema.clone();
			copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
			if (this.range) copy.range = this.range.slice();
			return copy;
		}
		/** Adds a value to the document. */
		add(value) {
			if (assertCollection(this.contents)) this.contents.add(value);
		}
		/** Adds a value to the document. */
		addIn(path, value) {
			if (assertCollection(this.contents)) this.contents.addIn(path, value);
		}
		/**
		* Create a new `Alias` node, ensuring that the target `node` has the required anchor.
		*
		* If `node` already has an anchor, `name` is ignored.
		* Otherwise, the `node.anchor` value will be set to `name`,
		* or if an anchor with that name is already present in the document,
		* `name` will be used as a prefix for a new unique anchor.
		* If `name` is undefined, the generated anchor will use 'a' as a prefix.
		*/
		createAlias(node, name) {
			if (!node.anchor) {
				const prev = anchors.anchorNames(this);
				node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
			}
			return new Alias.Alias(node.anchor);
		}
		createNode(value, replacer, options) {
			let _replacer = void 0;
			if (typeof replacer === "function") {
				value = replacer.call({ "": value }, "", value);
				_replacer = replacer;
			} else if (Array.isArray(replacer)) {
				const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
				const asStr = replacer.filter(keyToStr).map(String);
				if (asStr.length > 0) replacer = replacer.concat(asStr);
				_replacer = replacer;
			} else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
			const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
			const ctx = {
				aliasDuplicateObjects: aliasDuplicateObjects ?? true,
				keepUndefined: keepUndefined ?? false,
				onAnchor,
				onTagObj,
				replacer: _replacer,
				schema: this.schema,
				sourceObjects
			};
			const node = createNode.createNode(value, tag, ctx);
			if (flow && identity.isCollection(node)) node.flow = true;
			setAnchors();
			return node;
		}
		/**
		* Convert a key and a value into a `Pair` using the current schema,
		* recursively wrapping all values as `Scalar` or `Collection` nodes.
		*/
		createPair(key, value, options = {}) {
			const k = this.createNode(key, null, options);
			const v = this.createNode(value, null, options);
			return new Pair.Pair(k, v);
		}
		/**
		* Removes a value from the document.
		* @returns `true` if the item was found and removed.
		*/
		delete(key) {
			return assertCollection(this.contents) ? this.contents.delete(key) : false;
		}
		/**
		* Removes a value from the document.
		* @returns `true` if the item was found and removed.
		*/
		deleteIn(path) {
			if (Collection.isEmptyPath(path)) {
				if (this.contents == null) return false;
				this.contents = null;
				return true;
			}
			return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
		}
		/**
		* Returns item at `key`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		get(key, keepScalar) {
			return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
		}
		/**
		* Returns item at `path`, or `undefined` if not found. By default unwraps
		* scalar values from their surrounding node; to disable set `keepScalar` to
		* `true` (collections are always returned intact).
		*/
		getIn(path, keepScalar) {
			if (Collection.isEmptyPath(path)) return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
			return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
		}
		/**
		* Checks if the document includes a value with the key `key`.
		*/
		has(key) {
			return identity.isCollection(this.contents) ? this.contents.has(key) : false;
		}
		/**
		* Checks if the document includes a value at `path`.
		*/
		hasIn(path) {
			if (Collection.isEmptyPath(path)) return this.contents !== void 0;
			return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
		}
		/**
		* Sets a value in this document. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		set(key, value) {
			if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, [key], value);
			else if (assertCollection(this.contents)) this.contents.set(key, value);
		}
		/**
		* Sets a value in this document. For `!!set`, `value` needs to be a
		* boolean to add/remove the item from the set.
		*/
		setIn(path, value) {
			if (Collection.isEmptyPath(path)) this.contents = value;
			else if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
			else if (assertCollection(this.contents)) this.contents.setIn(path, value);
		}
		/**
		* Change the YAML version and schema used by the document.
		* A `null` version disables support for directives, explicit tags, anchors, and aliases.
		* It also requires the `schema` option to be given as a `Schema` instance value.
		*
		* Overrides all previously set schema options.
		*/
		setSchema(version, options = {}) {
			if (typeof version === "number") version = String(version);
			let opt;
			switch (version) {
				case "1.1":
					if (this.directives) this.directives.yaml.version = "1.1";
					else this.directives = new directives.Directives({ version: "1.1" });
					opt = {
						resolveKnownTags: false,
						schema: "yaml-1.1"
					};
					break;
				case "1.2":
				case "next":
					if (this.directives) this.directives.yaml.version = version;
					else this.directives = new directives.Directives({ version });
					opt = {
						resolveKnownTags: true,
						schema: "core"
					};
					break;
				case null:
					if (this.directives) delete this.directives;
					opt = null;
					break;
				default: {
					const sv = JSON.stringify(version);
					throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
				}
			}
			if (options.schema instanceof Object) this.schema = options.schema;
			else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));
			else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
		}
		toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc: this,
				keep: !json,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
			if (typeof onAnchor === "function") for (const { count, res } of ctx.anchors.values()) onAnchor(res, count);
			return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
		}
		/**
		* A JSON representation of the document `contents`.
		*
		* @param jsonArg Used by `JSON.stringify` to indicate the array index or
		*   property name.
		*/
		toJSON(jsonArg, onAnchor) {
			return this.toJS({
				json: true,
				jsonArg,
				mapAsMap: false,
				onAnchor
			});
		}
		/** A YAML representation of the document. */
		toString(options = {}) {
			if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
			if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
				const s = JSON.stringify(options.indent);
				throw new Error(`"indent" option must be a positive integer, not ${s}`);
			}
			return stringifyDocument.stringifyDocument(this, options);
		}
	};
	function assertCollection(contents) {
		if (identity.isCollection(contents)) return true;
		throw new Error("Expected a YAML collection as document contents");
	}
	exports.Document = Document;
}));

//#endregion
//#region ../../node_modules/yaml/dist/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports) => {
	var YAMLError = class extends Error {
		constructor(name, pos, code, message) {
			super();
			this.name = name;
			this.code = code;
			this.message = message;
			this.pos = pos;
		}
	};
	var YAMLParseError = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLParseError", pos, code, message);
		}
	};
	var YAMLWarning = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLWarning", pos, code, message);
		}
	};
	const prettifyError = (src, lc) => (error) => {
		if (error.pos[0] === -1) return;
		error.linePos = error.pos.map((pos) => lc.linePos(pos));
		const { line, col } = error.linePos[0];
		error.message += ` at line ${line}, column ${col}`;
		let ci = col - 1;
		let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
		if (ci >= 60 && lineStr.length > 80) {
			const trimStart = Math.min(ci - 39, lineStr.length - 79);
			lineStr = "" + lineStr.substring(trimStart);
			ci -= trimStart - 1;
		}
		if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "";
		if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
			let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
			if (prev.length > 80) prev = prev.substring(0, 79) + "\n";
			lineStr = prev + lineStr;
		}
		if (/[^ ]/.test(lineStr)) {
			let count = 1;
			const end = error.linePos[1];
			if (end?.line === line && end.col > col) count = Math.max(1, Math.min(end.col - col, 80 - ci));
			const pointer = " ".repeat(ci) + "^".repeat(count);
			error.message += `:\n\n${lineStr}\n${pointer}\n`;
		}
	};
	exports.YAMLError = YAMLError;
	exports.YAMLParseError = YAMLParseError;
	exports.YAMLWarning = YAMLWarning;
	exports.prettifyError = prettifyError;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = /* @__PURE__ */ __commonJSMin(((exports) => {
	function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
		let spaceBefore = false;
		let atNewline = startOnNewline;
		let hasSpace = startOnNewline;
		let comment = "";
		let commentSep = "";
		let hasNewline = false;
		let reqSpace = false;
		let tab = null;
		let anchor = null;
		let tag = null;
		let newlineAfterProp = null;
		let comma = null;
		let found = null;
		let start = null;
		for (const token of tokens) {
			if (reqSpace) {
				if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
				reqSpace = false;
			}
			if (tab) {
				if (atNewline && token.type !== "comment" && token.type !== "newline") onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
				tab = null;
			}
			switch (token.type) {
				case "space":
					if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) tab = token;
					hasSpace = true;
					break;
				case "comment": {
					if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					const cb = token.source.substring(1) || " ";
					if (!comment) comment = cb;
					else comment += commentSep + cb;
					commentSep = "";
					atNewline = false;
					break;
				}
				case "newline":
					if (atNewline) {
						if (comment) comment += token.source;
						else if (!found || indicator !== "seq-item-ind") spaceBefore = true;
					} else commentSep += token.source;
					atNewline = true;
					hasNewline = true;
					if (anchor || tag) newlineAfterProp = token;
					hasSpace = true;
					break;
				case "anchor":
					if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
					if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
					anchor = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case "tag":
					if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
					tag = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case indicator:
					if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
					if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
					found = token;
					atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
					hasSpace = false;
					break;
				case "comma": if (flow) {
					if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
					comma = token;
					atNewline = false;
					hasSpace = false;
					break;
				}
				default:
					onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
					atNewline = false;
					hasSpace = false;
			}
		}
		const last = tokens[tokens.length - 1];
		const end = last ? last.offset + last.source.length : offset;
		if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
		if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
		return {
			comma,
			found,
			spaceBefore,
			comment,
			hasNewline,
			anchor,
			tag,
			newlineAfterProp,
			end,
			start: start ?? end
		};
	}
	exports.resolveProps = resolveProps;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = /* @__PURE__ */ __commonJSMin(((exports) => {
	function containsNewline(key) {
		if (!key) return null;
		switch (key.type) {
			case "alias":
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				if (key.source.includes("\n")) return true;
				if (key.end) {
					for (const st of key.end) if (st.type === "newline") return true;
				}
				return false;
			case "flow-collection":
				for (const it of key.items) {
					for (const st of it.start) if (st.type === "newline") return true;
					if (it.sep) {
						for (const st of it.sep) if (st.type === "newline") return true;
					}
					if (containsNewline(it.key) || containsNewline(it.value)) return true;
				}
				return false;
			default: return true;
		}
	}
	exports.containsNewline = containsNewline;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilContainsNewline = require_util_contains_newline();
	function flowIndentCheck(indent, fc, onError) {
		if (fc?.type === "flow-collection") {
			const end = fc.end[0];
			if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
		}
	}
	exports.flowIndentCheck = flowIndentCheck;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	function mapIncludes(ctx, items, search) {
		const { uniqueKeys } = ctx.options;
		if (uniqueKeys === false) return false;
		const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
		return items.some((pair) => isEqual(pair.key, search));
	}
	exports.mapIncludes = mapIncludes;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var resolveProps = require_resolve_props();
	var utilContainsNewline = require_util_contains_newline();
	var utilFlowIndentCheck = require_util_flow_indent_check();
	var utilMapIncludes = require_util_map_includes();
	const startColMsg = "All mapping items must start at the same column";
	function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
		const map = new (tag?.nodeClass ?? YAMLMap.YAMLMap)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		let offset = bm.offset;
		let commentEnd = null;
		for (const collItem of bm.items) {
			const { start, key, sep, value } = collItem;
			const keyProps = resolveProps.resolveProps(start, {
				indicator: "explicit-key-ind",
				next: key ?? sep?.[0],
				offset,
				onError,
				parentIndent: bm.indent,
				startOnNewline: true
			});
			const implicitKey = !keyProps.found;
			if (implicitKey) {
				if (key) {
					if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
					else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
				}
				if (!keyProps.anchor && !keyProps.tag && !sep) {
					commentEnd = keyProps.end;
					if (keyProps.comment) if (map.comment) map.comment += "\n" + keyProps.comment;
					else map.comment = keyProps.comment;
					continue;
				}
				if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
			} else if (keyProps.found?.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
			ctx.atKey = true;
			const keyStart = keyProps.end;
			const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
			if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
			ctx.atKey = false;
			if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
			const valueProps = resolveProps.resolveProps(sep ?? [], {
				indicator: "map-value-ind",
				next: value,
				offset: keyNode.range[2],
				onError,
				parentIndent: bm.indent,
				startOnNewline: !key || key.type === "block-scalar"
			});
			offset = valueProps.end;
			if (valueProps.found) {
				if (implicitKey) {
					if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
					if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
				}
				const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
				if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
				offset = valueNode.range[2];
				const pair = new Pair.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map.items.push(pair);
			} else {
				if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
				if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair.Pair(keyNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map.items.push(pair);
			}
		}
		if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
		map.range = [
			bm.offset,
			offset,
			commentEnd ?? offset
		];
		return map;
	}
	exports.resolveBlockMap = resolveBlockMap;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var YAMLSeq = require_YAMLSeq();
	var resolveProps = require_resolve_props();
	var utilFlowIndentCheck = require_util_flow_indent_check();
	function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
		const seq = new (tag?.nodeClass ?? YAMLSeq.YAMLSeq)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = bs.offset;
		let commentEnd = null;
		for (const { start, value } of bs.items) {
			const props = resolveProps.resolveProps(start, {
				indicator: "seq-item-ind",
				next: value,
				offset,
				onError,
				parentIndent: bs.indent,
				startOnNewline: true
			});
			if (!props.found) if (props.anchor || props.tag || value) if (value?.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
			else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
			else {
				commentEnd = props.end;
				if (props.comment) seq.comment = props.comment;
				continue;
			}
			const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
			if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
			offset = node.range[2];
			seq.items.push(node);
		}
		seq.range = [
			bs.offset,
			offset,
			commentEnd ?? offset
		];
		return seq;
	}
	exports.resolveBlockSeq = resolveBlockSeq;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = /* @__PURE__ */ __commonJSMin(((exports) => {
	function resolveEnd(end, offset, reqSpace, onError) {
		let comment = "";
		if (end) {
			let hasSpace = false;
			let sep = "";
			for (const token of end) {
				const { source, type } = token;
				switch (type) {
					case "space":
						hasSpace = true;
						break;
					case "comment": {
						if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
						const cb = source.substring(1) || " ";
						if (!comment) comment = cb;
						else comment += sep + cb;
						sep = "";
						break;
					}
					case "newline":
						if (comment) sep += source;
						hasSpace = true;
						break;
					default: onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
				}
				offset += source.length;
			}
		}
		return {
			comment,
			offset
		};
	}
	exports.resolveEnd = resolveEnd;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var resolveEnd = require_resolve_end();
	var resolveProps = require_resolve_props();
	var utilContainsNewline = require_util_contains_newline();
	var utilMapIncludes = require_util_map_includes();
	const blockMsg = "Block collections are not allowed within flow collections";
	const isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
	function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
		const isMap = fc.start.source === "{";
		const fcName = isMap ? "flow map" : "flow sequence";
		const coll = new (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq))(ctx.schema);
		coll.flow = true;
		const atRoot = ctx.atRoot;
		if (atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = fc.offset + fc.start.source.length;
		for (let i = 0; i < fc.items.length; ++i) {
			const collItem = fc.items[i];
			const { start, key, sep, value } = collItem;
			const props = resolveProps.resolveProps(start, {
				flow: fcName,
				indicator: "explicit-key-ind",
				next: key ?? sep?.[0],
				offset,
				onError,
				parentIndent: fc.indent,
				startOnNewline: false
			});
			if (!props.found) {
				if (!props.anchor && !props.tag && !sep && !value) {
					if (i === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
					else if (i < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
					if (props.comment) if (coll.comment) coll.comment += "\n" + props.comment;
					else coll.comment = props.comment;
					offset = props.end;
					continue;
				}
				if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
			}
			if (i === 0) {
				if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
			} else {
				if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
				if (props.comment) {
					let prevItemComment = "";
					loop: for (const st of start) switch (st.type) {
						case "comma":
						case "space": break;
						case "comment":
							prevItemComment = st.source.substring(1);
							break loop;
						default: break loop;
					}
					if (prevItemComment) {
						let prev = coll.items[coll.items.length - 1];
						if (identity.isPair(prev)) prev = prev.value ?? prev.key;
						if (prev.comment) prev.comment += "\n" + prevItemComment;
						else prev.comment = prevItemComment;
						props.comment = props.comment.substring(prevItemComment.length + 1);
					}
				}
			}
			if (!isMap && !sep && !props.found) {
				const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
				coll.items.push(valueNode);
				offset = valueNode.range[2];
				if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
			} else {
				ctx.atKey = true;
				const keyStart = props.end;
				const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
				if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
				ctx.atKey = false;
				const valueProps = resolveProps.resolveProps(sep ?? [], {
					flow: fcName,
					indicator: "map-value-ind",
					next: value,
					offset: keyNode.range[2],
					onError,
					parentIndent: fc.indent,
					startOnNewline: false
				});
				if (valueProps.found) {
					if (!isMap && !props.found && ctx.options.strict) {
						if (sep) for (const st of sep) {
							if (st === valueProps.found) break;
							if (st.type === "newline") {
								onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
								break;
							}
						}
						if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
					}
				} else if (value) if ("source" in value && value.source?.[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
				else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
				const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
				if (valueNode) {
					if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
				} else if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				if (isMap) {
					const map = coll;
					if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
					map.items.push(pair);
				} else {
					const map = new YAMLMap.YAMLMap(ctx.schema);
					map.flow = true;
					map.items.push(pair);
					const endRange = (valueNode ?? keyNode).range;
					map.range = [
						keyNode.range[0],
						endRange[1],
						endRange[2]
					];
					coll.items.push(map);
				}
				offset = valueNode ? valueNode.range[2] : valueProps.end;
			}
		}
		const expectedEnd = isMap ? "}" : "]";
		const [ce, ...ee] = fc.end;
		let cePos = offset;
		if (ce?.source === expectedEnd) cePos = ce.offset + ce.source.length;
		else {
			const name = fcName[0].toUpperCase() + fcName.substring(1);
			const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
			onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
			if (ce && ce.source.length !== 1) ee.unshift(ce);
		}
		if (ee.length > 0) {
			const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
			if (end.comment) if (coll.comment) coll.comment += "\n" + end.comment;
			else coll.comment = end.comment;
			coll.range = [
				fc.offset,
				cePos,
				end.offset
			];
		} else coll.range = [
			fc.offset,
			cePos,
			cePos
		];
		return coll;
	}
	exports.resolveFlowCollection = resolveFlowCollection;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var resolveBlockMap = require_resolve_block_map();
	var resolveBlockSeq = require_resolve_block_seq();
	var resolveFlowCollection = require_resolve_flow_collection();
	function resolveCollection(CN, ctx, token, onError, tagName, tag) {
		const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
		const Coll = coll.constructor;
		if (tagName === "!" || tagName === Coll.tagName) {
			coll.tag = Coll.tagName;
			return coll;
		}
		if (tagName) coll.tag = tagName;
		return coll;
	}
	function composeCollection(CN, ctx, token, props, onError) {
		const tagToken = props.tag;
		const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
		if (token.type === "block-seq") {
			const { anchor, newlineAfterProp: nl } = props;
			const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
			if (lastProp && (!nl || nl.offset < lastProp.offset)) onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
		}
		const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
		if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") return resolveCollection(CN, ctx, token, onError, tagName);
		let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
		if (!tag) {
			const kt = ctx.schema.knownTags[tagName];
			if (kt?.collection === expType) {
				ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
				tag = kt;
			} else {
				if (kt) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
				else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
				return resolveCollection(CN, ctx, token, onError, tagName);
			}
		}
		const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
		const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
		const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
		node.range = coll.range;
		node.tag = tagName;
		if (tag?.format) node.format = tag.format;
		return node;
	}
	exports.composeCollection = composeCollection;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	function resolveBlockScalar(ctx, scalar, onError) {
		const start = scalar.offset;
		const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
		if (!header) return {
			value: "",
			type: null,
			comment: "",
			range: [
				start,
				start,
				start
			]
		};
		const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
		const lines = scalar.source ? splitLines(scalar.source) : [];
		let chompStart = lines.length;
		for (let i = lines.length - 1; i >= 0; --i) {
			const content = lines[i][1];
			if (content === "" || content === "\r") chompStart = i;
			else break;
		}
		if (chompStart === 0) {
			const value = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
			let end = start + header.length;
			if (scalar.source) end += scalar.source.length;
			return {
				value,
				type,
				comment: header.comment,
				range: [
					start,
					end,
					end
				]
			};
		}
		let trimIndent = scalar.indent + header.indent;
		let offset = scalar.offset + header.length;
		let contentStart = 0;
		for (let i = 0; i < chompStart; ++i) {
			const [indent, content] = lines[i];
			if (content === "" || content === "\r") {
				if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
			} else {
				if (indent.length < trimIndent) onError(offset + indent.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator");
				if (header.indent === 0) trimIndent = indent.length;
				contentStart = i;
				if (trimIndent === 0 && !ctx.atRoot) onError(offset, "BAD_INDENT", "Block scalar values in collections must be indented");
				break;
			}
			offset += indent.length + content.length + 1;
		}
		for (let i = lines.length - 1; i >= chompStart; --i) if (lines[i][0].length > trimIndent) chompStart = i + 1;
		let value = "";
		let sep = "";
		let prevMoreIndented = false;
		for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + "\n";
		for (let i = contentStart; i < chompStart; ++i) {
			let [indent, content] = lines[i];
			offset += indent.length + content.length + 1;
			const crlf = content[content.length - 1] === "\r";
			if (crlf) content = content.slice(0, -1);
			/* istanbul ignore if already caught in lexer */
			if (content && indent.length < trimIndent) {
				const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
				onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
				indent = "";
			}
			if (type === Scalar.Scalar.BLOCK_LITERAL) {
				value += sep + indent.slice(trimIndent) + content;
				sep = "\n";
			} else if (indent.length > trimIndent || content[0] === "	") {
				if (sep === " ") sep = "\n";
				else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
				value += sep + indent.slice(trimIndent) + content;
				sep = "\n";
				prevMoreIndented = true;
			} else if (content === "") if (sep === "\n") value += "\n";
			else sep = "\n";
			else {
				value += sep + content;
				sep = " ";
				prevMoreIndented = false;
			}
		}
		switch (header.chomp) {
			case "-": break;
			case "+":
				for (let i = chompStart; i < lines.length; ++i) value += "\n" + lines[i][0].slice(trimIndent);
				if (value[value.length - 1] !== "\n") value += "\n";
				break;
			default: value += "\n";
		}
		const end = start + header.length + scalar.source.length;
		return {
			value,
			type,
			comment: header.comment,
			range: [
				start,
				end,
				end
			]
		};
	}
	function parseBlockScalarHeader({ offset, props }, strict, onError) {
		/* istanbul ignore if should not happen */
		if (props[0].type !== "block-scalar-header") {
			onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
			return null;
		}
		const { source } = props[0];
		const mode = source[0];
		let indent = 0;
		let chomp = "";
		let error = -1;
		for (let i = 1; i < source.length; ++i) {
			const ch = source[i];
			if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
			else {
				const n = Number(ch);
				if (!indent && n) indent = n;
				else if (error === -1) error = offset + i;
			}
		}
		if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
		let hasSpace = false;
		let comment = "";
		let length = source.length;
		for (let i = 1; i < props.length; ++i) {
			const token = props[i];
			switch (token.type) {
				case "space": hasSpace = true;
				case "newline":
					length += token.source.length;
					break;
				case "comment":
					if (strict && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					length += token.source.length;
					comment = token.source.substring(1);
					break;
				case "error":
					onError(token, "UNEXPECTED_TOKEN", token.message);
					length += token.source.length;
					break;
				default: {
					onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
					const ts = token.source;
					if (ts && typeof ts === "string") length += ts.length;
				}
			}
		}
		return {
			mode,
			indent,
			chomp,
			comment,
			length
		};
	}
	/** @returns Array of lines split up as `[indent, content]` */
	function splitLines(source) {
		const split = source.split(/\n( *)/);
		const first = split[0];
		const m = first.match(/^( *)/);
		const lines = [m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first]];
		for (let i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);
		return lines;
	}
	exports.resolveBlockScalar = resolveBlockScalar;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var resolveEnd = require_resolve_end();
	function resolveFlowScalar(scalar, strict, onError) {
		const { offset, type, source, end } = scalar;
		let _type;
		let value;
		const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
		switch (type) {
			case "scalar":
				_type = Scalar.Scalar.PLAIN;
				value = plainValue(source, _onError);
				break;
			case "single-quoted-scalar":
				_type = Scalar.Scalar.QUOTE_SINGLE;
				value = singleQuotedValue(source, _onError);
				break;
			case "double-quoted-scalar":
				_type = Scalar.Scalar.QUOTE_DOUBLE;
				value = doubleQuotedValue(source, _onError);
				break;
			default:
				onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
				return {
					value: "",
					type: null,
					comment: "",
					range: [
						offset,
						offset + source.length,
						offset + source.length
					]
				};
		}
		const valueEnd = offset + source.length;
		const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
		return {
			value,
			type: _type,
			comment: re.comment,
			range: [
				offset,
				valueEnd,
				re.offset
			]
		};
	}
	function plainValue(source, onError) {
		let badChar = "";
		switch (source[0]) {
			case "	":
				badChar = "a tab character";
				break;
			case ",":
				badChar = "flow indicator character ,";
				break;
			case "%":
				badChar = "directive indicator character %";
				break;
			case "|":
			case ">":
				badChar = `block scalar indicator ${source[0]}`;
				break;
			case "@":
			case "`":
				badChar = `reserved character ${source[0]}`;
				break;
		}
		if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
		return foldLines(source);
	}
	function singleQuotedValue(source, onError) {
		if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
		return foldLines(source.slice(1, -1)).replace(/''/g, "'");
	}
	function foldLines(source) {
		/**
		* The negative lookbehind here and in the `re` RegExp is to
		* prevent causing a polynomial search time in certain cases.
		*
		* The try-catch is for Safari, which doesn't support this yet:
		* https://caniuse.com/js-regexp-lookbehind
		*/
		let first, line;
		try {
			first = /* @__PURE__ */ new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
			line = /* @__PURE__ */ new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
		} catch {
			first = /(.*?)[ \t]*\r?\n/sy;
			line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
		}
		let match = first.exec(source);
		if (!match) return source;
		let res = match[1];
		let sep = " ";
		let pos = first.lastIndex;
		line.lastIndex = pos;
		while (match = line.exec(source)) {
			if (match[1] === "") if (sep === "\n") res += sep;
			else sep = "\n";
			else {
				res += sep + match[1];
				sep = " ";
			}
			pos = line.lastIndex;
		}
		const last = /[ \t]*(.*)/sy;
		last.lastIndex = pos;
		match = last.exec(source);
		return res + sep + (match?.[1] ?? "");
	}
	function doubleQuotedValue(source, onError) {
		let res = "";
		for (let i = 1; i < source.length - 1; ++i) {
			const ch = source[i];
			if (ch === "\r" && source[i + 1] === "\n") continue;
			if (ch === "\n") {
				const { fold, offset } = foldNewline(source, i);
				res += fold;
				i = offset;
			} else if (ch === "\\") {
				let next = source[++i];
				const cc = escapeCodes[next];
				if (cc) res += cc;
				else if (next === "\n") {
					next = source[i + 1];
					while (next === " " || next === "	") next = source[++i + 1];
				} else if (next === "\r" && source[i + 1] === "\n") {
					next = source[++i + 1];
					while (next === " " || next === "	") next = source[++i + 1];
				} else if (next === "x" || next === "u" || next === "U") {
					const length = {
						x: 2,
						u: 4,
						U: 8
					}[next];
					res += parseCharCode(source, i + 1, length, onError);
					i += length;
				} else {
					const raw = source.substr(i - 1, 2);
					onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
					res += raw;
				}
			} else if (ch === " " || ch === "	") {
				const wsStart = i;
				let next = source[i + 1];
				while (next === " " || next === "	") next = source[++i + 1];
				if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n")) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
			} else res += ch;
		}
		if (source[source.length - 1] !== "\"" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing \"quote");
		return res;
	}
	/**
	* Fold a single newline into a space, multiple newlines to N - 1 newlines.
	* Presumes `source[offset] === '\n'`
	*/
	function foldNewline(source, offset) {
		let fold = "";
		let ch = source[offset + 1];
		while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
			if (ch === "\r" && source[offset + 2] !== "\n") break;
			if (ch === "\n") fold += "\n";
			offset += 1;
			ch = source[offset + 1];
		}
		if (!fold) fold = " ";
		return {
			fold,
			offset
		};
	}
	const escapeCodes = {
		"0": "\0",
		a: "\x07",
		b: "\b",
		e: "\x1B",
		f: "\f",
		n: "\n",
		r: "\r",
		t: "	",
		v: "\v",
		N: "",
		_: "\xA0",
		L: "\u2028",
		P: "\u2029",
		" ": " ",
		"\"": "\"",
		"/": "/",
		"\\": "\\",
		"	": "	"
	};
	function parseCharCode(source, offset, length, onError) {
		const cc = source.substr(offset, length);
		const code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
		if (isNaN(code)) {
			const raw = source.substr(offset - 2, length + 2);
			onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
			return raw;
		}
		return String.fromCodePoint(code);
	}
	exports.resolveFlowScalar = resolveFlowScalar;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var resolveBlockScalar = require_resolve_block_scalar();
	var resolveFlowScalar = require_resolve_flow_scalar();
	function composeScalar(ctx, token, tagToken, onError) {
		const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
		const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
		let tag;
		if (ctx.options.stringKeys && ctx.atKey) tag = ctx.schema[identity.SCALAR];
		else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
		else if (token.type === "scalar") tag = findScalarTagByTest(ctx, value, token, onError);
		else tag = ctx.schema[identity.SCALAR];
		let scalar;
		try {
			const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
			scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
		} catch (error) {
			const msg = error instanceof Error ? error.message : String(error);
			onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
			scalar = new Scalar.Scalar(value);
		}
		scalar.range = range;
		scalar.source = value;
		if (type) scalar.type = type;
		if (tagName) scalar.tag = tagName;
		if (tag.format) scalar.format = tag.format;
		if (comment) scalar.comment = comment;
		return scalar;
	}
	function findScalarTagByName(schema, value, tagName, tagToken, onError) {
		if (tagName === "!") return schema[identity.SCALAR];
		const matchWithTest = [];
		for (const tag of schema.tags) if (!tag.collection && tag.tag === tagName) if (tag.default && tag.test) matchWithTest.push(tag);
		else return tag;
		for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
		const kt = schema.knownTags[tagName];
		if (kt && !kt.collection) {
			schema.tags.push(Object.assign({}, kt, {
				default: false,
				test: void 0
			}));
			return kt;
		}
		onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
		return schema[identity.SCALAR];
	}
	function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
		const tag = schema.tags.find((tag) => (tag.default === true || atKey && tag.default === "key") && tag.test?.test(value)) || schema[identity.SCALAR];
		if (schema.compat) {
			const compat = schema.compat.find((tag) => tag.default && tag.test?.test(value)) ?? schema[identity.SCALAR];
			if (tag.tag !== compat.tag) onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, true);
		}
		return tag;
	}
	exports.composeScalar = composeScalar;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = /* @__PURE__ */ __commonJSMin(((exports) => {
	function emptyScalarPosition(offset, before, pos) {
		if (before) {
			pos ?? (pos = before.length);
			for (let i = pos - 1; i >= 0; --i) {
				let st = before[i];
				switch (st.type) {
					case "space":
					case "comment":
					case "newline":
						offset -= st.source.length;
						continue;
				}
				st = before[++i];
				while (st?.type === "space") {
					offset += st.source.length;
					st = before[++i];
				}
				break;
			}
		}
		return offset;
	}
	exports.emptyScalarPosition = emptyScalarPosition;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var identity = require_identity();
	var composeCollection = require_compose_collection();
	var composeScalar = require_compose_scalar();
	var resolveEnd = require_resolve_end();
	var utilEmptyScalarPosition = require_util_empty_scalar_position();
	const CN = {
		composeNode,
		composeEmptyNode
	};
	function composeNode(ctx, token, props, onError) {
		const atKey = ctx.atKey;
		const { spaceBefore, comment, anchor, tag } = props;
		let node;
		let isSrcToken = true;
		switch (token.type) {
			case "alias":
				node = composeAlias(ctx, token, onError);
				if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
				break;
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "block-scalar":
				node = composeScalar.composeScalar(ctx, token, tag, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			case "block-map":
			case "block-seq":
			case "flow-collection":
				node = composeCollection.composeCollection(CN, ctx, token, props, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			default:
				onError(token, "UNEXPECTED_TOKEN", token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`);
				node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
				isSrcToken = false;
		}
		if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) onError(tag ?? token, "NON_STRING_KEY", "With stringKeys, all keys must be strings");
		if (spaceBefore) node.spaceBefore = true;
		if (comment) if (token.type === "scalar" && token.source === "") node.comment = comment;
		else node.commentBefore = comment;
		if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
		return node;
	}
	function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
		const token = {
			type: "scalar",
			offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
			indent: -1,
			source: ""
		};
		const node = composeScalar.composeScalar(ctx, token, tag, onError);
		if (anchor) {
			node.anchor = anchor.source.substring(1);
			if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		}
		if (spaceBefore) node.spaceBefore = true;
		if (comment) {
			node.comment = comment;
			node.range[2] = end;
		}
		return node;
	}
	function composeAlias({ options }, { offset, source, end }, onError) {
		const alias = new Alias.Alias(source.substring(1));
		if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
		if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
		const valueEnd = offset + source.length;
		const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
		alias.range = [
			offset,
			valueEnd,
			re.offset
		];
		if (re.comment) alias.comment = re.comment;
		return alias;
	}
	exports.composeEmptyNode = composeEmptyNode;
	exports.composeNode = composeNode;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Document = require_Document();
	var composeNode = require_compose_node();
	var resolveEnd = require_resolve_end();
	var resolveProps = require_resolve_props();
	function composeDoc(options, directives, { offset, start, value, end }, onError) {
		const opts = Object.assign({ _directives: directives }, options);
		const doc = new Document.Document(void 0, opts);
		const ctx = {
			atKey: false,
			atRoot: true,
			directives: doc.directives,
			options: doc.options,
			schema: doc.schema
		};
		const props = resolveProps.resolveProps(start, {
			indicator: "doc-start",
			next: value ?? end?.[0],
			offset,
			onError,
			parentIndent: 0,
			startOnNewline: true
		});
		if (props.found) {
			doc.directives.docStart = true;
			if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
		}
		doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
		const contentEnd = doc.contents.range[2];
		const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
		if (re.comment) doc.comment = re.comment;
		doc.range = [
			offset,
			contentEnd,
			re.offset
		];
		return doc;
	}
	exports.composeDoc = composeDoc;
}));

//#endregion
//#region ../../node_modules/yaml/dist/compose/composer.js
var require_composer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process$2 = require("process");
	var directives = require_directives();
	var Document = require_Document();
	var errors = require_errors();
	var identity = require_identity();
	var composeDoc = require_compose_doc();
	var resolveEnd = require_resolve_end();
	function getErrorPos(src) {
		if (typeof src === "number") return [src, src + 1];
		if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
		const { offset, source } = src;
		return [offset, offset + (typeof source === "string" ? source.length : 1)];
	}
	function parsePrelude(prelude) {
		let comment = "";
		let atComment = false;
		let afterEmptyLine = false;
		for (let i = 0; i < prelude.length; ++i) {
			const source = prelude[i];
			switch (source[0]) {
				case "#":
					comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
					atComment = true;
					afterEmptyLine = false;
					break;
				case "%":
					if (prelude[i + 1]?.[0] !== "#") i += 1;
					atComment = false;
					break;
				default:
					if (!atComment) afterEmptyLine = true;
					atComment = false;
			}
		}
		return {
			comment,
			afterEmptyLine
		};
	}
	/**
	* Compose a stream of CST nodes into a stream of YAML Documents.
	*
	* ```ts
	* import { Composer, Parser } from 'yaml'
	*
	* const src: string = ...
	* const tokens = new Parser().parse(src)
	* const docs = new Composer().compose(tokens)
	* ```
	*/
	var Composer = class {
		constructor(options = {}) {
			this.doc = null;
			this.atDirectives = false;
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
			this.onError = (source, code, message, warning) => {
				const pos = getErrorPos(source);
				if (warning) this.warnings.push(new errors.YAMLWarning(pos, code, message));
				else this.errors.push(new errors.YAMLParseError(pos, code, message));
			};
			this.directives = new directives.Directives({ version: options.version || "1.2" });
			this.options = options;
		}
		decorate(doc, afterDoc) {
			const { comment, afterEmptyLine } = parsePrelude(this.prelude);
			if (comment) {
				const dc = doc.contents;
				if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
				else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment;
				else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
					let it = dc.items[0];
					if (identity.isPair(it)) it = it.key;
					const cb = it.commentBefore;
					it.commentBefore = cb ? `${comment}\n${cb}` : comment;
				} else {
					const cb = dc.commentBefore;
					dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
				}
			}
			if (afterDoc) {
				Array.prototype.push.apply(doc.errors, this.errors);
				Array.prototype.push.apply(doc.warnings, this.warnings);
			} else {
				doc.errors = this.errors;
				doc.warnings = this.warnings;
			}
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
		}
		/**
		* Current stream status information.
		*
		* Mostly useful at the end of input for an empty stream.
		*/
		streamInfo() {
			return {
				comment: parsePrelude(this.prelude).comment,
				directives: this.directives,
				errors: this.errors,
				warnings: this.warnings
			};
		}
		/**
		* Compose tokens into documents.
		*
		* @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
		* @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
		*/
		*compose(tokens, forceDoc = false, endOffset = -1) {
			for (const token of tokens) yield* this.next(token);
			yield* this.end(forceDoc, endOffset);
		}
		/** Advance the composer by one CST token. */
		*next(token) {
			if (node_process$2.env.LOG_STREAM) console.dir(token, { depth: null });
			switch (token.type) {
				case "directive":
					this.directives.add(token.source, (offset, message, warning) => {
						const pos = getErrorPos(token);
						pos[0] += offset;
						this.onError(pos, "BAD_DIRECTIVE", message, warning);
					});
					this.prelude.push(token.source);
					this.atDirectives = true;
					break;
				case "document": {
					const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
					if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
					this.decorate(doc, false);
					if (this.doc) yield this.doc;
					this.doc = doc;
					this.atDirectives = false;
					break;
				}
				case "byte-order-mark":
				case "space": break;
				case "comment":
				case "newline":
					this.prelude.push(token.source);
					break;
				case "error": {
					const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
					const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
					if (this.atDirectives || !this.doc) this.errors.push(error);
					else this.doc.errors.push(error);
					break;
				}
				case "doc-end": {
					if (!this.doc) {
						this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", "Unexpected doc-end without preceding document"));
						break;
					}
					this.doc.directives.docEnd = true;
					const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
					this.decorate(this.doc, true);
					if (end.comment) {
						const dc = this.doc.comment;
						this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
					}
					this.doc.range[2] = end.offset;
					break;
				}
				default: this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
			}
		}
		/**
		* Call at end of input to yield any remaining document.
		*
		* @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
		* @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
		*/
		*end(forceDoc = false, endOffset = -1) {
			if (this.doc) {
				this.decorate(this.doc, true);
				yield this.doc;
				this.doc = null;
			} else if (forceDoc) {
				const opts = Object.assign({ _directives: this.directives }, this.options);
				const doc = new Document.Document(void 0, opts);
				if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
				doc.range = [
					0,
					endOffset,
					endOffset
				];
				this.decorate(doc, false);
				yield doc;
			}
		}
	};
	exports.Composer = Composer;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var resolveBlockScalar = require_resolve_block_scalar();
	var resolveFlowScalar = require_resolve_flow_scalar();
	var errors = require_errors();
	var stringifyString = require_stringifyString();
	function resolveAsScalar(token, strict = true, onError) {
		if (token) {
			const _onError = (pos, code, message) => {
				const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
				if (onError) onError(offset, code, message);
				else throw new errors.YAMLParseError([offset, offset + 1], code, message);
			};
			switch (token.type) {
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
				case "block-scalar": return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
			}
		}
		return null;
	}
	/**
	* Create a new scalar token with `value`
	*
	* Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	* as this function does not support any schema operations and won't check for such conflicts.
	*
	* @param value The string representation of the value, which will have its content properly indented.
	* @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
	* @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	* @param context.indent The indent level of the token.
	* @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
	* @param context.offset The offset position of the token.
	* @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	*/
	function createScalarToken(value, context) {
		const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
		const source = stringifyString.stringifyString({
			type,
			value
		}, {
			implicitKey,
			indent: indent > 0 ? " ".repeat(indent) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		const end = context.end ?? [{
			type: "newline",
			offset: -1,
			indent,
			source: "\n"
		}];
		switch (source[0]) {
			case "|":
			case ">": {
				const he = source.indexOf("\n");
				const head = source.substring(0, he);
				const body = source.substring(he + 1) + "\n";
				const props = [{
					type: "block-scalar-header",
					offset,
					indent,
					source: head
				}];
				if (!addEndtoBlockProps(props, end)) props.push({
					type: "newline",
					offset: -1,
					indent,
					source: "\n"
				});
				return {
					type: "block-scalar",
					offset,
					indent,
					props,
					source: body
				};
			}
			case "\"": return {
				type: "double-quoted-scalar",
				offset,
				indent,
				source,
				end
			};
			case "'": return {
				type: "single-quoted-scalar",
				offset,
				indent,
				source,
				end
			};
			default: return {
				type: "scalar",
				offset,
				indent,
				source,
				end
			};
		}
	}
	/**
	* Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
	*
	* Best efforts are made to retain any comments previously associated with the `token`,
	* though all contents within a collection's `items` will be overwritten.
	*
	* Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
	* as this function does not support any schema operations and won't check for such conflicts.
	*
	* @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
	* @param value The string representation of the value, which will have its content properly indented.
	* @param context.afterKey In most cases, values after a key should have an additional level of indentation.
	* @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
	* @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
	* @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
	*/
	function setScalarValue(token, value, context = {}) {
		let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
		let indent = "indent" in token ? token.indent : null;
		if (afterKey && typeof indent === "number") indent += 2;
		if (!type) switch (token.type) {
			case "single-quoted-scalar":
				type = "QUOTE_SINGLE";
				break;
			case "double-quoted-scalar":
				type = "QUOTE_DOUBLE";
				break;
			case "block-scalar": {
				const header = token.props[0];
				if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
				type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
				break;
			}
			default: type = "PLAIN";
		}
		const source = stringifyString.stringifyString({
			type,
			value
		}, {
			implicitKey: implicitKey || indent === null,
			indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		switch (source[0]) {
			case "|":
			case ">":
				setBlockScalarValue(token, source);
				break;
			case "\"":
				setFlowScalarValue(token, source, "double-quoted-scalar");
				break;
			case "'":
				setFlowScalarValue(token, source, "single-quoted-scalar");
				break;
			default: setFlowScalarValue(token, source, "scalar");
		}
	}
	function setBlockScalarValue(token, source) {
		const he = source.indexOf("\n");
		const head = source.substring(0, he);
		const body = source.substring(he + 1) + "\n";
		if (token.type === "block-scalar") {
			const header = token.props[0];
			if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
			header.source = head;
			token.source = body;
		} else {
			const { offset } = token;
			const indent = "indent" in token ? token.indent : -1;
			const props = [{
				type: "block-scalar-header",
				offset,
				indent,
				source: head
			}];
			if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0)) props.push({
				type: "newline",
				offset: -1,
				indent,
				source: "\n"
			});
			for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
			Object.assign(token, {
				type: "block-scalar",
				indent,
				props,
				source: body
			});
		}
	}
	/** @returns `true` if last token is a newline */
	function addEndtoBlockProps(props, end) {
		if (end) for (const st of end) switch (st.type) {
			case "space":
			case "comment":
				props.push(st);
				break;
			case "newline":
				props.push(st);
				return true;
		}
		return false;
	}
	function setFlowScalarValue(token, source, type) {
		switch (token.type) {
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				token.type = type;
				token.source = source;
				break;
			case "block-scalar": {
				const end = token.props.slice(1);
				let oa = source.length;
				if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
				for (const tok of end) tok.offset += oa;
				delete token.props;
				Object.assign(token, {
					type,
					source,
					end
				});
				break;
			}
			case "block-map":
			case "block-seq": {
				const nl = {
					type: "newline",
					offset: token.offset + source.length,
					indent: token.indent,
					source: "\n"
				};
				delete token.items;
				Object.assign(token, {
					type,
					source,
					end: [nl]
				});
				break;
			}
			default: {
				const indent = "indent" in token ? token.indent : -1;
				const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
				for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
				Object.assign(token, {
					type,
					indent,
					source,
					end
				});
			}
		}
	}
	exports.createScalarToken = createScalarToken;
	exports.resolveAsScalar = resolveAsScalar;
	exports.setScalarValue = setScalarValue;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Stringify a CST document, token, or collection item
	*
	* Fair warning: This applies no validation whatsoever, and
	* simply concatenates the sources in their logical order.
	*/
	const stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
	function stringifyToken(token) {
		switch (token.type) {
			case "block-scalar": {
				let res = "";
				for (const tok of token.props) res += stringifyToken(tok);
				return res + token.source;
			}
			case "block-map":
			case "block-seq": {
				let res = "";
				for (const item of token.items) res += stringifyItem(item);
				return res;
			}
			case "flow-collection": {
				let res = token.start.source;
				for (const item of token.items) res += stringifyItem(item);
				for (const st of token.end) res += st.source;
				return res;
			}
			case "document": {
				let res = stringifyItem(token);
				if (token.end) for (const st of token.end) res += st.source;
				return res;
			}
			default: {
				let res = token.source;
				if ("end" in token && token.end) for (const st of token.end) res += st.source;
				return res;
			}
		}
	}
	function stringifyItem({ start, key, sep, value }) {
		let res = "";
		for (const st of start) res += st.source;
		if (key) res += stringifyToken(key);
		if (sep) for (const st of sep) res += st.source;
		if (value) res += stringifyToken(value);
		return res;
	}
	exports.stringify = stringify;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = /* @__PURE__ */ __commonJSMin(((exports) => {
	const BREAK = Symbol("break visit");
	const SKIP = Symbol("skip children");
	const REMOVE = Symbol("remove item");
	/**
	* Apply a visitor to a CST document or item.
	*
	* Walks through the tree (depth-first) starting from the root, calling a
	* `visitor` function with two arguments when entering each item:
	*   - `item`: The current item, which included the following members:
	*     - `start: SourceToken[]`  Source tokens before the key or value,
	*       possibly including its anchor or tag.
	*     - `key?: Token | null`  Set for pair values. May then be `null`, if
	*       the key before the `:` separator is empty.
	*     - `sep?: SourceToken[]`  Source tokens between the key and the value,
	*       which should include the `:` map value indicator if `value` is set.
	*     - `value?: Token`  The value of a sequence item, or of a map pair.
	*   - `path`: The steps from the root to the current node, as an array of
	*     `['key' | 'value', number]` tuples.
	*
	* The return value of the visitor may be used to control the traversal:
	*   - `undefined` (default): Do nothing and continue
	*   - `visit.SKIP`: Do not visit the children of this token, continue with
	*      next sibling
	*   - `visit.BREAK`: Terminate traversal completely
	*   - `visit.REMOVE`: Remove the current item, then continue with the next one
	*   - `number`: Set the index of the next step. This is useful especially if
	*     the index of the current token has changed.
	*   - `function`: Define the next visitor for this item. After the original
	*     visitor is called on item entry, next visitors are called after handling
	*     a non-empty `key` and when exiting the item.
	*/
	function visit(cst, visitor) {
		if ("type" in cst && cst.type === "document") cst = {
			start: cst.start,
			value: cst.value
		};
		_visit(Object.freeze([]), cst, visitor);
	}
	/** Terminate visit traversal completely */
	visit.BREAK = BREAK;
	/** Do not visit the children of the current item */
	visit.SKIP = SKIP;
	/** Remove the current item */
	visit.REMOVE = REMOVE;
	/** Find the item at `path` from `cst` as the root */
	visit.itemAtPath = (cst, path) => {
		let item = cst;
		for (const [field, index] of path) {
			const tok = item?.[field];
			if (tok && "items" in tok) item = tok.items[index];
			else return void 0;
		}
		return item;
	};
	/**
	* Get the immediate parent collection of the item at `path` from `cst` as the root.
	*
	* Throws an error if the collection is not found, which should never happen if the item itself exists.
	*/
	visit.parentCollection = (cst, path) => {
		const parent = visit.itemAtPath(cst, path.slice(0, -1));
		const field = path[path.length - 1][0];
		const coll = parent?.[field];
		if (coll && "items" in coll) return coll;
		throw new Error("Parent collection not found");
	};
	function _visit(path, item, visitor) {
		let ctrl = visitor(item, path);
		if (typeof ctrl === "symbol") return ctrl;
		for (const field of ["key", "value"]) {
			const token = item[field];
			if (token && "items" in token) {
				for (let i = 0; i < token.items.length; ++i) {
					const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						token.items.splice(i, 1);
						i -= 1;
					}
				}
				if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path);
			}
		}
		return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
	}
	exports.visit = visit;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/cst.js
var require_cst = /* @__PURE__ */ __commonJSMin(((exports) => {
	var cstScalar = require_cst_scalar();
	var cstStringify = require_cst_stringify();
	var cstVisit = require_cst_visit();
	/** The byte order mark */
	const BOM = "";
	/** Start of doc-mode */
	const DOCUMENT = "";
	/** Unexpected end of flow-mode */
	const FLOW_END = "";
	/** Next token is a scalar value */
	const SCALAR = "";
	/** @returns `true` if `token` is a flow or block collection */
	const isCollection = (token) => !!token && "items" in token;
	/** @returns `true` if `token` is a flow or block scalar; not an alias */
	const isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
	/* istanbul ignore next */
	/** Get a printable representation of a lexer token */
	function prettyToken(token) {
		switch (token) {
			case BOM: return "<BOM>";
			case DOCUMENT: return "<DOC>";
			case FLOW_END: return "<FLOW_END>";
			case SCALAR: return "<SCALAR>";
			default: return JSON.stringify(token);
		}
	}
	/** Identify the type of a lexer token. May return `null` for unknown tokens. */
	function tokenType(source) {
		switch (source) {
			case BOM: return "byte-order-mark";
			case DOCUMENT: return "doc-mode";
			case FLOW_END: return "flow-error-end";
			case SCALAR: return "scalar";
			case "---": return "doc-start";
			case "...": return "doc-end";
			case "":
			case "\n":
			case "\r\n": return "newline";
			case "-": return "seq-item-ind";
			case "?": return "explicit-key-ind";
			case ":": return "map-value-ind";
			case "{": return "flow-map-start";
			case "}": return "flow-map-end";
			case "[": return "flow-seq-start";
			case "]": return "flow-seq-end";
			case ",": return "comma";
		}
		switch (source[0]) {
			case " ":
			case "	": return "space";
			case "#": return "comment";
			case "%": return "directive-line";
			case "*": return "alias";
			case "&": return "anchor";
			case "!": return "tag";
			case "'": return "single-quoted-scalar";
			case "\"": return "double-quoted-scalar";
			case "|":
			case ">": return "block-scalar-header";
		}
		return null;
	}
	exports.createScalarToken = cstScalar.createScalarToken;
	exports.resolveAsScalar = cstScalar.resolveAsScalar;
	exports.setScalarValue = cstScalar.setScalarValue;
	exports.stringify = cstStringify.stringify;
	exports.visit = cstVisit.visit;
	exports.BOM = BOM;
	exports.DOCUMENT = DOCUMENT;
	exports.FLOW_END = FLOW_END;
	exports.SCALAR = SCALAR;
	exports.isCollection = isCollection;
	exports.isScalar = isScalar;
	exports.prettyToken = prettyToken;
	exports.tokenType = tokenType;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/lexer.js
var require_lexer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var cst = require_cst();
	function isEmpty(ch) {
		switch (ch) {
			case void 0:
			case " ":
			case "\n":
			case "\r":
			case "	": return true;
			default: return false;
		}
	}
	const hexDigits = /* @__PURE__ */ new Set("0123456789ABCDEFabcdef");
	const tagChars = /* @__PURE__ */ new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
	const flowIndicatorChars = /* @__PURE__ */ new Set(",[]{}");
	const invalidAnchorChars = /* @__PURE__ */ new Set(" ,[]{}\n\r	");
	const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
	/**
	* Splits an input string into lexical tokens, i.e. smaller strings that are
	* easily identifiable by `tokens.tokenType()`.
	*
	* Lexing starts always in a "stream" context. Incomplete input may be buffered
	* until a complete token can be emitted.
	*
	* In addition to slices of the original input, the following control characters
	* may also be emitted:
	*
	* - `\x02` (Start of Text): A document starts with the next token
	* - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
	* - `\x1f` (Unit Separator): Next token is a scalar value
	* - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
	*/
	var Lexer = class {
		constructor() {
			/**
			* Flag indicating whether the end of the current buffer marks the end of
			* all input
			*/
			this.atEnd = false;
			/**
			* Explicit indent set in block scalar header, as an offset from the current
			* minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
			* explicitly set.
			*/
			this.blockScalarIndent = -1;
			/**
			* Block scalars that include a + (keep) chomping indicator in their header
			* include trailing empty lines, which are otherwise excluded from the
			* scalar's contents.
			*/
			this.blockScalarKeep = false;
			/** Current input */
			this.buffer = "";
			/**
			* Flag noting whether the map value indicator : can immediately follow this
			* node within a flow context.
			*/
			this.flowKey = false;
			/** Count of surrounding flow collection levels. */
			this.flowLevel = 0;
			/**
			* Minimum level of indentation required for next lines to be parsed as a
			* part of the current scalar value.
			*/
			this.indentNext = 0;
			/** Indentation level of the current line. */
			this.indentValue = 0;
			/** Position of the next \n character. */
			this.lineEndPos = null;
			/** Stores the state of the lexer if reaching the end of incpomplete input */
			this.next = null;
			/** A pointer to `buffer`; the current position of the lexer. */
			this.pos = 0;
		}
		/**
		* Generate YAML tokens from the `source` string. If `incomplete`,
		* a part of the last line may be left as a buffer for the next call.
		*
		* @returns A generator of lexical tokens
		*/
		*lex(source, incomplete = false) {
			if (source) {
				if (typeof source !== "string") throw TypeError("source is not a string");
				this.buffer = this.buffer ? this.buffer + source : source;
				this.lineEndPos = null;
			}
			this.atEnd = !incomplete;
			let next = this.next ?? "stream";
			while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
		}
		atLineEnd() {
			let i = this.pos;
			let ch = this.buffer[i];
			while (ch === " " || ch === "	") ch = this.buffer[++i];
			if (!ch || ch === "#" || ch === "\n") return true;
			if (ch === "\r") return this.buffer[i + 1] === "\n";
			return false;
		}
		charAt(n) {
			return this.buffer[this.pos + n];
		}
		continueScalar(offset) {
			let ch = this.buffer[offset];
			if (this.indentNext > 0) {
				let indent = 0;
				while (ch === " ") ch = this.buffer[++indent + offset];
				if (ch === "\r") {
					const next = this.buffer[indent + offset + 1];
					if (next === "\n" || !next && !this.atEnd) return offset + indent + 1;
				}
				return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
			}
			if (ch === "-" || ch === ".") {
				const dt = this.buffer.substr(offset, 3);
				if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3])) return -1;
			}
			return offset;
		}
		getLine() {
			let end = this.lineEndPos;
			if (typeof end !== "number" || end !== -1 && end < this.pos) {
				end = this.buffer.indexOf("\n", this.pos);
				this.lineEndPos = end;
			}
			if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
			if (this.buffer[end - 1] === "\r") end -= 1;
			return this.buffer.substring(this.pos, end);
		}
		hasChars(n) {
			return this.pos + n <= this.buffer.length;
		}
		setNext(state) {
			this.buffer = this.buffer.substring(this.pos);
			this.pos = 0;
			this.lineEndPos = null;
			this.next = state;
			return null;
		}
		peek(n) {
			return this.buffer.substr(this.pos, n);
		}
		*parseNext(next) {
			switch (next) {
				case "stream": return yield* this.parseStream();
				case "line-start": return yield* this.parseLineStart();
				case "block-start": return yield* this.parseBlockStart();
				case "doc": return yield* this.parseDocument();
				case "flow": return yield* this.parseFlowCollection();
				case "quoted-scalar": return yield* this.parseQuotedScalar();
				case "block-scalar": return yield* this.parseBlockScalar();
				case "plain-scalar": return yield* this.parsePlainScalar();
			}
		}
		*parseStream() {
			let line = this.getLine();
			if (line === null) return this.setNext("stream");
			if (line[0] === cst.BOM) {
				yield* this.pushCount(1);
				line = line.substring(1);
			}
			if (line[0] === "%") {
				let dirEnd = line.length;
				let cs = line.indexOf("#");
				while (cs !== -1) {
					const ch = line[cs - 1];
					if (ch === " " || ch === "	") {
						dirEnd = cs - 1;
						break;
					} else cs = line.indexOf("#", cs + 1);
				}
				while (true) {
					const ch = line[dirEnd - 1];
					if (ch === " " || ch === "	") dirEnd -= 1;
					else break;
				}
				const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
				yield* this.pushCount(line.length - n);
				this.pushNewline();
				return "stream";
			}
			if (this.atLineEnd()) {
				const sp = yield* this.pushSpaces(true);
				yield* this.pushCount(line.length - sp);
				yield* this.pushNewline();
				return "stream";
			}
			yield cst.DOCUMENT;
			return yield* this.parseLineStart();
		}
		*parseLineStart() {
			const ch = this.charAt(0);
			if (!ch && !this.atEnd) return this.setNext("line-start");
			if (ch === "-" || ch === ".") {
				if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
				const s = this.peek(3);
				if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
					yield* this.pushCount(3);
					this.indentValue = 0;
					this.indentNext = 0;
					return s === "---" ? "doc" : "stream";
				}
			}
			this.indentValue = yield* this.pushSpaces(false);
			if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
			return yield* this.parseBlockStart();
		}
		*parseBlockStart() {
			const [ch0, ch1] = this.peek(2);
			if (!ch1 && !this.atEnd) return this.setNext("block-start");
			if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
				const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
				this.indentNext = this.indentValue + 1;
				this.indentValue += n;
				return yield* this.parseBlockStart();
			}
			return "doc";
		}
		*parseDocument() {
			yield* this.pushSpaces(true);
			const line = this.getLine();
			if (line === null) return this.setNext("doc");
			let n = yield* this.pushIndicators();
			switch (line[n]) {
				case "#": yield* this.pushCount(line.length - n);
				case void 0:
					yield* this.pushNewline();
					return yield* this.parseLineStart();
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel = 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					return "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "doc";
				case "\"":
				case "'": return yield* this.parseQuotedScalar();
				case "|":
				case ">":
					n += yield* this.parseBlockScalarHeader();
					n += yield* this.pushSpaces(true);
					yield* this.pushCount(line.length - n);
					yield* this.pushNewline();
					return yield* this.parseBlockScalar();
				default: return yield* this.parsePlainScalar();
			}
		}
		*parseFlowCollection() {
			let nl, sp;
			let indent = -1;
			do {
				nl = yield* this.pushNewline();
				if (nl > 0) {
					sp = yield* this.pushSpaces(false);
					this.indentValue = indent = sp;
				} else sp = 0;
				sp += yield* this.pushSpaces(true);
			} while (nl + sp > 0);
			const line = this.getLine();
			if (line === null) return this.setNext("flow");
			if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
				if (!(indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}"))) {
					this.flowLevel = 0;
					yield cst.FLOW_END;
					return yield* this.parseLineStart();
				}
			}
			let n = 0;
			while (line[n] === ",") {
				n += yield* this.pushCount(1);
				n += yield* this.pushSpaces(true);
				this.flowKey = false;
			}
			n += yield* this.pushIndicators();
			switch (line[n]) {
				case void 0: return "flow";
				case "#":
					yield* this.pushCount(line.length - n);
					return "flow";
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel += 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					this.flowKey = true;
					this.flowLevel -= 1;
					return this.flowLevel ? "flow" : "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "flow";
				case "\"":
				case "'":
					this.flowKey = true;
					return yield* this.parseQuotedScalar();
				case ":": {
					const next = this.charAt(1);
					if (this.flowKey || isEmpty(next) || next === ",") {
						this.flowKey = false;
						yield* this.pushCount(1);
						yield* this.pushSpaces(true);
						return "flow";
					}
				}
				default:
					this.flowKey = false;
					return yield* this.parsePlainScalar();
			}
		}
		*parseQuotedScalar() {
			const quote = this.charAt(0);
			let end = this.buffer.indexOf(quote, this.pos + 1);
			if (quote === "'") while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
			else while (end !== -1) {
				let n = 0;
				while (this.buffer[end - 1 - n] === "\\") n += 1;
				if (n % 2 === 0) break;
				end = this.buffer.indexOf("\"", end + 1);
			}
			const qb = this.buffer.substring(0, end);
			let nl = qb.indexOf("\n", this.pos);
			if (nl !== -1) {
				while (nl !== -1) {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = qb.indexOf("\n", cs);
				}
				if (nl !== -1) end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
			}
			if (end === -1) {
				if (!this.atEnd) return this.setNext("quoted-scalar");
				end = this.buffer.length;
			}
			yield* this.pushToIndex(end + 1, false);
			return this.flowLevel ? "flow" : "doc";
		}
		*parseBlockScalarHeader() {
			this.blockScalarIndent = -1;
			this.blockScalarKeep = false;
			let i = this.pos;
			while (true) {
				const ch = this.buffer[++i];
				if (ch === "+") this.blockScalarKeep = true;
				else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
				else if (ch !== "-") break;
			}
			return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
		}
		*parseBlockScalar() {
			let nl = this.pos - 1;
			let indent = 0;
			let ch;
			loop: for (let i = this.pos; ch = this.buffer[i]; ++i) switch (ch) {
				case " ":
					indent += 1;
					break;
				case "\n":
					nl = i;
					indent = 0;
					break;
				case "\r": {
					const next = this.buffer[i + 1];
					if (!next && !this.atEnd) return this.setNext("block-scalar");
					if (next === "\n") break;
				}
				default: break loop;
			}
			if (!ch && !this.atEnd) return this.setNext("block-scalar");
			if (indent >= this.indentNext) {
				if (this.blockScalarIndent === -1) this.indentNext = indent;
				else this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
				do {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = this.buffer.indexOf("\n", cs);
				} while (nl !== -1);
				if (nl === -1) {
					if (!this.atEnd) return this.setNext("block-scalar");
					nl = this.buffer.length;
				}
			}
			let i = nl + 1;
			ch = this.buffer[i];
			while (ch === " ") ch = this.buffer[++i];
			if (ch === "	") {
				while (ch === "	" || ch === " " || ch === "\r" || ch === "\n") ch = this.buffer[++i];
				nl = i - 1;
			} else if (!this.blockScalarKeep) do {
				let i = nl - 1;
				let ch = this.buffer[i];
				if (ch === "\r") ch = this.buffer[--i];
				const lastChar = i;
				while (ch === " ") ch = this.buffer[--i];
				if (ch === "\n" && i >= this.pos && i + 1 + indent > lastChar) nl = i;
				else break;
			} while (true);
			yield cst.SCALAR;
			yield* this.pushToIndex(nl + 1, true);
			return yield* this.parseLineStart();
		}
		*parsePlainScalar() {
			const inFlow = this.flowLevel > 0;
			let end = this.pos - 1;
			let i = this.pos - 1;
			let ch;
			while (ch = this.buffer[++i]) if (ch === ":") {
				const next = this.buffer[i + 1];
				if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
				end = i;
			} else if (isEmpty(ch)) {
				let next = this.buffer[i + 1];
				if (ch === "\r") if (next === "\n") {
					i += 1;
					ch = "\n";
					next = this.buffer[i + 1];
				} else end = i;
				if (next === "#" || inFlow && flowIndicatorChars.has(next)) break;
				if (ch === "\n") {
					const cs = this.continueScalar(i + 1);
					if (cs === -1) break;
					i = Math.max(i, cs - 2);
				}
			} else {
				if (inFlow && flowIndicatorChars.has(ch)) break;
				end = i;
			}
			if (!ch && !this.atEnd) return this.setNext("plain-scalar");
			yield cst.SCALAR;
			yield* this.pushToIndex(end + 1, true);
			return inFlow ? "flow" : "doc";
		}
		*pushCount(n) {
			if (n > 0) {
				yield this.buffer.substr(this.pos, n);
				this.pos += n;
				return n;
			}
			return 0;
		}
		*pushToIndex(i, allowEmpty) {
			const s = this.buffer.slice(this.pos, i);
			if (s) {
				yield s;
				this.pos += s.length;
				return s.length;
			} else if (allowEmpty) yield "";
			return 0;
		}
		*pushIndicators() {
			switch (this.charAt(0)) {
				case "!": return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "&": return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "-":
				case "?":
				case ":": {
					const inFlow = this.flowLevel > 0;
					const ch1 = this.charAt(1);
					if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
						if (!inFlow) this.indentNext = this.indentValue + 1;
						else if (this.flowKey) this.flowKey = false;
						return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
					}
				}
			}
			return 0;
		}
		*pushTag() {
			if (this.charAt(1) === "<") {
				let i = this.pos + 2;
				let ch = this.buffer[i];
				while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i];
				return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
			} else {
				let i = this.pos + 1;
				let ch = this.buffer[i];
				while (ch) if (tagChars.has(ch)) ch = this.buffer[++i];
				else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) ch = this.buffer[i += 3];
				else break;
				return yield* this.pushToIndex(i, false);
			}
		}
		*pushNewline() {
			const ch = this.buffer[this.pos];
			if (ch === "\n") return yield* this.pushCount(1);
			else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
			else return 0;
		}
		*pushSpaces(allowTabs) {
			let i = this.pos - 1;
			let ch;
			do
				ch = this.buffer[++i];
			while (ch === " " || allowTabs && ch === "	");
			const n = i - this.pos;
			if (n > 0) {
				yield this.buffer.substr(this.pos, n);
				this.pos = i;
			}
			return n;
		}
		*pushUntil(test) {
			let i = this.pos;
			let ch = this.buffer[i];
			while (!test(ch)) ch = this.buffer[++i];
			return yield* this.pushToIndex(i, false);
		}
	};
	exports.Lexer = Lexer;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Tracks newlines during parsing in order to provide an efficient API for
	* determining the one-indexed `{ line, col }` position for any offset
	* within the input.
	*/
	var LineCounter = class {
		constructor() {
			this.lineStarts = [];
			/**
			* Should be called in ascending order. Otherwise, call
			* `lineCounter.lineStarts.sort()` before calling `linePos()`.
			*/
			this.addNewLine = (offset) => this.lineStarts.push(offset);
			/**
			* Performs a binary search and returns the 1-indexed { line, col }
			* position of `offset`. If `line === 0`, `addNewLine` has never been
			* called or `offset` is before the first known newline.
			*/
			this.linePos = (offset) => {
				let low = 0;
				let high = this.lineStarts.length;
				while (low < high) {
					const mid = low + high >> 1;
					if (this.lineStarts[mid] < offset) low = mid + 1;
					else high = mid;
				}
				if (this.lineStarts[low] === offset) return {
					line: low + 1,
					col: 1
				};
				if (low === 0) return {
					line: 0,
					col: offset
				};
				const start = this.lineStarts[low - 1];
				return {
					line: low,
					col: offset - start + 1
				};
			};
		}
	};
	exports.LineCounter = LineCounter;
}));

//#endregion
//#region ../../node_modules/yaml/dist/parse/parser.js
var require_parser = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process$1 = require("process");
	var cst = require_cst();
	var lexer = require_lexer();
	function includesToken(list, type) {
		for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;
		return false;
	}
	function findNonEmptyIndex(list) {
		for (let i = 0; i < list.length; ++i) switch (list[i].type) {
			case "space":
			case "comment":
			case "newline": break;
			default: return i;
		}
		return -1;
	}
	function isFlowToken(token) {
		switch (token?.type) {
			case "alias":
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "flow-collection": return true;
			default: return false;
		}
	}
	function getPrevProps(parent) {
		switch (parent.type) {
			case "document": return parent.start;
			case "block-map": {
				const it = parent.items[parent.items.length - 1];
				return it.sep ?? it.start;
			}
			case "block-seq": return parent.items[parent.items.length - 1].start;
			default: return [];
		}
	}
	/** Note: May modify input array */
	function getFirstKeyStartProps(prev) {
		if (prev.length === 0) return [];
		let i = prev.length;
		loop: while (--i >= 0) switch (prev[i].type) {
			case "doc-start":
			case "explicit-key-ind":
			case "map-value-ind":
			case "seq-item-ind":
			case "newline": break loop;
		}
		while (prev[++i]?.type === "space");
		return prev.splice(i, prev.length);
	}
	function fixFlowSeqItems(fc) {
		if (fc.start.type === "flow-seq-start") {
			for (const it of fc.items) if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
				if (it.key) it.value = it.key;
				delete it.key;
				if (isFlowToken(it.value)) if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
				else it.value.end = it.sep;
				else Array.prototype.push.apply(it.start, it.sep);
				delete it.sep;
			}
		}
	}
	/**
	* A YAML concrete syntax tree (CST) parser
	*
	* ```ts
	* const src: string = ...
	* for (const token of new Parser().parse(src)) {
	*   // token: Token
	* }
	* ```
	*
	* To use the parser with a user-provided lexer:
	*
	* ```ts
	* function* parse(source: string, lexer: Lexer) {
	*   const parser = new Parser()
	*   for (const lexeme of lexer.lex(source))
	*     yield* parser.next(lexeme)
	*   yield* parser.end()
	* }
	*
	* const src: string = ...
	* const lexer = new Lexer()
	* for (const token of parse(src, lexer)) {
	*   // token: Token
	* }
	* ```
	*/
	var Parser = class {
		/**
		* @param onNewLine - If defined, called separately with the start position of
		*   each new line (in `parse()`, including the start of input).
		*/
		constructor(onNewLine) {
			/** If true, space and sequence indicators count as indentation */
			this.atNewLine = true;
			/** If true, next token is a scalar value */
			this.atScalar = false;
			/** Current indentation level */
			this.indent = 0;
			/** Current offset since the start of parsing */
			this.offset = 0;
			/** On the same line with a block map key */
			this.onKeyLine = false;
			/** Top indicates the node that's currently being built */
			this.stack = [];
			/** The source of the current token, set in parse() */
			this.source = "";
			/** The type of the current token, set in parse() */
			this.type = "";
			this.lexer = new lexer.Lexer();
			this.onNewLine = onNewLine;
		}
		/**
		* Parse `source` as a YAML stream.
		* If `incomplete`, a part of the last line may be left as a buffer for the next call.
		*
		* Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
		*
		* @returns A generator of tokens representing each directive, document, and other structure.
		*/
		*parse(source, incomplete = false) {
			if (this.onNewLine && this.offset === 0) this.onNewLine(0);
			for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
			if (!incomplete) yield* this.end();
		}
		/**
		* Advance the parser by the `source` of one lexical token.
		*/
		*next(source) {
			this.source = source;
			if (node_process$1.env.LOG_TOKENS) console.log("|", cst.prettyToken(source));
			if (this.atScalar) {
				this.atScalar = false;
				yield* this.step();
				this.offset += source.length;
				return;
			}
			const type = cst.tokenType(source);
			if (!type) {
				const message = `Not a YAML token: ${source}`;
				yield* this.pop({
					type: "error",
					offset: this.offset,
					message,
					source
				});
				this.offset += source.length;
			} else if (type === "scalar") {
				this.atNewLine = false;
				this.atScalar = true;
				this.type = "scalar";
			} else {
				this.type = type;
				yield* this.step();
				switch (type) {
					case "newline":
						this.atNewLine = true;
						this.indent = 0;
						if (this.onNewLine) this.onNewLine(this.offset + source.length);
						break;
					case "space":
						if (this.atNewLine && source[0] === " ") this.indent += source.length;
						break;
					case "explicit-key-ind":
					case "map-value-ind":
					case "seq-item-ind":
						if (this.atNewLine) this.indent += source.length;
						break;
					case "doc-mode":
					case "flow-error-end": return;
					default: this.atNewLine = false;
				}
				this.offset += source.length;
			}
		}
		/** Call at end of input to push out any remaining constructions */
		*end() {
			while (this.stack.length > 0) yield* this.pop();
		}
		get sourceToken() {
			return {
				type: this.type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		*step() {
			const top = this.peek(1);
			if (this.type === "doc-end" && top?.type !== "doc-end") {
				while (this.stack.length > 0) yield* this.pop();
				this.stack.push({
					type: "doc-end",
					offset: this.offset,
					source: this.source
				});
				return;
			}
			if (!top) return yield* this.stream();
			switch (top.type) {
				case "document": return yield* this.document(top);
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return yield* this.scalar(top);
				case "block-scalar": return yield* this.blockScalar(top);
				case "block-map": return yield* this.blockMap(top);
				case "block-seq": return yield* this.blockSequence(top);
				case "flow-collection": return yield* this.flowCollection(top);
				case "doc-end": return yield* this.documentEnd(top);
			}
			/* istanbul ignore next should not happen */
			yield* this.pop();
		}
		peek(n) {
			return this.stack[this.stack.length - n];
		}
		*pop(error) {
			const token = error ?? this.stack.pop();
			/* istanbul ignore if should not happen */
			if (!token) yield {
				type: "error",
				offset: this.offset,
				source: "",
				message: "Tried to pop an empty stack"
			};
			else if (this.stack.length === 0) yield token;
			else {
				const top = this.peek(1);
				if (token.type === "block-scalar") token.indent = "indent" in top ? top.indent : 0;
				else if (token.type === "flow-collection" && top.type === "document") token.indent = 0;
				if (token.type === "flow-collection") fixFlowSeqItems(token);
				switch (top.type) {
					case "document":
						top.value = token;
						break;
					case "block-scalar":
						top.props.push(token);
						break;
					case "block-map": {
						const it = top.items[top.items.length - 1];
						if (it.value) {
							top.items.push({
								start: [],
								key: token,
								sep: []
							});
							this.onKeyLine = true;
							return;
						} else if (it.sep) it.value = token;
						else {
							Object.assign(it, {
								key: token,
								sep: []
							});
							this.onKeyLine = !it.explicitKey;
							return;
						}
						break;
					}
					case "block-seq": {
						const it = top.items[top.items.length - 1];
						if (it.value) top.items.push({
							start: [],
							value: token
						});
						else it.value = token;
						break;
					}
					case "flow-collection": {
						const it = top.items[top.items.length - 1];
						if (!it || it.value) top.items.push({
							start: [],
							key: token,
							sep: []
						});
						else if (it.sep) it.value = token;
						else Object.assign(it, {
							key: token,
							sep: []
						});
						return;
					}
					default:
						yield* this.pop();
						yield* this.pop(token);
				}
				if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
					const last = token.items[token.items.length - 1];
					if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
						if (top.type === "document") top.end = last.start;
						else top.items.push({ start: last.start });
						token.items.splice(-1, 1);
					}
				}
			}
		}
		*stream() {
			switch (this.type) {
				case "directive-line":
					yield {
						type: "directive",
						offset: this.offset,
						source: this.source
					};
					return;
				case "byte-order-mark":
				case "space":
				case "comment":
				case "newline":
					yield this.sourceToken;
					return;
				case "doc-mode":
				case "doc-start": {
					const doc = {
						type: "document",
						offset: this.offset,
						start: []
					};
					if (this.type === "doc-start") doc.start.push(this.sourceToken);
					this.stack.push(doc);
					return;
				}
			}
			yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML stream`,
				source: this.source
			};
		}
		*document(doc) {
			if (doc.value) return yield* this.lineEnd(doc);
			switch (this.type) {
				case "doc-start":
					if (findNonEmptyIndex(doc.start) !== -1) {
						yield* this.pop();
						yield* this.step();
					} else doc.start.push(this.sourceToken);
					return;
				case "anchor":
				case "tag":
				case "space":
				case "comment":
				case "newline":
					doc.start.push(this.sourceToken);
					return;
			}
			const bv = this.startBlockValue(doc);
			if (bv) this.stack.push(bv);
			else yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML document`,
				source: this.source
			};
		}
		*scalar(scalar) {
			if (this.type === "map-value-ind") {
				const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
				let sep;
				if (scalar.end) {
					sep = scalar.end;
					sep.push(this.sourceToken);
					delete scalar.end;
				} else sep = [this.sourceToken];
				const map = {
					type: "block-map",
					offset: scalar.offset,
					indent: scalar.indent,
					items: [{
						start,
						key: scalar,
						sep
					}]
				};
				this.onKeyLine = true;
				this.stack[this.stack.length - 1] = map;
			} else yield* this.lineEnd(scalar);
		}
		*blockScalar(scalar) {
			switch (this.type) {
				case "space":
				case "comment":
				case "newline":
					scalar.props.push(this.sourceToken);
					return;
				case "scalar":
					scalar.source = this.source;
					this.atNewLine = true;
					this.indent = 0;
					if (this.onNewLine) {
						let nl = this.source.indexOf("\n") + 1;
						while (nl !== 0) {
							this.onNewLine(this.offset + nl);
							nl = this.source.indexOf("\n", nl) + 1;
						}
					}
					yield* this.pop();
					break;
				default:
					yield* this.pop();
					yield* this.step();
			}
		}
		*blockMap(map) {
			const it = map.items[map.items.length - 1];
			switch (this.type) {
				case "newline":
					this.onKeyLine = false;
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else map.items.push({ start: [this.sourceToken] });
					} else if (it.sep) it.sep.push(this.sourceToken);
					else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) map.items.push({ start: [this.sourceToken] });
					else if (it.sep) it.sep.push(this.sourceToken);
					else {
						if (this.atIndentedComment(it.start, map.indent)) {
							const end = map.items[map.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								map.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
			}
			if (this.indent >= map.indent) {
				const atMapIndent = !this.onKeyLine && this.indent === map.indent;
				const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
				let start = [];
				if (atNextItem && it.sep && !it.value) {
					const nl = [];
					for (let i = 0; i < it.sep.length; ++i) {
						const st = it.sep[i];
						switch (st.type) {
							case "newline":
								nl.push(i);
								break;
							case "space": break;
							case "comment":
								if (st.indent > map.indent) nl.length = 0;
								break;
							default: nl.length = 0;
						}
					}
					if (nl.length >= 2) start = it.sep.splice(nl[1]);
				}
				switch (this.type) {
					case "anchor":
					case "tag":
						if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map.items.push({ start });
							this.onKeyLine = true;
						} else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "explicit-key-ind":
						if (!it.sep && !it.explicitKey) {
							it.start.push(this.sourceToken);
							it.explicitKey = true;
						} else if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map.items.push({
								start,
								explicitKey: true
							});
						} else this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [this.sourceToken],
								explicitKey: true
							}]
						});
						this.onKeyLine = true;
						return;
					case "map-value-ind":
						if (it.explicitKey) if (!it.sep) if (includesToken(it.start, "newline")) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else {
							const start = getFirstKeyStartProps(it.start);
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start,
									key: null,
									sep: [this.sourceToken]
								}]
							});
						}
						else if (it.value) map.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start,
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
							const start = getFirstKeyStartProps(it.start);
							const key = it.key;
							const sep = it.sep;
							sep.push(this.sourceToken);
							delete it.key;
							delete it.sep;
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start,
									key,
									sep
								}]
							});
						} else if (start.length > 0) it.sep = it.sep.concat(start, this.sourceToken);
						else it.sep.push(this.sourceToken);
						else if (!it.sep) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.value || atNextItem) map.items.push({
							start,
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [],
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else it.sep.push(this.sourceToken);
						this.onKeyLine = true;
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs = this.flowScalar(this.type);
						if (atNextItem || it.value) {
							map.items.push({
								start,
								key: fs,
								sep: []
							});
							this.onKeyLine = true;
						} else if (it.sep) this.stack.push(fs);
						else {
							Object.assign(it, {
								key: fs,
								sep: []
							});
							this.onKeyLine = true;
						}
						return;
					}
					default: {
						const bv = this.startBlockValue(map);
						if (bv) {
							if (bv.type === "block-seq") {
								if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
									yield* this.pop({
										type: "error",
										offset: this.offset,
										message: "Unexpected block-seq-ind on same line with key",
										source: this.source
									});
									return;
								}
							} else if (atMapIndent) map.items.push({ start });
							this.stack.push(bv);
							return;
						}
					}
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*blockSequence(seq) {
			const it = seq.items[seq.items.length - 1];
			switch (this.type) {
				case "newline":
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else seq.items.push({ start: [this.sourceToken] });
					} else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) seq.items.push({ start: [this.sourceToken] });
					else {
						if (this.atIndentedComment(it.start, seq.indent)) {
							const end = seq.items[seq.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								seq.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
				case "anchor":
				case "tag":
					if (it.value || this.indent <= seq.indent) break;
					it.start.push(this.sourceToken);
					return;
				case "seq-item-ind":
					if (this.indent !== seq.indent) break;
					if (it.value || includesToken(it.start, "seq-item-ind")) seq.items.push({ start: [this.sourceToken] });
					else it.start.push(this.sourceToken);
					return;
			}
			if (this.indent > seq.indent) {
				const bv = this.startBlockValue(seq);
				if (bv) {
					this.stack.push(bv);
					return;
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*flowCollection(fc) {
			const it = fc.items[fc.items.length - 1];
			if (this.type === "flow-error-end") {
				let top;
				do {
					yield* this.pop();
					top = this.peek(1);
				} while (top?.type === "flow-collection");
			} else if (fc.end.length === 0) {
				switch (this.type) {
					case "comma":
					case "explicit-key-ind":
						if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
						else it.start.push(this.sourceToken);
						return;
					case "map-value-ind":
						if (!it || it.value) fc.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.sep) it.sep.push(this.sourceToken);
						else Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						return;
					case "space":
					case "comment":
					case "newline":
					case "anchor":
					case "tag":
						if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
						else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs = this.flowScalar(this.type);
						if (!it || it.value) fc.items.push({
							start: [],
							key: fs,
							sep: []
						});
						else if (it.sep) this.stack.push(fs);
						else Object.assign(it, {
							key: fs,
							sep: []
						});
						return;
					}
					case "flow-map-end":
					case "flow-seq-end":
						fc.end.push(this.sourceToken);
						return;
				}
				const bv = this.startBlockValue(fc);
				/* istanbul ignore else should not happen */
				if (bv) this.stack.push(bv);
				else {
					yield* this.pop();
					yield* this.step();
				}
			} else {
				const parent = this.peek(2);
				if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
					yield* this.pop();
					yield* this.step();
				} else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
					const start = getFirstKeyStartProps(getPrevProps(parent));
					fixFlowSeqItems(fc);
					const sep = fc.end.splice(1, fc.end.length);
					sep.push(this.sourceToken);
					const map = {
						type: "block-map",
						offset: fc.offset,
						indent: fc.indent,
						items: [{
							start,
							key: fc,
							sep
						}]
					};
					this.onKeyLine = true;
					this.stack[this.stack.length - 1] = map;
				} else yield* this.lineEnd(fc);
			}
		}
		flowScalar(type) {
			if (this.onNewLine) {
				let nl = this.source.indexOf("\n") + 1;
				while (nl !== 0) {
					this.onNewLine(this.offset + nl);
					nl = this.source.indexOf("\n", nl) + 1;
				}
			}
			return {
				type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		startBlockValue(parent) {
			switch (this.type) {
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return this.flowScalar(this.type);
				case "block-scalar-header": return {
					type: "block-scalar",
					offset: this.offset,
					indent: this.indent,
					props: [this.sourceToken],
					source: ""
				};
				case "flow-map-start":
				case "flow-seq-start": return {
					type: "flow-collection",
					offset: this.offset,
					indent: this.indent,
					start: this.sourceToken,
					items: [],
					end: []
				};
				case "seq-item-ind": return {
					type: "block-seq",
					offset: this.offset,
					indent: this.indent,
					items: [{ start: [this.sourceToken] }]
				};
				case "explicit-key-ind": {
					this.onKeyLine = true;
					const start = getFirstKeyStartProps(getPrevProps(parent));
					start.push(this.sourceToken);
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							explicitKey: true
						}]
					};
				}
				case "map-value-ind": {
					this.onKeyLine = true;
					const start = getFirstKeyStartProps(getPrevProps(parent));
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							key: null,
							sep: [this.sourceToken]
						}]
					};
				}
			}
			return null;
		}
		atIndentedComment(start, indent) {
			if (this.type !== "comment") return false;
			if (this.indent <= indent) return false;
			return start.every((st) => st.type === "newline" || st.type === "space");
		}
		*documentEnd(docEnd) {
			if (this.type !== "doc-mode") {
				if (docEnd.end) docEnd.end.push(this.sourceToken);
				else docEnd.end = [this.sourceToken];
				if (this.type === "newline") yield* this.pop();
			}
		}
		*lineEnd(token) {
			switch (this.type) {
				case "comma":
				case "doc-start":
				case "doc-end":
				case "flow-seq-end":
				case "flow-map-end":
				case "map-value-ind":
					yield* this.pop();
					yield* this.step();
					break;
				case "newline": this.onKeyLine = false;
				default:
					if (token.end) token.end.push(this.sourceToken);
					else token.end = [this.sourceToken];
					if (this.type === "newline") yield* this.pop();
			}
		}
	};
	exports.Parser = Parser;
}));

//#endregion
//#region ../../node_modules/yaml/dist/public-api.js
var require_public_api = /* @__PURE__ */ __commonJSMin(((exports) => {
	var composer = require_composer();
	var Document = require_Document();
	var errors = require_errors();
	var log = require_log();
	var identity = require_identity();
	var lineCounter = require_line_counter();
	var parser = require_parser();
	function parseOptions(options) {
		const prettyErrors = options.prettyErrors !== false;
		return {
			lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null,
			prettyErrors
		};
	}
	/**
	* Parse the input as a stream of YAML documents.
	*
	* Documents should be separated from each other by `...` or `---` marker lines.
	*
	* @returns If an empty `docs` array is returned, it will be of type
	*   EmptyStream and contain additional stream information. In
	*   TypeScript, you should use `'empty' in docs` as a type guard for it.
	*/
	function parseAllDocuments(source, options = {}) {
		const { lineCounter, prettyErrors } = parseOptions(options);
		const parser$1 = new parser.Parser(lineCounter?.addNewLine);
		const composer$1 = new composer.Composer(options);
		const docs = Array.from(composer$1.compose(parser$1.parse(source)));
		if (prettyErrors && lineCounter) for (const doc of docs) {
			doc.errors.forEach(errors.prettifyError(source, lineCounter));
			doc.warnings.forEach(errors.prettifyError(source, lineCounter));
		}
		if (docs.length > 0) return docs;
		return Object.assign([], { empty: true }, composer$1.streamInfo());
	}
	/** Parse an input string into a single YAML.Document */
	function parseDocument(source, options = {}) {
		const { lineCounter, prettyErrors } = parseOptions(options);
		const parser$1 = new parser.Parser(lineCounter?.addNewLine);
		const composer$1 = new composer.Composer(options);
		let doc = null;
		for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) if (!doc) doc = _doc;
		else if (doc.options.logLevel !== "silent") {
			doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
			break;
		}
		if (prettyErrors && lineCounter) {
			doc.errors.forEach(errors.prettifyError(source, lineCounter));
			doc.warnings.forEach(errors.prettifyError(source, lineCounter));
		}
		return doc;
	}
	function parse(src, reviver, options) {
		let _reviver = void 0;
		if (typeof reviver === "function") _reviver = reviver;
		else if (options === void 0 && reviver && typeof reviver === "object") options = reviver;
		const doc = parseDocument(src, options);
		if (!doc) return null;
		doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
		if (doc.errors.length > 0) if (doc.options.logLevel !== "silent") throw doc.errors[0];
		else doc.errors = [];
		return doc.toJS(Object.assign({ reviver: _reviver }, options));
	}
	function stringify(value, replacer, options) {
		let _replacer = null;
		if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
		else if (options === void 0 && replacer) options = replacer;
		if (typeof options === "string") options = options.length;
		if (typeof options === "number") {
			const indent = Math.round(options);
			options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
		}
		if (value === void 0) {
			const { keepUndefined } = options ?? replacer ?? {};
			if (!keepUndefined) return void 0;
		}
		if (identity.isDocument(value) && !_replacer) return value.toString(options);
		return new Document.Document(value, _replacer, options).toString(options);
	}
	exports.parse = parse;
	exports.parseAllDocuments = parseAllDocuments;
	exports.parseDocument = parseDocument;
	exports.stringify = stringify;
}));

//#endregion
//#region ../../node_modules/yaml/dist/index.js
var require_dist = /* @__PURE__ */ __commonJSMin(((exports) => {
	var composer = require_composer();
	var Document = require_Document();
	var Schema = require_Schema();
	var errors = require_errors();
	var Alias = require_Alias();
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var cst = require_cst();
	var lexer = require_lexer();
	var lineCounter = require_line_counter();
	var parser = require_parser();
	var publicApi = require_public_api();
	var visit = require_visit();
	exports.Composer = composer.Composer;
	exports.Document = Document.Document;
	exports.Schema = Schema.Schema;
	exports.YAMLError = errors.YAMLError;
	exports.YAMLParseError = errors.YAMLParseError;
	exports.YAMLWarning = errors.YAMLWarning;
	exports.Alias = Alias.Alias;
	exports.isAlias = identity.isAlias;
	exports.isCollection = identity.isCollection;
	exports.isDocument = identity.isDocument;
	exports.isMap = identity.isMap;
	exports.isNode = identity.isNode;
	exports.isPair = identity.isPair;
	exports.isScalar = identity.isScalar;
	exports.isSeq = identity.isSeq;
	exports.Pair = Pair.Pair;
	exports.Scalar = Scalar.Scalar;
	exports.YAMLMap = YAMLMap.YAMLMap;
	exports.YAMLSeq = YAMLSeq.YAMLSeq;
	exports.Lexer = lexer.Lexer;
	exports.LineCounter = lineCounter.LineCounter;
	exports.Parser = parser.Parser;
	exports.parse = publicApi.parse;
	exports.parseAllDocuments = publicApi.parseAllDocuments;
	exports.parseDocument = publicApi.parseDocument;
	exports.stringify = publicApi.stringify;
	exports.visit = visit.visit;
	exports.visitAsync = visit.visitAsync;
}));

//#endregion
//#region ../cli/src/core/frontmatter.ts
/**
* Frontmatter  YAML frontmatter parsing, serialization, and CRUD commands
*
* Uses the `yaml` npm package instead of a hand-rolled parser.
*/
var import_dist = /* @__PURE__ */ __toESM(require_dist());
/**
* Extract YAML frontmatter from markdown content into a typed object.
*/
function extractFrontmatter(content) {
	const match = content.match(/^---\n([\s\S]+?)\n---/);
	if (!match) return {};
	try {
		const parsed = import_dist.parse(match[1]);
		return parsed && typeof parsed === "object" && !Array.isArray(parsed) ? parsed : {};
	} catch {
		return {};
	}
}

//#endregion
//#region ../cli/src/core/config.ts
/**
* Config  Planning config CRUD operations
*
* Ported from maxsim/bin/lib/config.cjs
*/

//#endregion
//#region ../../node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
	if (typeof string !== "string") throw new TypeError("Expected a string");
	return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

//#endregion
//#region ../cli/src/core/state.ts
/**
* State  STATE.md operations and progression engine
*
* Ported from maxsim/bin/lib/state.cjs
*/
function stateExtractField(content, fieldName) {
	const pattern = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, "i");
	const match = content.match(pattern);
	return match ? match[1].trim() : null;
}
function stateReplaceField(content, fieldName, newValue) {
	const escaped = escapeStringRegexp(fieldName);
	const pattern = new RegExp(`(\\*\\*${escaped}:\\*\\*\\s*)(.*)`, "i");
	if (pattern.test(content)) return content.replace(pattern, (_match, prefix) => `${prefix}${newValue}`);
	return null;
}

//#endregion
//#region ../cli/src/core/roadmap.ts
/**
* Roadmap  Roadmap parsing and update operations
*
* Ported from maxsim/bin/lib/roadmap.cjs
*/

//#endregion
//#region ../cli/src/core/milestone.ts
/**
* Milestone  Milestone and requirements lifecycle operations
*
* Ported from maxsim/bin/lib/milestone.cjs
*/

//#endregion
//#region ../cli/src/core/commands.ts
/**
* Commands  Standalone utility commands
*
* Ported from maxsim/bin/lib/commands.cjs
*/

//#endregion
//#region ../cli/src/core/verify.ts
/**
* Verify  Verification suite, consistency, and health validation
*
* Ported from maxsim/bin/lib/verify.cjs
*/

//#endregion
//#region ../cli/src/core/phase.ts
/**
* Phase  Phase CRUD, query, and lifecycle operations
*
* Ported from maxsim/bin/lib/phase.cjs
*/

//#endregion
//#region ../cli/src/core/template.ts
/**
* Template  Template selection and fill operations
*
* Ported from maxsim/bin/lib/template.cjs
*/

//#endregion
//#region ../cli/src/core/init.ts
/**
* Init  Compound init commands for workflow bootstrapping
*
* Ported from maxsim/bin/lib/init.cjs
*/

//#endregion
//#region ../../node_modules/readdirp/esm/index.js
const EntryTypes = {
	FILE_TYPE: "files",
	DIR_TYPE: "directories",
	FILE_DIR_TYPE: "files_directories",
	EVERYTHING_TYPE: "all"
};
const defaultOptions = {
	root: ".",
	fileFilter: (_entryInfo) => true,
	directoryFilter: (_entryInfo) => true,
	type: EntryTypes.FILE_TYPE,
	lstat: false,
	depth: 2147483648,
	alwaysStat: false,
	highWaterMark: 4096
};
Object.freeze(defaultOptions);
const RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
const NORMAL_FLOW_ERRORS = new Set([
	"ENOENT",
	"EPERM",
	"EACCES",
	"ELOOP",
	RECURSIVE_ERROR_CODE
]);
const ALL_TYPES = [
	EntryTypes.DIR_TYPE,
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE,
	EntryTypes.FILE_TYPE
];
const DIR_TYPES = new Set([
	EntryTypes.DIR_TYPE,
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE
]);
const FILE_TYPES = new Set([
	EntryTypes.EVERYTHING_TYPE,
	EntryTypes.FILE_DIR_TYPE,
	EntryTypes.FILE_TYPE
]);
const isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
const wantBigintFsStats = process.platform === "win32";
const emptyFn = (_entryInfo) => true;
const normalizeFilter = (filter) => {
	if (filter === void 0) return emptyFn;
	if (typeof filter === "function") return filter;
	if (typeof filter === "string") {
		const fl = filter.trim();
		return (entry) => entry.basename === fl;
	}
	if (Array.isArray(filter)) {
		const trItems = filter.map((item) => item.trim());
		return (entry) => trItems.some((f) => entry.basename === f);
	}
	return emptyFn;
};
/** Readable readdir stream, emitting new files as they're being listed. */
var ReaddirpStream = class extends node_stream.Readable {
	constructor(options = {}) {
		super({
			objectMode: true,
			autoDestroy: true,
			highWaterMark: options.highWaterMark
		});
		const opts = {
			...defaultOptions,
			...options
		};
		const { root, type } = opts;
		this._fileFilter = normalizeFilter(opts.fileFilter);
		this._directoryFilter = normalizeFilter(opts.directoryFilter);
		const statMethod = opts.lstat ? node_fs_promises.lstat : node_fs_promises.stat;
		if (wantBigintFsStats) this._stat = (path) => statMethod(path, { bigint: true });
		else this._stat = statMethod;
		this._maxDepth = opts.depth ?? defaultOptions.depth;
		this._wantsDir = type ? DIR_TYPES.has(type) : false;
		this._wantsFile = type ? FILE_TYPES.has(type) : false;
		this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;
		this._root = (0, node_path.resolve)(root);
		this._isDirent = !opts.alwaysStat;
		this._statsProp = this._isDirent ? "dirent" : "stats";
		this._rdOptions = {
			encoding: "utf8",
			withFileTypes: this._isDirent
		};
		this.parents = [this._exploreDir(root, 1)];
		this.reading = false;
		this.parent = void 0;
	}
	async _read(batch) {
		if (this.reading) return;
		this.reading = true;
		try {
			while (!this.destroyed && batch > 0) {
				const par = this.parent;
				const fil = par && par.files;
				if (fil && fil.length > 0) {
					const { path, depth } = par;
					const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
					const awaited = await Promise.all(slice);
					for (const entry of awaited) {
						if (!entry) continue;
						if (this.destroyed) return;
						const entryType = await this._getEntryType(entry);
						if (entryType === "directory" && this._directoryFilter(entry)) {
							if (depth <= this._maxDepth) this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
							if (this._wantsDir) {
								this.push(entry);
								batch--;
							}
						} else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
							if (this._wantsFile) {
								this.push(entry);
								batch--;
							}
						}
					}
				} else {
					const parent = this.parents.pop();
					if (!parent) {
						this.push(null);
						break;
					}
					this.parent = await parent;
					if (this.destroyed) return;
				}
			}
		} catch (error) {
			this.destroy(error);
		} finally {
			this.reading = false;
		}
	}
	async _exploreDir(path, depth) {
		let files;
		try {
			files = await (0, node_fs_promises.readdir)(path, this._rdOptions);
		} catch (error) {
			this._onError(error);
		}
		return {
			files,
			depth,
			path
		};
	}
	async _formatEntry(dirent, path) {
		let entry;
		const basename = this._isDirent ? dirent.name : dirent;
		try {
			const fullPath = (0, node_path.resolve)((0, node_path.join)(path, basename));
			entry = {
				path: (0, node_path.relative)(this._root, fullPath),
				fullPath,
				basename
			};
			entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
		} catch (err) {
			this._onError(err);
			return;
		}
		return entry;
	}
	_onError(err) {
		if (isNormalFlowError(err) && !this.destroyed) this.emit("warn", err);
		else this.destroy(err);
	}
	async _getEntryType(entry) {
		if (!entry && this._statsProp in entry) return "";
		const stats = entry[this._statsProp];
		if (stats.isFile()) return "file";
		if (stats.isDirectory()) return "directory";
		if (stats && stats.isSymbolicLink()) {
			const full = entry.fullPath;
			try {
				const entryRealPath = await (0, node_fs_promises.realpath)(full);
				const entryRealPathStats = await (0, node_fs_promises.lstat)(entryRealPath);
				if (entryRealPathStats.isFile()) return "file";
				if (entryRealPathStats.isDirectory()) {
					const len = entryRealPath.length;
					if (full.startsWith(entryRealPath) && full.substr(len, 1) === node_path.sep) {
						const recursiveError = /* @__PURE__ */ new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
						recursiveError.code = RECURSIVE_ERROR_CODE;
						return this._onError(recursiveError);
					}
					return "directory";
				}
			} catch (error) {
				this._onError(error);
				return "";
			}
		}
	}
	_includeAsFile(entry) {
		const stats = entry && entry[this._statsProp];
		return stats && this._wantsEverything && !stats.isDirectory();
	}
};
/**
* Streaming version: Reads all files and directories in given root recursively.
* Consumes ~constant small amount of RAM.
* @param root Root directory
* @param options Options to specify root (start directory), filters and recursion depth
*/
function readdirp(root, options = {}) {
	let type = options.entryType || options.type;
	if (type === "both") type = EntryTypes.FILE_DIR_TYPE;
	if (type) options.type = type;
	if (!root) throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
	else if (typeof root !== "string") throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
	else if (type && !ALL_TYPES.includes(type)) throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
	options.root = root;
	return new ReaddirpStream(options);
}

//#endregion
//#region ../../node_modules/chokidar/esm/handler.js
const STR_DATA = "data";
const STR_END = "end";
const STR_CLOSE = "close";
const EMPTY_FN = () => {};
const pl = process.platform;
const isWindows = pl === "win32";
const isMacos = pl === "darwin";
const isLinux = pl === "linux";
const isFreeBSD = pl === "freebsd";
const isIBMi = (0, os.type)() === "OS400";
const EVENTS = {
	ALL: "all",
	READY: "ready",
	ADD: "add",
	CHANGE: "change",
	ADD_DIR: "addDir",
	UNLINK: "unlink",
	UNLINK_DIR: "unlinkDir",
	RAW: "raw",
	ERROR: "error"
};
const EV = EVENTS;
const THROTTLE_MODE_WATCH = "watch";
const statMethods = {
	lstat: fs_promises.lstat,
	stat: fs_promises.stat
};
const KEY_LISTENERS = "listeners";
const KEY_ERR = "errHandlers";
const KEY_RAW = "rawEmitters";
const HANDLER_KEYS = [
	KEY_LISTENERS,
	KEY_ERR,
	KEY_RAW
];
const binaryExtensions = new Set([
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"afdesign",
	"afphoto",
	"afpub",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"appimage",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"flatpak",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"odp",
	"ods",
	"odt",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"ott",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rpm",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"snap",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
]);
const isBinaryPath = (filePath) => binaryExtensions.has(path.extname(filePath).slice(1).toLowerCase());
const foreach = (val, fn) => {
	if (val instanceof Set) val.forEach(fn);
	else fn(val);
};
const addAndConvert = (main, prop, item) => {
	let container = main[prop];
	if (!(container instanceof Set)) main[prop] = container = new Set([container]);
	container.add(item);
};
const clearItem = (cont) => (key) => {
	const set = cont[key];
	if (set instanceof Set) set.clear();
	else delete cont[key];
};
const delFromSet = (main, prop, item) => {
	const container = main[prop];
	if (container instanceof Set) container.delete(item);
	else if (container === item) delete main[prop];
};
const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
const FsWatchInstances = /* @__PURE__ */ new Map();
/**
* Instantiates the fs_watch interface
* @param path to be watched
* @param options to be passed to fs_watch
* @param listener main event handler
* @param errHandler emits info about errors
* @param emitRaw emits raw event data
* @returns {NativeFsWatcher}
*/
function createFsWatchInstance(path$37, options, listener, errHandler, emitRaw) {
	const handleEvent = (rawEvent, evPath) => {
		listener(path$37);
		emitRaw(rawEvent, evPath, { watchedPath: path$37 });
		if (evPath && path$37 !== evPath) fsWatchBroadcast(path.resolve(path$37, evPath), KEY_LISTENERS, path.join(path$37, evPath));
	};
	try {
		return (0, fs.watch)(path$37, { persistent: options.persistent }, handleEvent);
	} catch (error) {
		errHandler(error);
		return;
	}
}
/**
* Helper for passing fs_watch event data to a collection of listeners
* @param fullPath absolute path bound to fs_watch instance
*/
const fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
	const cont = FsWatchInstances.get(fullPath);
	if (!cont) return;
	foreach(cont[listenerType], (listener) => {
		listener(val1, val2, val3);
	});
};
/**
* Instantiates the fs_watch interface or binds listeners
* to an existing one covering the same file system entry
* @param path
* @param fullPath absolute path
* @param options to be passed to fs_watch
* @param handlers container for event listener functions
*/
const setFsWatchListener = (path$41, fullPath, options, handlers) => {
	const { listener, errHandler, rawEmitter } = handlers;
	let cont = FsWatchInstances.get(fullPath);
	let watcher;
	if (!options.persistent) {
		watcher = createFsWatchInstance(path$41, options, listener, errHandler, rawEmitter);
		if (!watcher) return;
		return watcher.close.bind(watcher);
	}
	if (cont) {
		addAndConvert(cont, KEY_LISTENERS, listener);
		addAndConvert(cont, KEY_ERR, errHandler);
		addAndConvert(cont, KEY_RAW, rawEmitter);
	} else {
		watcher = createFsWatchInstance(path$41, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
		if (!watcher) return;
		watcher.on(EV.ERROR, async (error) => {
			const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
			if (cont) cont.watcherUnusable = true;
			if (isWindows && error.code === "EPERM") try {
				await (await (0, fs_promises.open)(path$41, "r")).close();
				broadcastErr(error);
			} catch (err) {}
			else broadcastErr(error);
		});
		cont = {
			listeners: listener,
			errHandlers: errHandler,
			rawEmitters: rawEmitter,
			watcher
		};
		FsWatchInstances.set(fullPath, cont);
	}
	return () => {
		delFromSet(cont, KEY_LISTENERS, listener);
		delFromSet(cont, KEY_ERR, errHandler);
		delFromSet(cont, KEY_RAW, rawEmitter);
		if (isEmptySet(cont.listeners)) {
			cont.watcher.close();
			FsWatchInstances.delete(fullPath);
			HANDLER_KEYS.forEach(clearItem(cont));
			cont.watcher = void 0;
			Object.freeze(cont);
		}
	};
};
const FsWatchFileInstances = /* @__PURE__ */ new Map();
/**
* Instantiates the fs_watchFile interface or binds listeners
* to an existing one covering the same file system entry
* @param path to be watched
* @param fullPath absolute path
* @param options options to be passed to fs_watchFile
* @param handlers container for event listener functions
* @returns closer
*/
const setFsWatchFileListener = (path$42, fullPath, options, handlers) => {
	const { listener, rawEmitter } = handlers;
	let cont = FsWatchFileInstances.get(fullPath);
	const copts = cont && cont.options;
	if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
		(0, fs.unwatchFile)(fullPath);
		cont = void 0;
	}
	if (cont) {
		addAndConvert(cont, KEY_LISTENERS, listener);
		addAndConvert(cont, KEY_RAW, rawEmitter);
	} else {
		cont = {
			listeners: listener,
			rawEmitters: rawEmitter,
			options,
			watcher: (0, fs.watchFile)(fullPath, options, (curr, prev) => {
				foreach(cont.rawEmitters, (rawEmitter) => {
					rawEmitter(EV.CHANGE, fullPath, {
						curr,
						prev
					});
				});
				const currmtime = curr.mtimeMs;
				if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) foreach(cont.listeners, (listener) => listener(path$42, curr));
			})
		};
		FsWatchFileInstances.set(fullPath, cont);
	}
	return () => {
		delFromSet(cont, KEY_LISTENERS, listener);
		delFromSet(cont, KEY_RAW, rawEmitter);
		if (isEmptySet(cont.listeners)) {
			FsWatchFileInstances.delete(fullPath);
			(0, fs.unwatchFile)(fullPath);
			cont.options = cont.watcher = void 0;
			Object.freeze(cont);
		}
	};
};
/**
* @mixin
*/
var NodeFsHandler = class {
	constructor(fsW) {
		this.fsw = fsW;
		this._boundHandleError = (error) => fsW._handleError(error);
	}
	/**
	* Watch file for changes with fs_watchFile or fs_watch.
	* @param path to file or dir
	* @param listener on fs change
	* @returns closer for the watcher instance
	*/
	_watchWithNodeFs(path$38, listener) {
		const opts = this.fsw.options;
		const directory = path.dirname(path$38);
		const basename = path.basename(path$38);
		this.fsw._getWatchedDir(directory).add(basename);
		const absolutePath = path.resolve(path$38);
		const options = { persistent: opts.persistent };
		if (!listener) listener = EMPTY_FN;
		let closer;
		if (opts.usePolling) {
			options.interval = opts.interval !== opts.binaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
			closer = setFsWatchFileListener(path$38, absolutePath, options, {
				listener,
				rawEmitter: this.fsw._emitRaw
			});
		} else closer = setFsWatchListener(path$38, absolutePath, options, {
			listener,
			errHandler: this._boundHandleError,
			rawEmitter: this.fsw._emitRaw
		});
		return closer;
	}
	/**
	* Watch a file and emit add event if warranted.
	* @returns closer for the watcher instance
	*/
	_handleFile(file, stats, initialAdd) {
		if (this.fsw.closed) return;
		const dirname = path.dirname(file);
		const basename = path.basename(file);
		const parent = this.fsw._getWatchedDir(dirname);
		let prevStats = stats;
		if (parent.has(basename)) return;
		const listener = async (path$43, newStats) => {
			if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
			if (!newStats || newStats.mtimeMs === 0) try {
				const newStats = await (0, fs_promises.stat)(file);
				if (this.fsw.closed) return;
				const at = newStats.atimeMs;
				const mt = newStats.mtimeMs;
				if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV.CHANGE, file, newStats);
				if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {
					this.fsw._closeFile(path$43);
					prevStats = newStats;
					const closer = this._watchWithNodeFs(file, listener);
					if (closer) this.fsw._addPathCloser(path$43, closer);
				} else prevStats = newStats;
			} catch (error) {
				this.fsw._remove(dirname, basename);
			}
			else if (parent.has(basename)) {
				const at = newStats.atimeMs;
				const mt = newStats.mtimeMs;
				if (!at || at <= mt || mt !== prevStats.mtimeMs) this.fsw._emit(EV.CHANGE, file, newStats);
				prevStats = newStats;
			}
		};
		const closer = this._watchWithNodeFs(file, listener);
		if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
			if (!this.fsw._throttle(EV.ADD, file, 0)) return;
			this.fsw._emit(EV.ADD, file, stats);
		}
		return closer;
	}
	/**
	* Handle symlinks encountered while reading a dir.
	* @param entry returned by readdirp
	* @param directory path of dir being read
	* @param path of this item
	* @param item basename of this item
	* @returns true if no more processing is needed for this entry.
	*/
	async _handleSymlink(entry, directory, path$44, item) {
		if (this.fsw.closed) return;
		const full = entry.fullPath;
		const dir = this.fsw._getWatchedDir(directory);
		if (!this.fsw.options.followSymlinks) {
			this.fsw._incrReadyCount();
			let linkPath;
			try {
				linkPath = await (0, fs_promises.realpath)(path$44);
			} catch (e) {
				this.fsw._emitReady();
				return true;
			}
			if (this.fsw.closed) return;
			if (dir.has(item)) {
				if (this.fsw._symlinkPaths.get(full) !== linkPath) {
					this.fsw._symlinkPaths.set(full, linkPath);
					this.fsw._emit(EV.CHANGE, path$44, entry.stats);
				}
			} else {
				dir.add(item);
				this.fsw._symlinkPaths.set(full, linkPath);
				this.fsw._emit(EV.ADD, path$44, entry.stats);
			}
			this.fsw._emitReady();
			return true;
		}
		if (this.fsw._symlinkPaths.has(full)) return true;
		this.fsw._symlinkPaths.set(full, true);
	}
	_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
		directory = path.join(directory, "");
		throttler = this.fsw._throttle("readdir", directory, 1e3);
		if (!throttler) return;
		const previous = this.fsw._getWatchedDir(wh.path);
		const current = /* @__PURE__ */ new Set();
		let stream = this.fsw._readdirp(directory, {
			fileFilter: (entry) => wh.filterPath(entry),
			directoryFilter: (entry) => wh.filterDir(entry)
		});
		if (!stream) return;
		stream.on(STR_DATA, async (entry) => {
			if (this.fsw.closed) {
				stream = void 0;
				return;
			}
			const item = entry.path;
			let path$39 = path.join(directory, item);
			current.add(item);
			if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path$39, item)) return;
			if (this.fsw.closed) {
				stream = void 0;
				return;
			}
			if (item === target || !target && !previous.has(item)) {
				this.fsw._incrReadyCount();
				path$39 = path.join(dir, path.relative(dir, path$39));
				this._addToNodeFs(path$39, initialAdd, wh, depth + 1);
			}
		}).on(EV.ERROR, this._boundHandleError);
		return new Promise((resolve, reject) => {
			if (!stream) return reject();
			stream.once(STR_END, () => {
				if (this.fsw.closed) {
					stream = void 0;
					return;
				}
				const wasThrottled = throttler ? throttler.clear() : false;
				resolve(void 0);
				previous.getChildren().filter((item) => {
					return item !== directory && !current.has(item);
				}).forEach((item) => {
					this.fsw._remove(directory, item);
				});
				stream = void 0;
				if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
			});
		});
	}
	/**
	* Read directory to add / remove files from `@watched` list and re-read it on change.
	* @param dir fs path
	* @param stats
	* @param initialAdd
	* @param depth relative to user-supplied path
	* @param target child path targeted for watch
	* @param wh Common watch helpers for this path
	* @param realpath
	* @returns closer for the watcher instance.
	*/
	async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
		const parentDir = this.fsw._getWatchedDir(path.dirname(dir));
		const tracked = parentDir.has(path.basename(dir));
		if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) this.fsw._emit(EV.ADD_DIR, dir, stats);
		parentDir.add(path.basename(dir));
		this.fsw._getWatchedDir(dir);
		let throttler;
		let closer;
		const oDepth = this.fsw.options.depth;
		if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
			if (!target) {
				await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
				if (this.fsw.closed) return;
			}
			closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
				if (stats && stats.mtimeMs === 0) return;
				this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
			});
		}
		return closer;
	}
	/**
	* Handle added file, directory, or glob pattern.
	* Delegates call to _handleFile / _handleDir after checks.
	* @param path to file or ir
	* @param initialAdd was the file added at watch instantiation?
	* @param priorWh depth relative to user-supplied path
	* @param depth Child path actually targeted for watch
	* @param target Child path actually targeted for watch
	*/
	async _addToNodeFs(path$40, initialAdd, priorWh, depth, target) {
		const ready = this.fsw._emitReady;
		if (this.fsw._isIgnored(path$40) || this.fsw.closed) {
			ready();
			return false;
		}
		const wh = this.fsw._getWatchHelpers(path$40);
		if (priorWh) {
			wh.filterPath = (entry) => priorWh.filterPath(entry);
			wh.filterDir = (entry) => priorWh.filterDir(entry);
		}
		try {
			const stats = await statMethods[wh.statMethod](wh.watchPath);
			if (this.fsw.closed) return;
			if (this.fsw._isIgnored(wh.watchPath, stats)) {
				ready();
				return false;
			}
			const follow = this.fsw.options.followSymlinks;
			let closer;
			if (stats.isDirectory()) {
				const absPath = path.resolve(path$40);
				const targetPath = follow ? await (0, fs_promises.realpath)(path$40) : path$40;
				if (this.fsw.closed) return;
				closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
				if (this.fsw.closed) return;
				if (absPath !== targetPath && targetPath !== void 0) this.fsw._symlinkPaths.set(absPath, targetPath);
			} else if (stats.isSymbolicLink()) {
				const targetPath = follow ? await (0, fs_promises.realpath)(path$40) : path$40;
				if (this.fsw.closed) return;
				const parent = path.dirname(wh.watchPath);
				this.fsw._getWatchedDir(parent).add(wh.watchPath);
				this.fsw._emit(EV.ADD, wh.watchPath, stats);
				closer = await this._handleDir(parent, stats, initialAdd, depth, path$40, wh, targetPath);
				if (this.fsw.closed) return;
				if (targetPath !== void 0) this.fsw._symlinkPaths.set(path.resolve(path$40), targetPath);
			} else closer = this._handleFile(wh.watchPath, stats, initialAdd);
			ready();
			if (closer) this.fsw._addPathCloser(path$40, closer);
			return false;
		} catch (error) {
			if (this.fsw._handleError(error)) {
				ready();
				return path$40;
			}
		}
	}
};

//#endregion
//#region ../../node_modules/chokidar/esm/index.js
/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */
const SLASH = "/";
const SLASH_SLASH = "//";
const ONE_DOT = ".";
const TWO_DOTS = "..";
const STRING_TYPE = "string";
const BACK_SLASH_RE = /\\/g;
const DOUBLE_SLASH_RE = /\/\//;
const DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
const REPLACER_RE = /^\.[/\\]/;
function arrify(item) {
	return Array.isArray(item) ? item : [item];
}
const isMatcherObject = (matcher) => typeof matcher === "object" && matcher !== null && !(matcher instanceof RegExp);
function createPattern(matcher) {
	if (typeof matcher === "function") return matcher;
	if (typeof matcher === "string") return (string) => matcher === string;
	if (matcher instanceof RegExp) return (string) => matcher.test(string);
	if (typeof matcher === "object" && matcher !== null) return (string) => {
		if (matcher.path === string) return true;
		if (matcher.recursive) {
			const relative = path.relative(matcher.path, string);
			if (!relative) return false;
			return !relative.startsWith("..") && !path.isAbsolute(relative);
		}
		return false;
	};
	return () => false;
}
function normalizePath(path$16) {
	if (typeof path$16 !== "string") throw new Error("string expected");
	path$16 = path.normalize(path$16);
	path$16 = path$16.replace(/\\/g, "/");
	let prepend = false;
	if (path$16.startsWith("//")) prepend = true;
	const DOUBLE_SLASH_RE = /\/\//;
	while (path$16.match(DOUBLE_SLASH_RE)) path$16 = path$16.replace(DOUBLE_SLASH_RE, "/");
	if (prepend) path$16 = "/" + path$16;
	return path$16;
}
function matchPatterns(patterns, testString, stats) {
	const path$26 = normalizePath(testString);
	for (let index = 0; index < patterns.length; index++) {
		const pattern = patterns[index];
		if (pattern(path$26, stats)) return true;
	}
	return false;
}
function anymatch(matchers, testString) {
	if (matchers == null) throw new TypeError("anymatch: specify first argument");
	const patterns = arrify(matchers).map((matcher) => createPattern(matcher));
	if (testString == null) return (testString, stats) => {
		return matchPatterns(patterns, testString, stats);
	};
	return matchPatterns(patterns, testString);
}
const unifyPaths = (paths_) => {
	const paths = arrify(paths_).flat();
	if (!paths.every((p) => typeof p === STRING_TYPE)) throw new TypeError(`Non-string provided as watch path: ${paths}`);
	return paths.map(normalizePathToUnix);
};
const toUnix = (string) => {
	let str = string.replace(BACK_SLASH_RE, SLASH);
	let prepend = false;
	if (str.startsWith(SLASH_SLASH)) prepend = true;
	while (str.match(DOUBLE_SLASH_RE)) str = str.replace(DOUBLE_SLASH_RE, SLASH);
	if (prepend) str = SLASH + str;
	return str;
};
const normalizePathToUnix = (path$17) => toUnix(path.normalize(toUnix(path$17)));
const normalizeIgnored = (cwd = "") => (path$18) => {
	if (typeof path$18 === "string") return normalizePathToUnix(path.isAbsolute(path$18) ? path$18 : path.join(cwd, path$18));
	else return path$18;
};
const getAbsolutePath = (path$19, cwd) => {
	if (path.isAbsolute(path$19)) return path$19;
	return path.join(cwd, path$19);
};
const EMPTY_SET = Object.freeze(/* @__PURE__ */ new Set());
/**
* Directory entry.
*/
var DirEntry = class {
	constructor(dir, removeWatcher) {
		this.path = dir;
		this._removeWatcher = removeWatcher;
		this.items = /* @__PURE__ */ new Set();
	}
	add(item) {
		const { items } = this;
		if (!items) return;
		if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
	}
	async remove(item) {
		const { items } = this;
		if (!items) return;
		items.delete(item);
		if (items.size > 0) return;
		const dir = this.path;
		try {
			await (0, fs_promises.readdir)(dir);
		} catch (err) {
			if (this._removeWatcher) this._removeWatcher(path.dirname(dir), path.basename(dir));
		}
	}
	has(item) {
		const { items } = this;
		if (!items) return;
		return items.has(item);
	}
	getChildren() {
		const { items } = this;
		if (!items) return [];
		return [...items.values()];
	}
	dispose() {
		this.items.clear();
		this.path = "";
		this._removeWatcher = EMPTY_FN;
		this.items = EMPTY_SET;
		Object.freeze(this);
	}
};
const STAT_METHOD_F = "stat";
const STAT_METHOD_L = "lstat";
var WatchHelper = class {
	constructor(path$20, follow, fsw) {
		this.fsw = fsw;
		const watchPath = path$20;
		this.path = path$20 = path$20.replace(REPLACER_RE, "");
		this.watchPath = watchPath;
		this.fullWatchPath = path.resolve(watchPath);
		this.dirParts = [];
		this.dirParts.forEach((parts) => {
			if (parts.length > 1) parts.pop();
		});
		this.followSymlinks = follow;
		this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
	}
	entryPath(entry) {
		return path.join(this.watchPath, path.relative(this.watchPath, entry.fullPath));
	}
	filterPath(entry) {
		const { stats } = entry;
		if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
		const resolvedPath = this.entryPath(entry);
		return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
	}
	filterDir(entry) {
		return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
	}
};
/**
* Watches files & directories for changes. Emitted events:
* `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
*
*     new FSWatcher()
*       .add(directories)
*       .on('add', path => log('File', path, 'was added'))
*/
var FSWatcher = class extends events.EventEmitter {
	constructor(_opts = {}) {
		super();
		this.closed = false;
		this._closers = /* @__PURE__ */ new Map();
		this._ignoredPaths = /* @__PURE__ */ new Set();
		this._throttled = /* @__PURE__ */ new Map();
		this._streams = /* @__PURE__ */ new Set();
		this._symlinkPaths = /* @__PURE__ */ new Map();
		this._watched = /* @__PURE__ */ new Map();
		this._pendingWrites = /* @__PURE__ */ new Map();
		this._pendingUnlinks = /* @__PURE__ */ new Map();
		this._readyCount = 0;
		this._readyEmitted = false;
		const awf = _opts.awaitWriteFinish;
		const DEF_AWF = {
			stabilityThreshold: 2e3,
			pollInterval: 100
		};
		const opts = {
			persistent: true,
			ignoreInitial: false,
			ignorePermissionErrors: false,
			interval: 100,
			binaryInterval: 300,
			followSymlinks: true,
			usePolling: false,
			atomic: true,
			..._opts,
			ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
			awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === "object" ? {
				...DEF_AWF,
				...awf
			} : false
		};
		if (isIBMi) opts.usePolling = true;
		if (opts.atomic === void 0) opts.atomic = !opts.usePolling;
		const envPoll = process.env.CHOKIDAR_USEPOLLING;
		if (envPoll !== void 0) {
			const envLower = envPoll.toLowerCase();
			if (envLower === "false" || envLower === "0") opts.usePolling = false;
			else if (envLower === "true" || envLower === "1") opts.usePolling = true;
			else opts.usePolling = !!envLower;
		}
		const envInterval = process.env.CHOKIDAR_INTERVAL;
		if (envInterval) opts.interval = Number.parseInt(envInterval, 10);
		let readyCalls = 0;
		this._emitReady = () => {
			readyCalls++;
			if (readyCalls >= this._readyCount) {
				this._emitReady = EMPTY_FN;
				this._readyEmitted = true;
				process.nextTick(() => this.emit(EVENTS.READY));
			}
		};
		this._emitRaw = (...args) => this.emit(EVENTS.RAW, ...args);
		this._boundRemove = this._remove.bind(this);
		this.options = opts;
		this._nodeFsHandler = new NodeFsHandler(this);
		Object.freeze(opts);
	}
	_addIgnoredPath(matcher) {
		if (isMatcherObject(matcher)) {
			for (const ignored of this._ignoredPaths) if (isMatcherObject(ignored) && ignored.path === matcher.path && ignored.recursive === matcher.recursive) return;
		}
		this._ignoredPaths.add(matcher);
	}
	_removeIgnoredPath(matcher) {
		this._ignoredPaths.delete(matcher);
		if (typeof matcher === "string") {
			for (const ignored of this._ignoredPaths) if (isMatcherObject(ignored) && ignored.path === matcher) this._ignoredPaths.delete(ignored);
		}
	}
	/**
	* Adds paths to be watched on an existing FSWatcher instance.
	* @param paths_ file or file list. Other arguments are unused
	*/
	add(paths_, _origAdd, _internal) {
		const { cwd } = this.options;
		this.closed = false;
		this._closePromise = void 0;
		let paths = unifyPaths(paths_);
		if (cwd) paths = paths.map((path$27) => {
			return getAbsolutePath(path$27, cwd);
		});
		paths.forEach((path$28) => {
			this._removeIgnoredPath(path$28);
		});
		this._userIgnored = void 0;
		if (!this._readyCount) this._readyCount = 0;
		this._readyCount += paths.length;
		Promise.all(paths.map(async (path$29) => {
			const res = await this._nodeFsHandler._addToNodeFs(path$29, !_internal, void 0, 0, _origAdd);
			if (res) this._emitReady();
			return res;
		})).then((results) => {
			if (this.closed) return;
			results.forEach((item) => {
				if (item) this.add(path.dirname(item), path.basename(_origAdd || item));
			});
		});
		return this;
	}
	/**
	* Close watchers or start ignoring events from specified paths.
	*/
	unwatch(paths_) {
		if (this.closed) return this;
		const paths = unifyPaths(paths_);
		const { cwd } = this.options;
		paths.forEach((path$21) => {
			if (!path.isAbsolute(path$21) && !this._closers.has(path$21)) {
				if (cwd) path$21 = path.join(cwd, path$21);
				path$21 = path.resolve(path$21);
			}
			this._closePath(path$21);
			this._addIgnoredPath(path$21);
			if (this._watched.has(path$21)) this._addIgnoredPath({
				path: path$21,
				recursive: true
			});
			this._userIgnored = void 0;
		});
		return this;
	}
	/**
	* Close watchers and remove all listeners from watched paths.
	*/
	close() {
		if (this._closePromise) return this._closePromise;
		this.closed = true;
		this.removeAllListeners();
		const closers = [];
		this._closers.forEach((closerList) => closerList.forEach((closer) => {
			const promise = closer();
			if (promise instanceof Promise) closers.push(promise);
		}));
		this._streams.forEach((stream) => stream.destroy());
		this._userIgnored = void 0;
		this._readyCount = 0;
		this._readyEmitted = false;
		this._watched.forEach((dirent) => dirent.dispose());
		this._closers.clear();
		this._watched.clear();
		this._streams.clear();
		this._symlinkPaths.clear();
		this._throttled.clear();
		this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
		return this._closePromise;
	}
	/**
	* Expose list of watched paths
	* @returns for chaining
	*/
	getWatched() {
		const watchList = {};
		this._watched.forEach((entry, dir) => {
			const index = (this.options.cwd ? path.relative(this.options.cwd, dir) : dir) || ONE_DOT;
			watchList[index] = entry.getChildren().sort();
		});
		return watchList;
	}
	emitWithAll(event, args) {
		this.emit(event, ...args);
		if (event !== EVENTS.ERROR) this.emit(EVENTS.ALL, event, ...args);
	}
	/**
	* Normalize and emit events.
	* Calling _emit DOES NOT MEAN emit() would be called!
	* @param event Type of event
	* @param path File or directory path
	* @param stats arguments to be passed with event
	* @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
	*/
	async _emit(event, path$22, stats) {
		if (this.closed) return;
		const opts = this.options;
		if (isWindows) path$22 = path.normalize(path$22);
		if (opts.cwd) path$22 = path.relative(opts.cwd, path$22);
		const args = [path$22];
		if (stats != null) args.push(stats);
		const awf = opts.awaitWriteFinish;
		let pw;
		if (awf && (pw = this._pendingWrites.get(path$22))) {
			pw.lastChange = /* @__PURE__ */ new Date();
			return this;
		}
		if (opts.atomic) {
			if (event === EVENTS.UNLINK) {
				this._pendingUnlinks.set(path$22, [event, ...args]);
				setTimeout(() => {
					this._pendingUnlinks.forEach((entry, path$30) => {
						this.emit(...entry);
						this.emit(EVENTS.ALL, ...entry);
						this._pendingUnlinks.delete(path$30);
					});
				}, typeof opts.atomic === "number" ? opts.atomic : 100);
				return this;
			}
			if (event === EVENTS.ADD && this._pendingUnlinks.has(path$22)) {
				event = EVENTS.CHANGE;
				this._pendingUnlinks.delete(path$22);
			}
		}
		if (awf && (event === EVENTS.ADD || event === EVENTS.CHANGE) && this._readyEmitted) {
			const awfEmit = (err, stats) => {
				if (err) {
					event = EVENTS.ERROR;
					args[0] = err;
					this.emitWithAll(event, args);
				} else if (stats) {
					if (args.length > 1) args[1] = stats;
					else args.push(stats);
					this.emitWithAll(event, args);
				}
			};
			this._awaitWriteFinish(path$22, awf.stabilityThreshold, event, awfEmit);
			return this;
		}
		if (event === EVENTS.CHANGE) {
			if (!this._throttle(EVENTS.CHANGE, path$22, 50)) return this;
		}
		if (opts.alwaysStat && stats === void 0 && (event === EVENTS.ADD || event === EVENTS.ADD_DIR || event === EVENTS.CHANGE)) {
			const fullPath = opts.cwd ? path.join(opts.cwd, path$22) : path$22;
			let stats;
			try {
				stats = await (0, fs_promises.stat)(fullPath);
			} catch (err) {}
			if (!stats || this.closed) return;
			args.push(stats);
		}
		this.emitWithAll(event, args);
		return this;
	}
	/**
	* Common handler for errors
	* @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
	*/
	_handleError(error) {
		const code = error && error.code;
		if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) this.emit(EVENTS.ERROR, error);
		return error || this.closed;
	}
	/**
	* Helper utility for throttling
	* @param actionType type being throttled
	* @param path being acted upon
	* @param timeout duration of time to suppress duplicate actions
	* @returns tracking object or false if action should be suppressed
	*/
	_throttle(actionType, path$31, timeout) {
		if (!this._throttled.has(actionType)) this._throttled.set(actionType, /* @__PURE__ */ new Map());
		const action = this._throttled.get(actionType);
		if (!action) throw new Error("invalid throttle");
		const actionPath = action.get(path$31);
		if (actionPath) {
			actionPath.count++;
			return false;
		}
		let timeoutObject;
		const clear = () => {
			const item = action.get(path$31);
			const count = item ? item.count : 0;
			action.delete(path$31);
			clearTimeout(timeoutObject);
			if (item) clearTimeout(item.timeoutObject);
			return count;
		};
		timeoutObject = setTimeout(clear, timeout);
		const thr = {
			timeoutObject,
			clear,
			count: 0
		};
		action.set(path$31, thr);
		return thr;
	}
	_incrReadyCount() {
		return this._readyCount++;
	}
	/**
	* Awaits write operation to finish.
	* Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
	* @param path being acted upon
	* @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
	* @param event
	* @param awfEmit Callback to be called when ready for event to be emitted.
	*/
	_awaitWriteFinish(path$23, threshold, event, awfEmit) {
		const awf = this.options.awaitWriteFinish;
		if (typeof awf !== "object") return;
		const pollInterval = awf.pollInterval;
		let timeoutHandler;
		let fullPath = path$23;
		if (this.options.cwd && !path.isAbsolute(path$23)) fullPath = path.join(this.options.cwd, path$23);
		const now = /* @__PURE__ */ new Date();
		const writes = this._pendingWrites;
		function awaitWriteFinishFn(prevStat) {
			(0, fs.stat)(fullPath, (err, curStat) => {
				if (err || !writes.has(path$23)) {
					if (err && err.code !== "ENOENT") awfEmit(err);
					return;
				}
				const now = Number(/* @__PURE__ */ new Date());
				if (prevStat && curStat.size !== prevStat.size) writes.get(path$23).lastChange = now;
				if (now - writes.get(path$23).lastChange >= threshold) {
					writes.delete(path$23);
					awfEmit(void 0, curStat);
				} else timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
			});
		}
		if (!writes.has(path$23)) {
			writes.set(path$23, {
				lastChange: now,
				cancelWait: () => {
					writes.delete(path$23);
					clearTimeout(timeoutHandler);
					return event;
				}
			});
			timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
		}
	}
	/**
	* Determines whether user has asked to ignore this path.
	*/
	_isIgnored(path$32, stats) {
		if (this.options.atomic && DOT_RE.test(path$32)) return true;
		if (!this._userIgnored) {
			const { cwd } = this.options;
			const ignored = (this.options.ignored || []).map(normalizeIgnored(cwd));
			this._userIgnored = anymatch([...[...this._ignoredPaths].map(normalizeIgnored(cwd)), ...ignored], void 0);
		}
		return this._userIgnored(path$32, stats);
	}
	_isntIgnored(path$33, stat) {
		return !this._isIgnored(path$33, stat);
	}
	/**
	* Provides a set of common helpers and properties relating to symlink handling.
	* @param path file or directory pattern being watched
	*/
	_getWatchHelpers(path$34) {
		return new WatchHelper(path$34, this.options.followSymlinks, this);
	}
	/**
	* Provides directory tracking objects
	* @param directory path of the directory
	*/
	_getWatchedDir(directory) {
		const dir = path.resolve(directory);
		if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
		return this._watched.get(dir);
	}
	/**
	* Check for read permissions: https://stackoverflow.com/a/11781404/1358405
	*/
	_hasReadPermissions(stats) {
		if (this.options.ignorePermissionErrors) return true;
		return Boolean(Number(stats.mode) & 256);
	}
	/**
	* Handles emitting unlink events for
	* files and directories, and via recursion, for
	* files and directories within directories that are unlinked
	* @param directory within which the following item is located
	* @param item      base path of item/directory
	*/
	_remove(directory, item, isDirectory) {
		const path$24 = path.join(directory, item);
		const fullPath = path.resolve(path$24);
		isDirectory = isDirectory != null ? isDirectory : this._watched.has(path$24) || this._watched.has(fullPath);
		if (!this._throttle("remove", path$24, 100)) return;
		if (!isDirectory && this._watched.size === 1) this.add(directory, item, true);
		this._getWatchedDir(path$24).getChildren().forEach((nested) => this._remove(path$24, nested));
		const parent = this._getWatchedDir(directory);
		const wasTracked = parent.has(item);
		parent.remove(item);
		if (this._symlinkPaths.has(fullPath)) this._symlinkPaths.delete(fullPath);
		let relPath = path$24;
		if (this.options.cwd) relPath = path.relative(this.options.cwd, path$24);
		if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
			if (this._pendingWrites.get(relPath).cancelWait() === EVENTS.ADD) return;
		}
		this._watched.delete(path$24);
		this._watched.delete(fullPath);
		const eventName = isDirectory ? EVENTS.UNLINK_DIR : EVENTS.UNLINK;
		if (wasTracked && !this._isIgnored(path$24)) this._emit(eventName, path$24);
		this._closePath(path$24);
	}
	/**
	* Closes all watchers for a path
	*/
	_closePath(path$25) {
		this._closeFile(path$25);
		const dir = path.dirname(path$25);
		this._getWatchedDir(dir).remove(path.basename(path$25));
	}
	/**
	* Closes only file-specific watchers
	*/
	_closeFile(path$35) {
		const closers = this._closers.get(path$35);
		if (!closers) return;
		closers.forEach((closer) => closer());
		this._closers.delete(path$35);
	}
	_addPathCloser(path$36, closer) {
		if (!closer) return;
		let list = this._closers.get(path$36);
		if (!list) {
			list = [];
			this._closers.set(path$36, list);
		}
		list.push(closer);
	}
	_readdirp(root, opts) {
		if (this.closed) return;
		let stream = readdirp(root, {
			type: EVENTS.ALL,
			alwaysStat: true,
			lstat: true,
			...opts,
			depth: 0
		});
		this._streams.add(stream);
		stream.once(STR_CLOSE, () => {
			stream = void 0;
		});
		stream.once(STR_END, () => {
			if (stream) {
				this._streams.delete(stream);
				stream = void 0;
			}
		});
		return stream;
	}
};
/**
* Instantiates watcher with paths to be tracked.
* @param paths file / directory paths
* @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others
* @returns an instance of FSWatcher for chaining.
* @example
* const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });
* watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })
*/
function watch(paths, options = {}) {
	const watcher = new FSWatcher(options);
	watcher.add(paths);
	return watcher;
}

//#endregion
//#region ../../node_modules/lodash.debounce/index.js
var require_lodash_debounce = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* lodash (Custom Build) <https://lodash.com/>
	* Build: `lodash modularize exports="npm" -o ./`
	* Copyright jQuery Foundation and other contributors <https://jquery.org/>
	* Released under MIT license <https://lodash.com/license>
	* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	*/
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = "Expected a function";
	/** Used as references for various `Number` constants. */
	var NAN = NaN;
	/** `Object#toString` result references. */
	var symbolTag = "[object Symbol]";
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var objectToString = Object.prototype.toString;
	var nativeMax = Math.max, nativeMin = Math.min;
	/**
	* Gets the timestamp of the number of milliseconds that have elapsed since
	* the Unix epoch (1 January 1970 00:00:00 UTC).
	*
	* @static
	* @memberOf _
	* @since 2.4.0
	* @category Date
	* @returns {number} Returns the timestamp.
	* @example
	*
	* _.defer(function(stamp) {
	*   console.log(_.now() - stamp);
	* }, _.now());
	* // => Logs the number of milliseconds it took for the deferred invocation.
	*/
	var now = function() {
		return root.Date.now();
	};
	/**
	* Creates a debounced function that delays invoking `func` until after `wait`
	* milliseconds have elapsed since the last time the debounced function was
	* invoked. The debounced function comes with a `cancel` method to cancel
	* delayed `func` invocations and a `flush` method to immediately invoke them.
	* Provide `options` to indicate whether `func` should be invoked on the
	* leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	* with the last arguments provided to the debounced function. Subsequent
	* calls to the debounced function return the result of the last `func`
	* invocation.
	*
	* **Note:** If `leading` and `trailing` options are `true`, `func` is
	* invoked on the trailing edge of the timeout only if the debounced function
	* is invoked more than once during the `wait` timeout.
	*
	* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	* until to the next tick, similar to `setTimeout` with a timeout of `0`.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `_.debounce` and `_.throttle`.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Function
	* @param {Function} func The function to debounce.
	* @param {number} [wait=0] The number of milliseconds to delay.
	* @param {Object} [options={}] The options object.
	* @param {boolean} [options.leading=false]
	*  Specify invoking on the leading edge of the timeout.
	* @param {number} [options.maxWait]
	*  The maximum time `func` is allowed to be delayed before it's invoked.
	* @param {boolean} [options.trailing=true]
	*  Specify invoking on the trailing edge of the timeout.
	* @returns {Function} Returns the new debounced function.
	* @example
	*
	* // Avoid costly calculations while the window size is in flux.
	* jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	*
	* // Invoke `sendMail` when clicked, debouncing subsequent calls.
	* jQuery(element).on('click', _.debounce(sendMail, 300, {
	*   'leading': true,
	*   'trailing': false
	* }));
	*
	* // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	* var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	* var source = new EventSource('/stream');
	* jQuery(source).on('message', debounced);
	*
	* // Cancel the trailing debounced invocation.
	* jQuery(window).on('popstate', debounced.cancel);
	*/
	function debounce(func, wait, options) {
		var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
		wait = toNumber(wait) || 0;
		if (isObject(options)) {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		function invokeFunc(time) {
			var args = lastArgs, thisArg = lastThis;
			lastArgs = lastThis = void 0;
			lastInvokeTime = time;
			result = func.apply(thisArg, args);
			return result;
		}
		function leadingEdge(time) {
			lastInvokeTime = time;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time) : result;
		}
		function remainingWait(time) {
			var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
			return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
		}
		function shouldInvoke(time) {
			var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
			return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
		}
		function timerExpired() {
			var time = now();
			if (shouldInvoke(time)) return trailingEdge(time);
			timerId = setTimeout(timerExpired, remainingWait(time));
		}
		function trailingEdge(time) {
			timerId = void 0;
			if (trailing && lastArgs) return invokeFunc(time);
			lastArgs = lastThis = void 0;
			return result;
		}
		function cancel() {
			if (timerId !== void 0) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = void 0;
		}
		function flush() {
			return timerId === void 0 ? result : trailingEdge(now());
		}
		function debounced() {
			var time = now(), isInvoking = shouldInvoke(time);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time;
			if (isInvoking) {
				if (timerId === void 0) return leadingEdge(lastCallTime);
				if (maxing) {
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
			return result;
		}
		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	/**
	* Checks if `value` is classified as a `Symbol` primitive or object.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	* @example
	*
	* _.isSymbol(Symbol.iterator);
	* // => true
	*
	* _.isSymbol('abc');
	* // => false
	*/
	function isSymbol(value) {
		return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
	}
	/**
	* Converts `value` to a number.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to process.
	* @returns {number} Returns the number.
	* @example
	*
	* _.toNumber(3.2);
	* // => 3.2
	*
	* _.toNumber(Number.MIN_VALUE);
	* // => 5e-324
	*
	* _.toNumber(Infinity);
	* // => Infinity
	*
	* _.toNumber('3.2');
	* // => 3.2
	*/
	function toNumber(value) {
		if (typeof value == "number") return value;
		if (isSymbol(value)) return NAN;
		if (isObject(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject(other) ? other + "" : other;
		}
		if (typeof value != "string") return value === 0 ? value : +value;
		value = value.replace(reTrim, "");
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	module.exports = debounce;
}));

//#endregion
//#region src/terminal/session-store.ts
var import_lodash_debounce = /* @__PURE__ */ __toESM(require_lodash_debounce());
const MAX_SCROLLBACK = 5e4;
var SessionStore = class {
	scrollback = [];
	append(data) {
		this.scrollback.push(data);
		if (this.scrollback.length > MAX_SCROLLBACK) this.scrollback = this.scrollback.slice(-MAX_SCROLLBACK);
	}
	getAll() {
		return this.scrollback.join("");
	}
	clear() {
		this.scrollback = [];
	}
};

//#endregion
//#region src/terminal/pty-manager.ts
let pty = null;
let ptyLoadError = null;
try {
	pty = require("node-pty");
} catch (err) {
	ptyLoadError = err instanceof Error ? err.message : String(err);
}
const DISCONNECT_TIMEOUT_MS = 6e4;
const STATUS_INTERVAL_MS = 1e3;
const ACTIVE_THRESHOLD_MS = 2e3;
function ptyLog(level, ...args) {
	const ts = (/* @__PURE__ */ new Date()).toISOString();
	const msg = args.map((a) => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
	console.error(`[${ts}] [${level}] [pty-manager] ${msg}`);
}
var PtyManager = class PtyManager {
	static instance = null;
	session = null;
	connectedClients = /* @__PURE__ */ new Set();
	lastOutputTime = 0;
	statusInterval = null;
	static getInstance() {
		if (!PtyManager.instance) PtyManager.instance = new PtyManager();
		return PtyManager.instance;
	}
	spawn(opts) {
		if (!pty) {
			ptyLog("ERROR", `node-pty not available: ${ptyLoadError}`);
			this.broadcastToClients({
				type: "output",
				data: `\r\n\x1b[31mTerminal unavailable: node-pty is not installed.\r\nError: ${ptyLoadError}\r\nRun: npm install node-pty\x1b[0m\r\n`
			});
			return;
		}
		if (this.session) {
			ptyLog("INFO", "Killing existing session before spawn");
			this.kill();
		}
		const isWin = process.platform === "win32";
		const shell = isWin ? "cmd.exe" : "/bin/sh";
		const claudeCmd = `claude${opts.skipPermissions ? " --dangerously-skip-permissions" : ""}`;
		const args = isWin ? ["/c", claudeCmd] : ["-c", claudeCmd];
		ptyLog("INFO", `Spawning: shell=${shell}, args=${JSON.stringify(args)}, cwd=${opts.cwd}, cols=${opts.cols ?? 120}, rows=${opts.rows ?? 30}`);
		const proc = pty.spawn(shell, args, {
			name: "xterm-256color",
			cols: opts.cols ?? 120,
			rows: opts.rows ?? 30,
			cwd: opts.cwd,
			env: process.env
		});
		ptyLog("INFO", `Process spawned with pid=${proc.pid}`);
		const store = new SessionStore();
		this.session = {
			process: proc,
			pid: proc.pid,
			startTime: Date.now(),
			cwd: opts.cwd,
			skipPermissions: opts.skipPermissions,
			disconnectTimer: null,
			store
		};
		this.lastOutputTime = Date.now();
		proc.onData((data) => {
			this.lastOutputTime = Date.now();
			store.append(data);
			if (this.session?.pid === proc.pid) this.broadcastToClients({
				type: "output",
				data
			});
		});
		proc.onExit(({ exitCode }) => {
			ptyLog("INFO", `Process exited with code=${exitCode}`);
			if (this.session?.pid !== proc.pid) {
				ptyLog("INFO", `Ignoring stale exit for old pid=${proc.pid} (current pid=${this.session?.pid ?? "none"})`);
				return;
			}
			this.broadcastToClients({
				type: "exit",
				code: exitCode
			});
			this.stopStatusBroadcast();
			this.session = null;
		});
		this.broadcastToClients({
			type: "started",
			pid: proc.pid
		});
		this.startStatusBroadcast();
	}
	write(data) {
		if (this.session) this.session.process.write(data);
	}
	resize(cols, rows) {
		if (this.session) this.session.process.resize(cols, rows);
	}
	kill() {
		if (this.session) {
			this.stopStatusBroadcast();
			try {
				this.session.process.kill();
			} catch {}
			if (this.session.disconnectTimer) clearTimeout(this.session.disconnectTimer);
			this.session = null;
		}
	}
	getStatus() {
		if (!this.session) return null;
		return {
			pid: this.session.pid,
			uptime: Math.floor((Date.now() - this.session.startTime) / 1e3),
			cwd: this.session.cwd,
			memoryMB: Math.round(process.memoryUsage().rss / 1024 / 1024 * 10) / 10,
			isActive: Date.now() - this.lastOutputTime < ACTIVE_THRESHOLD_MS,
			skipPermissions: this.session.skipPermissions,
			alive: true
		};
	}
	addClient(ws) {
		this.connectedClients.add(ws);
		if (this.session?.disconnectTimer) {
			clearTimeout(this.session.disconnectTimer);
			this.session.disconnectTimer = null;
		}
		if (this.session) {
			const scrollback = this.session.store.getAll();
			if (scrollback) ws.send(JSON.stringify({
				type: "scrollback",
				data: scrollback
			}));
			const status = this.getStatus();
			if (status) ws.send(JSON.stringify({
				type: "status",
				...status
			}));
		}
	}
	removeClient(ws) {
		this.connectedClients.delete(ws);
		if (this.connectedClients.size === 0 && this.session) this.session.disconnectTimer = setTimeout(() => {
			console.error("[pty] No clients connected for 60s, killing process");
			this.kill();
		}, DISCONNECT_TIMEOUT_MS);
	}
	isAlive() {
		return this.session !== null;
	}
	isAvailable() {
		return pty !== null;
	}
	broadcastToClients(message) {
		const data = JSON.stringify(message);
		for (const client of this.connectedClients) if (client.readyState === import_websocket.default.OPEN) client.send(data);
	}
	startStatusBroadcast() {
		this.stopStatusBroadcast();
		this.statusInterval = setInterval(() => {
			const status = this.getStatus();
			if (status) this.broadcastToClients({
				type: "status",
				...status
			});
		}, STATUS_INTERVAL_MS);
	}
	stopStatusBroadcast() {
		if (this.statusInterval) {
			clearInterval(this.statusInterval);
			this.statusInterval = null;
		}
	}
};

//#endregion
//#region src/server.ts
const logDir = node_path.join(__dirname, "logs");
node_fs.mkdirSync(logDir, { recursive: true });
const logFile = node_path.join(logDir, `dashboard-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.log`);
const logStream = node_fs.createWriteStream(logFile, { flags: "a" });
function log(level, tag, ...args) {
	const line = `[${(/* @__PURE__ */ new Date()).toISOString()}] [${level}] [${tag}] ${args.map((a) => typeof a === "string" ? a : JSON.stringify(a)).join(" ")}\n`;
	logStream.write(line);
	if (level === "ERROR") console.error(`[${tag}]`, ...args);
}
const projectCwd = process.env.MAXSIM_PROJECT_CWD || process.cwd();
const networkMode = process.env.MAXSIM_NETWORK_MODE === "1";
let resolvedPort = 3333;
function getTailscaleIp() {
	const ifaces = node_os.networkInterfaces();
	for (const [name, iface] of Object.entries(ifaces)) {
		const isTailscaleIface = name === "Tailscale" || name === "tailscale0" || name.toLowerCase().includes("tailscale");
		for (const info of iface ?? []) {
			if (info.family !== "IPv4") continue;
			const parts = info.address.split(".").map(Number);
			const isTailscaleRange = parts[0] === 100 && parts[1] >= 64 && parts[1] <= 127;
			if (isTailscaleIface || isTailscaleRange) return info.address;
		}
	}
	return null;
}
const tailscaleIp = getTailscaleIp();
function getLanIp() {
	const ifaces = node_os.networkInterfaces();
	for (const [name, iface] of Object.entries(ifaces)) {
		const isTailscaleIface = name === "Tailscale" || name === "tailscale0" || name.toLowerCase().includes("tailscale");
		for (const info of iface ?? []) {
			if (info.family !== "IPv4" || info.internal || isTailscaleIface) continue;
			const parts = info.address.split(".").map(Number);
			if (!(parts[0] === 100 && parts[1] >= 64 && parts[1] <= 127)) return info.address;
		}
	}
	return null;
}
const localNetworkIp = networkMode || tailscaleIp !== null ? getLanIp() : null;
log("INFO", "server", `Starting dashboard server, projectCwd=${projectCwd}, networkMode=${networkMode}`);
const clientDir = node_path.join(__dirname, "client");
function isWithinPlanning(cwd, targetPath) {
	const planningDir = node_path.resolve(cwd, ".planning");
	return node_path.resolve(cwd, targetPath).startsWith(planningDir);
}
const suppressedPaths = /* @__PURE__ */ new Map();
const SUPPRESS_TTL_MS = 500;
function suppressPath(filePath) {
	suppressedPaths.set(normalizeFsPath(filePath), Date.now());
}
function isSuppressed(filePath) {
	const normalized = normalizeFsPath(filePath);
	const timestamp = suppressedPaths.get(normalized);
	if (timestamp === void 0) return false;
	if (Date.now() - timestamp > SUPPRESS_TTL_MS) {
		suppressedPaths.delete(normalized);
		return false;
	}
	return true;
}
function normalizeFsPath(p) {
	return p.replace(/\\/g, "/");
}
let clientCount = 0;
const questionQueue = [];
const pendingAnswers = /* @__PURE__ */ new Map();
const currentLifecycleState = { value: null };
function createWSS(onClientCountChange) {
	const wss = new import_websocket_server.default({ noServer: true });
	wss.on("connection", (ws) => {
		clientCount++;
		console.error(`[ws] Client connected (${clientCount} total)`);
		onClientCountChange?.(clientCount);
		ws.on("close", () => {
			clientCount--;
			console.error(`[ws] Client disconnected (${clientCount} total)`);
			onClientCountChange?.(clientCount);
		});
		ws.on("error", (err) => {
			console.error("[ws] Client error:", err.message);
		});
		ws.send(JSON.stringify({
			type: "connected",
			timestamp: Date.now()
		}));
	});
	return wss;
}
function broadcast(wss, message) {
	const data = JSON.stringify(message);
	let sent = 0;
	for (const client of wss.clients) if (client.readyState === import_websocket.default.OPEN) {
		client.send(data);
		sent++;
	}
	if (sent > 0) console.error(`[ws] Broadcast to ${sent} client(s)`);
}
function setupWatcher(cwd, wss) {
	const planningDir = normalizeFsPath(`${cwd}/.planning`);
	console.error(`[watcher] Watching ${planningDir}`);
	const watcher = watch(planningDir, {
		persistent: true,
		ignoreInitial: true,
		awaitWriteFinish: {
			stabilityThreshold: 300,
			pollInterval: 100
		},
		depth: 5
	});
	const changedPaths = /* @__PURE__ */ new Set();
	const flushChanges = (0, import_lodash_debounce.default)(() => {
		if (changedPaths.size > 0) {
			const changes = Array.from(changedPaths);
			changedPaths.clear();
			console.error(`[watcher] Broadcasting ${changes.length} change(s)`);
			broadcast(wss, {
				type: "file-changes",
				changes,
				timestamp: Date.now()
			});
		}
	}, 200);
	function onFileChange(filePath) {
		const normalized = normalizeFsPath(filePath);
		if (isSuppressed(normalized)) {
			console.error(`[watcher] Suppressed: ${normalized}`);
			return;
		}
		changedPaths.add(normalized);
		flushChanges();
	}
	watcher.on("add", onFileChange);
	watcher.on("change", onFileChange);
	watcher.on("unlink", onFileChange);
	watcher.on("error", (err) => {
		console.error("[watcher] Error:", err.message);
	});
	return watcher;
}
function parseRoadmap(cwd) {
	const roadmapPath = node_path.join(cwd, ".planning", "ROADMAP.md");
	if (!node_fs.existsSync(roadmapPath)) return null;
	const content = node_fs.readFileSync(roadmapPath, "utf-8").replace(/\r\n/g, "\n");
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	const phasePattern = getPhasePattern();
	const phases = [];
	let match;
	while ((match = phasePattern.exec(content)) !== null) {
		const phaseNum = match[1];
		const phaseName = match[2].replace(/\(INSERTED\)/i, "").trim();
		const sectionStart = match.index;
		const nextHeader = content.slice(sectionStart).match(/\n#{2,4}\s+Phase\s+\d/i);
		const sectionEnd = nextHeader ? sectionStart + nextHeader.index : content.length;
		const section = content.slice(sectionStart, sectionEnd);
		const goalMatch = section.match(/\*\*Goal(?::\*\*|\*\*:)\s*([^\n]+)/i);
		const goal = goalMatch ? goalMatch[1].trim() : null;
		const dependsMatch = section.match(/\*\*Depends on:\*\*\s*([^\n]+)/i);
		const depends_on = dependsMatch ? dependsMatch[1].trim() : null;
		const normalized = normalizePhaseName(phaseNum);
		let diskStatus = "no_directory";
		let planCount = 0;
		let summaryCount = 0;
		let hasContext = false;
		let hasResearch = false;
		try {
			const dirMatch = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).find((d) => d.startsWith(normalized + "-") || d === normalized);
			if (dirMatch) {
				const phaseFiles = node_fs.readdirSync(node_path.join(phasesDir, dirMatch));
				planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
				summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
				hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
				hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
				if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
				else if (summaryCount > 0) diskStatus = "partial";
				else if (planCount > 0) diskStatus = "planned";
				else if (hasResearch) diskStatus = "researched";
				else if (hasContext) diskStatus = "discussed";
				else diskStatus = "empty";
			}
		} catch {}
		const checkboxPattern = new RegExp(`-\\s*\\[(x| )\\]\\s*.*Phase\\s+${phaseNum.replace(".", "\\.")}`, "i");
		const checkboxMatch = content.match(checkboxPattern);
		const roadmapComplete = checkboxMatch ? checkboxMatch[1] === "x" : false;
		phases.push({
			number: phaseNum,
			name: phaseName,
			goal,
			depends_on,
			plan_count: planCount,
			summary_count: summaryCount,
			has_context: hasContext,
			has_research: hasResearch,
			disk_status: diskStatus,
			roadmap_complete: roadmapComplete
		});
	}
	const milestones = [];
	const milestonePattern = /##\s*(.*v(\d+\.\d+)[^(\n]*)/gi;
	let mMatch;
	while ((mMatch = milestonePattern.exec(content)) !== null) milestones.push({
		heading: mMatch[1].trim(),
		version: "v" + mMatch[2]
	});
	const currentPhase = phases.find((p) => p.disk_status === "planned" || p.disk_status === "partial") || null;
	const nextPhase = phases.find((p) => p.disk_status === "empty" || p.disk_status === "no_directory" || p.disk_status === "discussed" || p.disk_status === "researched") || null;
	const totalPlans = phases.reduce((sum, p) => sum + p.plan_count, 0);
	const totalSummaries = phases.reduce((sum, p) => sum + p.summary_count, 0);
	const completedPhases = phases.filter((p) => p.disk_status === "complete").length;
	return {
		milestones,
		phases,
		phase_count: phases.length,
		completed_phases: completedPhases,
		total_plans: totalPlans,
		total_summaries: totalSummaries,
		progress_percent: totalPlans > 0 ? Math.min(100, Math.round(totalSummaries / totalPlans * 100)) : 0,
		current_phase: currentPhase ? currentPhase.number : null,
		next_phase: nextPhase ? nextPhase.number : null,
		missing_phase_details: null
	};
}
function parseState(cwd) {
	const statePath = node_path.join(cwd, ".planning", "STATE.md");
	if (!node_fs.existsSync(statePath)) return null;
	const content = node_fs.readFileSync(statePath, "utf-8").replace(/\r\n/g, "\n");
	const position = stateExtractField(content, "Current Position") || stateExtractField(content, "Phase");
	const lastActivity = stateExtractField(content, "Last activity") || stateExtractField(content, "Last Activity");
	const currentPhase = stateExtractField(content, "Current Phase") || stateExtractField(content, "Phase");
	const currentPlan = stateExtractField(content, "Current Plan") || stateExtractField(content, "Plan");
	const status = stateExtractField(content, "Status");
	const progress = stateExtractField(content, "Progress");
	const decisions = [];
	const decisionsMatch = content.match(/###?\s*Decisions\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
	if (decisionsMatch) {
		const items = decisionsMatch[1].match(/^-\s+(.+)$/gm) || [];
		for (const item of items) decisions.push(item.replace(/^-\s+/, "").trim());
	}
	const blockers = [];
	const blockersMatch = content.match(/###?\s*(?:Blockers|Blockers\/Concerns)\s*\n([\s\S]*?)(?=\n###?|\n##[^#]|$)/i);
	if (blockersMatch) {
		const items = blockersMatch[1].match(/^-\s+(.+)$/gm) || [];
		for (const item of items) blockers.push(item.replace(/^-\s+/, "").trim());
	}
	return {
		position,
		lastActivity,
		currentPhase,
		currentPlan,
		status,
		progress,
		decisions,
		blockers,
		content
	};
}
function parsePhases(cwd) {
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	if (!node_fs.existsSync(phasesDir)) return [];
	const phases = [];
	try {
		const dirs = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).sort((a, b) => comparePhaseNum(a, b));
		for (const dir of dirs) {
			const dm = dir.match(/^(\d+[A-Z]?(?:\.\d+)?)-?(.*)/i);
			const phaseNum = dm ? dm[1] : dir;
			const phaseName = dm && dm[2] ? dm[2].replace(/-/g, " ") : "";
			const phaseFiles = node_fs.readdirSync(node_path.join(phasesDir, dir));
			const planCount = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").length;
			const summaryCount = phaseFiles.filter((f) => f.endsWith("-SUMMARY.md") || f === "SUMMARY.md").length;
			const hasContext = phaseFiles.some((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
			const hasResearch = phaseFiles.some((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
			let diskStatus = "no_directory";
			if (summaryCount >= planCount && planCount > 0) diskStatus = "complete";
			else if (summaryCount > 0) diskStatus = "partial";
			else if (planCount > 0) diskStatus = "planned";
			else if (hasResearch) diskStatus = "researched";
			else if (hasContext) diskStatus = "discussed";
			else diskStatus = "empty";
			phases.push({
				number: phaseNum,
				name: phaseName,
				goal: "",
				dependsOn: [],
				planCount,
				summaryCount,
				diskStatus,
				roadmapComplete: diskStatus === "complete",
				hasContext,
				hasResearch
			});
		}
	} catch {}
	return phases;
}
function parsePhaseDetail(cwd, phaseId) {
	const phasesDir = node_path.join(cwd, ".planning", "phases");
	if (!node_fs.existsSync(phasesDir)) return null;
	const normalized = normalizePhaseName(phaseId);
	try {
		const dirMatch = node_fs.readdirSync(phasesDir, { withFileTypes: true }).filter((e) => e.isDirectory()).map((e) => e.name).find((d) => d.startsWith(normalized + "-") || d === normalized);
		if (!dirMatch) return null;
		const phaseDir = node_path.join(phasesDir, dirMatch);
		const phaseFiles = node_fs.readdirSync(phaseDir);
		const planFileNames = phaseFiles.filter((f) => f.endsWith("-PLAN.md") || f === "PLAN.md").sort();
		const plans = [];
		for (const planFileName of planFileNames) {
			const planPath = node_path.join(phaseDir, planFileName);
			const content = node_fs.readFileSync(planPath, "utf-8").replace(/\r\n/g, "\n");
			const frontmatter = extractFrontmatter(content);
			const tasks = [];
			const taskRegex = /<task\s+type="([^"]*)"[^>]*>\s*<name>([^<]+)<\/name>([\s\S]*?)<\/task>/g;
			let taskMatch;
			while ((taskMatch = taskRegex.exec(content)) !== null) {
				const taskType = taskMatch[1];
				const taskName = taskMatch[2].trim();
				const taskBody = taskMatch[3];
				const filesMatch = taskBody.match(/<files>([\s\S]*?)<\/files>/);
				const actionMatch = taskBody.match(/<action>([\s\S]*?)<\/action>/);
				const verifyMatch = taskBody.match(/<verify>([\s\S]*?)<\/verify>/);
				const doneMatch = taskBody.match(/<done>([\s\S]*?)<\/done>/);
				const files = filesMatch ? filesMatch[1].trim().split("\n").map((f) => f.trim()).filter(Boolean) : [];
				const doneText = doneMatch ? doneMatch[1].trim() : "";
				tasks.push({
					name: taskName,
					type: taskType,
					files,
					action: actionMatch ? actionMatch[1].trim() : "",
					verify: verifyMatch ? verifyMatch[1].trim() : "",
					done: doneText,
					completed: /^\[x\]/i.test(doneText)
				});
			}
			plans.push({
				path: node_path.join(".planning", "phases", dirMatch, planFileName),
				content,
				frontmatter,
				tasks
			});
		}
		let context = null;
		const contextFile = phaseFiles.find((f) => f.endsWith("-CONTEXT.md") || f === "CONTEXT.md");
		if (contextFile) context = node_fs.readFileSync(node_path.join(phaseDir, contextFile), "utf-8");
		let research = null;
		const researchFile = phaseFiles.find((f) => f.endsWith("-RESEARCH.md") || f === "RESEARCH.md");
		if (researchFile) research = node_fs.readFileSync(node_path.join(phaseDir, researchFile), "utf-8");
		return {
			plans,
			context,
			research
		};
	} catch {
		return null;
	}
}
function parseTodos(cwd) {
	const pendingDir = node_path.join(cwd, ".planning", "todos", "pending");
	const completedDir = node_path.join(cwd, ".planning", "todos", "completed");
	const pending = [];
	const completed = [];
	if (node_fs.existsSync(pendingDir)) try {
		const files = node_fs.readdirSync(pendingDir).filter((f) => f.endsWith(".md"));
		for (const file of files) try {
			const titleMatch = node_fs.readFileSync(node_path.join(pendingDir, file), "utf-8").match(/^title:\s*(.+)$/m);
			pending.push({
				text: titleMatch ? titleMatch[1].trim() : file.replace(".md", ""),
				completed: false,
				file
			});
		} catch {}
	} catch {}
	if (node_fs.existsSync(completedDir)) try {
		const files = node_fs.readdirSync(completedDir).filter((f) => f.endsWith(".md"));
		for (const file of files) try {
			const titleMatch = node_fs.readFileSync(node_path.join(completedDir, file), "utf-8").match(/^title:\s*(.+)$/m);
			completed.push({
				text: titleMatch ? titleMatch[1].trim() : file.replace(".md", ""),
				completed: true,
				file
			});
		} catch {}
	} catch {}
	return {
		pending,
		completed
	};
}
function parseProject(cwd) {
	const projectPath = node_path.join(cwd, ".planning", "PROJECT.md");
	const requirementsPath = node_path.join(cwd, ".planning", "REQUIREMENTS.md");
	return {
		project: node_fs.existsSync(projectPath) ? node_fs.readFileSync(projectPath, "utf-8") : null,
		requirements: node_fs.existsSync(requirementsPath) ? node_fs.readFileSync(requirementsPath, "utf-8") : null
	};
}
const app = (0, import_express.default)();
app.use(import_express.json());
app.get("/api/health", (_req, res) => {
	res.json({
		status: "ok",
		port: process.env.PORT || 3333,
		cwd: projectCwd,
		uptime: process.uptime()
	});
});
app.get("/api/roadmap", (_req, res) => {
	const data = parseRoadmap(projectCwd);
	if (!data) return res.status(404).json({ error: "ROADMAP.md not found" });
	return res.json(data);
});
app.patch("/api/roadmap", (req, res) => {
	const roadmapPath = node_path.join(projectCwd, ".planning", "ROADMAP.md");
	if (!node_fs.existsSync(roadmapPath)) return res.status(404).json({ error: "ROADMAP.md not found" });
	const { phaseNumber, checked } = req.body;
	if (!phaseNumber || checked === void 0) return res.status(400).json({ error: "phaseNumber and checked are required" });
	let content = node_fs.readFileSync(roadmapPath, "utf-8").replace(/\r\n/g, "\n");
	const escapedNum = phaseNumber.replace(".", "\\.");
	const pattern = new RegExp(`(-\\s*\\[)(x| )(\\]\\s*.*Phase\\s+${escapedNum})`, "i");
	if (!content.match(pattern)) return res.status(404).json({ error: `Phase ${phaseNumber} checkbox not found in ROADMAP.md` });
	content = content.replace(pattern, `$1${checked ? "x" : " "}$3`);
	suppressPath(roadmapPath);
	node_fs.writeFileSync(roadmapPath, content, "utf-8");
	return res.json({
		updated: true,
		phaseNumber,
		checked
	});
});
app.get("/api/state", (_req, res) => {
	const data = parseState(projectCwd);
	if (!data) return res.status(404).json({ error: "STATE.md not found" });
	return res.json(data);
});
app.patch("/api/state", (req, res) => {
	const statePath = node_path.join(projectCwd, ".planning", "STATE.md");
	if (!node_fs.existsSync(statePath)) return res.status(404).json({ error: "STATE.md not found" });
	if (!isWithinPlanning(projectCwd, ".planning/STATE.md")) return res.status(400).json({ error: "Invalid path" });
	const { field, value } = req.body;
	if (!field || value === void 0) return res.status(400).json({ error: "field and value are required" });
	const updated = stateReplaceField(node_fs.readFileSync(statePath, "utf-8").replace(/\r\n/g, "\n"), field, value);
	if (!updated) return res.status(404).json({ error: `Field "${field}" not found in STATE.md` });
	suppressPath(statePath);
	node_fs.writeFileSync(statePath, updated, "utf-8");
	return res.json({
		updated: true,
		field
	});
});
function ensureStateMd(statePath) {
	if (node_fs.existsSync(statePath)) return;
	const planningDir = node_path.dirname(statePath);
	node_fs.mkdirSync(planningDir, { recursive: true });
	const template = `# Project State

## Current Position

Phase: 1
Status: In progress
Last activity: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}  State file created

## Accumulated Context

### Decisions

None yet.

### Blockers/Concerns

None yet.
`;
	node_fs.writeFileSync(statePath, template, "utf-8");
}
function appendToStateSection(statePath, sectionPattern, entry, fallbackSection) {
	let content = node_fs.readFileSync(statePath, "utf-8").replace(/\r\n/g, "\n");
	const match = content.match(sectionPattern);
	if (match) {
		let sectionBody = match[2];
		sectionBody = sectionBody.replace(/None yet\.?\s*\n?/gi, "").replace(/No decisions yet\.?\s*\n?/gi, "").replace(/None\.?\s*\n?/gi, "");
		sectionBody = sectionBody.trimEnd() + "\n" + entry + "\n";
		content = content.replace(sectionPattern, (_m, header) => `${header}${sectionBody}`);
	} else content = content.trimEnd() + "\n\n" + fallbackSection + "\n" + entry + "\n";
	suppressPath(statePath);
	node_fs.writeFileSync(statePath, content, "utf-8");
	return { success: true };
}
app.post("/api/state/decision", (req, res) => {
	const statePath = node_path.join(projectCwd, ".planning", "STATE.md");
	ensureStateMd(statePath);
	const { phase, text } = req.body;
	if (!text?.trim()) return res.status(400).json({ error: "text is required" });
	const entry = `- [Phase ${phase?.trim() || "?"}]: ${text.trim()}`;
	appendToStateSection(statePath, /(###?\s*(?:Decisions|Decisions Made|Accumulated.*Decisions)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i, entry, "### Decisions");
	return res.json({
		added: true,
		decision: entry
	});
});
app.post("/api/state/blocker", (req, res) => {
	const statePath = node_path.join(projectCwd, ".planning", "STATE.md");
	ensureStateMd(statePath);
	const { text } = req.body;
	if (!text?.trim()) return res.status(400).json({ error: "text is required" });
	appendToStateSection(statePath, /(###?\s*(?:Blockers|Blockers\/Concerns|Concerns)\s*\n)([\s\S]*?)(?=\n###?|\n##[^#]|$)/i, `- ${text.trim()}`, "### Blockers/Concerns");
	return res.json({
		added: true,
		blocker: text.trim()
	});
});
app.get("/api/phases", (_req, res) => {
	const phases = parsePhases(projectCwd);
	return res.json(phases);
});
app.get("/api/phase/:id", (req, res) => {
	const phaseId = req.params.id;
	const data = parsePhaseDetail(projectCwd, phaseId);
	if (!data) return res.status(404).json({ error: `Phase ${phaseId} not found` });
	return res.json(data);
});
app.get("/api/todos", (_req, res) => {
	const data = parseTodos(projectCwd);
	return res.json(data);
});
app.post("/api/todos", (req, res) => {
	const pendingDir = node_path.join(projectCwd, ".planning", "todos", "pending");
	const { text } = req.body;
	if (!text) return res.status(400).json({ error: "text is required" });
	node_fs.mkdirSync(pendingDir, { recursive: true });
	const timestamp = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
	const filename = `${timestamp}-${(0, import_slugify.default)(text, {
		lower: true,
		strict: true
	}).slice(0, 40)}.md`;
	const filePath = node_path.join(pendingDir, filename);
	const content = `title: ${text}\ncreated: ${timestamp}\narea: general\n\n${text}\n`;
	suppressPath(filePath);
	node_fs.writeFileSync(filePath, content, "utf-8");
	return res.json({
		created: true,
		file: filename,
		text
	});
});
app.patch("/api/todos", (req, res) => {
	const pendingDir = node_path.join(projectCwd, ".planning", "todos", "pending");
	const completedDir = node_path.join(projectCwd, ".planning", "todos", "completed");
	const { file, completed } = req.body;
	if (!file) return res.status(400).json({ error: "file is required" });
	if (file.includes("/") || file.includes("\\") || file.includes("..")) return res.status(400).json({ error: "Invalid filename" });
	if (completed) {
		const sourcePath = node_path.join(pendingDir, file);
		if (!node_fs.existsSync(sourcePath)) return res.status(404).json({ error: "Todo not found in pending" });
		if (!isWithinPlanning(projectCwd, node_path.relative(projectCwd, sourcePath))) return res.status(400).json({ error: "Invalid path" });
		node_fs.mkdirSync(completedDir, { recursive: true });
		const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
		let content = node_fs.readFileSync(sourcePath, "utf-8");
		content = `completed: ${today}\n` + content;
		const destPath = node_path.join(completedDir, file);
		suppressPath(sourcePath);
		suppressPath(destPath);
		node_fs.writeFileSync(destPath, content, "utf-8");
		node_fs.unlinkSync(sourcePath);
		return res.json({
			completed: true,
			file,
			date: today
		});
	} else {
		const sourcePath = node_path.join(completedDir, file);
		if (!node_fs.existsSync(sourcePath)) return res.status(404).json({ error: "Todo not found in completed" });
		if (!isWithinPlanning(projectCwd, node_path.relative(projectCwd, sourcePath))) return res.status(400).json({ error: "Invalid path" });
		node_fs.mkdirSync(pendingDir, { recursive: true });
		let content = node_fs.readFileSync(sourcePath, "utf-8");
		content = content.replace(/^completed:\s*.+\n/m, "");
		const destPath = node_path.join(pendingDir, file);
		suppressPath(sourcePath);
		suppressPath(destPath);
		node_fs.writeFileSync(destPath, content, "utf-8");
		node_fs.unlinkSync(sourcePath);
		return res.json({
			completed: false,
			file
		});
	}
});
app.get("/api/project", (_req, res) => {
	const data = parseProject(projectCwd);
	return res.json(data);
});
app.get("/api/plan/*", (req, res) => {
	const pathSegments = req.params["0"].split("/");
	const relativePath = node_path.join(".planning", ...pathSegments);
	if (!isWithinPlanning(projectCwd, relativePath)) return res.status(403).json({ error: "Path traversal not allowed" });
	const fullPath = node_path.join(projectCwd, relativePath);
	if (!node_fs.existsSync(fullPath)) return res.status(404).json({ error: "File not found" });
	try {
		const content = node_fs.readFileSync(fullPath, "utf-8");
		return res.json({
			path: relativePath,
			content
		});
	} catch {
		return res.status(500).json({ error: "Failed to read file" });
	}
});
app.put("/api/plan/*", (req, res) => {
	const pathSegments = req.params["0"].split("/");
	const relativePath = node_path.join(".planning", ...pathSegments);
	if (!isWithinPlanning(projectCwd, relativePath)) return res.status(403).json({ error: "Path traversal not allowed" });
	const { content } = req.body;
	if (content === void 0) return res.status(400).json({ error: "content is required" });
	const fullPath = node_path.join(projectCwd, relativePath);
	const dir = node_path.dirname(fullPath);
	if (!node_fs.existsSync(dir)) node_fs.mkdirSync(dir, { recursive: true });
	suppressPath(fullPath);
	node_fs.writeFileSync(fullPath, content, "utf-8");
	return res.json({
		written: true,
		path: relativePath
	});
});
app.get("/api/server-info", (_req, res) => {
	return res.json({
		networkEnabled: networkMode,
		localUrl: `http://localhost:${resolvedPort}`,
		networkUrl: localNetworkIp ? `http://${localNetworkIp}:${resolvedPort}` : null,
		tailscaleUrl: tailscaleIp ? `http://${tailscaleIp}:${resolvedPort}` : null
	});
});
let shutdownFn = null;
app.post("/api/shutdown", (_req, res) => {
	res.json({ shutdown: true });
	setTimeout(() => shutdownFn?.(), 100);
});
const simpleModeConfigPath = node_path.join(__dirname, "simple-mode-config.json");
app.get("/api/simple-mode-config", (_req, res) => {
	try {
		if (!node_fs.existsSync(simpleModeConfigPath)) return res.json({});
		const data = JSON.parse(node_fs.readFileSync(simpleModeConfigPath, "utf-8"));
		return res.json(data);
	} catch {
		return res.json({});
	}
});
app.post("/api/simple-mode-config", (req, res) => {
	const { default_mode } = req.body;
	if (default_mode !== "simple" && default_mode !== "advanced") return res.status(400).json({ error: "default_mode must be \"simple\" or \"advanced\"" });
	let existing = {};
	if (node_fs.existsSync(simpleModeConfigPath)) try {
		existing = JSON.parse(node_fs.readFileSync(simpleModeConfigPath, "utf-8"));
	} catch {}
	existing.default_mode = default_mode;
	node_fs.writeFileSync(simpleModeConfigPath, JSON.stringify(existing, null, 2), "utf-8");
	log("INFO", "simple-mode-config", `default_mode set to ${default_mode}`);
	return res.json({
		written: true,
		default_mode
	});
});
if (node_fs.existsSync(clientDir)) app.use(build_default(clientDir, { single: true }));
else app.get("/", (_req, res) => {
	res.send("<html><body><p>Dashboard client not found. Run <code>pnpm run build</code> first.</p></body></html>");
});
const AUTO_SHUTDOWN_DELAY_MS = 6e4;
function registerMcpServerInClaudeJson(projectPath, port) {
	const claudeJsonPath = node_path.join(node_os.homedir(), ".claude.json");
	let claudeJson = {};
	if (node_fs.existsSync(claudeJsonPath)) try {
		claudeJson = JSON.parse(node_fs.readFileSync(claudeJsonPath, "utf-8"));
	} catch {
		log("WARN", "mcp-register", "Failed to parse ~/.claude.json, starting fresh");
	}
	const projects = claudeJson.projects ?? {};
	const projectConfig = projects[projectPath] ?? {};
	const mcpServers = projectConfig.mcpServers ?? {};
	mcpServers["maxsim-dashboard"] = {
		type: "http",
		url: `http://localhost:${port}/mcp`
	};
	projectConfig.mcpServers = mcpServers;
	projects[projectPath] = projectConfig;
	claudeJson.projects = projects;
	const tmp = claudeJsonPath + ".tmp." + Date.now();
	node_fs.writeFileSync(tmp, JSON.stringify(claudeJson, null, 2) + "\n", "utf-8");
	node_fs.renameSync(tmp, claudeJsonPath);
	log("INFO", "mcp-register", `MCP server registered at http://localhost:${port}/mcp for ${projectPath}`);
}
function unregisterMcpServerFromClaudeJson(projectPath) {
	const claudeJsonPath = node_path.join(node_os.homedir(), ".claude.json");
	if (!node_fs.existsSync(claudeJsonPath)) return;
	try {
		const claudeJson = JSON.parse(node_fs.readFileSync(claudeJsonPath, "utf-8"));
		const projects = claudeJson.projects ?? {};
		if (projects[projectPath]?.mcpServers) delete projects[projectPath].mcpServers["maxsim-dashboard"];
		const tmp = claudeJsonPath + ".tmp." + Date.now();
		node_fs.writeFileSync(tmp, JSON.stringify(claudeJson, null, 2) + "\n", "utf-8");
		node_fs.renameSync(tmp, claudeJsonPath);
		log("INFO", "mcp-register", `MCP server unregistered for ${projectPath}`);
	} catch {}
}
async function main() {
	let autoShutdownTimer = null;
	const wss = createWSS((count) => {
		if (count > 0) {
			if (autoShutdownTimer) {
				clearTimeout(autoShutdownTimer);
				autoShutdownTimer = null;
				log("INFO", "server", "Auto-shutdown cancelled  client connected");
			}
		} else {
			autoShutdownTimer = setTimeout(() => {
				if (wss.clients.size === 0) {
					log("INFO", "server", "Auto-shutdown: no clients for 60s  shutting down");
					shutdown();
				}
			}, AUTO_SHUTDOWN_DELAY_MS);
			log("INFO", "server", `Auto-shutdown scheduled in ${AUTO_SHUTDOWN_DELAY_MS / 1e3}s (no clients)`);
		}
	});
	const mcpServer = createMcpServer({
		wss,
		questionQueue,
		pendingAnswers,
		currentLifecycleState,
		broadcast
	});
	app.post("/mcp", async (req, res) => {
		const transport = new _modelcontextprotocol_sdk_server_streamableHttp_js.StreamableHTTPServerTransport({ sessionIdGenerator: void 0 });
		await mcpServer.connect(transport);
		await transport.handleRequest(req, res, req.body);
	});
	app.get("/mcp", async (req, res) => {
		const transport = new _modelcontextprotocol_sdk_server_streamableHttp_js.StreamableHTTPServerTransport({ sessionIdGenerator: void 0 });
		await mcpServer.connect(transport);
		await transport.handleRequest(req, res);
	});
	app.delete("/mcp", (_req, res) => {
		res.status(200).end();
	});
	app.post("/api/mcp-answer", (req, res) => {
		const { questionId, answer } = req.body;
		if (!questionId || !answer) return res.status(400).json({ error: "questionId and answer are required" });
		const resolve = pendingAnswers.get(questionId);
		if (!resolve) return res.status(404).json({ error: "No pending question with that ID" });
		pendingAnswers.delete(questionId);
		resolve(answer);
		return res.json({ answered: true });
	});
	wss.on("connection", (ws) => {
		if (questionQueue.length > 0) ws.send(JSON.stringify({
			type: "questions-queued",
			questions: questionQueue,
			count: questionQueue.length
		}));
		if (currentLifecycleState.value) ws.send(JSON.stringify({
			type: "lifecycle",
			event: currentLifecycleState.value
		}));
	});
	const terminalWss = new import_websocket_server.default({ noServer: true });
	const ptyManager = PtyManager.getInstance();
	if (!ptyManager.isAvailable()) log("WARN", "server", "node-pty not available  terminal features disabled");
	else log("INFO", "server", "node-pty available  terminal features enabled");
	terminalWss.on("connection", (ws) => {
		log("INFO", "terminal-ws", "Client connected");
		ptyManager.addClient(ws);
		if (!ptyManager.isAvailable()) {
			ws.send(JSON.stringify({
				type: "unavailable",
				reason: "node-pty is not installed  terminal features disabled"
			}));
			log("WARN", "terminal-ws", "Sent unavailable to client  node-pty missing");
		}
		ws.on("message", (raw) => {
			try {
				const msg = JSON.parse(typeof raw === "string" ? raw : raw.toString());
				switch (msg.type) {
					case "input":
						ptyManager.write(msg.data);
						break;
					case "resize":
						log("INFO", "terminal-ws", `Resize: ${msg.cols}x${msg.rows}`);
						ptyManager.resize(msg.cols, msg.rows);
						break;
					case "spawn":
						log("INFO", "terminal-ws", `Spawn requested: skipPermissions=${!!msg.skipPermissions}, cwd=${projectCwd}`);
						try {
							ptyManager.spawn({
								skipPermissions: !!msg.skipPermissions,
								cwd: projectCwd,
								cols: msg.cols,
								rows: msg.rows
							});
							log("INFO", "terminal-ws", `Spawn succeeded, pid=${ptyManager.getStatus()?.pid}`);
						} catch (err) {
							const errMsg = err instanceof Error ? err.message : String(err);
							log("ERROR", "terminal-ws", `Spawn failed: ${errMsg}`);
							ws.send(JSON.stringify({
								type: "output",
								data: `\r\n\x1b[31mFailed to start terminal: ${errMsg}\x1b[0m\r\n`
							}));
						}
						break;
					case "kill":
						log("INFO", "terminal-ws", "Kill requested");
						ptyManager.kill();
						break;
					default: log("WARN", "terminal-ws", `Unknown message type: ${msg.type}`);
				}
			} catch (err) {
				log("ERROR", "terminal-ws", `Message handling error: ${err instanceof Error ? err.message : String(err)}`);
			}
		});
		ws.on("close", () => {
			log("INFO", "terminal-ws", "Client disconnected");
			ptyManager.removeClient(ws);
		});
		ws.on("error", (err) => {
			log("ERROR", "terminal-ws", `Client error: ${err.message}`);
		});
	});
	const server = (0, node_http.createServer)(app);
	server.on("upgrade", (req, socket, head) => {
		const url = req.url || "/";
		if (url === "/ws/terminal" || url.startsWith("/ws/terminal?")) terminalWss.handleUpgrade(req, socket, head, (ws) => {
			terminalWss.emit("connection", ws, req);
		});
		else if (url === "/api/ws" || url.startsWith("/api/ws?")) wss.handleUpgrade(req, socket, head, (ws) => {
			wss.emit("connection", ws, req);
		});
		else socket.destroy();
	});
	let watcher;
	try {
		watcher = setupWatcher(projectCwd, wss);
	} catch (err) {
		console.error("[server] Failed to start file watcher:", err.message);
	}
	const port = await esm_default(3333);
	resolvedPort = port;
	const localUrl = `http://localhost:${port}`;
	const bindHost = networkMode || tailscaleIp !== null ? "0.0.0.0" : "127.0.0.1";
	server.listen(port, bindHost, () => {
		log("INFO", "server", `Dashboard ready at ${localUrl}, log file: ${logFile}`);
		console.error(`Dashboard ready at ${localUrl}`);
		if (localNetworkIp) console.error(`LAN URL:          http://${localNetworkIp}:${port}`);
		if (tailscaleIp) {
			console.error(`Tailscale URL:    http://${tailscaleIp}:${port}`);
			console.error(`                   open on any Tailscale device`);
		}
		if (bindHost === "0.0.0.0" && localNetworkIp && process.platform === "win32") {
			console.error("");
			console.error(`[firewall] Windows may block LAN connections on port ${port}.`);
			console.error(`[firewall] Run once as Administrator to allow it:`);
			console.error(`[firewall]   netsh advfirewall firewall add rule name="MAXSIM Dashboard" dir=in action=allow protocol=TCP localport=${port}`);
		}
		log("INFO", "mcp", `MCP server available at http://localhost:${port}/mcp`);
		console.error(`MCP endpoint: http://localhost:${port}/mcp`);
		console.error(`Logs: ${logFile}`);
		registerMcpServerInClaudeJson(projectCwd, port);
		console.error("MCP server registered. Restart Claude Code to activate dashboard tools.");
		open$1(localUrl).catch(() => {});
	});
	function shutdown() {
		console.error("\n[server] Shutting down...");
		unregisterMcpServerFromClaudeJson(projectCwd);
		ptyManager.kill();
		if (watcher) watcher.close().catch(() => {});
		terminalWss.close(() => {});
		wss.close(() => {
			server.close(() => {
				process.exit(0);
			});
		});
		setTimeout(() => {
			console.error("[server] Forced exit after timeout");
			process.exit(1);
		}, 5e3);
	}
	shutdownFn = shutdown;
	process.on("SIGINT", shutdown);
	process.on("SIGTERM", shutdown);
	process.on("exit", () => {
		ptyManager.kill();
	});
}
main().catch((err) => {
	console.error("[server] Fatal error:", err);
	process.exit(1);
});

//#endregion