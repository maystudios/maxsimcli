{"version":3,"file":"base-BYHjQPHa.cjs","names":["path","os","fs"],"sources":["../src/base.ts"],"sourcesContent":["/**\n * @maxsim/adapters â€” Shared base utilities extracted from bin/install.js\n */\n\nimport * as path from 'node:path';\nimport * as os from 'node:os';\nimport * as fs from 'node:fs';\n\n/**\n * Expand ~ to home directory (shell doesn't expand in env vars passed to node)\n */\nexport function expandTilde(filePath: string): string {\n  if (filePath && filePath.startsWith('~/')) {\n    return path.join(os.homedir(), filePath.slice(2));\n  }\n  return filePath;\n}\n\n/**\n * Extract YAML frontmatter and body from markdown content.\n * Returns null frontmatter if content doesn't start with ---.\n */\nexport function extractFrontmatterAndBody(\n  content: string,\n): { frontmatter: string | null; body: string } {\n  if (!content.startsWith('---')) {\n    return { frontmatter: null, body: content };\n  }\n\n  const endIndex = content.indexOf('---', 3);\n  if (endIndex === -1) {\n    return { frontmatter: null, body: content };\n  }\n\n  return {\n    frontmatter: content.substring(3, endIndex).trim(),\n    body: content.substring(endIndex + 3),\n  };\n}\n\n/**\n * Process Co-Authored-By lines based on attribution setting.\n * @param content - File content to process\n * @param attribution - null=remove, undefined=keep default, string=replace\n */\nexport function processAttribution(\n  content: string,\n  attribution: null | undefined | string,\n): string {\n  if (attribution === null) {\n    return content.replace(/(\\r?\\n){2}Co-Authored-By:.*$/gim, '');\n  }\n  if (attribution === undefined) {\n    return content;\n  }\n  const safeAttribution = attribution.replace(/\\$/g, '$$$$');\n  return content.replace(\n    /Co-Authored-By:.*$/gim,\n    `Co-Authored-By: ${safeAttribution}`,\n  );\n}\n\n/**\n * Build a hook command path using forward slashes for cross-platform compatibility.\n */\nexport function buildHookCommand(configDir: string, hookName: string): string {\n  const hooksPath = configDir.replace(/\\\\/g, '/') + '/hooks/' + hookName;\n  return `node \"${hooksPath}\"`;\n}\n\n/**\n * Read and parse settings.json, returning empty object if it doesn't exist.\n */\nexport function readSettings(\n  settingsPath: string,\n): Record<string, unknown> {\n  if (fs.existsSync(settingsPath)) {\n    try {\n      return JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n    } catch {\n      return {};\n    }\n  }\n  return {};\n}\n\n/**\n * Write settings.json with proper formatting.\n */\nexport function writeSettings(\n  settingsPath: string,\n  settings: Record<string, unknown>,\n): void {\n  fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + '\\n');\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA,SAAgB,YAAY,UAA0B;AACpD,KAAI,YAAY,SAAS,WAAW,KAAK,CACvC,QAAOA,UAAK,KAAKC,QAAG,SAAS,EAAE,SAAS,MAAM,EAAE,CAAC;AAEnD,QAAO;;;;;;AAOT,SAAgB,0BACd,SAC8C;AAC9C,KAAI,CAAC,QAAQ,WAAW,MAAM,CAC5B,QAAO;EAAE,aAAa;EAAM,MAAM;EAAS;CAG7C,MAAM,WAAW,QAAQ,QAAQ,OAAO,EAAE;AAC1C,KAAI,aAAa,GACf,QAAO;EAAE,aAAa;EAAM,MAAM;EAAS;AAG7C,QAAO;EACL,aAAa,QAAQ,UAAU,GAAG,SAAS,CAAC,MAAM;EAClD,MAAM,QAAQ,UAAU,WAAW,EAAE;EACtC;;;;;;;AAQH,SAAgB,mBACd,SACA,aACQ;AACR,KAAI,gBAAgB,KAClB,QAAO,QAAQ,QAAQ,mCAAmC,GAAG;AAE/D,KAAI,gBAAgB,OAClB,QAAO;CAET,MAAM,kBAAkB,YAAY,QAAQ,OAAO,OAAO;AAC1D,QAAO,QAAQ,QACb,yBACA,mBAAmB,kBACpB;;;;;AAMH,SAAgB,iBAAiB,WAAmB,UAA0B;AAE5E,QAAO,SADW,UAAU,QAAQ,OAAO,IAAI,GAAG,YAAY,SACpC;;;;;AAM5B,SAAgB,aACd,cACyB;AACzB,KAAIC,QAAG,WAAW,aAAa,CAC7B,KAAI;AACF,SAAO,KAAK,MAAMA,QAAG,aAAa,cAAc,OAAO,CAAC;SAClD;AACN,SAAO,EAAE;;AAGb,QAAO,EAAE;;;;;AAMX,SAAgB,cACd,cACA,UACM;AACN,SAAG,cAAc,cAAc,KAAK,UAAU,UAAU,MAAM,EAAE,GAAG,KAAK"}