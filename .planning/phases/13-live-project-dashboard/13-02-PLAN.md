---
phase: 13-live-project-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - packages/dashboard/server.ts
  - packages/dashboard/lib/watcher.ts
  - packages/dashboard/lib/websocket.ts
  - packages/dashboard/app/components/providers/websocket-provider.tsx
autonomous: true
requirements: []

must_haves:
  truths:
    - "A developer can start the dashboard server and it serves both the web UI and WebSocket on a single auto-detected port"
    - "Hot module reload works in dev mode without interference from the dashboard WebSocket"
    - "Editing a .planning/ file causes the browser dashboard to update within 1 second without manual refresh"
    - "Closing and reopening the browser tab automatically re-establishes the WebSocket connection"
    - "The dashboard auto-opens in the default browser when the server starts"
  artifacts:
    - path: "packages/dashboard/server.ts"
      provides: "Custom HTTP server with WebSocket upgrade handling and Next.js delegation"
      min_lines: 50
    - path: "packages/dashboard/lib/watcher.ts"
      provides: "chokidar file watcher with debounced WebSocket broadcast and write-suppression"
      min_lines: 40
      exports: ["setupWatcher", "suppressPath"]
    - path: "packages/dashboard/lib/websocket.ts"
      provides: "WebSocket server singleton and client message broadcasting"
      min_lines: 20
      exports: ["createWSS", "broadcast"]
    - path: "packages/dashboard/app/components/providers/websocket-provider.tsx"
      provides: "React context provider for WebSocket connection state and live change events"
      min_lines: 40
      exports: ["WebSocketProvider", "useWebSocket"]
  key_links:
    - from: "packages/dashboard/server.ts"
      to: "packages/dashboard/lib/watcher.ts"
      via: "setupWatcher() call on server start"
      pattern: "setupWatcher"
    - from: "packages/dashboard/server.ts"
      to: "packages/dashboard/lib/websocket.ts"
      via: "createWSS() for WebSocket server"
      pattern: "createWSS"
    - from: "packages/dashboard/lib/watcher.ts"
      to: "packages/dashboard/lib/websocket.ts"
      via: "broadcast() on file change"
      pattern: "broadcast"
    - from: "packages/dashboard/app/components/providers/websocket-provider.tsx"
      to: "/api/ws"
      via: "WebSocket connection to server"
      pattern: "new WebSocket.*api/ws"
---

<objective>
Build the custom server with WebSocket integration and real-time file watching infrastructure.

Purpose: Establish the real-time data pipeline from filesystem changes through WebSocket to the browser, which is the backbone of the live dashboard experience.
Output: A custom Node.js server (server.ts) that hosts Next.js + WebSocket, a chokidar watcher that monitors .planning/, and a React provider that delivers live change events to UI components.
</objective>

<execution_context>
@./workflows/execute-plan.md
@./templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-live-project-dashboard/13-CONTEXT.md
@.planning/phases/13-live-project-dashboard/13-RESEARCH.md
@.planning/phases/13-live-project-dashboard/13-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom server with WebSocket and file watcher modules</name>
  <files>
    packages/dashboard/server.ts
    packages/dashboard/lib/watcher.ts
    packages/dashboard/lib/websocket.ts
  </files>
  <action>
  1. **lib/websocket.ts** — WebSocket server factory and broadcast utility:
     - `createWSS()`: Creates a `WebSocketServer` with `noServer: true` (upgrade handling done in server.ts)
     - `broadcast(wss, message)`: Sends JSON message to all connected clients with `readyState === OPEN`
     - Track connected client count for logging

  2. **lib/watcher.ts** — chokidar file watcher with debounced broadcast:
     - `setupWatcher(cwd: string, wss: WebSocketServer)`: Starts chokidar watcher on `${cwd}/.planning/`
     - Options: `persistent: true`, `ignoreInitial: true`, `awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 }`, `depth: 5`
     - Debounce: Collect changed paths in a Set, broadcast after 200ms of quiet
     - **Write-suppression mechanism** (CRITICAL — prevents infinite loops): `suppressPath(filePath: string)` adds path to a "recently written" Set with 500ms TTL. Watcher callback skips broadcasting for paths in this set.
     - Normalize all paths from chokidar to forward slashes (Windows compatibility per research pitfall #7)
     - Broadcast message format: `{ type: "file-changes", changes: string[], timestamp: number }`
     - Return the watcher instance for cleanup

  3. **server.ts** — Custom HTTP server integrating Next.js + WebSocket:
     - Import `next` from `next`, create app with `{ dev: process.env.NODE_ENV !== 'production' }`
     - Import `createWSS` from `./lib/websocket.js` and `setupWatcher` from `./lib/watcher.js`
     - Read project CWD from `process.env.MAXSIM_PROJECT_CWD || process.cwd()`
     - After `await app.prepare()`, create HTTP server with `createServer()` that delegates to `app.getRequestHandler()`
     - Handle `upgrade` event:
       - If `pathname === '/_next/webpack-hmr'` — delegate to `app.getUpgradeHandler()` (Next.js HMR in dev mode)
       - If `pathname === '/api/ws'` — handle with `wss.handleUpgrade()` then emit `connection`
       - Otherwise — `socket.destroy()`
     - Start file watcher via `setupWatcher(projectCwd, wss)`
     - Auto-detect free port: `import detectPort from 'detect-port'`, start from 3333
     - Auto-open browser: `import open from 'open'`, call `open(url)` after server listen
     - Log: `Dashboard ready at http://localhost:${port}` to stderr (not stdout, to avoid interfering with potential pipe)
     - Handle SIGINT/SIGTERM for graceful shutdown (close watcher, close wss, close server)
  </action>
  <verify>
    <automated>cd C:/Development/cli/maxsim/packages/dashboard && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>server.ts, watcher.ts, and websocket.ts compile without TypeScript errors; server handles WebSocket upgrades at /api/ws and HMR at /_next/webpack-hmr; watcher has write-suppression and path normalization</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket React provider with auto-reconnect</name>
  <files>
    packages/dashboard/app/components/providers/websocket-provider.tsx
  </files>
  <action>
  Create a React context provider that manages the WebSocket connection lifecycle:

  1. **websocket-provider.tsx** — "use client" component:
     - Create `WSContext` with `{ connected: boolean, lastChange: number }` value
     - `WebSocketProvider` component:
       - On mount, connect to `${protocol}//${host}/api/ws` (ws: or wss: based on page protocol)
       - `onopen`: set connected = true
       - `onclose`: set connected = false, schedule reconnect with exponential backoff (start 2s, max 30s, multiplier 1.5)
       - `onmessage`: parse JSON, if `type === "file-changes"` update `lastChange` to `data.timestamp`
       - `onerror`: log to console.warn (do not crash)
       - On unmount: close WebSocket, clear reconnect timer
     - `useWebSocket()` hook: returns `{ connected, lastChange }` from context
     - Export both `WebSocketProvider` and `useWebSocket`

  2. **Wire into layout** — Update `app/layout.tsx` to wrap children with `<WebSocketProvider>`. Since WebSocketProvider is a client component, the layout remains a Server Component shell with the provider as a client boundary.

  The `lastChange` timestamp is the key signal: downstream data-fetching hooks (in Plans 04/05) will refetch when `lastChange` changes, creating the real-time reactivity chain: chokidar -> WebSocket -> React state -> data refetch -> UI update.
  </action>
  <verify>
    <automated>cd C:/Development/cli/maxsim/packages/dashboard && npx next build 2>&1 | tail -5</automated>
  </verify>
  <done>WebSocketProvider wraps the app layout, useWebSocket() hook is available, auto-reconnect with exponential backoff is implemented, lastChange timestamp updates on file-changes events</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for server.ts, watcher.ts, websocket.ts, websocket-provider.tsx
2. `next build` succeeds with the WebSocketProvider in the layout
3. Write-suppression mechanism prevents broadcast loops when dashboard writes a file
4. Path normalization converts Windows backslashes to forward slashes
5. HMR WebSocket at /_next/webpack-hmr is not intercepted by dashboard WebSocket handler
</verification>

<success_criteria>
- Custom server hosts Next.js + WebSocket on a single auto-detected port
- chokidar watches .planning/ with debounced broadcast and write-suppression
- React WebSocket provider auto-reconnects and exposes lastChange for downstream hooks
- No interference between dashboard WebSocket and Next.js HMR in dev mode
- All files compile with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-live-project-dashboard/13-02-SUMMARY.md`
</output>
